/*! For license information please see main.cda53fe5.js.LICENSE.txt */
!function(){var e={694:function(e,i){var t;!function(){"use strict";var _={}.hasOwnProperty;function s(){for(var e=[],i=0;i<arguments.length;i++){var t=arguments[i];if(t){var a=typeof t;if("string"===a||"number"===a)e.push(t);else if(Array.isArray(t)){if(t.length){var n=s.apply(null,t);n&&e.push(n)}}else if("object"===a)if(t.toString===Object.prototype.toString)for(var r in t)_.call(t,r)&&t[r]&&e.push(r);else e.push(t.toString())}}return e.join(" ")}e.exports?(s.default=s,e.exports=s):void 0===(t=function(){return s}.apply(i,[]))||(e.exports=t)}()},998:function(e,i,t){"use strict";var _=t(458),s={"text/plain":"Text","text/html":"Url",default:"Text"};e.exports=function(e,i){var t,a,n,r,l,d,o=!1;i||(i={}),t=i.debug||!1;try{if(n=_(),r=document.createRange(),l=document.getSelection(),(d=document.createElement("span")).textContent=e,d.style.all="unset",d.style.position="fixed",d.style.top=0,d.style.clip="rect(0, 0, 0, 0)",d.style.whiteSpace="pre",d.style.webkitUserSelect="text",d.style.MozUserSelect="text",d.style.msUserSelect="text",d.style.userSelect="text",d.addEventListener("copy",(function(_){if(_.stopPropagation(),i.format)if(_.preventDefault(),"undefined"===typeof _.clipboardData){t&&console.warn("unable to use e.clipboardData"),t&&console.warn("trying IE specific stuff"),window.clipboardData.clearData();var a=s[i.format]||s.default;window.clipboardData.setData(a,e)}else _.clipboardData.clearData(),_.clipboardData.setData(i.format,e);i.onCopy&&(_.preventDefault(),i.onCopy(_.clipboardData))})),document.body.appendChild(d),r.selectNodeContents(d),l.addRange(r),!document.execCommand("copy"))throw new Error("copy command was unsuccessful");o=!0}catch(m){t&&console.error("unable to copy using execCommand: ",m),t&&console.warn("trying IE specific stuff");try{window.clipboardData.setData(i.format||"text",e),i.onCopy&&i.onCopy(window.clipboardData),o=!0}catch(m){t&&console.error("unable to copy using clipboardData: ",m),t&&console.error("falling back to prompt"),a=function(e){var i=(/mac os x/i.test(navigator.userAgent)?"\u2318":"Ctrl")+"+C";return e.replace(/#{\s*key\s*}/g,i)}("message"in i?i.message:"Copy to clipboard: #{key}, Enter"),window.prompt(a,e)}}finally{l&&("function"==typeof l.removeRange?l.removeRange(r):l.removeAllRanges()),d&&document.body.removeChild(d),n()}return o}},95:function(e,i,t){var _=NaN,s="[object Symbol]",a=/^\s+|\s+$/g,n=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,l=/^0o[0-7]+$/i,d=parseInt,o="object"==typeof t.g&&t.g&&t.g.Object===Object&&t.g,m="object"==typeof self&&self&&self.Object===Object&&self,v=o||m||Function("return this")(),c=Object.prototype.toString,u=Math.max,f=Math.min,b=function(){return v.Date.now()};function p(e){var i=typeof e;return!!e&&("object"==i||"function"==i)}function g(e){if("number"==typeof e)return e;if(function(e){return"symbol"==typeof e||function(e){return!!e&&"object"==typeof e}(e)&&c.call(e)==s}(e))return _;if(p(e)){var i="function"==typeof e.valueOf?e.valueOf():e;e=p(i)?i+"":i}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(a,"");var t=r.test(e);return t||l.test(e)?d(e.slice(2),t?2:8):n.test(e)?_:+e}e.exports=function(e,i,t){var _,s,a,n,r,l,d=0,o=!1,m=!1,v=!0;if("function"!=typeof e)throw new TypeError("Expected a function");function c(i){var t=_,a=s;return _=s=void 0,d=i,n=e.apply(a,t)}function E(e){var t=e-l;return void 0===l||t>=i||t<0||m&&e-d>=a}function w(){var e=b();if(E(e))return h(e);r=setTimeout(w,function(e){var t=i-(e-l);return m?f(t,a-(e-d)):t}(e))}function h(e){return r=void 0,v&&_?c(e):(_=s=void 0,n)}function x(){var e=b(),t=E(e);if(_=arguments,s=this,l=e,t){if(void 0===r)return function(e){return d=e,r=setTimeout(w,i),o?c(e):n}(l);if(m)return r=setTimeout(w,i),c(l)}return void 0===r&&(r=setTimeout(w,i)),n}return i=g(i)||0,p(t)&&(o=!!t.leading,a=(m="maxWait"in t)?u(g(t.maxWait)||0,i):a,v="trailing"in t?!!t.trailing:v),x.cancel=function(){void 0!==r&&clearTimeout(r),d=0,_=l=s=r=void 0},x.flush=function(){return void 0===r?n:h(b())},x}},725:function(e){"use strict";var i=Object.getOwnPropertySymbols,t=Object.prototype.hasOwnProperty,_=Object.prototype.propertyIsEnumerable;e.exports=function(){try{if(!Object.assign)return!1;var e=new String("abc");if(e[5]="de","5"===Object.getOwnPropertyNames(e)[0])return!1;for(var i={},t=0;t<10;t++)i["_"+String.fromCharCode(t)]=t;if("0123456789"!==Object.getOwnPropertyNames(i).map((function(e){return i[e]})).join(""))return!1;var _={};return"abcdefghijklmnopqrst".split("").forEach((function(e){_[e]=e})),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},_)).join("")}catch(s){return!1}}()?Object.assign:function(e,s){for(var a,n,r=function(e){if(null===e||void 0===e)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(e)}(e),l=1;l<arguments.length;l++){for(var d in a=Object(arguments[l]))t.call(a,d)&&(r[d]=a[d]);if(i){n=i(a);for(var o=0;o<n.length;o++)_.call(a,n[o])&&(r[n[o]]=a[n[o]])}}return r}},888:function(e,i,t){"use strict";var _=t(47);function s(){}function a(){}a.resetWarningCache=s,e.exports=function(){function e(e,i,t,s,a,n){if(n!==_){var r=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw r.name="Invariant Violation",r}}function i(){return e}e.isRequired=e;var t={array:e,bigint:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:i,element:e,elementType:e,instanceOf:i,node:e,objectOf:i,oneOf:i,oneOfType:i,shape:i,exact:i,checkPropTypes:a,resetWarningCache:s};return t.PropTypes=t,t}},7:function(e,i,t){e.exports=t(888)()},47:function(e){"use strict";e.exports="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"},568:function(e,i,t){"use strict";function _(e){return _="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},_(e)}Object.defineProperty(i,"__esModule",{value:!0}),i.CopyToClipboard=void 0;var s=r(t(791)),a=r(t(998)),n=["text","onCopy","options","children"];function r(e){return e&&e.__esModule?e:{default:e}}function l(e,i){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var _=Object.getOwnPropertySymbols(e);i&&(_=_.filter((function(i){return Object.getOwnPropertyDescriptor(e,i).enumerable}))),t.push.apply(t,_)}return t}function d(e){for(var i=1;i<arguments.length;i++){var t=null!=arguments[i]?arguments[i]:{};i%2?l(Object(t),!0).forEach((function(i){b(e,i,t[i])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(i){Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(t,i))}))}return e}function o(e,i){if(null==e)return{};var t,_,s=function(e,i){if(null==e)return{};var t,_,s={},a=Object.keys(e);for(_=0;_<a.length;_++)t=a[_],i.indexOf(t)>=0||(s[t]=e[t]);return s}(e,i);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(_=0;_<a.length;_++)t=a[_],i.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}function m(e,i){for(var t=0;t<i.length;t++){var _=i[t];_.enumerable=_.enumerable||!1,_.configurable=!0,"value"in _&&(_.writable=!0),Object.defineProperty(e,_.key,_)}}function v(e,i){return v=Object.setPrototypeOf||function(e,i){return e.__proto__=i,e},v(e,i)}function c(e){var i=function(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var t,s=f(e);if(i){var a=f(this).constructor;t=Reflect.construct(s,arguments,a)}else t=s.apply(this,arguments);return function(e,i){if(i&&("object"===_(i)||"function"===typeof i))return i;if(void 0!==i)throw new TypeError("Derived constructors may only return object or undefined");return u(e)}(this,t)}}function u(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function f(e){return f=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},f(e)}function b(e,i,t){return i in e?Object.defineProperty(e,i,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[i]=t,e}var p=function(e){!function(e,i){if("function"!==typeof i&&null!==i)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(i&&i.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),i&&v(e,i)}(l,e);var i,t,_,r=c(l);function l(){var e;!function(e,i){if(!(e instanceof i))throw new TypeError("Cannot call a class as a function")}(this,l);for(var i=arguments.length,t=new Array(i),_=0;_<i;_++)t[_]=arguments[_];return b(u(e=r.call.apply(r,[this].concat(t))),"onClick",(function(i){var t=e.props,_=t.text,n=t.onCopy,r=t.children,l=t.options,d=s.default.Children.only(r),o=(0,a.default)(_,l);n&&n(_,o),d&&d.props&&"function"===typeof d.props.onClick&&d.props.onClick(i)})),e}return i=l,(t=[{key:"render",value:function(){var e=this.props,i=(e.text,e.onCopy,e.options,e.children),t=o(e,n),_=s.default.Children.only(i);return s.default.cloneElement(_,d(d({},t),{},{onClick:this.onClick}))}}])&&m(i.prototype,t),_&&m(i,_),Object.defineProperty(i,"prototype",{writable:!1}),l}(s.default.PureComponent);i.CopyToClipboard=p,b(p,"defaultProps",{onCopy:void 0,options:void 0})},29:function(e,i,t){"use strict";var _=t(568).CopyToClipboard;_.CopyToClipboard=_,e.exports=_},463:function(e,i,t){"use strict";var _=t(791),s=t(725),a=t(296);function n(e){for(var i="https://reactjs.org/docs/error-decoder.html?invariant="+e,t=1;t<arguments.length;t++)i+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+e+"; visit "+i+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!_)throw Error(n(227));var r=new Set,l={};function d(e,i){o(e,i),o(e+"Capture",i)}function o(e,i){for(l[e]=i,e=0;e<i.length;e++)r.add(i[e])}var m=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),v=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,c=Object.prototype.hasOwnProperty,u={},f={};function b(e,i,t,_,s,a,n){this.acceptsBooleans=2===i||3===i||4===i,this.attributeName=_,this.attributeNamespace=s,this.mustUseProperty=t,this.propertyName=e,this.type=i,this.sanitizeURL=a,this.removeEmptyString=n}var p={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){p[e]=new b(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var i=e[0];p[i]=new b(i,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){p[e]=new b(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){p[e]=new b(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){p[e]=new b(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){p[e]=new b(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){p[e]=new b(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){p[e]=new b(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){p[e]=new b(e,5,!1,e.toLowerCase(),null,!1,!1)}));var g=/[\-:]([a-z])/g;function E(e){return e[1].toUpperCase()}function w(e,i,t,_){var s=p.hasOwnProperty(i)?p[i]:null;(null!==s?0===s.type:!_&&(2<i.length&&("o"===i[0]||"O"===i[0])&&("n"===i[1]||"N"===i[1])))||(function(e,i,t,_){if(null===i||"undefined"===typeof i||function(e,i,t,_){if(null!==t&&0===t.type)return!1;switch(typeof i){case"function":case"symbol":return!0;case"boolean":return!_&&(null!==t?!t.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,i,t,_))return!0;if(_)return!1;if(null!==t)switch(t.type){case 3:return!i;case 4:return!1===i;case 5:return isNaN(i);case 6:return isNaN(i)||1>i}return!1}(i,t,s,_)&&(t=null),_||null===s?function(e){return!!c.call(f,e)||!c.call(u,e)&&(v.test(e)?f[e]=!0:(u[e]=!0,!1))}(i)&&(null===t?e.removeAttribute(i):e.setAttribute(i,""+t)):s.mustUseProperty?e[s.propertyName]=null===t?3!==s.type&&"":t:(i=s.attributeName,_=s.attributeNamespace,null===t?e.removeAttribute(i):(t=3===(s=s.type)||4===s&&!0===t?"":""+t,_?e.setAttributeNS(_,i,t):e.setAttribute(i,t))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var i=e.replace(g,E);p[i]=new b(i,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var i=e.replace(g,E);p[i]=new b(i,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var i=e.replace(g,E);p[i]=new b(i,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){p[e]=new b(e,1,!1,e.toLowerCase(),null,!1,!1)})),p.xlinkHref=new b("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){p[e]=new b(e,1,!1,e.toLowerCase(),null,!0,!0)}));var h=_.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,x=60103,z=60106,L=60107,M=60108,R=60114,S=60109,D=60110,y=60112,V=60113,A=60120,T=60115,W=60116,U=60121,I=60128,B=60129,O=60130,F=60131;if("function"===typeof Symbol&&Symbol.for){var q=Symbol.for;x=q("react.element"),z=q("react.portal"),L=q("react.fragment"),M=q("react.strict_mode"),R=q("react.profiler"),S=q("react.provider"),D=q("react.context"),y=q("react.forward_ref"),V=q("react.suspense"),A=q("react.suspense_list"),T=q("react.memo"),W=q("react.lazy"),U=q("react.block"),q("react.scope"),I=q("react.opaque.id"),B=q("react.debug_trace_mode"),O=q("react.offscreen"),F=q("react.legacy_hidden")}var X,C="function"===typeof Symbol&&Symbol.iterator;function H(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=C&&e[C]||e["@@iterator"])?e:null}function k(e){if(void 0===X)try{throw Error()}catch(t){var i=t.stack.trim().match(/\n( *(at )?)/);X=i&&i[1]||""}return"\n"+X+e}var N=!1;function Z(e,i){if(!e||N)return"";N=!0;var t=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(i)if(i=function(){throw Error()},Object.defineProperty(i.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(i,[])}catch(l){var _=l}Reflect.construct(e,[],i)}else{try{i.call()}catch(l){_=l}e.call(i.prototype)}else{try{throw Error()}catch(l){_=l}e()}}catch(l){if(l&&_&&"string"===typeof l.stack){for(var s=l.stack.split("\n"),a=_.stack.split("\n"),n=s.length-1,r=a.length-1;1<=n&&0<=r&&s[n]!==a[r];)r--;for(;1<=n&&0<=r;n--,r--)if(s[n]!==a[r]){if(1!==n||1!==r)do{if(n--,0>--r||s[n]!==a[r])return"\n"+s[n].replace(" at new "," at ")}while(1<=n&&0<=r);break}}}finally{N=!1,Error.prepareStackTrace=t}return(e=e?e.displayName||e.name:"")?k(e):""}function Y(e){switch(e.tag){case 5:return k(e.type);case 16:return k("Lazy");case 13:return k("Suspense");case 19:return k("SuspenseList");case 0:case 2:case 15:return e=Z(e.type,!1);case 11:return e=Z(e.type.render,!1);case 22:return e=Z(e.type._render,!1);case 1:return e=Z(e.type,!0);default:return""}}function P(e){if(null==e)return null;if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case L:return"Fragment";case z:return"Portal";case R:return"Profiler";case M:return"StrictMode";case V:return"Suspense";case A:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case D:return(e.displayName||"Context")+".Consumer";case S:return(e._context.displayName||"Context")+".Provider";case y:var i=e.render;return i=i.displayName||i.name||"",e.displayName||(""!==i?"ForwardRef("+i+")":"ForwardRef");case T:return P(e.type);case U:return P(e._render);case W:i=e._payload,e=e._init;try{return P(e(i))}catch(t){}}return null}function j(e){switch(typeof e){case"boolean":case"number":case"object":case"string":case"undefined":return e;default:return""}}function K(e){var i=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===i||"radio"===i)}function G(e){e._valueTracker||(e._valueTracker=function(e){var i=K(e)?"checked":"value",t=Object.getOwnPropertyDescriptor(e.constructor.prototype,i),_=""+e[i];if(!e.hasOwnProperty(i)&&"undefined"!==typeof t&&"function"===typeof t.get&&"function"===typeof t.set){var s=t.get,a=t.set;return Object.defineProperty(e,i,{configurable:!0,get:function(){return s.call(this)},set:function(e){_=""+e,a.call(this,e)}}),Object.defineProperty(e,i,{enumerable:t.enumerable}),{getValue:function(){return _},setValue:function(e){_=""+e},stopTracking:function(){e._valueTracker=null,delete e[i]}}}}(e))}function Q(e){if(!e)return!1;var i=e._valueTracker;if(!i)return!0;var t=i.getValue(),_="";return e&&(_=K(e)?e.checked?"true":"false":e.value),(e=_)!==t&&(i.setValue(e),!0)}function J(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(i){return e.body}}function $(e,i){var t=i.checked;return s({},i,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=t?t:e._wrapperState.initialChecked})}function ee(e,i){var t=null==i.defaultValue?"":i.defaultValue,_=null!=i.checked?i.checked:i.defaultChecked;t=j(null!=i.value?i.value:t),e._wrapperState={initialChecked:_,initialValue:t,controlled:"checkbox"===i.type||"radio"===i.type?null!=i.checked:null!=i.value}}function ie(e,i){null!=(i=i.checked)&&w(e,"checked",i,!1)}function te(e,i){ie(e,i);var t=j(i.value),_=i.type;if(null!=t)"number"===_?(0===t&&""===e.value||e.value!=t)&&(e.value=""+t):e.value!==""+t&&(e.value=""+t);else if("submit"===_||"reset"===_)return void e.removeAttribute("value");i.hasOwnProperty("value")?se(e,i.type,t):i.hasOwnProperty("defaultValue")&&se(e,i.type,j(i.defaultValue)),null==i.checked&&null!=i.defaultChecked&&(e.defaultChecked=!!i.defaultChecked)}function _e(e,i,t){if(i.hasOwnProperty("value")||i.hasOwnProperty("defaultValue")){var _=i.type;if(!("submit"!==_&&"reset"!==_||void 0!==i.value&&null!==i.value))return;i=""+e._wrapperState.initialValue,t||i===e.value||(e.value=i),e.defaultValue=i}""!==(t=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==t&&(e.name=t)}function se(e,i,t){"number"===i&&J(e.ownerDocument)===e||(null==t?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+t&&(e.defaultValue=""+t))}function ae(e,i){return e=s({children:void 0},i),(i=function(e){var i="";return _.Children.forEach(e,(function(e){null!=e&&(i+=e)})),i}(i.children))&&(e.children=i),e}function ne(e,i,t,_){if(e=e.options,i){i={};for(var s=0;s<t.length;s++)i["$"+t[s]]=!0;for(t=0;t<e.length;t++)s=i.hasOwnProperty("$"+e[t].value),e[t].selected!==s&&(e[t].selected=s),s&&_&&(e[t].defaultSelected=!0)}else{for(t=""+j(t),i=null,s=0;s<e.length;s++){if(e[s].value===t)return e[s].selected=!0,void(_&&(e[s].defaultSelected=!0));null!==i||e[s].disabled||(i=e[s])}null!==i&&(i.selected=!0)}}function re(e,i){if(null!=i.dangerouslySetInnerHTML)throw Error(n(91));return s({},i,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function le(e,i){var t=i.value;if(null==t){if(t=i.children,i=i.defaultValue,null!=t){if(null!=i)throw Error(n(92));if(Array.isArray(t)){if(!(1>=t.length))throw Error(n(93));t=t[0]}i=t}null==i&&(i=""),t=i}e._wrapperState={initialValue:j(t)}}function de(e,i){var t=j(i.value),_=j(i.defaultValue);null!=t&&((t=""+t)!==e.value&&(e.value=t),null==i.defaultValue&&e.defaultValue!==t&&(e.defaultValue=t)),null!=_&&(e.defaultValue=""+_)}function oe(e){var i=e.textContent;i===e._wrapperState.initialValue&&""!==i&&null!==i&&(e.value=i)}var me={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};function ve(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function ce(e,i){return null==e||"http://www.w3.org/1999/xhtml"===e?ve(i):"http://www.w3.org/2000/svg"===e&&"foreignObject"===i?"http://www.w3.org/1999/xhtml":e}var ue,fe,be=(fe=function(e,i){if(e.namespaceURI!==me.svg||"innerHTML"in e)e.innerHTML=i;else{for((ue=ue||document.createElement("div")).innerHTML="<svg>"+i.valueOf().toString()+"</svg>",i=ue.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;i.firstChild;)e.appendChild(i.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,i,t,_){MSApp.execUnsafeLocalFunction((function(){return fe(e,i)}))}:fe);function pe(e,i){if(i){var t=e.firstChild;if(t&&t===e.lastChild&&3===t.nodeType)return void(t.nodeValue=i)}e.textContent=i}var ge={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Ee=["Webkit","ms","Moz","O"];function we(e,i,t){return null==i||"boolean"===typeof i||""===i?"":t||"number"!==typeof i||0===i||ge.hasOwnProperty(e)&&ge[e]?(""+i).trim():i+"px"}function he(e,i){for(var t in e=e.style,i)if(i.hasOwnProperty(t)){var _=0===t.indexOf("--"),s=we(t,i[t],_);"float"===t&&(t="cssFloat"),_?e.setProperty(t,s):e[t]=s}}Object.keys(ge).forEach((function(e){Ee.forEach((function(i){i=i+e.charAt(0).toUpperCase()+e.substring(1),ge[i]=ge[e]}))}));var xe=s({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ze(e,i){if(i){if(xe[e]&&(null!=i.children||null!=i.dangerouslySetInnerHTML))throw Error(n(137,e));if(null!=i.dangerouslySetInnerHTML){if(null!=i.children)throw Error(n(60));if("object"!==typeof i.dangerouslySetInnerHTML||!("__html"in i.dangerouslySetInnerHTML))throw Error(n(61))}if(null!=i.style&&"object"!==typeof i.style)throw Error(n(62))}}function Le(e,i){if(-1===e.indexOf("-"))return"string"===typeof i.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}function Me(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var Re=null,Se=null,De=null;function ye(e){if(e=is(e)){if("function"!==typeof Re)throw Error(n(280));var i=e.stateNode;i&&(i=_s(i),Re(e.stateNode,e.type,i))}}function Ve(e){Se?De?De.push(e):De=[e]:Se=e}function Ae(){if(Se){var e=Se,i=De;if(De=Se=null,ye(e),i)for(e=0;e<i.length;e++)ye(i[e])}}function Te(e,i){return e(i)}function We(e,i,t,_,s){return e(i,t,_,s)}function Ue(){}var Ie=Te,Be=!1,Oe=!1;function Fe(){null===Se&&null===De||(Ue(),Ae())}function qe(e,i){var t=e.stateNode;if(null===t)return null;var _=_s(t);if(null===_)return null;t=_[i];e:switch(i){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(_=!_.disabled)||(_=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!_;break e;default:e=!1}if(e)return null;if(t&&"function"!==typeof t)throw Error(n(231,i,typeof t));return t}var Xe=!1;if(m)try{var Ce={};Object.defineProperty(Ce,"passive",{get:function(){Xe=!0}}),window.addEventListener("test",Ce,Ce),window.removeEventListener("test",Ce,Ce)}catch(fe){Xe=!1}function He(e,i,t,_,s,a,n,r,l){var d=Array.prototype.slice.call(arguments,3);try{i.apply(t,d)}catch(o){this.onError(o)}}var ke=!1,Ne=null,Ze=!1,Ye=null,Pe={onError:function(e){ke=!0,Ne=e}};function je(e,i,t,_,s,a,n,r,l){ke=!1,Ne=null,He.apply(Pe,arguments)}function Ke(e){var i=e,t=e;if(e.alternate)for(;i.return;)i=i.return;else{e=i;do{0!==(1026&(i=e).flags)&&(t=i.return),e=i.return}while(e)}return 3===i.tag?t:null}function Ge(e){if(13===e.tag){var i=e.memoizedState;if(null===i&&(null!==(e=e.alternate)&&(i=e.memoizedState)),null!==i)return i.dehydrated}return null}function Qe(e){if(Ke(e)!==e)throw Error(n(188))}function Je(e){if(e=function(e){var i=e.alternate;if(!i){if(null===(i=Ke(e)))throw Error(n(188));return i!==e?null:e}for(var t=e,_=i;;){var s=t.return;if(null===s)break;var a=s.alternate;if(null===a){if(null!==(_=s.return)){t=_;continue}break}if(s.child===a.child){for(a=s.child;a;){if(a===t)return Qe(s),e;if(a===_)return Qe(s),i;a=a.sibling}throw Error(n(188))}if(t.return!==_.return)t=s,_=a;else{for(var r=!1,l=s.child;l;){if(l===t){r=!0,t=s,_=a;break}if(l===_){r=!0,_=s,t=a;break}l=l.sibling}if(!r){for(l=a.child;l;){if(l===t){r=!0,t=a,_=s;break}if(l===_){r=!0,_=a,t=s;break}l=l.sibling}if(!r)throw Error(n(189))}}if(t.alternate!==_)throw Error(n(190))}if(3!==t.tag)throw Error(n(188));return t.stateNode.current===t?e:i}(e),!e)return null;for(var i=e;;){if(5===i.tag||6===i.tag)return i;if(i.child)i.child.return=i,i=i.child;else{if(i===e)break;for(;!i.sibling;){if(!i.return||i.return===e)return null;i=i.return}i.sibling.return=i.return,i=i.sibling}}return null}function $e(e,i){for(var t=e.alternate;null!==i;){if(i===e||i===t)return!0;i=i.return}return!1}var ei,ii,ti,_i,si=!1,ai=[],ni=null,ri=null,li=null,di=new Map,oi=new Map,mi=[],vi="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function ci(e,i,t,_,s){return{blockedOn:e,domEventName:i,eventSystemFlags:16|t,nativeEvent:s,targetContainers:[_]}}function ui(e,i){switch(e){case"focusin":case"focusout":ni=null;break;case"dragenter":case"dragleave":ri=null;break;case"mouseover":case"mouseout":li=null;break;case"pointerover":case"pointerout":di.delete(i.pointerId);break;case"gotpointercapture":case"lostpointercapture":oi.delete(i.pointerId)}}function fi(e,i,t,_,s,a){return null===e||e.nativeEvent!==a?(e=ci(i,t,_,s,a),null!==i&&(null!==(i=is(i))&&ii(i)),e):(e.eventSystemFlags|=_,i=e.targetContainers,null!==s&&-1===i.indexOf(s)&&i.push(s),e)}function bi(e){var i=es(e.target);if(null!==i){var t=Ke(i);if(null!==t)if(13===(i=t.tag)){if(null!==(i=Ge(t)))return e.blockedOn=i,void _i(e.lanePriority,(function(){a.unstable_runWithPriority(e.priority,(function(){ti(t)}))}))}else if(3===i&&t.stateNode.hydrate)return void(e.blockedOn=3===t.tag?t.stateNode.containerInfo:null)}e.blockedOn=null}function pi(e){if(null!==e.blockedOn)return!1;for(var i=e.targetContainers;0<i.length;){var t=Ji(e.domEventName,e.eventSystemFlags,i[0],e.nativeEvent);if(null!==t)return null!==(i=is(t))&&ii(i),e.blockedOn=t,!1;i.shift()}return!0}function gi(e,i,t){pi(e)&&t.delete(i)}function Ei(){for(si=!1;0<ai.length;){var e=ai[0];if(null!==e.blockedOn){null!==(e=is(e.blockedOn))&&ei(e);break}for(var i=e.targetContainers;0<i.length;){var t=Ji(e.domEventName,e.eventSystemFlags,i[0],e.nativeEvent);if(null!==t){e.blockedOn=t;break}i.shift()}null===e.blockedOn&&ai.shift()}null!==ni&&pi(ni)&&(ni=null),null!==ri&&pi(ri)&&(ri=null),null!==li&&pi(li)&&(li=null),di.forEach(gi),oi.forEach(gi)}function wi(e,i){e.blockedOn===i&&(e.blockedOn=null,si||(si=!0,a.unstable_scheduleCallback(a.unstable_NormalPriority,Ei)))}function hi(e){function i(i){return wi(i,e)}if(0<ai.length){wi(ai[0],e);for(var t=1;t<ai.length;t++){var _=ai[t];_.blockedOn===e&&(_.blockedOn=null)}}for(null!==ni&&wi(ni,e),null!==ri&&wi(ri,e),null!==li&&wi(li,e),di.forEach(i),oi.forEach(i),t=0;t<mi.length;t++)(_=mi[t]).blockedOn===e&&(_.blockedOn=null);for(;0<mi.length&&null===(t=mi[0]).blockedOn;)bi(t),null===t.blockedOn&&mi.shift()}function xi(e,i){var t={};return t[e.toLowerCase()]=i.toLowerCase(),t["Webkit"+e]="webkit"+i,t["Moz"+e]="moz"+i,t}var zi={animationend:xi("Animation","AnimationEnd"),animationiteration:xi("Animation","AnimationIteration"),animationstart:xi("Animation","AnimationStart"),transitionend:xi("Transition","TransitionEnd")},Li={},Mi={};function Ri(e){if(Li[e])return Li[e];if(!zi[e])return e;var i,t=zi[e];for(i in t)if(t.hasOwnProperty(i)&&i in Mi)return Li[e]=t[i];return e}m&&(Mi=document.createElement("div").style,"AnimationEvent"in window||(delete zi.animationend.animation,delete zi.animationiteration.animation,delete zi.animationstart.animation),"TransitionEvent"in window||delete zi.transitionend.transition);var Si=Ri("animationend"),Di=Ri("animationiteration"),yi=Ri("animationstart"),Vi=Ri("transitionend"),Ai=new Map,Ti=new Map,Wi=["abort","abort",Si,"animationEnd",Di,"animationIteration",yi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",Vi,"transitionEnd","waiting","waiting"];function Ui(e,i){for(var t=0;t<e.length;t+=2){var _=e[t],s=e[t+1];s="on"+(s[0].toUpperCase()+s.slice(1)),Ti.set(_,i),Ai.set(_,s),d(s,[_])}}(0,a.unstable_now)();var Ii=8;function Bi(e){if(0!==(1&e))return Ii=15,1;if(0!==(2&e))return Ii=14,2;if(0!==(4&e))return Ii=13,4;var i=24&e;return 0!==i?(Ii=12,i):0!==(32&e)?(Ii=11,32):0!==(i=192&e)?(Ii=10,i):0!==(256&e)?(Ii=9,256):0!==(i=3584&e)?(Ii=8,i):0!==(4096&e)?(Ii=7,4096):0!==(i=4186112&e)?(Ii=6,i):0!==(i=62914560&e)?(Ii=5,i):67108864&e?(Ii=4,67108864):0!==(134217728&e)?(Ii=3,134217728):0!==(i=805306368&e)?(Ii=2,i):0!==(1073741824&e)?(Ii=1,1073741824):(Ii=8,e)}function Oi(e,i){var t=e.pendingLanes;if(0===t)return Ii=0;var _=0,s=0,a=e.expiredLanes,n=e.suspendedLanes,r=e.pingedLanes;if(0!==a)_=a,s=Ii=15;else if(0!==(a=134217727&t)){var l=a&~n;0!==l?(_=Bi(l),s=Ii):0!==(r&=a)&&(_=Bi(r),s=Ii)}else 0!==(a=t&~n)?(_=Bi(a),s=Ii):0!==r&&(_=Bi(r),s=Ii);if(0===_)return 0;if(_=t&((0>(_=31-ki(_))?0:1<<_)<<1)-1,0!==i&&i!==_&&0===(i&n)){if(Bi(i),s<=Ii)return i;Ii=s}if(0!==(i=e.entangledLanes))for(e=e.entanglements,i&=_;0<i;)s=1<<(t=31-ki(i)),_|=e[t],i&=~s;return _}function Fi(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function qi(e,i){switch(e){case 15:return 1;case 14:return 2;case 12:return 0===(e=Xi(24&~i))?qi(10,i):e;case 10:return 0===(e=Xi(192&~i))?qi(8,i):e;case 8:return 0===(e=Xi(3584&~i))&&(0===(e=Xi(4186112&~i))&&(e=512)),e;case 2:return 0===(i=Xi(805306368&~i))&&(i=268435456),i}throw Error(n(358,e))}function Xi(e){return e&-e}function Ci(e){for(var i=[],t=0;31>t;t++)i.push(e);return i}function Hi(e,i,t){e.pendingLanes|=i;var _=i-1;e.suspendedLanes&=_,e.pingedLanes&=_,(e=e.eventTimes)[i=31-ki(i)]=t}var ki=Math.clz32?Math.clz32:function(e){return 0===e?32:31-(Ni(e)/Zi|0)|0},Ni=Math.log,Zi=Math.LN2;var Yi=a.unstable_UserBlockingPriority,Pi=a.unstable_runWithPriority,ji=!0;function Ki(e,i,t,_){Be||Ue();var s=Qi,a=Be;Be=!0;try{We(s,e,i,t,_)}finally{(Be=a)||Fe()}}function Gi(e,i,t,_){Pi(Yi,Qi.bind(null,e,i,t,_))}function Qi(e,i,t,_){var s;if(ji)if((s=0===(4&i))&&0<ai.length&&-1<vi.indexOf(e))e=ci(null,e,i,t,_),ai.push(e);else{var a=Ji(e,i,t,_);if(null===a)s&&ui(e,_);else{if(s){if(-1<vi.indexOf(e))return e=ci(a,e,i,t,_),void ai.push(e);if(function(e,i,t,_,s){switch(i){case"focusin":return ni=fi(ni,e,i,t,_,s),!0;case"dragenter":return ri=fi(ri,e,i,t,_,s),!0;case"mouseover":return li=fi(li,e,i,t,_,s),!0;case"pointerover":var a=s.pointerId;return di.set(a,fi(di.get(a)||null,e,i,t,_,s)),!0;case"gotpointercapture":return a=s.pointerId,oi.set(a,fi(oi.get(a)||null,e,i,t,_,s)),!0}return!1}(a,e,i,t,_))return;ui(e,_)}W_(e,i,_,null,t)}}}function Ji(e,i,t,_){var s=Me(_);if(null!==(s=es(s))){var a=Ke(s);if(null===a)s=null;else{var n=a.tag;if(13===n){if(null!==(s=Ge(a)))return s;s=null}else if(3===n){if(a.stateNode.hydrate)return 3===a.tag?a.stateNode.containerInfo:null;s=null}else a!==s&&(s=null)}}return W_(e,i,_,s,t),null}var $i=null,et=null,it=null;function tt(){if(it)return it;var e,i,t=et,_=t.length,s="value"in $i?$i.value:$i.textContent,a=s.length;for(e=0;e<_&&t[e]===s[e];e++);var n=_-e;for(i=1;i<=n&&t[_-i]===s[a-i];i++);return it=s.slice(e,1<i?1-i:void 0)}function _t(e){var i=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===i&&(e=13):e=i,10===e&&(e=13),32<=e||13===e?e:0}function st(){return!0}function at(){return!1}function nt(e){function i(i,t,_,s,a){for(var n in this._reactName=i,this._targetInst=_,this.type=t,this.nativeEvent=s,this.target=a,this.currentTarget=null,e)e.hasOwnProperty(n)&&(i=e[n],this[n]=i?i(s):s[n]);return this.isDefaultPrevented=(null!=s.defaultPrevented?s.defaultPrevented:!1===s.returnValue)?st:at,this.isPropagationStopped=at,this}return s(i.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=st)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=st)},persist:function(){},isPersistent:st}),i}var rt,lt,dt,ot={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},mt=nt(ot),vt=s({},ot,{view:0,detail:0}),ct=nt(vt),ut=s({},vt,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Rt,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==dt&&(dt&&"mousemove"===e.type?(rt=e.screenX-dt.screenX,lt=e.screenY-dt.screenY):lt=rt=0,dt=e),rt)},movementY:function(e){return"movementY"in e?e.movementY:lt}}),ft=nt(ut),bt=nt(s({},ut,{dataTransfer:0})),pt=nt(s({},vt,{relatedTarget:0})),gt=nt(s({},ot,{animationName:0,elapsedTime:0,pseudoElement:0})),Et=s({},ot,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),wt=nt(Et),ht=nt(s({},ot,{data:0})),xt={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},zt={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Lt={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Mt(e){var i=this.nativeEvent;return i.getModifierState?i.getModifierState(e):!!(e=Lt[e])&&!!i[e]}function Rt(){return Mt}var St=s({},vt,{key:function(e){if(e.key){var i=xt[e.key]||e.key;if("Unidentified"!==i)return i}return"keypress"===e.type?13===(e=_t(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?zt[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Rt,charCode:function(e){return"keypress"===e.type?_t(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?_t(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),Dt=nt(St),yt=nt(s({},ut,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Vt=nt(s({},vt,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Rt})),At=nt(s({},ot,{propertyName:0,elapsedTime:0,pseudoElement:0})),Tt=s({},ut,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Wt=nt(Tt),Ut=[9,13,27,32],It=m&&"CompositionEvent"in window,Bt=null;m&&"documentMode"in document&&(Bt=document.documentMode);var Ot=m&&"TextEvent"in window&&!Bt,Ft=m&&(!It||Bt&&8<Bt&&11>=Bt),qt=String.fromCharCode(32),Xt=!1;function Ct(e,i){switch(e){case"keyup":return-1!==Ut.indexOf(i.keyCode);case"keydown":return 229!==i.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Ht(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var kt=!1;var Nt={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Zt(e){var i=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===i?!!Nt[e.type]:"textarea"===i}function Yt(e,i,t,_){Ve(_),0<(i=I_(i,"onChange")).length&&(t=new mt("onChange","change",null,t,_),e.push({event:t,listeners:i}))}var Pt=null,jt=null;function Kt(e){S_(e,0)}function Gt(e){if(Q(ts(e)))return e}function Qt(e,i){if("change"===e)return i}var Jt=!1;if(m){var $t;if(m){var e_="oninput"in document;if(!e_){var i_=document.createElement("div");i_.setAttribute("oninput","return;"),e_="function"===typeof i_.oninput}$t=e_}else $t=!1;Jt=$t&&(!document.documentMode||9<document.documentMode)}function t_(){Pt&&(Pt.detachEvent("onpropertychange",__),jt=Pt=null)}function __(e){if("value"===e.propertyName&&Gt(jt)){var i=[];if(Yt(i,jt,e,Me(e)),e=Kt,Be)e(i);else{Be=!0;try{Te(e,i)}finally{Be=!1,Fe()}}}}function s_(e,i,t){"focusin"===e?(t_(),jt=t,(Pt=i).attachEvent("onpropertychange",__)):"focusout"===e&&t_()}function a_(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Gt(jt)}function n_(e,i){if("click"===e)return Gt(i)}function r_(e,i){if("input"===e||"change"===e)return Gt(i)}var l_="function"===typeof Object.is?Object.is:function(e,i){return e===i&&(0!==e||1/e===1/i)||e!==e&&i!==i},d_=Object.prototype.hasOwnProperty;function o_(e,i){if(l_(e,i))return!0;if("object"!==typeof e||null===e||"object"!==typeof i||null===i)return!1;var t=Object.keys(e),_=Object.keys(i);if(t.length!==_.length)return!1;for(_=0;_<t.length;_++)if(!d_.call(i,t[_])||!l_(e[t[_]],i[t[_]]))return!1;return!0}function m_(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function v_(e,i){var t,_=m_(e);for(e=0;_;){if(3===_.nodeType){if(t=e+_.textContent.length,e<=i&&t>=i)return{node:_,offset:i-e};e=t}e:{for(;_;){if(_.nextSibling){_=_.nextSibling;break e}_=_.parentNode}_=void 0}_=m_(_)}}function c_(e,i){return!(!e||!i)&&(e===i||(!e||3!==e.nodeType)&&(i&&3===i.nodeType?c_(e,i.parentNode):"contains"in e?e.contains(i):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(i))))}function u_(){for(var e=window,i=J();i instanceof e.HTMLIFrameElement;){try{var t="string"===typeof i.contentWindow.location.href}catch(_){t=!1}if(!t)break;i=J((e=i.contentWindow).document)}return i}function f_(e){var i=e&&e.nodeName&&e.nodeName.toLowerCase();return i&&("input"===i&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===i||"true"===e.contentEditable)}var b_=m&&"documentMode"in document&&11>=document.documentMode,p_=null,g_=null,E_=null,w_=!1;function h_(e,i,t){var _=t.window===t?t.document:9===t.nodeType?t:t.ownerDocument;w_||null==p_||p_!==J(_)||("selectionStart"in(_=p_)&&f_(_)?_={start:_.selectionStart,end:_.selectionEnd}:_={anchorNode:(_=(_.ownerDocument&&_.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:_.anchorOffset,focusNode:_.focusNode,focusOffset:_.focusOffset},E_&&o_(E_,_)||(E_=_,0<(_=I_(g_,"onSelect")).length&&(i=new mt("onSelect","select",null,i,t),e.push({event:i,listeners:_}),i.target=p_)))}Ui("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),0),Ui("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1),Ui(Wi,2);for(var x_="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),z_=0;z_<x_.length;z_++)Ti.set(x_[z_],0);o("onMouseEnter",["mouseout","mouseover"]),o("onMouseLeave",["mouseout","mouseover"]),o("onPointerEnter",["pointerout","pointerover"]),o("onPointerLeave",["pointerout","pointerover"]),d("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),d("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),d("onBeforeInput",["compositionend","keypress","textInput","paste"]),d("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),d("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),d("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var L_="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),M_=new Set("cancel close invalid load scroll toggle".split(" ").concat(L_));function R_(e,i,t){var _=e.type||"unknown-event";e.currentTarget=t,function(e,i,t,_,s,a,r,l,d){if(je.apply(this,arguments),ke){if(!ke)throw Error(n(198));var o=Ne;ke=!1,Ne=null,Ze||(Ze=!0,Ye=o)}}(_,i,void 0,e),e.currentTarget=null}function S_(e,i){i=0!==(4&i);for(var t=0;t<e.length;t++){var _=e[t],s=_.event;_=_.listeners;e:{var a=void 0;if(i)for(var n=_.length-1;0<=n;n--){var r=_[n],l=r.instance,d=r.currentTarget;if(r=r.listener,l!==a&&s.isPropagationStopped())break e;R_(s,r,d),a=l}else for(n=0;n<_.length;n++){if(l=(r=_[n]).instance,d=r.currentTarget,r=r.listener,l!==a&&s.isPropagationStopped())break e;R_(s,r,d),a=l}}}if(Ze)throw e=Ye,Ze=!1,Ye=null,e}function D_(e,i){var t=ss(i),_=e+"__bubble";t.has(_)||(T_(i,e,2,!1),t.add(_))}var y_="_reactListening"+Math.random().toString(36).slice(2);function V_(e){e[y_]||(e[y_]=!0,r.forEach((function(i){M_.has(i)||A_(i,!1,e,null),A_(i,!0,e,null)})))}function A_(e,i,t,_){var s=4<arguments.length&&void 0!==arguments[4]?arguments[4]:0,a=t;if("selectionchange"===e&&9!==t.nodeType&&(a=t.ownerDocument),null!==_&&!i&&M_.has(e)){if("scroll"!==e)return;s|=2,a=_}var n=ss(a),r=e+"__"+(i?"capture":"bubble");n.has(r)||(i&&(s|=4),T_(a,e,s,i),n.add(r))}function T_(e,i,t,_){var s=Ti.get(i);switch(void 0===s?2:s){case 0:s=Ki;break;case 1:s=Gi;break;default:s=Qi}t=s.bind(null,i,t,e),s=void 0,!Xe||"touchstart"!==i&&"touchmove"!==i&&"wheel"!==i||(s=!0),_?void 0!==s?e.addEventListener(i,t,{capture:!0,passive:s}):e.addEventListener(i,t,!0):void 0!==s?e.addEventListener(i,t,{passive:s}):e.addEventListener(i,t,!1)}function W_(e,i,t,_,s){var a=_;if(0===(1&i)&&0===(2&i)&&null!==_)e:for(;;){if(null===_)return;var n=_.tag;if(3===n||4===n){var r=_.stateNode.containerInfo;if(r===s||8===r.nodeType&&r.parentNode===s)break;if(4===n)for(n=_.return;null!==n;){var l=n.tag;if((3===l||4===l)&&((l=n.stateNode.containerInfo)===s||8===l.nodeType&&l.parentNode===s))return;n=n.return}for(;null!==r;){if(null===(n=es(r)))return;if(5===(l=n.tag)||6===l){_=a=n;continue e}r=r.parentNode}}_=_.return}!function(e,i,t){if(Oe)return e(i,t);Oe=!0;try{return Ie(e,i,t)}finally{Oe=!1,Fe()}}((function(){var _=a,s=Me(t),n=[];e:{var r=Ai.get(e);if(void 0!==r){var l=mt,d=e;switch(e){case"keypress":if(0===_t(t))break e;case"keydown":case"keyup":l=Dt;break;case"focusin":d="focus",l=pt;break;case"focusout":d="blur",l=pt;break;case"beforeblur":case"afterblur":l=pt;break;case"click":if(2===t.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=ft;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=bt;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=Vt;break;case Si:case Di:case yi:l=gt;break;case Vi:l=At;break;case"scroll":l=ct;break;case"wheel":l=Wt;break;case"copy":case"cut":case"paste":l=wt;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=yt}var o=0!==(4&i),m=!o&&"scroll"===e,v=o?null!==r?r+"Capture":null:r;o=[];for(var c,u=_;null!==u;){var f=(c=u).stateNode;if(5===c.tag&&null!==f&&(c=f,null!==v&&(null!=(f=qe(u,v))&&o.push(U_(u,f,c)))),m)break;u=u.return}0<o.length&&(r=new l(r,d,null,t,s),n.push({event:r,listeners:o}))}}if(0===(7&i)){if(l="mouseout"===e||"pointerout"===e,(!(r="mouseover"===e||"pointerover"===e)||0!==(16&i)||!(d=t.relatedTarget||t.fromElement)||!es(d)&&!d[J_])&&(l||r)&&(r=s.window===s?s:(r=s.ownerDocument)?r.defaultView||r.parentWindow:window,l?(l=_,null!==(d=(d=t.relatedTarget||t.toElement)?es(d):null)&&(d!==(m=Ke(d))||5!==d.tag&&6!==d.tag)&&(d=null)):(l=null,d=_),l!==d)){if(o=ft,f="onMouseLeave",v="onMouseEnter",u="mouse","pointerout"!==e&&"pointerover"!==e||(o=yt,f="onPointerLeave",v="onPointerEnter",u="pointer"),m=null==l?r:ts(l),c=null==d?r:ts(d),(r=new o(f,u+"leave",l,t,s)).target=m,r.relatedTarget=c,f=null,es(s)===_&&((o=new o(v,u+"enter",d,t,s)).target=c,o.relatedTarget=m,f=o),m=f,l&&d)e:{for(v=d,u=0,c=o=l;c;c=B_(c))u++;for(c=0,f=v;f;f=B_(f))c++;for(;0<u-c;)o=B_(o),u--;for(;0<c-u;)v=B_(v),c--;for(;u--;){if(o===v||null!==v&&o===v.alternate)break e;o=B_(o),v=B_(v)}o=null}else o=null;null!==l&&O_(n,r,l,o,!1),null!==d&&null!==m&&O_(n,m,d,o,!0)}if("select"===(l=(r=_?ts(_):window).nodeName&&r.nodeName.toLowerCase())||"input"===l&&"file"===r.type)var b=Qt;else if(Zt(r))if(Jt)b=r_;else{b=a_;var p=s_}else(l=r.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===r.type||"radio"===r.type)&&(b=n_);switch(b&&(b=b(e,_))?Yt(n,b,t,s):(p&&p(e,r,_),"focusout"===e&&(p=r._wrapperState)&&p.controlled&&"number"===r.type&&se(r,"number",r.value)),p=_?ts(_):window,e){case"focusin":(Zt(p)||"true"===p.contentEditable)&&(p_=p,g_=_,E_=null);break;case"focusout":E_=g_=p_=null;break;case"mousedown":w_=!0;break;case"contextmenu":case"mouseup":case"dragend":w_=!1,h_(n,t,s);break;case"selectionchange":if(b_)break;case"keydown":case"keyup":h_(n,t,s)}var g;if(It)e:{switch(e){case"compositionstart":var E="onCompositionStart";break e;case"compositionend":E="onCompositionEnd";break e;case"compositionupdate":E="onCompositionUpdate";break e}E=void 0}else kt?Ct(e,t)&&(E="onCompositionEnd"):"keydown"===e&&229===t.keyCode&&(E="onCompositionStart");E&&(Ft&&"ko"!==t.locale&&(kt||"onCompositionStart"!==E?"onCompositionEnd"===E&&kt&&(g=tt()):(et="value"in($i=s)?$i.value:$i.textContent,kt=!0)),0<(p=I_(_,E)).length&&(E=new ht(E,e,null,t,s),n.push({event:E,listeners:p}),g?E.data=g:null!==(g=Ht(t))&&(E.data=g))),(g=Ot?function(e,i){switch(e){case"compositionend":return Ht(i);case"keypress":return 32!==i.which?null:(Xt=!0,qt);case"textInput":return(e=i.data)===qt&&Xt?null:e;default:return null}}(e,t):function(e,i){if(kt)return"compositionend"===e||!It&&Ct(e,i)?(e=tt(),it=et=$i=null,kt=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(i.ctrlKey||i.altKey||i.metaKey)||i.ctrlKey&&i.altKey){if(i.char&&1<i.char.length)return i.char;if(i.which)return String.fromCharCode(i.which)}return null;case"compositionend":return Ft&&"ko"!==i.locale?null:i.data}}(e,t))&&(0<(_=I_(_,"onBeforeInput")).length&&(s=new ht("onBeforeInput","beforeinput",null,t,s),n.push({event:s,listeners:_}),s.data=g))}S_(n,i)}))}function U_(e,i,t){return{instance:e,listener:i,currentTarget:t}}function I_(e,i){for(var t=i+"Capture",_=[];null!==e;){var s=e,a=s.stateNode;5===s.tag&&null!==a&&(s=a,null!=(a=qe(e,t))&&_.unshift(U_(e,a,s)),null!=(a=qe(e,i))&&_.push(U_(e,a,s))),e=e.return}return _}function B_(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function O_(e,i,t,_,s){for(var a=i._reactName,n=[];null!==t&&t!==_;){var r=t,l=r.alternate,d=r.stateNode;if(null!==l&&l===_)break;5===r.tag&&null!==d&&(r=d,s?null!=(l=qe(t,a))&&n.unshift(U_(t,l,r)):s||null!=(l=qe(t,a))&&n.push(U_(t,l,r))),t=t.return}0!==n.length&&e.push({event:i,listeners:n})}function F_(){}var q_=null,X_=null;function C_(e,i){switch(e){case"button":case"input":case"select":case"textarea":return!!i.autoFocus}return!1}function H_(e,i){return"textarea"===e||"option"===e||"noscript"===e||"string"===typeof i.children||"number"===typeof i.children||"object"===typeof i.dangerouslySetInnerHTML&&null!==i.dangerouslySetInnerHTML&&null!=i.dangerouslySetInnerHTML.__html}var k_="function"===typeof setTimeout?setTimeout:void 0,N_="function"===typeof clearTimeout?clearTimeout:void 0;function Z_(e){1===e.nodeType?e.textContent="":9===e.nodeType&&(null!=(e=e.body)&&(e.textContent=""))}function Y_(e){for(;null!=e;e=e.nextSibling){var i=e.nodeType;if(1===i||3===i)break}return e}function P_(e){e=e.previousSibling;for(var i=0;e;){if(8===e.nodeType){var t=e.data;if("$"===t||"$!"===t||"$?"===t){if(0===i)return e;i--}else"/$"===t&&i++}e=e.previousSibling}return null}var j_=0;var K_=Math.random().toString(36).slice(2),G_="__reactFiber$"+K_,Q_="__reactProps$"+K_,J_="__reactContainer$"+K_,$_="__reactEvents$"+K_;function es(e){var i=e[G_];if(i)return i;for(var t=e.parentNode;t;){if(i=t[J_]||t[G_]){if(t=i.alternate,null!==i.child||null!==t&&null!==t.child)for(e=P_(e);null!==e;){if(t=e[G_])return t;e=P_(e)}return i}t=(e=t).parentNode}return null}function is(e){return!(e=e[G_]||e[J_])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function ts(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(n(33))}function _s(e){return e[Q_]||null}function ss(e){var i=e[$_];return void 0===i&&(i=e[$_]=new Set),i}var as=[],ns=-1;function rs(e){return{current:e}}function ls(e){0>ns||(e.current=as[ns],as[ns]=null,ns--)}function ds(e,i){ns++,as[ns]=e.current,e.current=i}var os={},ms=rs(os),vs=rs(!1),cs=os;function us(e,i){var t=e.type.contextTypes;if(!t)return os;var _=e.stateNode;if(_&&_.__reactInternalMemoizedUnmaskedChildContext===i)return _.__reactInternalMemoizedMaskedChildContext;var s,a={};for(s in t)a[s]=i[s];return _&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=i,e.__reactInternalMemoizedMaskedChildContext=a),a}function fs(e){return null!==(e=e.childContextTypes)&&void 0!==e}function bs(){ls(vs),ls(ms)}function ps(e,i,t){if(ms.current!==os)throw Error(n(168));ds(ms,i),ds(vs,t)}function gs(e,i,t){var _=e.stateNode;if(e=i.childContextTypes,"function"!==typeof _.getChildContext)return t;for(var a in _=_.getChildContext())if(!(a in e))throw Error(n(108,P(i)||"Unknown",a));return s({},t,_)}function Es(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||os,cs=ms.current,ds(ms,e),ds(vs,vs.current),!0}function ws(e,i,t){var _=e.stateNode;if(!_)throw Error(n(169));t?(e=gs(e,i,cs),_.__reactInternalMemoizedMergedChildContext=e,ls(vs),ls(ms),ds(ms,e)):ls(vs),ds(vs,t)}var hs=null,xs=null,zs=a.unstable_runWithPriority,Ls=a.unstable_scheduleCallback,Ms=a.unstable_cancelCallback,Rs=a.unstable_shouldYield,Ss=a.unstable_requestPaint,Ds=a.unstable_now,ys=a.unstable_getCurrentPriorityLevel,Vs=a.unstable_ImmediatePriority,As=a.unstable_UserBlockingPriority,Ts=a.unstable_NormalPriority,Ws=a.unstable_LowPriority,Us=a.unstable_IdlePriority,Is={},Bs=void 0!==Ss?Ss:function(){},Os=null,Fs=null,qs=!1,Xs=Ds(),Cs=1e4>Xs?Ds:function(){return Ds()-Xs};function Hs(){switch(ys()){case Vs:return 99;case As:return 98;case Ts:return 97;case Ws:return 96;case Us:return 95;default:throw Error(n(332))}}function ks(e){switch(e){case 99:return Vs;case 98:return As;case 97:return Ts;case 96:return Ws;case 95:return Us;default:throw Error(n(332))}}function Ns(e,i){return e=ks(e),zs(e,i)}function Zs(e,i,t){return e=ks(e),Ls(e,i,t)}function Ys(){if(null!==Fs){var e=Fs;Fs=null,Ms(e)}Ps()}function Ps(){if(!qs&&null!==Os){qs=!0;var e=0;try{var i=Os;Ns(99,(function(){for(;e<i.length;e++){var t=i[e];do{t=t(!0)}while(null!==t)}})),Os=null}catch(t){throw null!==Os&&(Os=Os.slice(e+1)),Ls(Vs,Ys),t}finally{qs=!1}}}var js=h.ReactCurrentBatchConfig;function Ks(e,i){if(e&&e.defaultProps){for(var t in i=s({},i),e=e.defaultProps)void 0===i[t]&&(i[t]=e[t]);return i}return i}var Gs=rs(null),Qs=null,Js=null,$s=null;function ea(){$s=Js=Qs=null}function ia(e){var i=Gs.current;ls(Gs),e.type._context._currentValue=i}function ta(e,i){for(;null!==e;){var t=e.alternate;if((e.childLanes&i)===i){if(null===t||(t.childLanes&i)===i)break;t.childLanes|=i}else e.childLanes|=i,null!==t&&(t.childLanes|=i);e=e.return}}function _a(e,i){Qs=e,$s=Js=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&i)&&(In=!0),e.firstContext=null)}function sa(e,i){if($s!==e&&!1!==i&&0!==i)if("number"===typeof i&&1073741823!==i||($s=e,i=1073741823),i={context:e,observedBits:i,next:null},null===Js){if(null===Qs)throw Error(n(308));Js=i,Qs.dependencies={lanes:0,firstContext:i,responders:null}}else Js=Js.next=i;return e._currentValue}var aa=!1;function na(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null},effects:null}}function ra(e,i){e=e.updateQueue,i.updateQueue===e&&(i.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function la(e,i){return{eventTime:e,lane:i,tag:0,payload:null,callback:null,next:null}}function da(e,i){if(null!==(e=e.updateQueue)){var t=(e=e.shared).pending;null===t?i.next=i:(i.next=t.next,t.next=i),e.pending=i}}function oa(e,i){var t=e.updateQueue,_=e.alternate;if(null!==_&&t===(_=_.updateQueue)){var s=null,a=null;if(null!==(t=t.firstBaseUpdate)){do{var n={eventTime:t.eventTime,lane:t.lane,tag:t.tag,payload:t.payload,callback:t.callback,next:null};null===a?s=a=n:a=a.next=n,t=t.next}while(null!==t);null===a?s=a=i:a=a.next=i}else s=a=i;return t={baseState:_.baseState,firstBaseUpdate:s,lastBaseUpdate:a,shared:_.shared,effects:_.effects},void(e.updateQueue=t)}null===(e=t.lastBaseUpdate)?t.firstBaseUpdate=i:e.next=i,t.lastBaseUpdate=i}function ma(e,i,t,_){var a=e.updateQueue;aa=!1;var n=a.firstBaseUpdate,r=a.lastBaseUpdate,l=a.shared.pending;if(null!==l){a.shared.pending=null;var d=l,o=d.next;d.next=null,null===r?n=o:r.next=o,r=d;var m=e.alternate;if(null!==m){var v=(m=m.updateQueue).lastBaseUpdate;v!==r&&(null===v?m.firstBaseUpdate=o:v.next=o,m.lastBaseUpdate=d)}}if(null!==n){for(v=a.baseState,r=0,m=o=d=null;;){l=n.lane;var c=n.eventTime;if((_&l)===l){null!==m&&(m=m.next={eventTime:c,lane:0,tag:n.tag,payload:n.payload,callback:n.callback,next:null});e:{var u=e,f=n;switch(l=i,c=t,f.tag){case 1:if("function"===typeof(u=f.payload)){v=u.call(c,v,l);break e}v=u;break e;case 3:u.flags=-4097&u.flags|64;case 0:if(null===(l="function"===typeof(u=f.payload)?u.call(c,v,l):u)||void 0===l)break e;v=s({},v,l);break e;case 2:aa=!0}}null!==n.callback&&(e.flags|=32,null===(l=a.effects)?a.effects=[n]:l.push(n))}else c={eventTime:c,lane:l,tag:n.tag,payload:n.payload,callback:n.callback,next:null},null===m?(o=m=c,d=v):m=m.next=c,r|=l;if(null===(n=n.next)){if(null===(l=a.shared.pending))break;n=l.next,l.next=null,a.lastBaseUpdate=l,a.shared.pending=null}}null===m&&(d=v),a.baseState=d,a.firstBaseUpdate=o,a.lastBaseUpdate=m,Xr|=r,e.lanes=r,e.memoizedState=v}}function va(e,i,t){if(e=i.effects,i.effects=null,null!==e)for(i=0;i<e.length;i++){var _=e[i],s=_.callback;if(null!==s){if(_.callback=null,_=t,"function"!==typeof s)throw Error(n(191,s));s.call(_)}}}var ca=(new _.Component).refs;function ua(e,i,t,_){t=null===(t=t(_,i=e.memoizedState))||void 0===t?i:s({},i,t),e.memoizedState=t,0===e.lanes&&(e.updateQueue.baseState=t)}var fa={isMounted:function(e){return!!(e=e._reactInternals)&&Ke(e)===e},enqueueSetState:function(e,i,t){e=e._reactInternals;var _=ml(),s=vl(e),a=la(_,s);a.payload=i,void 0!==t&&null!==t&&(a.callback=t),da(e,a),cl(e,s,_)},enqueueReplaceState:function(e,i,t){e=e._reactInternals;var _=ml(),s=vl(e),a=la(_,s);a.tag=1,a.payload=i,void 0!==t&&null!==t&&(a.callback=t),da(e,a),cl(e,s,_)},enqueueForceUpdate:function(e,i){e=e._reactInternals;var t=ml(),_=vl(e),s=la(t,_);s.tag=2,void 0!==i&&null!==i&&(s.callback=i),da(e,s),cl(e,_,t)}};function ba(e,i,t,_,s,a,n){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(_,a,n):!i.prototype||!i.prototype.isPureReactComponent||(!o_(t,_)||!o_(s,a))}function pa(e,i,t){var _=!1,s=os,a=i.contextType;return"object"===typeof a&&null!==a?a=sa(a):(s=fs(i)?cs:ms.current,a=(_=null!==(_=i.contextTypes)&&void 0!==_)?us(e,s):os),i=new i(t,a),e.memoizedState=null!==i.state&&void 0!==i.state?i.state:null,i.updater=fa,e.stateNode=i,i._reactInternals=e,_&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=s,e.__reactInternalMemoizedMaskedChildContext=a),i}function ga(e,i,t,_){e=i.state,"function"===typeof i.componentWillReceiveProps&&i.componentWillReceiveProps(t,_),"function"===typeof i.UNSAFE_componentWillReceiveProps&&i.UNSAFE_componentWillReceiveProps(t,_),i.state!==e&&fa.enqueueReplaceState(i,i.state,null)}function Ea(e,i,t,_){var s=e.stateNode;s.props=t,s.state=e.memoizedState,s.refs=ca,na(e);var a=i.contextType;"object"===typeof a&&null!==a?s.context=sa(a):(a=fs(i)?cs:ms.current,s.context=us(e,a)),ma(e,t,s,_),s.state=e.memoizedState,"function"===typeof(a=i.getDerivedStateFromProps)&&(ua(e,i,a,t),s.state=e.memoizedState),"function"===typeof i.getDerivedStateFromProps||"function"===typeof s.getSnapshotBeforeUpdate||"function"!==typeof s.UNSAFE_componentWillMount&&"function"!==typeof s.componentWillMount||(i=s.state,"function"===typeof s.componentWillMount&&s.componentWillMount(),"function"===typeof s.UNSAFE_componentWillMount&&s.UNSAFE_componentWillMount(),i!==s.state&&fa.enqueueReplaceState(s,s.state,null),ma(e,t,s,_),s.state=e.memoizedState),"function"===typeof s.componentDidMount&&(e.flags|=4)}var wa=Array.isArray;function ha(e,i,t){if(null!==(e=t.ref)&&"function"!==typeof e&&"object"!==typeof e){if(t._owner){if(t=t._owner){if(1!==t.tag)throw Error(n(309));var _=t.stateNode}if(!_)throw Error(n(147,e));var s=""+e;return null!==i&&null!==i.ref&&"function"===typeof i.ref&&i.ref._stringRef===s?i.ref:(i=function(e){var i=_.refs;i===ca&&(i=_.refs={}),null===e?delete i[s]:i[s]=e},i._stringRef=s,i)}if("string"!==typeof e)throw Error(n(284));if(!t._owner)throw Error(n(290,e))}return e}function xa(e,i){if("textarea"!==e.type)throw Error(n(31,"[object Object]"===Object.prototype.toString.call(i)?"object with keys {"+Object.keys(i).join(", ")+"}":i))}function za(e){function i(i,t){if(e){var _=i.lastEffect;null!==_?(_.nextEffect=t,i.lastEffect=t):i.firstEffect=i.lastEffect=t,t.nextEffect=null,t.flags=8}}function t(t,_){if(!e)return null;for(;null!==_;)i(t,_),_=_.sibling;return null}function _(e,i){for(e=new Map;null!==i;)null!==i.key?e.set(i.key,i):e.set(i.index,i),i=i.sibling;return e}function s(e,i){return(e=Zl(e,i)).index=0,e.sibling=null,e}function a(i,t,_){return i.index=_,e?null!==(_=i.alternate)?(_=_.index)<t?(i.flags=2,t):_:(i.flags=2,t):t}function r(i){return e&&null===i.alternate&&(i.flags=2),i}function l(e,i,t,_){return null===i||6!==i.tag?((i=Kl(t,e.mode,_)).return=e,i):((i=s(i,t)).return=e,i)}function d(e,i,t,_){return null!==i&&i.elementType===t.type?((_=s(i,t.props)).ref=ha(e,i,t),_.return=e,_):((_=Yl(t.type,t.key,t.props,null,e.mode,_)).ref=ha(e,i,t),_.return=e,_)}function o(e,i,t,_){return null===i||4!==i.tag||i.stateNode.containerInfo!==t.containerInfo||i.stateNode.implementation!==t.implementation?((i=Gl(t,e.mode,_)).return=e,i):((i=s(i,t.children||[])).return=e,i)}function m(e,i,t,_,a){return null===i||7!==i.tag?((i=Pl(t,e.mode,_,a)).return=e,i):((i=s(i,t)).return=e,i)}function v(e,i,t){if("string"===typeof i||"number"===typeof i)return(i=Kl(""+i,e.mode,t)).return=e,i;if("object"===typeof i&&null!==i){switch(i.$$typeof){case x:return(t=Yl(i.type,i.key,i.props,null,e.mode,t)).ref=ha(e,null,i),t.return=e,t;case z:return(i=Gl(i,e.mode,t)).return=e,i}if(wa(i)||H(i))return(i=Pl(i,e.mode,t,null)).return=e,i;xa(e,i)}return null}function c(e,i,t,_){var s=null!==i?i.key:null;if("string"===typeof t||"number"===typeof t)return null!==s?null:l(e,i,""+t,_);if("object"===typeof t&&null!==t){switch(t.$$typeof){case x:return t.key===s?t.type===L?m(e,i,t.props.children,_,s):d(e,i,t,_):null;case z:return t.key===s?o(e,i,t,_):null}if(wa(t)||H(t))return null!==s?null:m(e,i,t,_,null);xa(e,t)}return null}function u(e,i,t,_,s){if("string"===typeof _||"number"===typeof _)return l(i,e=e.get(t)||null,""+_,s);if("object"===typeof _&&null!==_){switch(_.$$typeof){case x:return e=e.get(null===_.key?t:_.key)||null,_.type===L?m(i,e,_.props.children,s,_.key):d(i,e,_,s);case z:return o(i,e=e.get(null===_.key?t:_.key)||null,_,s)}if(wa(_)||H(_))return m(i,e=e.get(t)||null,_,s,null);xa(i,_)}return null}function f(s,n,r,l){for(var d=null,o=null,m=n,f=n=0,b=null;null!==m&&f<r.length;f++){m.index>f?(b=m,m=null):b=m.sibling;var p=c(s,m,r[f],l);if(null===p){null===m&&(m=b);break}e&&m&&null===p.alternate&&i(s,m),n=a(p,n,f),null===o?d=p:o.sibling=p,o=p,m=b}if(f===r.length)return t(s,m),d;if(null===m){for(;f<r.length;f++)null!==(m=v(s,r[f],l))&&(n=a(m,n,f),null===o?d=m:o.sibling=m,o=m);return d}for(m=_(s,m);f<r.length;f++)null!==(b=u(m,s,f,r[f],l))&&(e&&null!==b.alternate&&m.delete(null===b.key?f:b.key),n=a(b,n,f),null===o?d=b:o.sibling=b,o=b);return e&&m.forEach((function(e){return i(s,e)})),d}function b(s,r,l,d){var o=H(l);if("function"!==typeof o)throw Error(n(150));if(null==(l=o.call(l)))throw Error(n(151));for(var m=o=null,f=r,b=r=0,p=null,g=l.next();null!==f&&!g.done;b++,g=l.next()){f.index>b?(p=f,f=null):p=f.sibling;var E=c(s,f,g.value,d);if(null===E){null===f&&(f=p);break}e&&f&&null===E.alternate&&i(s,f),r=a(E,r,b),null===m?o=E:m.sibling=E,m=E,f=p}if(g.done)return t(s,f),o;if(null===f){for(;!g.done;b++,g=l.next())null!==(g=v(s,g.value,d))&&(r=a(g,r,b),null===m?o=g:m.sibling=g,m=g);return o}for(f=_(s,f);!g.done;b++,g=l.next())null!==(g=u(f,s,b,g.value,d))&&(e&&null!==g.alternate&&f.delete(null===g.key?b:g.key),r=a(g,r,b),null===m?o=g:m.sibling=g,m=g);return e&&f.forEach((function(e){return i(s,e)})),o}return function(e,_,a,l){var d="object"===typeof a&&null!==a&&a.type===L&&null===a.key;d&&(a=a.props.children);var o="object"===typeof a&&null!==a;if(o)switch(a.$$typeof){case x:e:{for(o=a.key,d=_;null!==d;){if(d.key===o){if(7===d.tag){if(a.type===L){t(e,d.sibling),(_=s(d,a.props.children)).return=e,e=_;break e}}else if(d.elementType===a.type){t(e,d.sibling),(_=s(d,a.props)).ref=ha(e,d,a),_.return=e,e=_;break e}t(e,d);break}i(e,d),d=d.sibling}a.type===L?((_=Pl(a.props.children,e.mode,l,a.key)).return=e,e=_):((l=Yl(a.type,a.key,a.props,null,e.mode,l)).ref=ha(e,_,a),l.return=e,e=l)}return r(e);case z:e:{for(d=a.key;null!==_;){if(_.key===d){if(4===_.tag&&_.stateNode.containerInfo===a.containerInfo&&_.stateNode.implementation===a.implementation){t(e,_.sibling),(_=s(_,a.children||[])).return=e,e=_;break e}t(e,_);break}i(e,_),_=_.sibling}(_=Gl(a,e.mode,l)).return=e,e=_}return r(e)}if("string"===typeof a||"number"===typeof a)return a=""+a,null!==_&&6===_.tag?(t(e,_.sibling),(_=s(_,a)).return=e,e=_):(t(e,_),(_=Kl(a,e.mode,l)).return=e,e=_),r(e);if(wa(a))return f(e,_,a,l);if(H(a))return b(e,_,a,l);if(o&&xa(e,a),"undefined"===typeof a&&!d)switch(e.tag){case 1:case 22:case 0:case 11:case 15:throw Error(n(152,P(e.type)||"Component"))}return t(e,_)}}var La=za(!0),Ma=za(!1),Ra={},Sa=rs(Ra),Da=rs(Ra),ya=rs(Ra);function Va(e){if(e===Ra)throw Error(n(174));return e}function Aa(e,i){switch(ds(ya,i),ds(Da,e),ds(Sa,Ra),e=i.nodeType){case 9:case 11:i=(i=i.documentElement)?i.namespaceURI:ce(null,"");break;default:i=ce(i=(e=8===e?i.parentNode:i).namespaceURI||null,e=e.tagName)}ls(Sa),ds(Sa,i)}function Ta(){ls(Sa),ls(Da),ls(ya)}function Wa(e){Va(ya.current);var i=Va(Sa.current),t=ce(i,e.type);i!==t&&(ds(Da,e),ds(Sa,t))}function Ua(e){Da.current===e&&(ls(Sa),ls(Da))}var Ia=rs(0);function Ba(e){for(var i=e;null!==i;){if(13===i.tag){var t=i.memoizedState;if(null!==t&&(null===(t=t.dehydrated)||"$?"===t.data||"$!"===t.data))return i}else if(19===i.tag&&void 0!==i.memoizedProps.revealOrder){if(0!==(64&i.flags))return i}else if(null!==i.child){i.child.return=i,i=i.child;continue}if(i===e)break;for(;null===i.sibling;){if(null===i.return||i.return===e)return null;i=i.return}i.sibling.return=i.return,i=i.sibling}return null}var Oa=null,Fa=null,qa=!1;function Xa(e,i){var t=kl(5,null,null,0);t.elementType="DELETED",t.type="DELETED",t.stateNode=i,t.return=e,t.flags=8,null!==e.lastEffect?(e.lastEffect.nextEffect=t,e.lastEffect=t):e.firstEffect=e.lastEffect=t}function Ca(e,i){switch(e.tag){case 5:var t=e.type;return null!==(i=1!==i.nodeType||t.toLowerCase()!==i.nodeName.toLowerCase()?null:i)&&(e.stateNode=i,!0);case 6:return null!==(i=""===e.pendingProps||3!==i.nodeType?null:i)&&(e.stateNode=i,!0);default:return!1}}function Ha(e){if(qa){var i=Fa;if(i){var t=i;if(!Ca(e,i)){if(!(i=Y_(t.nextSibling))||!Ca(e,i))return e.flags=-1025&e.flags|2,qa=!1,void(Oa=e);Xa(Oa,t)}Oa=e,Fa=Y_(i.firstChild)}else e.flags=-1025&e.flags|2,qa=!1,Oa=e}}function ka(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;Oa=e}function Na(e){if(e!==Oa)return!1;if(!qa)return ka(e),qa=!0,!1;var i=e.type;if(5!==e.tag||"head"!==i&&"body"!==i&&!H_(i,e.memoizedProps))for(i=Fa;i;)Xa(e,i),i=Y_(i.nextSibling);if(ka(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(n(317));e:{for(e=e.nextSibling,i=0;e;){if(8===e.nodeType){var t=e.data;if("/$"===t){if(0===i){Fa=Y_(e.nextSibling);break e}i--}else"$"!==t&&"$!"!==t&&"$?"!==t||i++}e=e.nextSibling}Fa=null}}else Fa=Oa?Y_(e.stateNode.nextSibling):null;return!0}function Za(){Fa=Oa=null,qa=!1}var Ya=[];function Pa(){for(var e=0;e<Ya.length;e++)Ya[e]._workInProgressVersionPrimary=null;Ya.length=0}var ja=h.ReactCurrentDispatcher,Ka=h.ReactCurrentBatchConfig,Ga=0,Qa=null,Ja=null,$a=null,en=!1,tn=!1;function _n(){throw Error(n(321))}function sn(e,i){if(null===i)return!1;for(var t=0;t<i.length&&t<e.length;t++)if(!l_(e[t],i[t]))return!1;return!0}function an(e,i,t,_,s,a){if(Ga=a,Qa=i,i.memoizedState=null,i.updateQueue=null,i.lanes=0,ja.current=null===e||null===e.memoizedState?An:Tn,e=t(_,s),tn){a=0;do{if(tn=!1,!(25>a))throw Error(n(301));a+=1,$a=Ja=null,i.updateQueue=null,ja.current=Wn,e=t(_,s)}while(tn)}if(ja.current=Vn,i=null!==Ja&&null!==Ja.next,Ga=0,$a=Ja=Qa=null,en=!1,i)throw Error(n(300));return e}function nn(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===$a?Qa.memoizedState=$a=e:$a=$a.next=e,$a}function rn(){if(null===Ja){var e=Qa.alternate;e=null!==e?e.memoizedState:null}else e=Ja.next;var i=null===$a?Qa.memoizedState:$a.next;if(null!==i)$a=i,Ja=e;else{if(null===e)throw Error(n(310));e={memoizedState:(Ja=e).memoizedState,baseState:Ja.baseState,baseQueue:Ja.baseQueue,queue:Ja.queue,next:null},null===$a?Qa.memoizedState=$a=e:$a=$a.next=e}return $a}function ln(e,i){return"function"===typeof i?i(e):i}function dn(e){var i=rn(),t=i.queue;if(null===t)throw Error(n(311));t.lastRenderedReducer=e;var _=Ja,s=_.baseQueue,a=t.pending;if(null!==a){if(null!==s){var r=s.next;s.next=a.next,a.next=r}_.baseQueue=s=a,t.pending=null}if(null!==s){s=s.next,_=_.baseState;var l=r=a=null,d=s;do{var o=d.lane;if((Ga&o)===o)null!==l&&(l=l.next={lane:0,action:d.action,eagerReducer:d.eagerReducer,eagerState:d.eagerState,next:null}),_=d.eagerReducer===e?d.eagerState:e(_,d.action);else{var m={lane:o,action:d.action,eagerReducer:d.eagerReducer,eagerState:d.eagerState,next:null};null===l?(r=l=m,a=_):l=l.next=m,Qa.lanes|=o,Xr|=o}d=d.next}while(null!==d&&d!==s);null===l?a=_:l.next=r,l_(_,i.memoizedState)||(In=!0),i.memoizedState=_,i.baseState=a,i.baseQueue=l,t.lastRenderedState=_}return[i.memoizedState,t.dispatch]}function on(e){var i=rn(),t=i.queue;if(null===t)throw Error(n(311));t.lastRenderedReducer=e;var _=t.dispatch,s=t.pending,a=i.memoizedState;if(null!==s){t.pending=null;var r=s=s.next;do{a=e(a,r.action),r=r.next}while(r!==s);l_(a,i.memoizedState)||(In=!0),i.memoizedState=a,null===i.baseQueue&&(i.baseState=a),t.lastRenderedState=a}return[a,_]}function mn(e,i,t){var _=i._getVersion;_=_(i._source);var s=i._workInProgressVersionPrimary;if(null!==s?e=s===_:(e=e.mutableReadLanes,(e=(Ga&e)===e)&&(i._workInProgressVersionPrimary=_,Ya.push(i))),e)return t(i._source);throw Ya.push(i),Error(n(350))}function vn(e,i,t,_){var s=Tr;if(null===s)throw Error(n(349));var a=i._getVersion,r=a(i._source),l=ja.current,d=l.useState((function(){return mn(s,i,t)})),o=d[1],m=d[0];d=$a;var v=e.memoizedState,c=v.refs,u=c.getSnapshot,f=v.source;v=v.subscribe;var b=Qa;return e.memoizedState={refs:c,source:i,subscribe:_},l.useEffect((function(){c.getSnapshot=t,c.setSnapshot=o;var e=a(i._source);if(!l_(r,e)){e=t(i._source),l_(m,e)||(o(e),e=vl(b),s.mutableReadLanes|=e&s.pendingLanes),e=s.mutableReadLanes,s.entangledLanes|=e;for(var _=s.entanglements,n=e;0<n;){var l=31-ki(n),d=1<<l;_[l]|=e,n&=~d}}}),[t,i,_]),l.useEffect((function(){return _(i._source,(function(){var e=c.getSnapshot,t=c.setSnapshot;try{t(e(i._source));var _=vl(b);s.mutableReadLanes|=_&s.pendingLanes}catch(a){t((function(){throw a}))}}))}),[i,_]),l_(u,t)&&l_(f,i)&&l_(v,_)||((e={pending:null,dispatch:null,lastRenderedReducer:ln,lastRenderedState:m}).dispatch=o=yn.bind(null,Qa,e),d.queue=e,d.baseQueue=null,m=mn(s,i,t),d.memoizedState=d.baseState=m),m}function cn(e,i,t){return vn(rn(),e,i,t)}function un(e){var i=nn();return"function"===typeof e&&(e=e()),i.memoizedState=i.baseState=e,e=(e=i.queue={pending:null,dispatch:null,lastRenderedReducer:ln,lastRenderedState:e}).dispatch=yn.bind(null,Qa,e),[i.memoizedState,e]}function fn(e,i,t,_){return e={tag:e,create:i,destroy:t,deps:_,next:null},null===(i=Qa.updateQueue)?(i={lastEffect:null},Qa.updateQueue=i,i.lastEffect=e.next=e):null===(t=i.lastEffect)?i.lastEffect=e.next=e:(_=t.next,t.next=e,e.next=_,i.lastEffect=e),e}function bn(e){return e={current:e},nn().memoizedState=e}function pn(){return rn().memoizedState}function gn(e,i,t,_){var s=nn();Qa.flags|=e,s.memoizedState=fn(1|i,t,void 0,void 0===_?null:_)}function En(e,i,t,_){var s=rn();_=void 0===_?null:_;var a=void 0;if(null!==Ja){var n=Ja.memoizedState;if(a=n.destroy,null!==_&&sn(_,n.deps))return void fn(i,t,a,_)}Qa.flags|=e,s.memoizedState=fn(1|i,t,a,_)}function wn(e,i){return gn(516,4,e,i)}function hn(e,i){return En(516,4,e,i)}function xn(e,i){return En(4,2,e,i)}function zn(e,i){return"function"===typeof i?(e=e(),i(e),function(){i(null)}):null!==i&&void 0!==i?(e=e(),i.current=e,function(){i.current=null}):void 0}function Ln(e,i,t){return t=null!==t&&void 0!==t?t.concat([e]):null,En(4,2,zn.bind(null,i,e),t)}function Mn(){}function Rn(e,i){var t=rn();i=void 0===i?null:i;var _=t.memoizedState;return null!==_&&null!==i&&sn(i,_[1])?_[0]:(t.memoizedState=[e,i],e)}function Sn(e,i){var t=rn();i=void 0===i?null:i;var _=t.memoizedState;return null!==_&&null!==i&&sn(i,_[1])?_[0]:(e=e(),t.memoizedState=[e,i],e)}function Dn(e,i){var t=Hs();Ns(98>t?98:t,(function(){e(!0)})),Ns(97<t?97:t,(function(){var t=Ka.transition;Ka.transition=1;try{e(!1),i()}finally{Ka.transition=t}}))}function yn(e,i,t){var _=ml(),s=vl(e),a={lane:s,action:t,eagerReducer:null,eagerState:null,next:null},n=i.pending;if(null===n?a.next=a:(a.next=n.next,n.next=a),i.pending=a,n=e.alternate,e===Qa||null!==n&&n===Qa)tn=en=!0;else{if(0===e.lanes&&(null===n||0===n.lanes)&&null!==(n=i.lastRenderedReducer))try{var r=i.lastRenderedState,l=n(r,t);if(a.eagerReducer=n,a.eagerState=l,l_(l,r))return}catch(d){}cl(e,s,_)}}var Vn={readContext:sa,useCallback:_n,useContext:_n,useEffect:_n,useImperativeHandle:_n,useLayoutEffect:_n,useMemo:_n,useReducer:_n,useRef:_n,useState:_n,useDebugValue:_n,useDeferredValue:_n,useTransition:_n,useMutableSource:_n,useOpaqueIdentifier:_n,unstable_isNewReconciler:!1},An={readContext:sa,useCallback:function(e,i){return nn().memoizedState=[e,void 0===i?null:i],e},useContext:sa,useEffect:wn,useImperativeHandle:function(e,i,t){return t=null!==t&&void 0!==t?t.concat([e]):null,gn(4,2,zn.bind(null,i,e),t)},useLayoutEffect:function(e,i){return gn(4,2,e,i)},useMemo:function(e,i){var t=nn();return i=void 0===i?null:i,e=e(),t.memoizedState=[e,i],e},useReducer:function(e,i,t){var _=nn();return i=void 0!==t?t(i):i,_.memoizedState=_.baseState=i,e=(e=_.queue={pending:null,dispatch:null,lastRenderedReducer:e,lastRenderedState:i}).dispatch=yn.bind(null,Qa,e),[_.memoizedState,e]},useRef:bn,useState:un,useDebugValue:Mn,useDeferredValue:function(e){var i=un(e),t=i[0],_=i[1];return wn((function(){var i=Ka.transition;Ka.transition=1;try{_(e)}finally{Ka.transition=i}}),[e]),t},useTransition:function(){var e=un(!1),i=e[0];return bn(e=Dn.bind(null,e[1])),[e,i]},useMutableSource:function(e,i,t){var _=nn();return _.memoizedState={refs:{getSnapshot:i,setSnapshot:null},source:e,subscribe:t},vn(_,e,i,t)},useOpaqueIdentifier:function(){if(qa){var e=!1,i=function(e){return{$$typeof:I,toString:e,valueOf:e}}((function(){throw e||(e=!0,t("r:"+(j_++).toString(36))),Error(n(355))})),t=un(i)[1];return 0===(2&Qa.mode)&&(Qa.flags|=516,fn(5,(function(){t("r:"+(j_++).toString(36))}),void 0,null)),i}return un(i="r:"+(j_++).toString(36)),i},unstable_isNewReconciler:!1},Tn={readContext:sa,useCallback:Rn,useContext:sa,useEffect:hn,useImperativeHandle:Ln,useLayoutEffect:xn,useMemo:Sn,useReducer:dn,useRef:pn,useState:function(){return dn(ln)},useDebugValue:Mn,useDeferredValue:function(e){var i=dn(ln),t=i[0],_=i[1];return hn((function(){var i=Ka.transition;Ka.transition=1;try{_(e)}finally{Ka.transition=i}}),[e]),t},useTransition:function(){var e=dn(ln)[0];return[pn().current,e]},useMutableSource:cn,useOpaqueIdentifier:function(){return dn(ln)[0]},unstable_isNewReconciler:!1},Wn={readContext:sa,useCallback:Rn,useContext:sa,useEffect:hn,useImperativeHandle:Ln,useLayoutEffect:xn,useMemo:Sn,useReducer:on,useRef:pn,useState:function(){return on(ln)},useDebugValue:Mn,useDeferredValue:function(e){var i=on(ln),t=i[0],_=i[1];return hn((function(){var i=Ka.transition;Ka.transition=1;try{_(e)}finally{Ka.transition=i}}),[e]),t},useTransition:function(){var e=on(ln)[0];return[pn().current,e]},useMutableSource:cn,useOpaqueIdentifier:function(){return on(ln)[0]},unstable_isNewReconciler:!1},Un=h.ReactCurrentOwner,In=!1;function Bn(e,i,t,_){i.child=null===e?Ma(i,null,t,_):La(i,e.child,t,_)}function On(e,i,t,_,s){t=t.render;var a=i.ref;return _a(i,s),_=an(e,i,t,_,a,s),null===e||In?(i.flags|=1,Bn(e,i,_,s),i.child):(i.updateQueue=e.updateQueue,i.flags&=-517,e.lanes&=~s,sr(e,i,s))}function Fn(e,i,t,_,s,a){if(null===e){var n=t.type;return"function"!==typeof n||Nl(n)||void 0!==n.defaultProps||null!==t.compare||void 0!==t.defaultProps?((e=Yl(t.type,null,_,i,i.mode,a)).ref=i.ref,e.return=i,i.child=e):(i.tag=15,i.type=n,qn(e,i,n,_,s,a))}return n=e.child,0===(s&a)&&(s=n.memoizedProps,(t=null!==(t=t.compare)?t:o_)(s,_)&&e.ref===i.ref)?sr(e,i,a):(i.flags|=1,(e=Zl(n,_)).ref=i.ref,e.return=i,i.child=e)}function qn(e,i,t,_,s,a){if(null!==e&&o_(e.memoizedProps,_)&&e.ref===i.ref){if(In=!1,0===(a&s))return i.lanes=e.lanes,sr(e,i,a);0!==(16384&e.flags)&&(In=!0)}return Hn(e,i,t,_,a)}function Xn(e,i,t){var _=i.pendingProps,s=_.children,a=null!==e?e.memoizedState:null;if("hidden"===_.mode||"unstable-defer-without-hiding"===_.mode)if(0===(4&i.mode))i.memoizedState={baseLanes:0},hl(i,t);else{if(0===(1073741824&t))return e=null!==a?a.baseLanes|t:t,i.lanes=i.childLanes=1073741824,i.memoizedState={baseLanes:e},hl(i,e),null;i.memoizedState={baseLanes:0},hl(i,null!==a?a.baseLanes:t)}else null!==a?(_=a.baseLanes|t,i.memoizedState=null):_=t,hl(i,_);return Bn(e,i,s,t),i.child}function Cn(e,i){var t=i.ref;(null===e&&null!==t||null!==e&&e.ref!==t)&&(i.flags|=128)}function Hn(e,i,t,_,s){var a=fs(t)?cs:ms.current;return a=us(i,a),_a(i,s),t=an(e,i,t,_,a,s),null===e||In?(i.flags|=1,Bn(e,i,t,s),i.child):(i.updateQueue=e.updateQueue,i.flags&=-517,e.lanes&=~s,sr(e,i,s))}function kn(e,i,t,_,s){if(fs(t)){var a=!0;Es(i)}else a=!1;if(_a(i,s),null===i.stateNode)null!==e&&(e.alternate=null,i.alternate=null,i.flags|=2),pa(i,t,_),Ea(i,t,_,s),_=!0;else if(null===e){var n=i.stateNode,r=i.memoizedProps;n.props=r;var l=n.context,d=t.contextType;"object"===typeof d&&null!==d?d=sa(d):d=us(i,d=fs(t)?cs:ms.current);var o=t.getDerivedStateFromProps,m="function"===typeof o||"function"===typeof n.getSnapshotBeforeUpdate;m||"function"!==typeof n.UNSAFE_componentWillReceiveProps&&"function"!==typeof n.componentWillReceiveProps||(r!==_||l!==d)&&ga(i,n,_,d),aa=!1;var v=i.memoizedState;n.state=v,ma(i,_,n,s),l=i.memoizedState,r!==_||v!==l||vs.current||aa?("function"===typeof o&&(ua(i,t,o,_),l=i.memoizedState),(r=aa||ba(i,t,r,_,v,l,d))?(m||"function"!==typeof n.UNSAFE_componentWillMount&&"function"!==typeof n.componentWillMount||("function"===typeof n.componentWillMount&&n.componentWillMount(),"function"===typeof n.UNSAFE_componentWillMount&&n.UNSAFE_componentWillMount()),"function"===typeof n.componentDidMount&&(i.flags|=4)):("function"===typeof n.componentDidMount&&(i.flags|=4),i.memoizedProps=_,i.memoizedState=l),n.props=_,n.state=l,n.context=d,_=r):("function"===typeof n.componentDidMount&&(i.flags|=4),_=!1)}else{n=i.stateNode,ra(e,i),r=i.memoizedProps,d=i.type===i.elementType?r:Ks(i.type,r),n.props=d,m=i.pendingProps,v=n.context,"object"===typeof(l=t.contextType)&&null!==l?l=sa(l):l=us(i,l=fs(t)?cs:ms.current);var c=t.getDerivedStateFromProps;(o="function"===typeof c||"function"===typeof n.getSnapshotBeforeUpdate)||"function"!==typeof n.UNSAFE_componentWillReceiveProps&&"function"!==typeof n.componentWillReceiveProps||(r!==m||v!==l)&&ga(i,n,_,l),aa=!1,v=i.memoizedState,n.state=v,ma(i,_,n,s);var u=i.memoizedState;r!==m||v!==u||vs.current||aa?("function"===typeof c&&(ua(i,t,c,_),u=i.memoizedState),(d=aa||ba(i,t,d,_,v,u,l))?(o||"function"!==typeof n.UNSAFE_componentWillUpdate&&"function"!==typeof n.componentWillUpdate||("function"===typeof n.componentWillUpdate&&n.componentWillUpdate(_,u,l),"function"===typeof n.UNSAFE_componentWillUpdate&&n.UNSAFE_componentWillUpdate(_,u,l)),"function"===typeof n.componentDidUpdate&&(i.flags|=4),"function"===typeof n.getSnapshotBeforeUpdate&&(i.flags|=256)):("function"!==typeof n.componentDidUpdate||r===e.memoizedProps&&v===e.memoizedState||(i.flags|=4),"function"!==typeof n.getSnapshotBeforeUpdate||r===e.memoizedProps&&v===e.memoizedState||(i.flags|=256),i.memoizedProps=_,i.memoizedState=u),n.props=_,n.state=u,n.context=l,_=d):("function"!==typeof n.componentDidUpdate||r===e.memoizedProps&&v===e.memoizedState||(i.flags|=4),"function"!==typeof n.getSnapshotBeforeUpdate||r===e.memoizedProps&&v===e.memoizedState||(i.flags|=256),_=!1)}return Nn(e,i,t,_,a,s)}function Nn(e,i,t,_,s,a){Cn(e,i);var n=0!==(64&i.flags);if(!_&&!n)return s&&ws(i,t,!1),sr(e,i,a);_=i.stateNode,Un.current=i;var r=n&&"function"!==typeof t.getDerivedStateFromError?null:_.render();return i.flags|=1,null!==e&&n?(i.child=La(i,e.child,null,a),i.child=La(i,null,r,a)):Bn(e,i,r,a),i.memoizedState=_.state,s&&ws(i,t,!0),i.child}function Zn(e){var i=e.stateNode;i.pendingContext?ps(0,i.pendingContext,i.pendingContext!==i.context):i.context&&ps(0,i.context,!1),Aa(e,i.containerInfo)}var Yn,Pn,jn,Kn,Gn={dehydrated:null,retryLane:0};function Qn(e,i,t){var _,s=i.pendingProps,a=Ia.current,n=!1;return(_=0!==(64&i.flags))||(_=(null===e||null!==e.memoizedState)&&0!==(2&a)),_?(n=!0,i.flags&=-65):null!==e&&null===e.memoizedState||void 0===s.fallback||!0===s.unstable_avoidThisFallback||(a|=1),ds(Ia,1&a),null===e?(void 0!==s.fallback&&Ha(i),e=s.children,a=s.fallback,n?(e=Jn(i,e,a,t),i.child.memoizedState={baseLanes:t},i.memoizedState=Gn,e):"number"===typeof s.unstable_expectedLoadTime?(e=Jn(i,e,a,t),i.child.memoizedState={baseLanes:t},i.memoizedState=Gn,i.lanes=33554432,e):((t=jl({mode:"visible",children:e},i.mode,t,null)).return=i,i.child=t)):(e.memoizedState,n?(s=er(e,i,s.children,s.fallback,t),n=i.child,a=e.child.memoizedState,n.memoizedState=null===a?{baseLanes:t}:{baseLanes:a.baseLanes|t},n.childLanes=e.childLanes&~t,i.memoizedState=Gn,s):(t=$n(e,i,s.children,t),i.memoizedState=null,t))}function Jn(e,i,t,_){var s=e.mode,a=e.child;return i={mode:"hidden",children:i},0===(2&s)&&null!==a?(a.childLanes=0,a.pendingProps=i):a=jl(i,s,0,null),t=Pl(t,s,_,null),a.return=e,t.return=e,a.sibling=t,e.child=a,t}function $n(e,i,t,_){var s=e.child;return e=s.sibling,t=Zl(s,{mode:"visible",children:t}),0===(2&i.mode)&&(t.lanes=_),t.return=i,t.sibling=null,null!==e&&(e.nextEffect=null,e.flags=8,i.firstEffect=i.lastEffect=e),i.child=t}function er(e,i,t,_,s){var a=i.mode,n=e.child;e=n.sibling;var r={mode:"hidden",children:t};return 0===(2&a)&&i.child!==n?((t=i.child).childLanes=0,t.pendingProps=r,null!==(n=t.lastEffect)?(i.firstEffect=t.firstEffect,i.lastEffect=n,n.nextEffect=null):i.firstEffect=i.lastEffect=null):t=Zl(n,r),null!==e?_=Zl(e,_):(_=Pl(_,a,s,null)).flags|=2,_.return=i,t.return=i,t.sibling=_,i.child=t,_}function ir(e,i){e.lanes|=i;var t=e.alternate;null!==t&&(t.lanes|=i),ta(e.return,i)}function tr(e,i,t,_,s,a){var n=e.memoizedState;null===n?e.memoizedState={isBackwards:i,rendering:null,renderingStartTime:0,last:_,tail:t,tailMode:s,lastEffect:a}:(n.isBackwards=i,n.rendering=null,n.renderingStartTime=0,n.last=_,n.tail=t,n.tailMode=s,n.lastEffect=a)}function _r(e,i,t){var _=i.pendingProps,s=_.revealOrder,a=_.tail;if(Bn(e,i,_.children,t),0!==(2&(_=Ia.current)))_=1&_|2,i.flags|=64;else{if(null!==e&&0!==(64&e.flags))e:for(e=i.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&ir(e,t);else if(19===e.tag)ir(e,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===i)break e;for(;null===e.sibling;){if(null===e.return||e.return===i)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}_&=1}if(ds(Ia,_),0===(2&i.mode))i.memoizedState=null;else switch(s){case"forwards":for(t=i.child,s=null;null!==t;)null!==(e=t.alternate)&&null===Ba(e)&&(s=t),t=t.sibling;null===(t=s)?(s=i.child,i.child=null):(s=t.sibling,t.sibling=null),tr(i,!1,s,t,a,i.lastEffect);break;case"backwards":for(t=null,s=i.child,i.child=null;null!==s;){if(null!==(e=s.alternate)&&null===Ba(e)){i.child=s;break}e=s.sibling,s.sibling=t,t=s,s=e}tr(i,!0,t,null,a,i.lastEffect);break;case"together":tr(i,!1,null,null,void 0,i.lastEffect);break;default:i.memoizedState=null}return i.child}function sr(e,i,t){if(null!==e&&(i.dependencies=e.dependencies),Xr|=i.lanes,0!==(t&i.childLanes)){if(null!==e&&i.child!==e.child)throw Error(n(153));if(null!==i.child){for(t=Zl(e=i.child,e.pendingProps),i.child=t,t.return=i;null!==e.sibling;)e=e.sibling,(t=t.sibling=Zl(e,e.pendingProps)).return=i;t.sibling=null}return i.child}return null}function ar(e,i){if(!qa)switch(e.tailMode){case"hidden":i=e.tail;for(var t=null;null!==i;)null!==i.alternate&&(t=i),i=i.sibling;null===t?e.tail=null:t.sibling=null;break;case"collapsed":t=e.tail;for(var _=null;null!==t;)null!==t.alternate&&(_=t),t=t.sibling;null===_?i||null===e.tail?e.tail=null:e.tail.sibling=null:_.sibling=null}}function nr(e,i,t){var _=i.pendingProps;switch(i.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:case 17:return fs(i.type)&&bs(),null;case 3:return Ta(),ls(vs),ls(ms),Pa(),(_=i.stateNode).pendingContext&&(_.context=_.pendingContext,_.pendingContext=null),null!==e&&null!==e.child||(Na(i)?i.flags|=4:_.hydrate||(i.flags|=256)),Pn(i),null;case 5:Ua(i);var a=Va(ya.current);if(t=i.type,null!==e&&null!=i.stateNode)jn(e,i,t,_,a),e.ref!==i.ref&&(i.flags|=128);else{if(!_){if(null===i.stateNode)throw Error(n(166));return null}if(e=Va(Sa.current),Na(i)){_=i.stateNode,t=i.type;var r=i.memoizedProps;switch(_[G_]=i,_[Q_]=r,t){case"dialog":D_("cancel",_),D_("close",_);break;case"iframe":case"object":case"embed":D_("load",_);break;case"video":case"audio":for(e=0;e<L_.length;e++)D_(L_[e],_);break;case"source":D_("error",_);break;case"img":case"image":case"link":D_("error",_),D_("load",_);break;case"details":D_("toggle",_);break;case"input":ee(_,r),D_("invalid",_);break;case"select":_._wrapperState={wasMultiple:!!r.multiple},D_("invalid",_);break;case"textarea":le(_,r),D_("invalid",_)}for(var d in ze(t,r),e=null,r)r.hasOwnProperty(d)&&(a=r[d],"children"===d?"string"===typeof a?_.textContent!==a&&(e=["children",a]):"number"===typeof a&&_.textContent!==""+a&&(e=["children",""+a]):l.hasOwnProperty(d)&&null!=a&&"onScroll"===d&&D_("scroll",_));switch(t){case"input":G(_),_e(_,r,!0);break;case"textarea":G(_),oe(_);break;case"select":case"option":break;default:"function"===typeof r.onClick&&(_.onclick=F_)}_=e,i.updateQueue=_,null!==_&&(i.flags|=4)}else{switch(d=9===a.nodeType?a:a.ownerDocument,e===me.html&&(e=ve(t)),e===me.html?"script"===t?((e=d.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"===typeof _.is?e=d.createElement(t,{is:_.is}):(e=d.createElement(t),"select"===t&&(d=e,_.multiple?d.multiple=!0:_.size&&(d.size=_.size))):e=d.createElementNS(e,t),e[G_]=i,e[Q_]=_,Yn(e,i,!1,!1),i.stateNode=e,d=Le(t,_),t){case"dialog":D_("cancel",e),D_("close",e),a=_;break;case"iframe":case"object":case"embed":D_("load",e),a=_;break;case"video":case"audio":for(a=0;a<L_.length;a++)D_(L_[a],e);a=_;break;case"source":D_("error",e),a=_;break;case"img":case"image":case"link":D_("error",e),D_("load",e),a=_;break;case"details":D_("toggle",e),a=_;break;case"input":ee(e,_),a=$(e,_),D_("invalid",e);break;case"option":a=ae(e,_);break;case"select":e._wrapperState={wasMultiple:!!_.multiple},a=s({},_,{value:void 0}),D_("invalid",e);break;case"textarea":le(e,_),a=re(e,_),D_("invalid",e);break;default:a=_}ze(t,a);var o=a;for(r in o)if(o.hasOwnProperty(r)){var m=o[r];"style"===r?he(e,m):"dangerouslySetInnerHTML"===r?null!=(m=m?m.__html:void 0)&&be(e,m):"children"===r?"string"===typeof m?("textarea"!==t||""!==m)&&pe(e,m):"number"===typeof m&&pe(e,""+m):"suppressContentEditableWarning"!==r&&"suppressHydrationWarning"!==r&&"autoFocus"!==r&&(l.hasOwnProperty(r)?null!=m&&"onScroll"===r&&D_("scroll",e):null!=m&&w(e,r,m,d))}switch(t){case"input":G(e),_e(e,_,!1);break;case"textarea":G(e),oe(e);break;case"option":null!=_.value&&e.setAttribute("value",""+j(_.value));break;case"select":e.multiple=!!_.multiple,null!=(r=_.value)?ne(e,!!_.multiple,r,!1):null!=_.defaultValue&&ne(e,!!_.multiple,_.defaultValue,!0);break;default:"function"===typeof a.onClick&&(e.onclick=F_)}C_(t,_)&&(i.flags|=4)}null!==i.ref&&(i.flags|=128)}return null;case 6:if(e&&null!=i.stateNode)Kn(e,i,e.memoizedProps,_);else{if("string"!==typeof _&&null===i.stateNode)throw Error(n(166));t=Va(ya.current),Va(Sa.current),Na(i)?(_=i.stateNode,t=i.memoizedProps,_[G_]=i,_.nodeValue!==t&&(i.flags|=4)):((_=(9===t.nodeType?t:t.ownerDocument).createTextNode(_))[G_]=i,i.stateNode=_)}return null;case 13:return ls(Ia),_=i.memoizedState,0!==(64&i.flags)?(i.lanes=t,i):(_=null!==_,t=!1,null===e?void 0!==i.memoizedProps.fallback&&Na(i):t=null!==e.memoizedState,_&&!t&&0!==(2&i.mode)&&(null===e&&!0!==i.memoizedProps.unstable_avoidThisFallback||0!==(1&Ia.current)?0===Or&&(Or=3):(0!==Or&&3!==Or||(Or=4),null===Tr||0===(134217727&Xr)&&0===(134217727&Cr)||pl(Tr,Ur))),(_||t)&&(i.flags|=4),null);case 4:return Ta(),Pn(i),null===e&&V_(i.stateNode.containerInfo),null;case 10:return ia(i),null;case 19:if(ls(Ia),null===(_=i.memoizedState))return null;if(r=0!==(64&i.flags),null===(d=_.rendering))if(r)ar(_,!1);else{if(0!==Or||null!==e&&0!==(64&e.flags))for(e=i.child;null!==e;){if(null!==(d=Ba(e))){for(i.flags|=64,ar(_,!1),null!==(r=d.updateQueue)&&(i.updateQueue=r,i.flags|=4),null===_.lastEffect&&(i.firstEffect=null),i.lastEffect=_.lastEffect,_=t,t=i.child;null!==t;)e=_,(r=t).flags&=2,r.nextEffect=null,r.firstEffect=null,r.lastEffect=null,null===(d=r.alternate)?(r.childLanes=0,r.lanes=e,r.child=null,r.memoizedProps=null,r.memoizedState=null,r.updateQueue=null,r.dependencies=null,r.stateNode=null):(r.childLanes=d.childLanes,r.lanes=d.lanes,r.child=d.child,r.memoizedProps=d.memoizedProps,r.memoizedState=d.memoizedState,r.updateQueue=d.updateQueue,r.type=d.type,e=d.dependencies,r.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),t=t.sibling;return ds(Ia,1&Ia.current|2),i.child}e=e.sibling}null!==_.tail&&Cs()>Zr&&(i.flags|=64,r=!0,ar(_,!1),i.lanes=33554432)}else{if(!r)if(null!==(e=Ba(d))){if(i.flags|=64,r=!0,null!==(t=e.updateQueue)&&(i.updateQueue=t,i.flags|=4),ar(_,!0),null===_.tail&&"hidden"===_.tailMode&&!d.alternate&&!qa)return null!==(i=i.lastEffect=_.lastEffect)&&(i.nextEffect=null),null}else 2*Cs()-_.renderingStartTime>Zr&&1073741824!==t&&(i.flags|=64,r=!0,ar(_,!1),i.lanes=33554432);_.isBackwards?(d.sibling=i.child,i.child=d):(null!==(t=_.last)?t.sibling=d:i.child=d,_.last=d)}return null!==_.tail?(t=_.tail,_.rendering=t,_.tail=t.sibling,_.lastEffect=i.lastEffect,_.renderingStartTime=Cs(),t.sibling=null,i=Ia.current,ds(Ia,r?1&i|2:1&i),t):null;case 23:case 24:return xl(),null!==e&&null!==e.memoizedState!==(null!==i.memoizedState)&&"unstable-defer-without-hiding"!==_.mode&&(i.flags|=4),null}throw Error(n(156,i.tag))}function rr(e){switch(e.tag){case 1:fs(e.type)&&bs();var i=e.flags;return 4096&i?(e.flags=-4097&i|64,e):null;case 3:if(Ta(),ls(vs),ls(ms),Pa(),0!==(64&(i=e.flags)))throw Error(n(285));return e.flags=-4097&i|64,e;case 5:return Ua(e),null;case 13:return ls(Ia),4096&(i=e.flags)?(e.flags=-4097&i|64,e):null;case 19:return ls(Ia),null;case 4:return Ta(),null;case 10:return ia(e),null;case 23:case 24:return xl(),null;default:return null}}function lr(e,i){try{var t="",_=i;do{t+=Y(_),_=_.return}while(_);var s=t}catch(a){s="\nError generating stack: "+a.message+"\n"+a.stack}return{value:e,source:i,stack:s}}function dr(e,i){try{console.error(i.value)}catch(t){setTimeout((function(){throw t}))}}Yn=function(e,i){for(var t=i.child;null!==t;){if(5===t.tag||6===t.tag)e.appendChild(t.stateNode);else if(4!==t.tag&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===i)break;for(;null===t.sibling;){if(null===t.return||t.return===i)return;t=t.return}t.sibling.return=t.return,t=t.sibling}},Pn=function(){},jn=function(e,i,t,_){var a=e.memoizedProps;if(a!==_){e=i.stateNode,Va(Sa.current);var n,r=null;switch(t){case"input":a=$(e,a),_=$(e,_),r=[];break;case"option":a=ae(e,a),_=ae(e,_),r=[];break;case"select":a=s({},a,{value:void 0}),_=s({},_,{value:void 0}),r=[];break;case"textarea":a=re(e,a),_=re(e,_),r=[];break;default:"function"!==typeof a.onClick&&"function"===typeof _.onClick&&(e.onclick=F_)}for(m in ze(t,_),t=null,a)if(!_.hasOwnProperty(m)&&a.hasOwnProperty(m)&&null!=a[m])if("style"===m){var d=a[m];for(n in d)d.hasOwnProperty(n)&&(t||(t={}),t[n]="")}else"dangerouslySetInnerHTML"!==m&&"children"!==m&&"suppressContentEditableWarning"!==m&&"suppressHydrationWarning"!==m&&"autoFocus"!==m&&(l.hasOwnProperty(m)?r||(r=[]):(r=r||[]).push(m,null));for(m in _){var o=_[m];if(d=null!=a?a[m]:void 0,_.hasOwnProperty(m)&&o!==d&&(null!=o||null!=d))if("style"===m)if(d){for(n in d)!d.hasOwnProperty(n)||o&&o.hasOwnProperty(n)||(t||(t={}),t[n]="");for(n in o)o.hasOwnProperty(n)&&d[n]!==o[n]&&(t||(t={}),t[n]=o[n])}else t||(r||(r=[]),r.push(m,t)),t=o;else"dangerouslySetInnerHTML"===m?(o=o?o.__html:void 0,d=d?d.__html:void 0,null!=o&&d!==o&&(r=r||[]).push(m,o)):"children"===m?"string"!==typeof o&&"number"!==typeof o||(r=r||[]).push(m,""+o):"suppressContentEditableWarning"!==m&&"suppressHydrationWarning"!==m&&(l.hasOwnProperty(m)?(null!=o&&"onScroll"===m&&D_("scroll",e),r||d===o||(r=[])):"object"===typeof o&&null!==o&&o.$$typeof===I?o.toString():(r=r||[]).push(m,o))}t&&(r=r||[]).push("style",t);var m=r;(i.updateQueue=m)&&(i.flags|=4)}},Kn=function(e,i,t,_){t!==_&&(i.flags|=4)};var or="function"===typeof WeakMap?WeakMap:Map;function mr(e,i,t){(t=la(-1,t)).tag=3,t.payload={element:null};var _=i.value;return t.callback=function(){Kr||(Kr=!0,Gr=_),dr(0,i)},t}function vr(e,i,t){(t=la(-1,t)).tag=3;var _=e.type.getDerivedStateFromError;if("function"===typeof _){var s=i.value;t.payload=function(){return dr(0,i),_(s)}}var a=e.stateNode;return null!==a&&"function"===typeof a.componentDidCatch&&(t.callback=function(){"function"!==typeof _&&(null===Qr?Qr=new Set([this]):Qr.add(this),dr(0,i));var e=i.stack;this.componentDidCatch(i.value,{componentStack:null!==e?e:""})}),t}var cr="function"===typeof WeakSet?WeakSet:Set;function ur(e){var i=e.ref;if(null!==i)if("function"===typeof i)try{i(null)}catch(t){ql(e,t)}else i.current=null}function fr(e,i){switch(i.tag){case 0:case 11:case 15:case 22:case 5:case 6:case 4:case 17:return;case 1:if(256&i.flags&&null!==e){var t=e.memoizedProps,_=e.memoizedState;i=(e=i.stateNode).getSnapshotBeforeUpdate(i.elementType===i.type?t:Ks(i.type,t),_),e.__reactInternalSnapshotBeforeUpdate=i}return;case 3:return void(256&i.flags&&Z_(i.stateNode.containerInfo))}throw Error(n(163))}function br(e,i,t){switch(t.tag){case 0:case 11:case 15:case 22:if(null!==(i=null!==(i=t.updateQueue)?i.lastEffect:null)){e=i=i.next;do{if(3===(3&e.tag)){var _=e.create;e.destroy=_()}e=e.next}while(e!==i)}if(null!==(i=null!==(i=t.updateQueue)?i.lastEffect:null)){e=i=i.next;do{var s=e;_=s.next,0!==(4&(s=s.tag))&&0!==(1&s)&&(Bl(t,e),Il(t,e)),e=_}while(e!==i)}return;case 1:return e=t.stateNode,4&t.flags&&(null===i?e.componentDidMount():(_=t.elementType===t.type?i.memoizedProps:Ks(t.type,i.memoizedProps),e.componentDidUpdate(_,i.memoizedState,e.__reactInternalSnapshotBeforeUpdate))),void(null!==(i=t.updateQueue)&&va(t,i,e));case 3:if(null!==(i=t.updateQueue)){if(e=null,null!==t.child)switch(t.child.tag){case 5:case 1:e=t.child.stateNode}va(t,i,e)}return;case 5:return e=t.stateNode,void(null===i&&4&t.flags&&C_(t.type,t.memoizedProps)&&e.focus());case 6:case 4:case 12:case 19:case 17:case 20:case 21:case 23:case 24:return;case 13:return void(null===t.memoizedState&&(t=t.alternate,null!==t&&(t=t.memoizedState,null!==t&&(t=t.dehydrated,null!==t&&hi(t)))))}throw Error(n(163))}function pr(e,i){for(var t=e;;){if(5===t.tag){var _=t.stateNode;if(i)"function"===typeof(_=_.style).setProperty?_.setProperty("display","none","important"):_.display="none";else{_=t.stateNode;var s=t.memoizedProps.style;s=void 0!==s&&null!==s&&s.hasOwnProperty("display")?s.display:null,_.style.display=we("display",s)}}else if(6===t.tag)t.stateNode.nodeValue=i?"":t.memoizedProps;else if((23!==t.tag&&24!==t.tag||null===t.memoizedState||t===e)&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return;t=t.return}t.sibling.return=t.return,t=t.sibling}}function gr(e,i){if(xs&&"function"===typeof xs.onCommitFiberUnmount)try{xs.onCommitFiberUnmount(hs,i)}catch(a){}switch(i.tag){case 0:case 11:case 14:case 15:case 22:if(null!==(e=i.updateQueue)&&null!==(e=e.lastEffect)){var t=e=e.next;do{var _=t,s=_.destroy;if(_=_.tag,void 0!==s)if(0!==(4&_))Bl(i,t);else{_=i;try{s()}catch(a){ql(_,a)}}t=t.next}while(t!==e)}break;case 1:if(ur(i),"function"===typeof(e=i.stateNode).componentWillUnmount)try{e.props=i.memoizedProps,e.state=i.memoizedState,e.componentWillUnmount()}catch(a){ql(i,a)}break;case 5:ur(i);break;case 4:Lr(e,i)}}function Er(e){e.alternate=null,e.child=null,e.dependencies=null,e.firstEffect=null,e.lastEffect=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.return=null,e.updateQueue=null}function wr(e){return 5===e.tag||3===e.tag||4===e.tag}function hr(e){e:{for(var i=e.return;null!==i;){if(wr(i))break e;i=i.return}throw Error(n(160))}var t=i;switch(i=t.stateNode,t.tag){case 5:var _=!1;break;case 3:case 4:i=i.containerInfo,_=!0;break;default:throw Error(n(161))}16&t.flags&&(pe(i,""),t.flags&=-17);e:i:for(t=e;;){for(;null===t.sibling;){if(null===t.return||wr(t.return)){t=null;break e}t=t.return}for(t.sibling.return=t.return,t=t.sibling;5!==t.tag&&6!==t.tag&&18!==t.tag;){if(2&t.flags)continue i;if(null===t.child||4===t.tag)continue i;t.child.return=t,t=t.child}if(!(2&t.flags)){t=t.stateNode;break e}}_?xr(e,t,i):zr(e,t,i)}function xr(e,i,t){var _=e.tag,s=5===_||6===_;if(s)e=s?e.stateNode:e.stateNode.instance,i?8===t.nodeType?t.parentNode.insertBefore(e,i):t.insertBefore(e,i):(8===t.nodeType?(i=t.parentNode).insertBefore(e,t):(i=t).appendChild(e),null!==(t=t._reactRootContainer)&&void 0!==t||null!==i.onclick||(i.onclick=F_));else if(4!==_&&null!==(e=e.child))for(xr(e,i,t),e=e.sibling;null!==e;)xr(e,i,t),e=e.sibling}function zr(e,i,t){var _=e.tag,s=5===_||6===_;if(s)e=s?e.stateNode:e.stateNode.instance,i?t.insertBefore(e,i):t.appendChild(e);else if(4!==_&&null!==(e=e.child))for(zr(e,i,t),e=e.sibling;null!==e;)zr(e,i,t),e=e.sibling}function Lr(e,i){for(var t,_,s=i,a=!1;;){if(!a){a=s.return;e:for(;;){if(null===a)throw Error(n(160));switch(t=a.stateNode,a.tag){case 5:_=!1;break e;case 3:case 4:t=t.containerInfo,_=!0;break e}a=a.return}a=!0}if(5===s.tag||6===s.tag){e:for(var r=e,l=s,d=l;;)if(gr(r,d),null!==d.child&&4!==d.tag)d.child.return=d,d=d.child;else{if(d===l)break e;for(;null===d.sibling;){if(null===d.return||d.return===l)break e;d=d.return}d.sibling.return=d.return,d=d.sibling}_?(r=t,l=s.stateNode,8===r.nodeType?r.parentNode.removeChild(l):r.removeChild(l)):t.removeChild(s.stateNode)}else if(4===s.tag){if(null!==s.child){t=s.stateNode.containerInfo,_=!0,s.child.return=s,s=s.child;continue}}else if(gr(e,s),null!==s.child){s.child.return=s,s=s.child;continue}if(s===i)break;for(;null===s.sibling;){if(null===s.return||s.return===i)return;4===(s=s.return).tag&&(a=!1)}s.sibling.return=s.return,s=s.sibling}}function Mr(e,i){switch(i.tag){case 0:case 11:case 14:case 15:case 22:var t=i.updateQueue;if(null!==(t=null!==t?t.lastEffect:null)){var _=t=t.next;do{3===(3&_.tag)&&(e=_.destroy,_.destroy=void 0,void 0!==e&&e()),_=_.next}while(_!==t)}return;case 1:case 12:case 17:return;case 5:if(null!=(t=i.stateNode)){_=i.memoizedProps;var s=null!==e?e.memoizedProps:_;e=i.type;var a=i.updateQueue;if(i.updateQueue=null,null!==a){for(t[Q_]=_,"input"===e&&"radio"===_.type&&null!=_.name&&ie(t,_),Le(e,s),i=Le(e,_),s=0;s<a.length;s+=2){var r=a[s],l=a[s+1];"style"===r?he(t,l):"dangerouslySetInnerHTML"===r?be(t,l):"children"===r?pe(t,l):w(t,r,l,i)}switch(e){case"input":te(t,_);break;case"textarea":de(t,_);break;case"select":e=t._wrapperState.wasMultiple,t._wrapperState.wasMultiple=!!_.multiple,null!=(a=_.value)?ne(t,!!_.multiple,a,!1):e!==!!_.multiple&&(null!=_.defaultValue?ne(t,!!_.multiple,_.defaultValue,!0):ne(t,!!_.multiple,_.multiple?[]:"",!1))}}}return;case 6:if(null===i.stateNode)throw Error(n(162));return void(i.stateNode.nodeValue=i.memoizedProps);case 3:return void((t=i.stateNode).hydrate&&(t.hydrate=!1,hi(t.containerInfo)));case 13:return null!==i.memoizedState&&(Nr=Cs(),pr(i.child,!0)),void Rr(i);case 19:return void Rr(i);case 23:case 24:return void pr(i,null!==i.memoizedState)}throw Error(n(163))}function Rr(e){var i=e.updateQueue;if(null!==i){e.updateQueue=null;var t=e.stateNode;null===t&&(t=e.stateNode=new cr),i.forEach((function(i){var _=Cl.bind(null,e,i);t.has(i)||(t.add(i),i.then(_,_))}))}}function Sr(e,i){return null!==e&&(null===(e=e.memoizedState)||null!==e.dehydrated)&&(null!==(i=i.memoizedState)&&null===i.dehydrated)}var Dr=Math.ceil,yr=h.ReactCurrentDispatcher,Vr=h.ReactCurrentOwner,Ar=0,Tr=null,Wr=null,Ur=0,Ir=0,Br=rs(0),Or=0,Fr=null,qr=0,Xr=0,Cr=0,Hr=0,kr=null,Nr=0,Zr=1/0;function Yr(){Zr=Cs()+500}var Pr,jr=null,Kr=!1,Gr=null,Qr=null,Jr=!1,$r=null,el=90,il=[],tl=[],_l=null,sl=0,al=null,nl=-1,rl=0,ll=0,dl=null,ol=!1;function ml(){return 0!==(48&Ar)?Cs():-1!==nl?nl:nl=Cs()}function vl(e){if(0===(2&(e=e.mode)))return 1;if(0===(4&e))return 99===Hs()?1:2;if(0===rl&&(rl=qr),0!==js.transition){0!==ll&&(ll=null!==kr?kr.pendingLanes:0),e=rl;var i=4186112&~ll;return 0===(i&=-i)&&(0===(i=(e=4186112&~e)&-e)&&(i=8192)),i}return e=Hs(),0!==(4&Ar)&&98===e?e=qi(12,rl):e=qi(e=function(e){switch(e){case 99:return 15;case 98:return 10;case 97:case 96:return 8;case 95:return 2;default:return 0}}(e),rl),e}function cl(e,i,t){if(50<sl)throw sl=0,al=null,Error(n(185));if(null===(e=ul(e,i)))return null;Hi(e,i,t),e===Tr&&(Cr|=i,4===Or&&pl(e,Ur));var _=Hs();1===i?0!==(8&Ar)&&0===(48&Ar)?gl(e):(fl(e,t),0===Ar&&(Yr(),Ys())):(0===(4&Ar)||98!==_&&99!==_||(null===_l?_l=new Set([e]):_l.add(e)),fl(e,t)),kr=e}function ul(e,i){e.lanes|=i;var t=e.alternate;for(null!==t&&(t.lanes|=i),t=e,e=e.return;null!==e;)e.childLanes|=i,null!==(t=e.alternate)&&(t.childLanes|=i),t=e,e=e.return;return 3===t.tag?t.stateNode:null}function fl(e,i){for(var t=e.callbackNode,_=e.suspendedLanes,s=e.pingedLanes,a=e.expirationTimes,r=e.pendingLanes;0<r;){var l=31-ki(r),d=1<<l,o=a[l];if(-1===o){if(0===(d&_)||0!==(d&s)){o=i,Bi(d);var m=Ii;a[l]=10<=m?o+250:6<=m?o+5e3:-1}}else o<=i&&(e.expiredLanes|=d);r&=~d}if(_=Oi(e,e===Tr?Ur:0),i=Ii,0===_)null!==t&&(t!==Is&&Ms(t),e.callbackNode=null,e.callbackPriority=0);else{if(null!==t){if(e.callbackPriority===i)return;t!==Is&&Ms(t)}15===i?(t=gl.bind(null,e),null===Os?(Os=[t],Fs=Ls(Vs,Ps)):Os.push(t),t=Is):14===i?t=Zs(99,gl.bind(null,e)):(t=function(e){switch(e){case 15:case 14:return 99;case 13:case 12:case 11:case 10:return 98;case 9:case 8:case 7:case 6:case 4:case 5:return 97;case 3:case 2:case 1:return 95;case 0:return 90;default:throw Error(n(358,e))}}(i),t=Zs(t,bl.bind(null,e))),e.callbackPriority=i,e.callbackNode=t}}function bl(e){if(nl=-1,ll=rl=0,0!==(48&Ar))throw Error(n(327));var i=e.callbackNode;if(Ul()&&e.callbackNode!==i)return null;var t=Oi(e,e===Tr?Ur:0);if(0===t)return null;var _=t,s=Ar;Ar|=16;var a=Ml();for(Tr===e&&Ur===_||(Yr(),zl(e,_));;)try{Dl();break}catch(l){Ll(e,l)}if(ea(),yr.current=a,Ar=s,null!==Wr?_=0:(Tr=null,Ur=0,_=Or),0!==(qr&Cr))zl(e,0);else if(0!==_){if(2===_&&(Ar|=64,e.hydrate&&(e.hydrate=!1,Z_(e.containerInfo)),0!==(t=Fi(e))&&(_=Rl(e,t))),1===_)throw i=Fr,zl(e,0),pl(e,t),fl(e,Cs()),i;switch(e.finishedWork=e.current.alternate,e.finishedLanes=t,_){case 0:case 1:throw Error(n(345));case 2:case 5:Al(e);break;case 3:if(pl(e,t),(62914560&t)===t&&10<(_=Nr+500-Cs())){if(0!==Oi(e,0))break;if(((s=e.suspendedLanes)&t)!==t){ml(),e.pingedLanes|=e.suspendedLanes&s;break}e.timeoutHandle=k_(Al.bind(null,e),_);break}Al(e);break;case 4:if(pl(e,t),(4186112&t)===t)break;for(_=e.eventTimes,s=-1;0<t;){var r=31-ki(t);a=1<<r,(r=_[r])>s&&(s=r),t&=~a}if(t=s,10<(t=(120>(t=Cs()-t)?120:480>t?480:1080>t?1080:1920>t?1920:3e3>t?3e3:4320>t?4320:1960*Dr(t/1960))-t)){e.timeoutHandle=k_(Al.bind(null,e),t);break}Al(e);break;default:throw Error(n(329))}}return fl(e,Cs()),e.callbackNode===i?bl.bind(null,e):null}function pl(e,i){for(i&=~Hr,i&=~Cr,e.suspendedLanes|=i,e.pingedLanes&=~i,e=e.expirationTimes;0<i;){var t=31-ki(i),_=1<<t;e[t]=-1,i&=~_}}function gl(e){if(0!==(48&Ar))throw Error(n(327));if(Ul(),e===Tr&&0!==(e.expiredLanes&Ur)){var i=Ur,t=Rl(e,i);0!==(qr&Cr)&&(t=Rl(e,i=Oi(e,i)))}else t=Rl(e,i=Oi(e,0));if(0!==e.tag&&2===t&&(Ar|=64,e.hydrate&&(e.hydrate=!1,Z_(e.containerInfo)),0!==(i=Fi(e))&&(t=Rl(e,i))),1===t)throw t=Fr,zl(e,0),pl(e,i),fl(e,Cs()),t;return e.finishedWork=e.current.alternate,e.finishedLanes=i,Al(e),fl(e,Cs()),null}function El(e,i){var t=Ar;Ar|=1;try{return e(i)}finally{0===(Ar=t)&&(Yr(),Ys())}}function wl(e,i){var t=Ar;Ar&=-2,Ar|=8;try{return e(i)}finally{0===(Ar=t)&&(Yr(),Ys())}}function hl(e,i){ds(Br,Ir),Ir|=i,qr|=i}function xl(){Ir=Br.current,ls(Br)}function zl(e,i){e.finishedWork=null,e.finishedLanes=0;var t=e.timeoutHandle;if(-1!==t&&(e.timeoutHandle=-1,N_(t)),null!==Wr)for(t=Wr.return;null!==t;){var _=t;switch(_.tag){case 1:null!==(_=_.type.childContextTypes)&&void 0!==_&&bs();break;case 3:Ta(),ls(vs),ls(ms),Pa();break;case 5:Ua(_);break;case 4:Ta();break;case 13:case 19:ls(Ia);break;case 10:ia(_);break;case 23:case 24:xl()}t=t.return}Tr=e,Wr=Zl(e.current,null),Ur=Ir=qr=i,Or=0,Fr=null,Hr=Cr=Xr=0}function Ll(e,i){for(;;){var t=Wr;try{if(ea(),ja.current=Vn,en){for(var _=Qa.memoizedState;null!==_;){var s=_.queue;null!==s&&(s.pending=null),_=_.next}en=!1}if(Ga=0,$a=Ja=Qa=null,tn=!1,Vr.current=null,null===t||null===t.return){Or=1,Fr=i,Wr=null;break}e:{var a=e,n=t.return,r=t,l=i;if(i=Ur,r.flags|=2048,r.firstEffect=r.lastEffect=null,null!==l&&"object"===typeof l&&"function"===typeof l.then){var d=l;if(0===(2&r.mode)){var o=r.alternate;o?(r.updateQueue=o.updateQueue,r.memoizedState=o.memoizedState,r.lanes=o.lanes):(r.updateQueue=null,r.memoizedState=null)}var m=0!==(1&Ia.current),v=n;do{var c;if(c=13===v.tag){var u=v.memoizedState;if(null!==u)c=null!==u.dehydrated;else{var f=v.memoizedProps;c=void 0!==f.fallback&&(!0!==f.unstable_avoidThisFallback||!m)}}if(c){var b=v.updateQueue;if(null===b){var p=new Set;p.add(d),v.updateQueue=p}else b.add(d);if(0===(2&v.mode)){if(v.flags|=64,r.flags|=16384,r.flags&=-2981,1===r.tag)if(null===r.alternate)r.tag=17;else{var g=la(-1,1);g.tag=2,da(r,g)}r.lanes|=1;break e}l=void 0,r=i;var E=a.pingCache;if(null===E?(E=a.pingCache=new or,l=new Set,E.set(d,l)):void 0===(l=E.get(d))&&(l=new Set,E.set(d,l)),!l.has(r)){l.add(r);var w=Xl.bind(null,a,d,r);d.then(w,w)}v.flags|=4096,v.lanes=i;break e}v=v.return}while(null!==v);l=Error((P(r.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.")}5!==Or&&(Or=2),l=lr(l,r),v=n;do{switch(v.tag){case 3:a=l,v.flags|=4096,i&=-i,v.lanes|=i,oa(v,mr(0,a,i));break e;case 1:a=l;var h=v.type,x=v.stateNode;if(0===(64&v.flags)&&("function"===typeof h.getDerivedStateFromError||null!==x&&"function"===typeof x.componentDidCatch&&(null===Qr||!Qr.has(x)))){v.flags|=4096,i&=-i,v.lanes|=i,oa(v,vr(v,a,i));break e}}v=v.return}while(null!==v)}Vl(t)}catch(z){i=z,Wr===t&&null!==t&&(Wr=t=t.return);continue}break}}function Ml(){var e=yr.current;return yr.current=Vn,null===e?Vn:e}function Rl(e,i){var t=Ar;Ar|=16;var _=Ml();for(Tr===e&&Ur===i||zl(e,i);;)try{Sl();break}catch(s){Ll(e,s)}if(ea(),Ar=t,yr.current=_,null!==Wr)throw Error(n(261));return Tr=null,Ur=0,Or}function Sl(){for(;null!==Wr;)yl(Wr)}function Dl(){for(;null!==Wr&&!Rs();)yl(Wr)}function yl(e){var i=Pr(e.alternate,e,Ir);e.memoizedProps=e.pendingProps,null===i?Vl(e):Wr=i,Vr.current=null}function Vl(e){var i=e;do{var t=i.alternate;if(e=i.return,0===(2048&i.flags)){if(null!==(t=nr(t,i,Ir)))return void(Wr=t);if(24!==(t=i).tag&&23!==t.tag||null===t.memoizedState||0!==(1073741824&Ir)||0===(4&t.mode)){for(var _=0,s=t.child;null!==s;)_|=s.lanes|s.childLanes,s=s.sibling;t.childLanes=_}null!==e&&0===(2048&e.flags)&&(null===e.firstEffect&&(e.firstEffect=i.firstEffect),null!==i.lastEffect&&(null!==e.lastEffect&&(e.lastEffect.nextEffect=i.firstEffect),e.lastEffect=i.lastEffect),1<i.flags&&(null!==e.lastEffect?e.lastEffect.nextEffect=i:e.firstEffect=i,e.lastEffect=i))}else{if(null!==(t=rr(i)))return t.flags&=2047,void(Wr=t);null!==e&&(e.firstEffect=e.lastEffect=null,e.flags|=2048)}if(null!==(i=i.sibling))return void(Wr=i);Wr=i=e}while(null!==i);0===Or&&(Or=5)}function Al(e){var i=Hs();return Ns(99,Tl.bind(null,e,i)),null}function Tl(e,i){do{Ul()}while(null!==$r);if(0!==(48&Ar))throw Error(n(327));var t=e.finishedWork;if(null===t)return null;if(e.finishedWork=null,e.finishedLanes=0,t===e.current)throw Error(n(177));e.callbackNode=null;var _=t.lanes|t.childLanes,s=_,a=e.pendingLanes&~s;e.pendingLanes=s,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=s,e.mutableReadLanes&=s,e.entangledLanes&=s,s=e.entanglements;for(var r=e.eventTimes,l=e.expirationTimes;0<a;){var d=31-ki(a),o=1<<d;s[d]=0,r[d]=-1,l[d]=-1,a&=~o}if(null!==_l&&0===(24&_)&&_l.has(e)&&_l.delete(e),e===Tr&&(Wr=Tr=null,Ur=0),1<t.flags?null!==t.lastEffect?(t.lastEffect.nextEffect=t,_=t.firstEffect):_=t:_=t.firstEffect,null!==_){if(s=Ar,Ar|=32,Vr.current=null,q_=ji,f_(r=u_())){if("selectionStart"in r)l={start:r.selectionStart,end:r.selectionEnd};else e:if(l=(l=r.ownerDocument)&&l.defaultView||window,(o=l.getSelection&&l.getSelection())&&0!==o.rangeCount){l=o.anchorNode,a=o.anchorOffset,d=o.focusNode,o=o.focusOffset;try{l.nodeType,d.nodeType}catch(R){l=null;break e}var m=0,v=-1,c=-1,u=0,f=0,b=r,p=null;i:for(;;){for(var g;b!==l||0!==a&&3!==b.nodeType||(v=m+a),b!==d||0!==o&&3!==b.nodeType||(c=m+o),3===b.nodeType&&(m+=b.nodeValue.length),null!==(g=b.firstChild);)p=b,b=g;for(;;){if(b===r)break i;if(p===l&&++u===a&&(v=m),p===d&&++f===o&&(c=m),null!==(g=b.nextSibling))break;p=(b=p).parentNode}b=g}l=-1===v||-1===c?null:{start:v,end:c}}else l=null;l=l||{start:0,end:0}}else l=null;X_={focusedElem:r,selectionRange:l},ji=!1,dl=null,ol=!1,jr=_;do{try{Wl()}catch(R){if(null===jr)throw Error(n(330));ql(jr,R),jr=jr.nextEffect}}while(null!==jr);dl=null,jr=_;do{try{for(r=e;null!==jr;){var E=jr.flags;if(16&E&&pe(jr.stateNode,""),128&E){var w=jr.alternate;if(null!==w){var h=w.ref;null!==h&&("function"===typeof h?h(null):h.current=null)}}switch(1038&E){case 2:hr(jr),jr.flags&=-3;break;case 6:hr(jr),jr.flags&=-3,Mr(jr.alternate,jr);break;case 1024:jr.flags&=-1025;break;case 1028:jr.flags&=-1025,Mr(jr.alternate,jr);break;case 4:Mr(jr.alternate,jr);break;case 8:Lr(r,l=jr);var x=l.alternate;Er(l),null!==x&&Er(x)}jr=jr.nextEffect}}catch(R){if(null===jr)throw Error(n(330));ql(jr,R),jr=jr.nextEffect}}while(null!==jr);if(h=X_,w=u_(),E=h.focusedElem,r=h.selectionRange,w!==E&&E&&E.ownerDocument&&c_(E.ownerDocument.documentElement,E)){null!==r&&f_(E)&&(w=r.start,void 0===(h=r.end)&&(h=w),"selectionStart"in E?(E.selectionStart=w,E.selectionEnd=Math.min(h,E.value.length)):(h=(w=E.ownerDocument||document)&&w.defaultView||window).getSelection&&(h=h.getSelection(),l=E.textContent.length,x=Math.min(r.start,l),r=void 0===r.end?x:Math.min(r.end,l),!h.extend&&x>r&&(l=r,r=x,x=l),l=v_(E,x),a=v_(E,r),l&&a&&(1!==h.rangeCount||h.anchorNode!==l.node||h.anchorOffset!==l.offset||h.focusNode!==a.node||h.focusOffset!==a.offset)&&((w=w.createRange()).setStart(l.node,l.offset),h.removeAllRanges(),x>r?(h.addRange(w),h.extend(a.node,a.offset)):(w.setEnd(a.node,a.offset),h.addRange(w))))),w=[];for(h=E;h=h.parentNode;)1===h.nodeType&&w.push({element:h,left:h.scrollLeft,top:h.scrollTop});for("function"===typeof E.focus&&E.focus(),E=0;E<w.length;E++)(h=w[E]).element.scrollLeft=h.left,h.element.scrollTop=h.top}ji=!!q_,X_=q_=null,e.current=t,jr=_;do{try{for(E=e;null!==jr;){var z=jr.flags;if(36&z&&br(E,jr.alternate,jr),128&z){w=void 0;var L=jr.ref;if(null!==L){var M=jr.stateNode;jr.tag,w=M,"function"===typeof L?L(w):L.current=w}}jr=jr.nextEffect}}catch(R){if(null===jr)throw Error(n(330));ql(jr,R),jr=jr.nextEffect}}while(null!==jr);jr=null,Bs(),Ar=s}else e.current=t;if(Jr)Jr=!1,$r=e,el=i;else for(jr=_;null!==jr;)i=jr.nextEffect,jr.nextEffect=null,8&jr.flags&&((z=jr).sibling=null,z.stateNode=null),jr=i;if(0===(_=e.pendingLanes)&&(Qr=null),1===_?e===al?sl++:(sl=0,al=e):sl=0,t=t.stateNode,xs&&"function"===typeof xs.onCommitFiberRoot)try{xs.onCommitFiberRoot(hs,t,void 0,64===(64&t.current.flags))}catch(R){}if(fl(e,Cs()),Kr)throw Kr=!1,e=Gr,Gr=null,e;return 0!==(8&Ar)||Ys(),null}function Wl(){for(;null!==jr;){var e=jr.alternate;ol||null===dl||(0!==(8&jr.flags)?$e(jr,dl)&&(ol=!0):13===jr.tag&&Sr(e,jr)&&$e(jr,dl)&&(ol=!0));var i=jr.flags;0!==(256&i)&&fr(e,jr),0===(512&i)||Jr||(Jr=!0,Zs(97,(function(){return Ul(),null}))),jr=jr.nextEffect}}function Ul(){if(90!==el){var e=97<el?97:el;return el=90,Ns(e,Ol)}return!1}function Il(e,i){il.push(i,e),Jr||(Jr=!0,Zs(97,(function(){return Ul(),null})))}function Bl(e,i){tl.push(i,e),Jr||(Jr=!0,Zs(97,(function(){return Ul(),null})))}function Ol(){if(null===$r)return!1;var e=$r;if($r=null,0!==(48&Ar))throw Error(n(331));var i=Ar;Ar|=32;var t=tl;tl=[];for(var _=0;_<t.length;_+=2){var s=t[_],a=t[_+1],r=s.destroy;if(s.destroy=void 0,"function"===typeof r)try{r()}catch(d){if(null===a)throw Error(n(330));ql(a,d)}}for(t=il,il=[],_=0;_<t.length;_+=2){s=t[_],a=t[_+1];try{var l=s.create;s.destroy=l()}catch(d){if(null===a)throw Error(n(330));ql(a,d)}}for(l=e.current.firstEffect;null!==l;)e=l.nextEffect,l.nextEffect=null,8&l.flags&&(l.sibling=null,l.stateNode=null),l=e;return Ar=i,Ys(),!0}function Fl(e,i,t){da(e,i=mr(0,i=lr(t,i),1)),i=ml(),null!==(e=ul(e,1))&&(Hi(e,1,i),fl(e,i))}function ql(e,i){if(3===e.tag)Fl(e,e,i);else for(var t=e.return;null!==t;){if(3===t.tag){Fl(t,e,i);break}if(1===t.tag){var _=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof _.componentDidCatch&&(null===Qr||!Qr.has(_))){var s=vr(t,e=lr(i,e),1);if(da(t,s),s=ml(),null!==(t=ul(t,1)))Hi(t,1,s),fl(t,s);else if("function"===typeof _.componentDidCatch&&(null===Qr||!Qr.has(_)))try{_.componentDidCatch(i,e)}catch(a){}break}}t=t.return}}function Xl(e,i,t){var _=e.pingCache;null!==_&&_.delete(i),i=ml(),e.pingedLanes|=e.suspendedLanes&t,Tr===e&&(Ur&t)===t&&(4===Or||3===Or&&(62914560&Ur)===Ur&&500>Cs()-Nr?zl(e,0):Hr|=t),fl(e,i)}function Cl(e,i){var t=e.stateNode;null!==t&&t.delete(i),0===(i=0)&&(0===(2&(i=e.mode))?i=1:0===(4&i)?i=99===Hs()?1:2:(0===rl&&(rl=qr),0===(i=Xi(62914560&~rl))&&(i=4194304))),t=ml(),null!==(e=ul(e,i))&&(Hi(e,i,t),fl(e,t))}function Hl(e,i,t,_){this.tag=e,this.key=t,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=i,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=_,this.flags=0,this.lastEffect=this.firstEffect=this.nextEffect=null,this.childLanes=this.lanes=0,this.alternate=null}function kl(e,i,t,_){return new Hl(e,i,t,_)}function Nl(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Zl(e,i){var t=e.alternate;return null===t?((t=kl(e.tag,i,e.key,e.mode)).elementType=e.elementType,t.type=e.type,t.stateNode=e.stateNode,t.alternate=e,e.alternate=t):(t.pendingProps=i,t.type=e.type,t.flags=0,t.nextEffect=null,t.firstEffect=null,t.lastEffect=null),t.childLanes=e.childLanes,t.lanes=e.lanes,t.child=e.child,t.memoizedProps=e.memoizedProps,t.memoizedState=e.memoizedState,t.updateQueue=e.updateQueue,i=e.dependencies,t.dependencies=null===i?null:{lanes:i.lanes,firstContext:i.firstContext},t.sibling=e.sibling,t.index=e.index,t.ref=e.ref,t}function Yl(e,i,t,_,s,a){var r=2;if(_=e,"function"===typeof e)Nl(e)&&(r=1);else if("string"===typeof e)r=5;else e:switch(e){case L:return Pl(t.children,s,a,i);case B:r=8,s|=16;break;case M:r=8,s|=1;break;case R:return(e=kl(12,t,i,8|s)).elementType=R,e.type=R,e.lanes=a,e;case V:return(e=kl(13,t,i,s)).type=V,e.elementType=V,e.lanes=a,e;case A:return(e=kl(19,t,i,s)).elementType=A,e.lanes=a,e;case O:return jl(t,s,a,i);case F:return(e=kl(24,t,i,s)).elementType=F,e.lanes=a,e;default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case S:r=10;break e;case D:r=9;break e;case y:r=11;break e;case T:r=14;break e;case W:r=16,_=null;break e;case U:r=22;break e}throw Error(n(130,null==e?e:typeof e,""))}return(i=kl(r,t,i,s)).elementType=e,i.type=_,i.lanes=a,i}function Pl(e,i,t,_){return(e=kl(7,e,_,i)).lanes=t,e}function jl(e,i,t,_){return(e=kl(23,e,_,i)).elementType=O,e.lanes=t,e}function Kl(e,i,t){return(e=kl(6,e,null,i)).lanes=t,e}function Gl(e,i,t){return(i=kl(4,null!==e.children?e.children:[],e.key,i)).lanes=t,i.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},i}function Ql(e,i,t){this.tag=i,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.pendingContext=this.context=null,this.hydrate=t,this.callbackNode=null,this.callbackPriority=0,this.eventTimes=Ci(0),this.expirationTimes=Ci(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Ci(0),this.mutableSourceEagerHydrationData=null}function Jl(e,i,t,_){var s=i.current,a=ml(),r=vl(s);e:if(t){i:{if(Ke(t=t._reactInternals)!==t||1!==t.tag)throw Error(n(170));var l=t;do{switch(l.tag){case 3:l=l.stateNode.context;break i;case 1:if(fs(l.type)){l=l.stateNode.__reactInternalMemoizedMergedChildContext;break i}}l=l.return}while(null!==l);throw Error(n(171))}if(1===t.tag){var d=t.type;if(fs(d)){t=gs(t,d,l);break e}}t=l}else t=os;return null===i.context?i.context=t:i.pendingContext=t,(i=la(a,r)).payload={element:e},null!==(_=void 0===_?null:_)&&(i.callback=_),da(s,i),cl(s,r,a),r}function $l(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function ed(e,i){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var t=e.retryLane;e.retryLane=0!==t&&t<i?t:i}}function id(e,i){ed(e,i),(e=e.alternate)&&ed(e,i)}function td(e,i,t){var _=null!=t&&null!=t.hydrationOptions&&t.hydrationOptions.mutableSources||null;if(t=new Ql(e,i,null!=t&&!0===t.hydrate),i=kl(3,null,null,2===i?7:1===i?3:0),t.current=i,i.stateNode=t,na(i),e[J_]=t.current,V_(8===e.nodeType?e.parentNode:e),_)for(e=0;e<_.length;e++){var s=(i=_[e])._getVersion;s=s(i._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[i,s]:t.mutableSourceEagerHydrationData.push(i,s)}this._internalRoot=t}function _d(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function sd(e,i,t,_,s){var a=t._reactRootContainer;if(a){var n=a._internalRoot;if("function"===typeof s){var r=s;s=function(){var e=$l(n);r.call(e)}}Jl(i,n,e,s)}else{if(a=t._reactRootContainer=function(e,i){if(i||(i=!(!(i=e?9===e.nodeType?e.documentElement:e.firstChild:null)||1!==i.nodeType||!i.hasAttribute("data-reactroot"))),!i)for(var t;t=e.lastChild;)e.removeChild(t);return new td(e,0,i?{hydrate:!0}:void 0)}(t,_),n=a._internalRoot,"function"===typeof s){var l=s;s=function(){var e=$l(n);l.call(e)}}wl((function(){Jl(i,n,e,s)}))}return $l(n)}function ad(e,i){var t=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!_d(i))throw Error(n(200));return function(e,i,t){var _=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:z,key:null==_?null:""+_,children:e,containerInfo:i,implementation:t}}(e,i,null,t)}Pr=function(e,i,t){var _=i.lanes;if(null!==e)if(e.memoizedProps!==i.pendingProps||vs.current)In=!0;else{if(0===(t&_)){switch(In=!1,i.tag){case 3:Zn(i),Za();break;case 5:Wa(i);break;case 1:fs(i.type)&&Es(i);break;case 4:Aa(i,i.stateNode.containerInfo);break;case 10:_=i.memoizedProps.value;var s=i.type._context;ds(Gs,s._currentValue),s._currentValue=_;break;case 13:if(null!==i.memoizedState)return 0!==(t&i.child.childLanes)?Qn(e,i,t):(ds(Ia,1&Ia.current),null!==(i=sr(e,i,t))?i.sibling:null);ds(Ia,1&Ia.current);break;case 19:if(_=0!==(t&i.childLanes),0!==(64&e.flags)){if(_)return _r(e,i,t);i.flags|=64}if(null!==(s=i.memoizedState)&&(s.rendering=null,s.tail=null,s.lastEffect=null),ds(Ia,Ia.current),_)break;return null;case 23:case 24:return i.lanes=0,Xn(e,i,t)}return sr(e,i,t)}In=0!==(16384&e.flags)}else In=!1;switch(i.lanes=0,i.tag){case 2:if(_=i.type,null!==e&&(e.alternate=null,i.alternate=null,i.flags|=2),e=i.pendingProps,s=us(i,ms.current),_a(i,t),s=an(null,i,_,e,s,t),i.flags|=1,"object"===typeof s&&null!==s&&"function"===typeof s.render&&void 0===s.$$typeof){if(i.tag=1,i.memoizedState=null,i.updateQueue=null,fs(_)){var a=!0;Es(i)}else a=!1;i.memoizedState=null!==s.state&&void 0!==s.state?s.state:null,na(i);var r=_.getDerivedStateFromProps;"function"===typeof r&&ua(i,_,r,e),s.updater=fa,i.stateNode=s,s._reactInternals=i,Ea(i,_,e,t),i=Nn(null,i,_,!0,a,t)}else i.tag=0,Bn(null,i,s,t),i=i.child;return i;case 16:s=i.elementType;e:{switch(null!==e&&(e.alternate=null,i.alternate=null,i.flags|=2),e=i.pendingProps,s=(a=s._init)(s._payload),i.type=s,a=i.tag=function(e){if("function"===typeof e)return Nl(e)?1:0;if(void 0!==e&&null!==e){if((e=e.$$typeof)===y)return 11;if(e===T)return 14}return 2}(s),e=Ks(s,e),a){case 0:i=Hn(null,i,s,e,t);break e;case 1:i=kn(null,i,s,e,t);break e;case 11:i=On(null,i,s,e,t);break e;case 14:i=Fn(null,i,s,Ks(s.type,e),_,t);break e}throw Error(n(306,s,""))}return i;case 0:return _=i.type,s=i.pendingProps,Hn(e,i,_,s=i.elementType===_?s:Ks(_,s),t);case 1:return _=i.type,s=i.pendingProps,kn(e,i,_,s=i.elementType===_?s:Ks(_,s),t);case 3:if(Zn(i),_=i.updateQueue,null===e||null===_)throw Error(n(282));if(_=i.pendingProps,s=null!==(s=i.memoizedState)?s.element:null,ra(e,i),ma(i,_,null,t),(_=i.memoizedState.element)===s)Za(),i=sr(e,i,t);else{if((a=(s=i.stateNode).hydrate)&&(Fa=Y_(i.stateNode.containerInfo.firstChild),Oa=i,a=qa=!0),a){if(null!=(e=s.mutableSourceEagerHydrationData))for(s=0;s<e.length;s+=2)(a=e[s])._workInProgressVersionPrimary=e[s+1],Ya.push(a);for(t=Ma(i,null,_,t),i.child=t;t;)t.flags=-3&t.flags|1024,t=t.sibling}else Bn(e,i,_,t),Za();i=i.child}return i;case 5:return Wa(i),null===e&&Ha(i),_=i.type,s=i.pendingProps,a=null!==e?e.memoizedProps:null,r=s.children,H_(_,s)?r=null:null!==a&&H_(_,a)&&(i.flags|=16),Cn(e,i),Bn(e,i,r,t),i.child;case 6:return null===e&&Ha(i),null;case 13:return Qn(e,i,t);case 4:return Aa(i,i.stateNode.containerInfo),_=i.pendingProps,null===e?i.child=La(i,null,_,t):Bn(e,i,_,t),i.child;case 11:return _=i.type,s=i.pendingProps,On(e,i,_,s=i.elementType===_?s:Ks(_,s),t);case 7:return Bn(e,i,i.pendingProps,t),i.child;case 8:case 12:return Bn(e,i,i.pendingProps.children,t),i.child;case 10:e:{_=i.type._context,s=i.pendingProps,r=i.memoizedProps,a=s.value;var l=i.type._context;if(ds(Gs,l._currentValue),l._currentValue=a,null!==r)if(l=r.value,0===(a=l_(l,a)?0:0|("function"===typeof _._calculateChangedBits?_._calculateChangedBits(l,a):1073741823))){if(r.children===s.children&&!vs.current){i=sr(e,i,t);break e}}else for(null!==(l=i.child)&&(l.return=i);null!==l;){var d=l.dependencies;if(null!==d){r=l.child;for(var o=d.firstContext;null!==o;){if(o.context===_&&0!==(o.observedBits&a)){1===l.tag&&((o=la(-1,t&-t)).tag=2,da(l,o)),l.lanes|=t,null!==(o=l.alternate)&&(o.lanes|=t),ta(l.return,t),d.lanes|=t;break}o=o.next}}else r=10===l.tag&&l.type===i.type?null:l.child;if(null!==r)r.return=l;else for(r=l;null!==r;){if(r===i){r=null;break}if(null!==(l=r.sibling)){l.return=r.return,r=l;break}r=r.return}l=r}Bn(e,i,s.children,t),i=i.child}return i;case 9:return s=i.type,_=(a=i.pendingProps).children,_a(i,t),_=_(s=sa(s,a.unstable_observedBits)),i.flags|=1,Bn(e,i,_,t),i.child;case 14:return a=Ks(s=i.type,i.pendingProps),Fn(e,i,s,a=Ks(s.type,a),_,t);case 15:return qn(e,i,i.type,i.pendingProps,_,t);case 17:return _=i.type,s=i.pendingProps,s=i.elementType===_?s:Ks(_,s),null!==e&&(e.alternate=null,i.alternate=null,i.flags|=2),i.tag=1,fs(_)?(e=!0,Es(i)):e=!1,_a(i,t),pa(i,_,s),Ea(i,_,s,t),Nn(null,i,_,!0,e,t);case 19:return _r(e,i,t);case 23:case 24:return Xn(e,i,t)}throw Error(n(156,i.tag))},td.prototype.render=function(e){Jl(e,this._internalRoot,null,null)},td.prototype.unmount=function(){var e=this._internalRoot,i=e.containerInfo;Jl(null,e,null,(function(){i[J_]=null}))},ei=function(e){13===e.tag&&(cl(e,4,ml()),id(e,4))},ii=function(e){13===e.tag&&(cl(e,67108864,ml()),id(e,67108864))},ti=function(e){if(13===e.tag){var i=ml(),t=vl(e);cl(e,t,i),id(e,t)}},_i=function(e,i){return i()},Re=function(e,i,t){switch(i){case"input":if(te(e,t),i=t.name,"radio"===t.type&&null!=i){for(t=e;t.parentNode;)t=t.parentNode;for(t=t.querySelectorAll("input[name="+JSON.stringify(""+i)+'][type="radio"]'),i=0;i<t.length;i++){var _=t[i];if(_!==e&&_.form===e.form){var s=_s(_);if(!s)throw Error(n(90));Q(_),te(_,s)}}}break;case"textarea":de(e,t);break;case"select":null!=(i=t.value)&&ne(e,!!t.multiple,i,!1)}},Te=El,We=function(e,i,t,_,s){var a=Ar;Ar|=4;try{return Ns(98,e.bind(null,i,t,_,s))}finally{0===(Ar=a)&&(Yr(),Ys())}},Ue=function(){0===(49&Ar)&&(function(){if(null!==_l){var e=_l;_l=null,e.forEach((function(e){e.expiredLanes|=24&e.pendingLanes,fl(e,Cs())}))}Ys()}(),Ul())},Ie=function(e,i){var t=Ar;Ar|=2;try{return e(i)}finally{0===(Ar=t)&&(Yr(),Ys())}};var nd={Events:[is,ts,_s,Ve,Ae,Ul,{current:!1}]},rd={findFiberByHostInstance:es,bundleType:0,version:"17.0.2",rendererPackageName:"react-dom"},ld={bundleType:rd.bundleType,version:rd.version,rendererPackageName:rd.rendererPackageName,rendererConfig:rd.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:h.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=Je(e))?null:e.stateNode},findFiberByHostInstance:rd.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var dd=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!dd.isDisabled&&dd.supportsFiber)try{hs=dd.inject(ld),xs=dd}catch(fe){}}i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=nd,i.createPortal=ad,i.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var i=e._reactInternals;if(void 0===i){if("function"===typeof e.render)throw Error(n(188));throw Error(n(268,Object.keys(e)))}return e=null===(e=Je(i))?null:e.stateNode},i.flushSync=function(e,i){var t=Ar;if(0!==(48&t))return e(i);Ar|=1;try{if(e)return Ns(99,e.bind(null,i))}finally{Ar=t,Ys()}},i.hydrate=function(e,i,t){if(!_d(i))throw Error(n(200));return sd(null,e,i,!0,t)},i.render=function(e,i,t){if(!_d(i))throw Error(n(200));return sd(null,e,i,!1,t)},i.unmountComponentAtNode=function(e){if(!_d(e))throw Error(n(40));return!!e._reactRootContainer&&(wl((function(){sd(null,null,e,!1,(function(){e._reactRootContainer=null,e[J_]=null}))})),!0)},i.unstable_batchedUpdates=El,i.unstable_createPortal=function(e,i){return ad(e,i,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)},i.unstable_renderSubtreeIntoContainer=function(e,i,t,_){if(!_d(t))throw Error(n(200));if(null==e||void 0===e._reactInternals)throw Error(n(38));return sd(e,i,t,!1,_)},i.version="17.0.2"},164:function(e,i,t){"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(i){console.error(i)}}(),e.exports=t(463)},374:function(e,i,t){"use strict";t(725);var _=t(791),s=60103;if(60107,"function"===typeof Symbol&&Symbol.for){var a=Symbol.for;s=a("react.element"),a("react.fragment")}var n=_.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,r=Object.prototype.hasOwnProperty,l={key:!0,ref:!0,__self:!0,__source:!0};function d(e,i,t){var _,a={},d=null,o=null;for(_ in void 0!==t&&(d=""+t),void 0!==i.key&&(d=""+i.key),void 0!==i.ref&&(o=i.ref),i)r.call(i,_)&&!l.hasOwnProperty(_)&&(a[_]=i[_]);if(e&&e.defaultProps)for(_ in i=e.defaultProps)void 0===a[_]&&(a[_]=i[_]);return{$$typeof:s,type:e,key:d,ref:o,props:a,_owner:n.current}}i.jsx=d,i.jsxs=d},117:function(e,i,t){"use strict";var _=t(725),s=60103,a=60106;i.Fragment=60107,i.StrictMode=60108,i.Profiler=60114;var n=60109,r=60110,l=60112;i.Suspense=60113;var d=60115,o=60116;if("function"===typeof Symbol&&Symbol.for){var m=Symbol.for;s=m("react.element"),a=m("react.portal"),i.Fragment=m("react.fragment"),i.StrictMode=m("react.strict_mode"),i.Profiler=m("react.profiler"),n=m("react.provider"),r=m("react.context"),l=m("react.forward_ref"),i.Suspense=m("react.suspense"),d=m("react.memo"),o=m("react.lazy")}var v="function"===typeof Symbol&&Symbol.iterator;function c(e){for(var i="https://reactjs.org/docs/error-decoder.html?invariant="+e,t=1;t<arguments.length;t++)i+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+e+"; visit "+i+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var u={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},f={};function b(e,i,t){this.props=e,this.context=i,this.refs=f,this.updater=t||u}function p(){}function g(e,i,t){this.props=e,this.context=i,this.refs=f,this.updater=t||u}b.prototype.isReactComponent={},b.prototype.setState=function(e,i){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error(c(85));this.updater.enqueueSetState(this,e,i,"setState")},b.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},p.prototype=b.prototype;var E=g.prototype=new p;E.constructor=g,_(E,b.prototype),E.isPureReactComponent=!0;var w={current:null},h=Object.prototype.hasOwnProperty,x={key:!0,ref:!0,__self:!0,__source:!0};function z(e,i,t){var _,a={},n=null,r=null;if(null!=i)for(_ in void 0!==i.ref&&(r=i.ref),void 0!==i.key&&(n=""+i.key),i)h.call(i,_)&&!x.hasOwnProperty(_)&&(a[_]=i[_]);var l=arguments.length-2;if(1===l)a.children=t;else if(1<l){for(var d=Array(l),o=0;o<l;o++)d[o]=arguments[o+2];a.children=d}if(e&&e.defaultProps)for(_ in l=e.defaultProps)void 0===a[_]&&(a[_]=l[_]);return{$$typeof:s,type:e,key:n,ref:r,props:a,_owner:w.current}}function L(e){return"object"===typeof e&&null!==e&&e.$$typeof===s}var M=/\/+/g;function R(e,i){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var i={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return i[e]}))}(""+e.key):i.toString(36)}function S(e,i,t,_,n){var r=typeof e;"undefined"!==r&&"boolean"!==r||(e=null);var l=!1;if(null===e)l=!0;else switch(r){case"string":case"number":l=!0;break;case"object":switch(e.$$typeof){case s:case a:l=!0}}if(l)return n=n(l=e),e=""===_?"."+R(l,0):_,Array.isArray(n)?(t="",null!=e&&(t=e.replace(M,"$&/")+"/"),S(n,i,t,"",(function(e){return e}))):null!=n&&(L(n)&&(n=function(e,i){return{$$typeof:s,type:e.type,key:i,ref:e.ref,props:e.props,_owner:e._owner}}(n,t+(!n.key||l&&l.key===n.key?"":(""+n.key).replace(M,"$&/")+"/")+e)),i.push(n)),1;if(l=0,_=""===_?".":_+":",Array.isArray(e))for(var d=0;d<e.length;d++){var o=_+R(r=e[d],d);l+=S(r,i,t,o,n)}else if(o=function(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=v&&e[v]||e["@@iterator"])?e:null}(e),"function"===typeof o)for(e=o.call(e),d=0;!(r=e.next()).done;)l+=S(r=r.value,i,t,o=_+R(r,d++),n);else if("object"===r)throw i=""+e,Error(c(31,"[object Object]"===i?"object with keys {"+Object.keys(e).join(", ")+"}":i));return l}function D(e,i,t){if(null==e)return e;var _=[],s=0;return S(e,_,"","",(function(e){return i.call(t,e,s++)})),_}function y(e){if(-1===e._status){var i=e._result;i=i(),e._status=0,e._result=i,i.then((function(i){0===e._status&&(i=i.default,e._status=1,e._result=i)}),(function(i){0===e._status&&(e._status=2,e._result=i)}))}if(1===e._status)return e._result;throw e._result}var V={current:null};function A(){var e=V.current;if(null===e)throw Error(c(321));return e}var T={ReactCurrentDispatcher:V,ReactCurrentBatchConfig:{transition:0},ReactCurrentOwner:w,IsSomeRendererActing:{current:!1},assign:_};i.Children={map:D,forEach:function(e,i,t){D(e,(function(){i.apply(this,arguments)}),t)},count:function(e){var i=0;return D(e,(function(){i++})),i},toArray:function(e){return D(e,(function(e){return e}))||[]},only:function(e){if(!L(e))throw Error(c(143));return e}},i.Component=b,i.PureComponent=g,i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=T,i.cloneElement=function(e,i,t){if(null===e||void 0===e)throw Error(c(267,e));var a=_({},e.props),n=e.key,r=e.ref,l=e._owner;if(null!=i){if(void 0!==i.ref&&(r=i.ref,l=w.current),void 0!==i.key&&(n=""+i.key),e.type&&e.type.defaultProps)var d=e.type.defaultProps;for(o in i)h.call(i,o)&&!x.hasOwnProperty(o)&&(a[o]=void 0===i[o]&&void 0!==d?d[o]:i[o])}var o=arguments.length-2;if(1===o)a.children=t;else if(1<o){d=Array(o);for(var m=0;m<o;m++)d[m]=arguments[m+2];a.children=d}return{$$typeof:s,type:e.type,key:n,ref:r,props:a,_owner:l}},i.createContext=function(e,i){return void 0===i&&(i=null),(e={$$typeof:r,_calculateChangedBits:i,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null}).Provider={$$typeof:n,_context:e},e.Consumer=e},i.createElement=z,i.createFactory=function(e){var i=z.bind(null,e);return i.type=e,i},i.createRef=function(){return{current:null}},i.forwardRef=function(e){return{$$typeof:l,render:e}},i.isValidElement=L,i.lazy=function(e){return{$$typeof:o,_payload:{_status:-1,_result:e},_init:y}},i.memo=function(e,i){return{$$typeof:d,type:e,compare:void 0===i?null:i}},i.useCallback=function(e,i){return A().useCallback(e,i)},i.useContext=function(e,i){return A().useContext(e,i)},i.useDebugValue=function(){},i.useEffect=function(e,i){return A().useEffect(e,i)},i.useImperativeHandle=function(e,i,t){return A().useImperativeHandle(e,i,t)},i.useLayoutEffect=function(e,i){return A().useLayoutEffect(e,i)},i.useMemo=function(e,i){return A().useMemo(e,i)},i.useReducer=function(e,i,t){return A().useReducer(e,i,t)},i.useRef=function(e){return A().useRef(e)},i.useState=function(e){return A().useState(e)},i.version="17.0.2"},791:function(e,i,t){"use strict";e.exports=t(117)},184:function(e,i,t){"use strict";e.exports=t(374)},813:function(e,i){"use strict";var t,_,s,a;if("object"===typeof performance&&"function"===typeof performance.now){var n=performance;i.unstable_now=function(){return n.now()}}else{var r=Date,l=r.now();i.unstable_now=function(){return r.now()-l}}if("undefined"===typeof window||"function"!==typeof MessageChannel){var d=null,o=null,m=function e(){if(null!==d)try{var t=i.unstable_now();d(!0,t),d=null}catch(_){throw setTimeout(e,0),_}};t=function(e){null!==d?setTimeout(t,0,e):(d=e,setTimeout(m,0))},_=function(e,i){o=setTimeout(e,i)},s=function(){clearTimeout(o)},i.unstable_shouldYield=function(){return!1},a=i.unstable_forceFrameRate=function(){}}else{var v=window.setTimeout,c=window.clearTimeout;if("undefined"!==typeof console){var u=window.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"),"function"!==typeof u&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")}var f=!1,b=null,p=-1,g=5,E=0;i.unstable_shouldYield=function(){return i.unstable_now()>=E},a=function(){},i.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):g=0<e?Math.floor(1e3/e):5};var w=new MessageChannel,h=w.port2;w.port1.onmessage=function(){if(null!==b){var e=i.unstable_now();E=e+g;try{b(!0,e)?h.postMessage(null):(f=!1,b=null)}catch(t){throw h.postMessage(null),t}}else f=!1},t=function(e){b=e,f||(f=!0,h.postMessage(null))},_=function(e,t){p=v((function(){e(i.unstable_now())}),t)},s=function(){c(p),p=-1}}function x(e,i){var t=e.length;e.push(i);e:for(;;){var _=t-1>>>1,s=e[_];if(!(void 0!==s&&0<M(s,i)))break e;e[_]=i,e[t]=s,t=_}}function z(e){return void 0===(e=e[0])?null:e}function L(e){var i=e[0];if(void 0!==i){var t=e.pop();if(t!==i){e[0]=t;e:for(var _=0,s=e.length;_<s;){var a=2*(_+1)-1,n=e[a],r=a+1,l=e[r];if(void 0!==n&&0>M(n,t))void 0!==l&&0>M(l,n)?(e[_]=l,e[r]=t,_=r):(e[_]=n,e[a]=t,_=a);else{if(!(void 0!==l&&0>M(l,t)))break e;e[_]=l,e[r]=t,_=r}}}return i}return null}function M(e,i){var t=e.sortIndex-i.sortIndex;return 0!==t?t:e.id-i.id}var R=[],S=[],D=1,y=null,V=3,A=!1,T=!1,W=!1;function U(e){for(var i=z(S);null!==i;){if(null===i.callback)L(S);else{if(!(i.startTime<=e))break;L(S),i.sortIndex=i.expirationTime,x(R,i)}i=z(S)}}function I(e){if(W=!1,U(e),!T)if(null!==z(R))T=!0,t(B);else{var i=z(S);null!==i&&_(I,i.startTime-e)}}function B(e,t){T=!1,W&&(W=!1,s()),A=!0;var a=V;try{for(U(t),y=z(R);null!==y&&(!(y.expirationTime>t)||e&&!i.unstable_shouldYield());){var n=y.callback;if("function"===typeof n){y.callback=null,V=y.priorityLevel;var r=n(y.expirationTime<=t);t=i.unstable_now(),"function"===typeof r?y.callback=r:y===z(R)&&L(R),U(t)}else L(R);y=z(R)}if(null!==y)var l=!0;else{var d=z(S);null!==d&&_(I,d.startTime-t),l=!1}return l}finally{y=null,V=a,A=!1}}var O=a;i.unstable_IdlePriority=5,i.unstable_ImmediatePriority=1,i.unstable_LowPriority=4,i.unstable_NormalPriority=3,i.unstable_Profiling=null,i.unstable_UserBlockingPriority=2,i.unstable_cancelCallback=function(e){e.callback=null},i.unstable_continueExecution=function(){T||A||(T=!0,t(B))},i.unstable_getCurrentPriorityLevel=function(){return V},i.unstable_getFirstCallbackNode=function(){return z(R)},i.unstable_next=function(e){switch(V){case 1:case 2:case 3:var i=3;break;default:i=V}var t=V;V=i;try{return e()}finally{V=t}},i.unstable_pauseExecution=function(){},i.unstable_requestPaint=O,i.unstable_runWithPriority=function(e,i){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var t=V;V=e;try{return i()}finally{V=t}},i.unstable_scheduleCallback=function(e,a,n){var r=i.unstable_now();switch("object"===typeof n&&null!==n?n="number"===typeof(n=n.delay)&&0<n?r+n:r:n=r,e){case 1:var l=-1;break;case 2:l=250;break;case 5:l=1073741823;break;case 4:l=1e4;break;default:l=5e3}return e={id:D++,callback:a,priorityLevel:e,startTime:n,expirationTime:l=n+l,sortIndex:-1},n>r?(e.sortIndex=n,x(S,e),null===z(R)&&e===z(S)&&(W?s():W=!0,_(I,n-r))):(e.sortIndex=l,x(R,e),T||A||(T=!0,t(B))),e},i.unstable_wrapCallback=function(e){var i=V;return function(){var t=V;V=i;try{return e.apply(this,arguments)}finally{V=t}}}},296:function(e,i,t){"use strict";e.exports=t(813)},458:function(e){e.exports=function(){var e=document.getSelection();if(!e.rangeCount)return function(){};for(var i=document.activeElement,t=[],_=0;_<e.rangeCount;_++)t.push(e.getRangeAt(_));switch(i.tagName.toUpperCase()){case"INPUT":case"TEXTAREA":i.blur();break;default:i=null}return e.removeAllRanges(),function(){"Caret"===e.type&&e.removeAllRanges(),e.rangeCount||t.forEach((function(i){e.addRange(i)})),i&&i.focus()}}}},i={};function t(_){var s=i[_];if(void 0!==s)return s.exports;var a=i[_]={exports:{}};return e[_](a,a.exports,t),a.exports}t.n=function(e){var i=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(i,{a:i}),i},t.d=function(e,i){for(var _ in i)t.o(i,_)&&!t.o(e,_)&&Object.defineProperty(e,_,{enumerable:!0,get:i[_]})},t.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),t.o=function(e,i){return Object.prototype.hasOwnProperty.call(e,i)},t.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},function(){"use strict";var e={};t.r(e),t.d(e,{default:function(){return pl}});var i=t(791),_=t(164);function s(e,i){if(!(e instanceof i))throw new TypeError("Cannot call a class as a function")}function a(e,i){for(var t=0;t<i.length;t++){var _=i[t];_.enumerable=_.enumerable||!1,_.configurable=!0,"value"in _&&(_.writable=!0),Object.defineProperty(e,_.key,_)}}function n(e,i,t){return i&&a(e.prototype,i),t&&a(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}function r(e,i){return r=Object.setPrototypeOf||function(e,i){return e.__proto__=i,e},r(e,i)}function l(e,i){if("function"!==typeof i&&null!==i)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(i&&i.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),i&&r(e,i)}function d(e){return d=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},d(e)}function o(e){return o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},o(e)}function m(e,i){if(i&&("object"===o(i)||"function"===typeof i))return i;if(void 0!==i)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}function v(e){var i=function(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var t,_=d(e);if(i){var s=d(this).constructor;t=Reflect.construct(_,arguments,s)}else t=_.apply(this,arguments);return m(this,t)}}var c={};try{c.enableCssCustomProperties=!!{NODE_ENV:"production",PUBLIC_URL:"/RISC-V_ISA",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.CARBON_ENABLE_CSS_CUSTOM_PROPERTIES&&"true"==={NODE_ENV:"production",PUBLIC_URL:"/RISC-V_ISA",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.CARBON_ENABLE_CSS_CUSTOM_PROPERTIES,c.enableUseControlledStateWithValue=!!{NODE_ENV:"production",PUBLIC_URL:"/RISC-V_ISA",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.CARBON_ENABLE_USE_CONTROLLED_STATE_WITH_VALUE&&"true"==={NODE_ENV:"production",PUBLIC_URL:"/RISC-V_ISA",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.CARBON_ENABLE_USE_CONTROLLED_STATE_WITH_VALUE,c.enableCssGrid=!!{NODE_ENV:"production",PUBLIC_URL:"/RISC-V_ISA",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.CARBON_ENABLE_CSS_GRID&&"true"==={NODE_ENV:"production",PUBLIC_URL:"/RISC-V_ISA",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.CARBON_ENABLE_CSS_GRID,c.enableV11Release=!!{NODE_ENV:"production",PUBLIC_URL:"/RISC-V_ISA",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.CARBON_ENABLE_V11_RELEASE&&"true"==={NODE_ENV:"production",PUBLIC_URL:"/RISC-V_ISA",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.CARBON_ENABLE_V11_RELEASE}catch(iz){c.enableCssCustomProperties=!1,c.enableUseControlledStateWithValue=!1,c.enableCssGrid=!1,c.enableV11Release=!1}var u=[{name:"enable-css-custom-properties",description:"Describe what the flag does",enabled:c.enableCssCustomProperties},{name:"enable-use-controlled-state-with-value",description:"Enable components to be created in either a controlled or uncontrolled mode\n",enabled:c.enableUseControlledStateWithValue},{name:"enable-css-grid",description:"Enable CSS Grid Layout in the Grid and Column React components\n",enabled:c.enableCssGrid},{name:"enable-v11-release",description:"Enable the features and functionality for the v11 Release\n",enabled:c.enableV11Release}];function f(e,i){for(var t=0;t<i.length;t++){var _=i[t];_.enumerable=_.enumerable||!1,_.configurable=!0,"value"in _&&(_.writable=!0),Object.defineProperty(e,_.key,_)}}function b(e,i){return function(e){if(Array.isArray(e))return e}(e)||function(e,i){var t=null==e?null:"undefined"!==typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null==t)return;var _,s,a=[],n=!0,r=!1;try{for(t=t.call(e);!(n=(_=t.next()).done)&&(a.push(_.value),!i||a.length!==i);n=!0);}catch(l){r=!0,s=l}finally{try{n||null==t.return||t.return()}finally{if(r)throw s}}return a}(e,i)||p(e,i)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function p(e,i){if(e){if("string"===typeof e)return g(e,i);var t=Object.prototype.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?g(e,i):void 0}}function g(e,i){(null==i||i>e.length)&&(i=e.length);for(var t=0,_=new Array(i);t<i;t++)_[t]=e[t];return _}for(var E=function(){function e(i){var t=this;!function(e,i){if(!(e instanceof i))throw new TypeError("Cannot call a class as a function")}(this,e),this.flags=new Map,i&&Object.keys(i).forEach((function(e){t.flags.set(e,i[e])}))}var i,t,_;return i=e,t=[{key:"checkForFlag",value:function(e){if(!this.flags.has(e))throw new Error("Unable to find a feature flag with the name: `".concat(e,"`"))}},{key:"add",value:function(e,i){if(this.flags.has(e))throw new Error("The feature flag: ".concat(e," already exists"));this.flags.set(e,i)}},{key:"enable",value:function(e){this.checkForFlag(e),this.flags.set(e,!0)}},{key:"disable",value:function(e){this.checkForFlag(e),this.flags.set(e,!1)}},{key:"merge",value:function(e){var i=this;Object.keys(e).forEach((function(t){i.flags.set(t,e[t])}))}},{key:"mergeWithScope",value:function(e){var i,t=function(e,i){var t="undefined"!==typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!t){if(Array.isArray(e)||(t=p(e))||i&&e&&"number"===typeof e.length){t&&(e=t);var _=0,s=function(){};return{s:s,n:function(){return _>=e.length?{done:!0}:{done:!1,value:e[_++]}},e:function(e){throw e},f:s}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,n=!0,r=!1;return{s:function(){t=t.call(e)},n:function(){var e=t.next();return n=e.done,e},e:function(e){r=!0,a=e},f:function(){try{n||null==t.return||t.return()}finally{if(r)throw a}}}}(e.flags);try{for(t.s();!(i=t.n()).done;){var _=b(i.value,2),s=_[0],a=_[1];this.flags.has(s)||this.flags.set(s,a)}}catch(n){t.e(n)}finally{t.f()}}},{key:"enabled",value:function(e){return this.checkForFlag(e),this.flags.get(e)}}],t&&f(i.prototype,t),_&&f(i,_),Object.defineProperty(i,"prototype",{writable:!1}),e}(),w=z(),h=0;h<u.length;h++){var x=u[h];w.add(x.name,x.enabled)}function z(e){return new E(e)}function L(){return w.enabled.apply(w,arguments)}function M(e,i){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var _=Object.getOwnPropertySymbols(e);i&&(_=_.filter((function(i){return Object.getOwnPropertyDescriptor(e,i).enumerable}))),t.push.apply(t,_)}return t}function R(e){for(var i=1;i<arguments.length;i++){var t=null!=arguments[i]?arguments[i]:{};i%2?M(Object(t),!0).forEach((function(i){A(e,i,t[i])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):M(Object(t)).forEach((function(i){Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(t,i))}))}return e}function S(e){return S="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},S(e)}function D(e,i){if(!(e instanceof i))throw new TypeError("Cannot call a class as a function")}function y(e,i){for(var t=0;t<i.length;t++){var _=i[t];_.enumerable=_.enumerable||!1,_.configurable=!0,"value"in _&&(_.writable=!0),Object.defineProperty(e,_.key,_)}}function V(e,i,t){return i&&y(e.prototype,i),t&&y(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}function A(e,i,t){return i in e?Object.defineProperty(e,i,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[i]=t,e}function T(){return T=Object.assign||function(e){for(var i=1;i<arguments.length;i++){var t=arguments[i];for(var _ in t)Object.prototype.hasOwnProperty.call(t,_)&&(e[_]=t[_])}return e},T.apply(this,arguments)}function W(e,i){if("function"!==typeof i&&null!==i)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(i&&i.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),i&&I(e,i)}function U(e){return U=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},U(e)}function I(e,i){return I=Object.setPrototypeOf||function(e,i){return e.__proto__=i,e},I(e,i)}function B(e,i){if(null==e)return{};var t,_,s=function(e,i){if(null==e)return{};var t,_,s={},a=Object.keys(e);for(_=0;_<a.length;_++)t=a[_],i.indexOf(t)>=0||(s[t]=e[t]);return s}(e,i);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(_=0;_<a.length;_++)t=a[_],i.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}function O(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function F(e){var i=function(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var t,_=U(e);if(i){var s=U(this).constructor;t=Reflect.construct(_,arguments,s)}else t=_.apply(this,arguments);return function(e,i){if(i&&("object"===typeof i||"function"===typeof i))return i;if(void 0!==i)throw new TypeError("Derived constructors may only return object or undefined");return O(e)}(this,t)}}function q(e,i){return function(e){if(Array.isArray(e))return e}(e)||function(e,i){var t=null==e?null:"undefined"!==typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null==t)return;var _,s,a=[],n=!0,r=!1;try{for(t=t.call(e);!(n=(_=t.next()).done)&&(a.push(_.value),!i||a.length!==i);n=!0);}catch(l){r=!0,s=l}finally{try{n||null==t.return||t.return()}finally{if(r)throw s}}return a}(e,i)||X(e,i)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function X(e,i){if(e){if("string"===typeof e)return C(e,i);var t=Object.prototype.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?C(e,i):void 0}}function C(e,i){(null==i||i>e.length)&&(i=e.length);for(var t=0,_=new Array(i);t<i;t++)_[t]=e[t];return _}!function(){w.merge.apply(w,arguments)}({"enable-css-custom-properties":!0,"enable-css-grid":!0,"enable-v11-release":!0});var H=t(694),k=t.n(H),N=i.createContext("cds");function Z(){return i.useContext(N)}var Y=t(7),P=t.n(Y),j=["align","children","className","disabled","size"];function K(e){var t,_=e.align,s=void 0===_?"end":_,a=e.children,n=e.className,r=e.disabled,l=void 0!==r&&r,d=e.size,o=void 0===d?"md":d,m=B(e,j),v=Z(),c=k()("".concat(v,"--accordion"),n,(A(t={},"".concat(v,"--accordion--").concat(s),s),A(t,"".concat(v,"--accordion--").concat(o),o),t));return i.createElement("ul",T({className:c},m),l?i.Children.toArray(a).map((function(e){return i.cloneElement(e,{disabled:l})})):a)}function G(e,i){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var _=Object.getOwnPropertySymbols(e);i&&(_=_.filter((function(i){return Object.getOwnPropertyDescriptor(e,i).enumerable}))),t.push.apply(t,_)}return t}function Q(e){for(var i=1;i<arguments.length;i++){var t=null!=arguments[i]?arguments[i]:{};i%2?G(Object(t),!0).forEach((function(i){J(e,i,t[i])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):G(Object(t)).forEach((function(i){Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(t,i))}))}return e}function J(e,i,t){return i in e?Object.defineProperty(e,i,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[i]=t,e}function $(e,i){if(null==e)return{};var t,_,s=function(e,i){if(null==e)return{};var t,_,s={},a=Object.keys(e);for(_=0;_<a.length;_++)t=a[_],i.indexOf(t)>=0||(s[t]=e[t]);return s}(e,i);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(_=0;_<a.length;_++)t=a[_],i.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}K.propTypes={align:P().oneOf(["start","end"]),children:P().node,className:P().string,disabled:P().bool,size:L("enable-v11-release")?P().oneOf(["sm","md","lg"]):P().oneOf(["sm","md","lg","xl"])};var ee=["width","height","viewBox"],ie=["tabindex"],te={focusable:"false",preserveAspectRatio:"xMidYMid meet"};function _e(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=e.width,t=e.height,_=e.viewBox,s=void 0===_?"0 0 ".concat(i," ").concat(t):_,a=$(e,ee),n=a.tabindex,r=$(a,ie),l=Q(Q(Q({},te),r),{},{width:i,height:t,viewBox:s});return l["aria-label"]||l["aria-labelledby"]||l.title?(l.role="img",void 0!==n&&null!==n&&(l.focusable="true",l.tabindex=n)):l["aria-hidden"]=!0,l}function se(e,i){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var _=Object.getOwnPropertySymbols(e);i&&(_=_.filter((function(i){return Object.getOwnPropertyDescriptor(e,i).enumerable}))),t.push.apply(t,_)}return t}function ae(e){for(var i=1;i<arguments.length;i++){var t=null!=arguments[i]?arguments[i]:{};i%2?se(Object(t),!0).forEach((function(i){ne(e,i,t[i])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):se(Object(t)).forEach((function(i){Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(t,i))}))}return e}function ne(e,i,t){return i in e?Object.defineProperty(e,i,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[i]=t,e}function re(e,i){if(null==e)return{};var t,_,s=function(e,i){if(null==e)return{};var t,_,s={},a=Object.keys(e);for(_=0;_<a.length;_++)t=a[_],i.indexOf(t)>=0||(s[t]=e[t]);return s}(e,i);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(_=0;_<a.length;_++)t=a[_],i.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var le=["className","children","tabIndex"],de=["tabindex"],oe=i.forwardRef((function(e,t){var _=e.className,s=e.children,a=e.tabIndex,n=_e(ae(ae({},re(e,le)),{},{tabindex:a})),r=n.tabindex,l=re(n,de);return _&&(l.className=_),void 0!==r&&null!==r&&(l.tabIndex=r),t&&(l.ref=t),i.createElement("svg",l,s)}));oe.displayName="Icon",oe.propTypes={"aria-hidden":P().string,"aria-label":P().string,"aria-labelledby":P().string,children:P().node,className:P().string,height:P().oneOfType([P().number,P().string]),preserveAspectRatio:P().string,tabIndex:P().string,viewBox:P().string,width:P().oneOfType([P().number,P().string]),xmlns:P().string},oe.defaultProps={xmlns:"http://www.w3.org/2000/svg",preserveAspectRatio:"xMidYMid meet"};var me,ve,ce,ue,fe,be,pe,ge,Ee,we,he,xe,ze,Le,Me,Re,Se,De,ye,Ve,Ae,Te,We,Ue,Ie,Be,Oe,Fe,qe,Xe,Ce,He,ke,Ne,Ze,Ye,Pe,je,Ke,Ge,Qe,Je,$e,ei,ii,ti,_i,si,ai,ni,ri,li,di,oi,mi,vi,ci,ui,fi,bi,pi,gi,Ei,wi,hi,xi,zi,Li,Mi,Ri,Si,Di,yi,Vi,Ai,Ti,Wi,Ui,Ii,Bi,Oi,Fi,qi,Xi,Ci,Hi,ki,Ni,Zi,Yi,Pi,ji,Ki,Gi,Qi,Ji,$i,et,it,tt,_t,st,at,nt,rt,lt,dt,ot,mt,vt,ct,ut,ft,bt,pt,gt,Et,wt,ht,xt,zt,Lt,Mt,Rt,St,Dt,yt,Vt,At,Tt,Wt,Ut,It,Bt,Ot,Ft,qt,Xt,Ct,Ht,kt,Nt,Zt,Yt,Pt,jt,Kt,Gt,Qt,Jt,$t,e_,i_,t_,__,s_,a_,n_,r_,l_,d_,o_,m_,v_,c_,u_,f_,b_,p_,g_,E_,w_,h_,x_,z_,L_,M_,R_,S_,D_,y_,V_,A_,T_,W_,U_,I_,B_,O_,F_,q_,X_,C_,H_,k_,N_,Z_,Y_,P_,j_,K_,G_,Q_,J_,$_,es,is,ts,_s,ss,as,ns,rs,ls,ds,os,ms,vs,cs,us,fs,bs,ps,gs,Es,ws,hs,xs,zs,Ls,Ms,Rs,Ss,Ds,ys,Vs,As,Ts,Ws,Us,Is,Bs,Os,Fs,qs,Xs,Cs,Hs,ks,Ns,Zs,Ys,Ps,js,Ks,Gs,Qs,Js,$s,ea,ia,ta,_a,sa,aa,na,ra,la,da={size:P().oneOfType([P().number,P().string])},oa=["children","size"],ma=["children","size"],va=["children","size"],ca=["children","size"],ua=["children","size"],fa=["children","size"],ba=["children","size"],pa=["children","size"],ga=["children","size"],Ea=["children","size"],wa=["children","size"],ha=["children","size"],xa=["children","size"],za=["children","size"],La=["children","size"],Ma=["children","size"],Ra=["children","size"],Sa=["children","size"],Da=["children","size"],ya=["children","size"],Va=["children","size"],Aa=["children","size"],Ta=["children","size"],Wa=["children","size"],Ua=["children","size"],Ia=["children","size"],Ba=["children","size"],Oa=["children","size"],Fa=["children","size"],qa=["children","size"],Xa=["children","size"],Ca=["children","size"],Ha=["children","size"],ka=["children","size"],Na=["children","size"],Za=["children","size"],Ya=["children","size"],Pa=["children","size"],ja=["children","size"],Ka=["children","size"],Ga=["children","size"],Qa=["children","size"],Ja=["children","size"],$a=["children","size"],en=["children","size"],tn=["children","size"],_n=["children","size"],sn=["children","size"],an=["children","size"],nn=["children","size"],rn=["children","size"],ln=["children","size"],dn=["children","size"],on=["children","size"],mn=["children","size"],vn=["children","size"],cn=["children","size"],un=["children","size"],fn=["children","size"],bn=["children","size"],pn=["children","size"],gn=["children","size"],En=["children","size"],wn=["children","size"],hn=["children","size"],xn=["children","size"],zn=["children","size"],Ln=["children","size"],Mn=["children","size"],Rn=["children","size"],Sn=["children","size"],Dn=["children","size"],yn=["children","size"],Vn=["children","size"],An=["children","size"],Tn=["children","size"],Wn=["children","size"],Un=["children","size"],In=["children","size"],Bn=["children","size"],On=["children","size"],Fn=["children","size"],qn=["children","size"],Xn=["children","size"],Cn=["children","size"],Hn=["children","size"],kn=["children","size"],Nn=["children","size"],Zn=["children","size"],Yn=["children","size"],Pn=["children","size"],jn=["children","size"],Kn=["children","size"],Gn=["children","size"],Qn=["children","size"],Jn=["children","size"],$n=["children","size"],er=["children","size"],ir=["children","size"],tr=["children","size"],_r=["children","size"],sr=["children","size"],ar=["children","size"],nr=["children","size"],rr=["children","size"],lr=["children","size"],dr=["children","size"],or=["children","size"],mr=["children","size"],vr=["children","size"],cr=["children","size"],ur=["children","size"],fr=["children","size"],br=["children","size"],pr=["children","size"],gr=["children","size"],Er=["children","size"],wr=["children","size"],hr=["children","size"],xr=["children","size"],zr=["children","size"],Lr=["children","size"],Mr=["children","size"],Rr=["children","size"],Sr=["children","size"];i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,oa);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),me||(me=i.createElement("path",{d:"M28 24H14V16H28zM16 22H26V18H16zM26 12H8V4H26zM10 10H24V6H10z"})),ve||(ve=i.createElement("path",{d:"M30,30H4a2.0023,2.0023,0,0,1-2-2V2H4V28H30Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ma);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ce||(ce=i.createElement("path",{d:"M4,28V26H26V16H4V14H18V4H4V2H2V28a2,2,0,0,0,2,2H30V28ZM24,18v6H4V22H20V20H4V18ZM16,6v6H4V10h8V8H4V6Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,va);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ue||(ue=i.createElement("path",{d:"M4,28V25H26V17H4V13H18V5H4V2H2V28a2,2,0,0,0,2,2H30V28Zm20-5H14V19H24ZM16,11H10V7h6Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ca);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),fe||(fe=i.createElement("path",{d:"M28 17H30V25H28zM20 5H22V13H20z"})),be||(be=i.createElement("path",{d:"M4,2H2V28a2,2,0,0,0,2,2H30V28H4V25H26V17H4V13H18V5H4ZM24,19v4H4V19ZM16,7v4H4V7Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ua);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),pe||(pe=i.createElement("path",{d:"M30,30H4a2,2,0,0,1-2-2V2H4V28H30Z"})),ge||(ge=i.createElement("path",{d:"M10 16a2 2 0 11-2 2 2 2 0 012-2m0-2a4 4 0 104 4 4 4 0 00-4-4zM21 6a4 4 0 11-4 4 4 4 0 014-4m0-2a6 6 0 106 6 6 6 0 00-6-6zM24.5 21A1.5 1.5 0 1123 22.5 1.5 1.5 0 0124.5 21m0-2A3.5 3.5 0 1028 22.5 3.5 3.5 0 0024.5 19z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,fa);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ee||(Ee=i.createElement("path",{d:"M27.5322,17.1724A8.99,8.99,0,1,0,13.6074,5.88,5.9969,5.9969,0,1,0,5.051,13.2217a6.9967,6.9967,0,1,0,7.9942,11.4844A5.9981,5.9981,0,0,0,25,24c0-.1216-.011-.24-.0181-.3594a3.4873,3.4873,0,1,0,2.55-6.4682ZM21,4a7,7,0,1,1-7,7A7.0078,7.0078,0,0,1,21,4ZM8,4A4,4,0,1,1,4,8,4.0045,4.0045,0,0,1,8,4ZM19,28a4,4,0,1,1,4-4A4.0045,4.0045,0,0,1,19,28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ba);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),we||(we=i.createElement("path",{d:"M30 22H16V21H14v1H2v6H14v1h2V28H30zM4 26V24H14v2zm24 0H16V24H28zM30 13H24V12H22v1H2v6H22v1h2V19h6zM4 17V15H22v2zm24 0H24V15h4zM30 4H10V3H8V4H2v6H8v1h2V10H30zM4 8V6H8V8zM28 8H10V6H28z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,pa);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),he||(he=i.createElement("path",{d:"M26 10H24V6H22v4H20V22h2v4h2V22h2zM24 20H22V12h2zM14 8H12V4H10V8H8V18h2v4h2V18h2zm-2 8H10V10h2z"})),xe||(xe=i.createElement("path",{d:"M30,30H4a2,2,0,0,1-2-2V2H4V28H30Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ga);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ze||(ze=i.createElement("path",{d:"M30,30H4a2,2,0,0,1-2-2V2H4V28H30Z"})),Le||(Le=i.createElement("path",{d:"M10 16H12V26H10zM7 22H9V26H7zM26 8H28V26H26zM23 14H25V26H23z"})),Me||(Me=i.createElement("path",{d:"M15 12H17V26H15z",transform:"rotate(-180 16 19)"})),Re||(Re=i.createElement("path",{d:"M18 18H20V26H18z",transform:"rotate(-180 19 22)"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ea);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Se||(Se=i.createElement("path",{d:"M27,28V6H19V28H15V14H7V28H4V2H2V28a2,2,0,0,0,2,2H30V28ZM13,28H9V16h4Zm12,0H21V8h4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,wa);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),De||(De=i.createElement("path",{d:"M28 22H20V4h8zm-6-2h4V6H22zM16 24H8V10h8zm-6-2h4V12H10z"})),ye||(ye=i.createElement("path",{d:"M30,30H4a2.0021,2.0021,0,0,1-2-2V2H4V28H30Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ha);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ve||(Ve=i.createElement("path",{d:"M27 28V6H19V28H15V14H7V28H4V2H2V28a2 2 0 002 2H30V28zM13 28H9V16h4zm12 0H21V8h4zM19 2H27V4H19z"})),Ae||(Ae=i.createElement("path",{d:"M7 10H15V12H7z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,xa);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Te||(Te=i.createElement("path",{d:"M27,28V16H19V28H15V12H7V28H4V2H2V28a2,2,0,0,0,2,2H30V28ZM13,28H9V14h4Zm12,0H21V18h4Z"})),We||(We=i.createElement("path",{d:"M22.7856,14a1.9877,1.9877,0,0,1-1.1787-.3865L11.2041,5.987,8.2419,10,6.6374,8.8065l2.9812-4a1.9978,1.9978,0,0,1,2.749-.446l10.4214,7.64,3.6045-4.8613L28,8.3306l-3.6045,4.8611A2.0014,2.0014,0,0,1,22.7856,14Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,za);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ue||(Ue=i.createElement("path",{d:"M27,28V16H19V28H15V12H7V28H4V2H2V28a2,2,0,0,0,2,2H30V28ZM13,14v6H9V14Zm12,4v6H21V18Z"})),Ie||(Ie=i.createElement("path",{d:"M22.7856,14a1.9877,1.9877,0,0,1-1.1787-.3865L11.2041,5.987,8.2419,10,6.6374,8.8065l2.9812-4a1.9978,1.9978,0,0,1,2.749-.446l10.4214,7.64,3.6045-4.8613L28,8.3306l-3.6045,4.8611A2.0014,2.0014,0,0,1,22.7856,14Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,La);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Be||(Be=i.createElement("path",{d:"M29.707,19.293l-3-3a.9994.9994,0,0,0-1.414,0L16,25.5859V30h4.4141l9.2929-9.293A.9994.9994,0,0,0,29.707,19.293ZM19.5859,28H18V26.4141l5-5L24.5859,23ZM26,21.5859,24.4141,20,26,18.4141,27.5859,20Z"})),Oe||(Oe=i.createElement("path",{d:"M17 15H21V17H17z",transform:"rotate(-90 19 16)"})),Fe||(Fe=i.createElement("path",{d:"M12 14H18V16H12z",transform:"rotate(-90 15 15)"})),qe||(qe=i.createElement("path",{d:"M6 12H16V14H6z",transform:"rotate(-90 11 13)"})),Xe||(Xe=i.createElement("path",{d:"M12,30H6a2.0021,2.0021,0,0,1-2-2V4A2.0021,2.0021,0,0,1,6,2H22a2.0021,2.0021,0,0,1,2,2V14H22V4H6V28h6Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ma);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ce||(Ce=i.createElement("path",{d:"M22,28V12H18V8h2V6H14V8h2v4H12V28H4V2H2V28a2,2,0,0,0,2,2H30V28ZM14,14h2v4H14Zm6,14H14V20h6Zm0-10H18V14h2Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ra);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),He||(He=i.createElement("path",{d:"M14 10V8H8v2h2v4.1836a2.983 2.983 0 000 5.6328V24H8v2h6V24H12V19.8164a2.983 2.983 0 000-5.6328V10zM26 6V4H20V6h2V8.1836a2.983 2.983 0 000 5.6328V18H20v2h6V18H24V13.8164a2.983 2.983 0 000-5.6328V6z"})),ke||(ke=i.createElement("path",{d:"M30,30H4a2,2,0,0,1-2-2V2H4V28H30Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Sa);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ne||(Ne=i.createElement("path",{d:"M25.672 6.207H29.915V8.206H25.672z",transform:"rotate(-45.02 27.793 7.207)"})),Ze||(Ze=i.createElement("path",{d:"M16 20.5L11 15.539 12.59 13.969 16 17.349 23.41 10 25 11.579 16 20.5z"})),Ye||(Ye=i.createElement("path",{d:"M4,28V25.4131L10.4141,19,9,17.585l-5,5V2H2V28a2,2,0,0,0,2,2H30V28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Da);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Pe||(Pe=i.createElement("path",{d:"M15 8L12 8 12 6 10 6 10 20 7 20 7 22 10 22 10 24 12 24 12 10 15 10 15 8zM27 10L24 10 24 6 22 6 22 18 19 18 19 20 22 20 22 24 24 24 24 12 27 12 27 10z"})),je||(je=i.createElement("path",{d:"M30,30H4a2,2,0,0,1-2-2V2H4V28H30Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ya);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ke||(Ke=i.createElement("path",{d:"M6,16c2.9727,0,4.2324-2.251,5.3447-4.2373C12.4741,9.7441,13.45,8,16,8s3.5259,1.7441,4.6553,3.7627C21.7676,13.749,23.0273,16,26,16h4V14H26c-1.7129,0-2.4834-1.2207-3.5991-3.2144C21.2075,8.6543,19.7231,6,16,6s-5.2075,2.6543-6.4009,4.7856C8.4834,12.7793,7.7129,14,6,14H4V2H2V28a2,2,0,0,0,2,2H30V28H28V22H26v6H21.9992L22,20H20v8H16V16H14V28H9.9992L10,20H8v8H4V16Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Va);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ge||(Ge=i.createElement("path",{d:"M4.67,28l6.39-12,7.3,6.49a2,2,0,0,0,1.7.47,2,2,0,0,0,1.42-1.07L27,10.9,25.18,10,19.69,21l-7.3-6.49A2,2,0,0,0,10.71,14a2,2,0,0,0-1.42,1L4,25V2H2V28a2,2,0,0,0,2,2H30V28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Aa);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Qe||(Qe=i.createElement("path",{d:"M10.06,17.88A4.25,4.25,0,0,0,11,18a4,4,0,0,0,2.23-.68l3.22,2.87a3.88,3.88,0,0,0-.2,3.17A4,4,0,1,0,22.62,19l2.54-5.09a3.78,3.78,0,0,0,2.91-.53A4,4,0,1,0,23.38,13l-2.54,5.09A3.86,3.86,0,0,0,20,18a4,4,0,0,0-2.23.68l-3.22-2.87a3.88,3.88,0,0,0,.2-3.17A4,4,0,1,0,8.3,16.93L4,25V2H2V28a2,2,0,0,0,2,2H30V28H4.67ZM26,8a2,2,0,1,1-2,2A2,2,0,0,1,26,8ZM22,22a2,2,0,1,1-2-2A2,2,0,0,1,22,22ZM11,12a2,2,0,1,1-2,2A2,2,0,0,1,11,12Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ta);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Je||(Je=i.createElement("path",{d:"M13,15c1.4854,0,2.5544,1.4966,3.6863,3.0811C17.9983,19.918,19.4854,22,22,22c5.6709,0,7.78-10.79,8-12l-1.9678-.3584C27.55,12.2827,25.3938,20,22,20c-1.4854,0-2.5544-1.4966-3.6863-3.0811C17.0017,15.082,15.5146,13,13,13c-4.186,0-7.4448,7.4043-9,11.7617V2H2V28a2.0025,2.0025,0,0,0,2,2H30V28H5.0439C6.5544,22.8574,9.9634,15,13,15Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Wa);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),$e||($e=i.createElement("path",{d:"M27,3H5A2.0025,2.0025,0,0,0,3,5V27a2.0025,2.0025,0,0,0,2,2H27a2.0025,2.0025,0,0,0,2-2V5A2.0025,2.0025,0,0,0,27,3Zm0,7H21V5h6ZM19,8H13V5h6Zm0,2v8H13V10ZM11,22H5V12h6Zm2-2h6v7H13Zm8-8h6v4H21ZM11,5v5H5V5ZM5,24h6v3H5Zm16,3V18h6v9Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ua);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ei||(ei=i.createElement("path",{d:"M8 6H10V8H8zM12 6H14V8H12zM20 6H22V8H20zM24 6H26V8H24zM28 6H30V8H28z"})),ii||(ii=i.createElement("path",{d:"M27.989,28l-.0271-.1631C26.5105,19.0742,24.0662,9.0894,18,8.0889V6H16V8.085c-6.084.978-8.533,10.9775-9.9863,19.7519L5.9866,28H4V8H6V6H4V2H2V28a2,2,0,0,0,2,2H30V28ZM8.0151,28c2.024-12.1084,4.959-18,8.9727-18s6.9487,5.8916,8.9726,18Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ia);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ti||(ti=i.createElement("path",{d:"M16 22H18V24H16z",transform:"rotate(-90 17 23)"})),_i||(_i=i.createElement("path",{d:"M18,28V26H16v2H4V2H2V28a2,2,0,0,0,2,2H30V28Z"})),si||(si=i.createElement("path",{d:"M26.0532,19.6787A3.44,3.44,0,0,1,23,22c-2.17,0-3.3115-3.333-4.52-6.8623-.3557-1.0386-.7239-2.1094-1.1382-3.1377H18V10H16.4221C15.2124,7.7148,13.5811,6,11,6,7.3218,6,6.1016,9.5332,6.0513,9.6836l1.8955.6377A3.44,3.44,0,0,1,11,8c2.92,0,4.2764,3.958,5.5874,7.7861.2544.7422.5105,1.4893.7813,2.2139H16v2h2.2019c1.0828,2.2886,2.4959,4,4.7981,4,3.6782,0,4.8984-3.5332,4.9487-3.6836Z"})),ai||(ai=i.createElement("path",{d:"M16 6H18V8H16z",transform:"rotate(-90 17 7)"})),ni||(ni=i.createElement("path",{d:"M16 2H18V4H16z",transform:"rotate(-90 17 3)"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ba);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ri||(ri=i.createElement("path",{d:"M4,28V26H6V24H4V2H2V28a2,2,0,0,0,2,2H30V28Z"})),li||(li=i.createElement("path",{d:"M8 24H10V26H8zM12 24H14V26H12zM20 24H22V26H20zM24 24H26V26H24zM28 24H30V26H28z"})),di||(di=i.createElement("path",{d:"M27.9463,4.3281,25.9727,4C23.9487,16.1084,21.0137,22,17,22S10.0513,16.1084,8.0271,4l-1.9734.3281C7.51,13.0566,9.9631,22.93,16,23.9131V26h2V23.9131C24.0371,22.93,26.4907,13.0566,27.9463,4.3281Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Oa);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),oi||(oi=i.createElement("path",{d:"M4.5859,28l7.1783-5.998L19.7578,23.94a2.021,2.021,0,0,0,1.314-.1206L28,20.5811l-.8479-1.8121-6.9163,3.229L12.2422,20.06a2.0033,2.0033,0,0,0-1.74.3838L4,25.8818V20.49l7.7642-6.4877L19.7578,15.94a2.021,2.021,0,0,0,1.314-.1206l6.9287-3.2383-.8467-1.812-6.918,3.2285L12.2422,12.06a2.0049,2.0049,0,0,0-1.74.3838L4,17.8818V12.49L11.7642,6.002,19.7578,7.94a2.021,2.021,0,0,0,1.314-.1206L28,4.5859l-.8457-1.8115L20.2358,5.998,12.2422,4.06a2.0033,2.0033,0,0,0-1.74.3838L4,9.8818V2H2V28a2,2,0,0,0,2,2H30V28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Fa);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),mi||(mi=i.createElement("path",{d:"M28 22H30V30H28zM24 18H26V30H24zM20 26H22V30H20zM9 16a7 7 0 107 7A7.0078 7.0078 0 009 16zm4.8989 6H10V18.1011A5.0145 5.0145 0 0113.8989 22zM9 28a5 5 0 01-1-9.8989V22a2 2 0 002 2h3.8989A5.0081 5.0081 0 019 28zM22.5352 12l4-6H30V4H25.4648l-4 6H18V2H16V14a2 2 0 002 2H30V14H18V12z"})),vi||(vi=i.createElement("circle",{cx:"11",cy:"7",r:"1"})),ci||(ci=i.createElement("circle",{cx:"9",cy:"11",r:"1"})),ui||(ui=i.createElement("circle",{cx:"7",cy:"5",r:"1"})),fi||(fi=i.createElement("circle",{cx:"5",cy:"9",r:"1"})),bi||(bi=i.createElement("circle",{cx:"3",cy:"13",r:"1"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,qa);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),pi||(pi=i.createElement("path",{d:"M26,14a2,2,0,0,0,2-2V6a2,2,0,0,0-2-2H20a2,2,0,0,0-2,2v6a2,2,0,0,0,2,2h2v4.1A5,5,0,0,0,18.1,22H14V20a2,2,0,0,0-2-2H10V13.9a5,5,0,1,0-2,0V18H6a2,2,0,0,0-2,2v6a2,2,0,0,0,2,2h6a2,2,0,0,0,2-2V24h4.1A5,5,0,1,0,24,18.1V14ZM6,9a3,3,0,1,1,3,3A3,3,0,0,1,6,9Zm6,17H6V20h6Zm14-3a3,3,0,1,1-3-3A3,3,0,0,1,26,23ZM20,6h6v6H20Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Xa);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),gi||(gi=i.createElement("path",{d:"M28,2V5.3071l-6,2.25V2H20V7.5229l-8-3.2V2H10V4.4458l-6,3.75V2H2V30H4V27.6182l6-3V30h2V24.3442l8,2.4V30h2V26.5542l6-3.75V30h2V2Zm0,5.4429V12.5L22,17V9.6929ZM20,9.6768v7.5571l-8-4.8V6.4771ZM10,6.8042v5.7417l-6,5.25V10.5542ZM4,25.3818V20.4541l6-5.25v7.1777Zm8-3.1259v-7.49l8,4.8v5.0894Zm10,1.94V19.5L28,15v5.4458Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ca);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ei||(Ei=i.createElement("path",{d:"M16,4A12,12,0,1,0,28,16,12,12,0,0,0,16,4ZM26,15H17V6.05A10,10,0,0,1,26,15ZM15.42,26A10,10,0,0,1,15,6.05v9a2,2,0,0,0,2,2h9A10,10,0,0,1,15.42,26Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ha);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),wi||(wi=i.createElement("path",{d:"M30,30H4a2.0023,2.0023,0,0,1-2-2V2H4V28H30Z"})),hi||(hi=i.createElement("circle",{cx:"9",cy:"6",r:"3"})),xi||(xi=i.createElement("circle",{cx:"9",cy:"22",r:"3"})),zi||(zi=i.createElement("circle",{cx:"18",cy:"14",r:"3"})),Li||(Li=i.createElement("path",{d:"M9,17a3,3,0,1,1,3-3A3.0033,3.0033,0,0,1,9,17Zm0-4a1,1,0,1,0,1,1A1.001,1.001,0,0,0,9,13Z"})),Mi||(Mi=i.createElement("circle",{cx:"27",cy:"6",r:"3"})),Ri||(Ri=i.createElement("circle",{cx:"27",cy:"22",r:"3"})),Si||(Si=i.createElement("path",{d:"M27 17a3 3 0 113-3A3.0033 3.0033 0 0127 17zm0-4a1 1 0 101 1A1.001 1.001 0 0027 13zM18 26a3 3 0 113-3A3.0033 3.0033 0 0118 26zm0-4a1 1 0 101 1A1.001 1.001 0 0018 22zM18 8a3 3 0 113-3A3.0033 3.0033 0 0118 8zm0-4a1 1 0 101 1A1.001 1.001 0 0018 4z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ka);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Di||(Di=i.createElement("path",{d:"M30,22H17V20h9V14H17V12h5V6H17V2H15V6H10v6h5v2H6v6h9v2H2v6H15v2h2V28H30ZM20,8v2H17V8Zm-8,2V8h3v2Zm12,6v2H17V16ZM8,18V16h7v2ZM4,26V24H15v2Zm24,0H17V24H28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Na);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),yi||(yi=i.createElement("path",{d:"M16,2,2,13,8,30H24l6-17Zm2.5818,19.2651-5.9861,1.3306-1.4226-7.8252,4.91-4.209,5.4416,4.0816Zm.1977,2.0054L21.3264,28H10.6736l1.7912-3.3267ZM9.59,13.4937,5.74,12.605,15,5.3291V8.8569ZM17,8.75V5.3291l9.26,7.2759-3.15.727ZM4.6143,14.3979l4.6535,1.0738,1.4844,8.164-1.738,3.2281ZM22.9858,26.8638l-2.5766-4.7852,3.0063-6.7646,3.97-.9161Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Za);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Vi||(Vi=i.createElement("path",{d:"M16,30A14.0158,14.0158,0,0,1,2,16H4A12,12,0,1,0,16,4V2a14,14,0,0,1,0,28Z"})),Ai||(Ai=i.createElement("path",{d:"M16,26A10.0115,10.0115,0,0,1,6,16H8a8,8,0,1,0,8-8V6a10,10,0,0,1,0,20Z"})),Ti||(Ti=i.createElement("path",{d:"M16,22a6.0069,6.0069,0,0,1-6-6h2a4,4,0,1,0,4-4V10a6,6,0,0,1,0,12Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ya);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Wi||(Wi=i.createElement("path",{d:"M26,6a3.9963,3.9963,0,0,0-3.8579,3H17.9305A7.9964,7.9964,0,1,0,9,17.9307v4.2114a4,4,0,1,0,2,0V17.9307a7.951,7.951,0,0,0,3.8976-1.6192l3.6693,3.67A3.9529,3.9529,0,0,0,18,22a4,4,0,1,0,4-4,3.9521,3.9521,0,0,0-2.019.5669l-3.6694-3.6694A7.9493,7.9493,0,0,0,17.9305,11h4.2116A3.9934,3.9934,0,1,0,26,6ZM12,26a2,2,0,1,1-2-2A2.0023,2.0023,0,0,1,12,26ZM10,16a6,6,0,1,1,6-6A6.0066,6.0066,0,0,1,10,16Zm14,6a2,2,0,1,1-2-2A2.0023,2.0023,0,0,1,24,22Zm2-10a2,2,0,1,1,2-2A2.0023,2.0023,0,0,1,26,12Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Pa);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ui||(Ui=i.createElement("path",{d:"M16,2A14,14,0,1,0,30,16,14.0158,14.0158,0,0,0,16,2ZM27.9493,15.001H21.91a5.9825,5.9825,0,0,0-9.3806-3.8853l-4.27-4.27a11.9783,11.9783,0,0,1,19.69,8.1548ZM16,20a4,4,0,1,1,4-4A4.0045,4.0045,0,0,1,16,20ZM4,16A11.937,11.937,0,0,1,6.8455,8.26l4.27,4.2695A5.9836,5.9836,0,0,0,15,21.9106v6.04A12.0105,12.0105,0,0,1,4,16ZM17,27.95v-6.04A6.0069,6.0069,0,0,0,21.91,17h6.04A12.0082,12.0082,0,0,1,17,27.95Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ja);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ii||(Ii=i.createElement("path",{d:"M12.4326,20.0171l8.0376,4.68a1.958,1.958,0,0,0,1.0508.3012,2.2412,2.2412,0,0,0,.4888-.0556l7.2532-1.9769A1,1,0,0,0,30,22.0007V7.996A1,1,0,0,0,28.74,7.0305L21.5034,8.9829l-8.0371-4.68a1.9917,1.9917,0,0,0-1.8652-.1352L4,7.4727V2H2V28a2,2,0,0,0,2,2H30V28H4V23.6577ZM28,21.2344l-6.4966,1.75-8.0371-4.68a1.9931,1.9931,0,0,0-1.8652-.1353L4,21.4746V16.6572l8.4326-3.6416L20.47,17.6968a1.962,1.962,0,0,0,1.0508.3008,2.2112,2.2112,0,0,0,.4888-.0557L28,16.31ZM12.4326,6.0156l8.0376,4.68a2.0091,2.0091,0,0,0,1.54.2451L28,9.3081v4.9258l-6.4966,1.7505-8.0371-4.6812a1.9917,1.9917,0,0,0-1.8652-.1352L4,14.4736V9.6562Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ka);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Bi||(Bi=i.createElement("path",{d:"M30,17A15.017,15.017,0,0,0,15,2H14V8.0591A9.0122,9.0122,0,0,0,6.0591,16H4v1A11.0109,11.0109,0,0,0,14,27.9492V30h1A13.0084,13.0084,0,0,0,27.9492,18H30ZM16,4.0381A13.0217,13.0217,0,0,1,27.9619,16H16ZM14,10.08V16H8.08A7.0037,7.0037,0,0,1,14,10.08ZM6.0552,18H14v7.939A9.0134,9.0134,0,0,1,6.0552,18ZM16,27.9551V18h9.9551A11.0191,11.0191,0,0,1,16,27.9551Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ga);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Oi||(Oi=i.createElement("path",{d:"M30,30H4a2,2,0,0,1-2-2V2H4V28H30Z"})),Fi||(Fi=i.createElement("circle",{cx:"10",cy:"22",r:"2"})),qi||(qi=i.createElement("circle",{cx:"14",cy:"15",r:"2"})),Xi||(Xi=i.createElement("circle",{cx:"22",cy:"15",r:"2"})),Ci||(Ci=i.createElement("circle",{cx:"26",cy:"6",r:"2"})),Hi||(Hi=i.createElement("circle",{cx:"14",cy:"8",r:"2"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Qa);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ki||(ki=i.createElement("path",{d:"M16,2A13.919,13.919,0,0,0,7.3245,5.0327,1.9728,1.9728,0,0,0,7,5,2,2,0,0,0,5,7a1.9752,1.9752,0,0,0,.0327.3247A13.986,13.986,0,1,0,16,2Zm0,26A11.977,11.977,0,0,1,6.3589,8.8857a1.8311,1.8311,0,0,0,1.1528.04l1.4634,1.4634a8.9862,8.9862,0,0,0,11.8311,13.207,1.9916,1.9916,0,0,0,2.79-2.79,8.9294,8.9294,0,0,0,0-9.6124,1.9916,1.9916,0,0,0-2.79-2.79,8.9445,8.9445,0,0,0-10.417.5713L8.9258,7.5117a1.8294,1.8294,0,0,0-.04-1.1528A11.9925,11.9925,0,1,1,16,28Zm0-14a2,2,0,1,1-2,2A2.0025,2.0025,0,0,1,16,14Zm3.4331-.019,2.0552-2.0552a2.0443,2.0443,0,0,0,.2265.0454,6.9573,6.9573,0,0,1,0,8.0576,2.0443,2.0443,0,0,0-.2265.0454L19.4331,18.019a3.8788,3.8788,0,0,0,0-4.038Zm.5957-3.6958a1.9993,1.9993,0,0,0,.0454.2265L18.019,12.5669a3.8788,3.8788,0,0,0-4.038,0l-2.1653-2.1655a6.9522,6.9522,0,0,1,8.2131-.1162ZM12.5669,13.981A3.951,3.951,0,0,0,12,16a4.0045,4.0045,0,0,0,4,4,3.9521,3.9521,0,0,0,2.019-.5669l2.0552,2.0552a1.9993,1.9993,0,0,0-.0454.2265,6.988,6.988,0,0,1-9.6272-9.8994Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ja);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ni||(Ni=i.createElement("path",{d:"M28,28V6H20V28H16V14H8V28H4V2H2V28a2,2,0,0,0,2,2H30V28ZM22,8h4V18H22ZM10,16h4v6H10Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,$a);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Zi||(Zi=i.createElement("path",{d:"M14,22V14h8V6h8V4H20v8H12v8H4V2H2V28a2.0025,2.0025,0,0,0,2,2H30V28H4V22Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,en);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Yi||(Yi=i.createElement("path",{d:"M16,2a1,1,0,0,0-1,1v7.09a5.9618,5.9618,0,0,0-2.46,1.043L7.8384,6.4311a1.4554,1.4554,0,0,0-2.087.0244A14.05,14.05,0,0,0,9.8047,28.5972a10.8482,10.8482,0,0,0,1.8989.7676,14.0982,14.0982,0,0,0,13.8443-3.1319,1.4336,1.4336,0,0,0,.0278-2.0639L20.877,19.47A5.963,5.963,0,0,0,21.91,17H29a1,1,0,0,0,1-1A14.0158,14.0158,0,0,0,16,2Zm0,10a4,4,0,1,1-4,4A4.0045,4.0045,0,0,1,16,12ZM6.83,8.251l4.2959,4.2959a5.91,5.91,0,0,0-.0113,6.9243L6.8381,23.7481A12.0168,12.0168,0,0,1,6.83,8.251Zm1.4228,16.91,4.2759-4.2759A5.9589,5.9589,0,0,0,15,21.91v6.042A11.8783,11.8783,0,0,1,8.2529,25.1612ZM17,27.9561V21.9092a5.9631,5.9631,0,0,0,2.4609-1.0273l4.2818,4.2817A11.8905,11.8905,0,0,1,17,27.9561ZM21.91,15A6.0063,6.0063,0,0,0,17,10.09V4.041A12.0208,12.0208,0,0,1,27.9585,15Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,tn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Pi||(Pi=i.createElement("circle",{cx:"10",cy:"20",r:"2"})),ji||(ji=i.createElement("circle",{cx:"10",cy:"28",r:"2"})),Ki||(Ki=i.createElement("circle",{cx:"10",cy:"14",r:"2"})),Gi||(Gi=i.createElement("circle",{cx:"28",cy:"4",r:"2"})),Qi||(Qi=i.createElement("circle",{cx:"22",cy:"6",r:"2"})),Ji||(Ji=i.createElement("circle",{cx:"28",cy:"10",r:"2"})),$i||($i=i.createElement("circle",{cx:"20",cy:"12",r:"2"})),et||(et=i.createElement("circle",{cx:"28",cy:"22",r:"2"})),it||(it=i.createElement("circle",{cx:"26",cy:"28",r:"2"})),tt||(tt=i.createElement("circle",{cx:"20",cy:"26",r:"2"})),_t||(_t=i.createElement("circle",{cx:"22",cy:"20",r:"2"})),st||(st=i.createElement("circle",{cx:"16",cy:"4",r:"2"})),at||(at=i.createElement("circle",{cx:"4",cy:"24",r:"2"})),nt||(nt=i.createElement("circle",{cx:"4",cy:"16",r:"2"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,_n);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),rt||(rt=i.createElement("path",{d:"M28,2H4A2.0023,2.0023,0,0,0,2,4V28a2.0023,2.0023,0,0,0,2,2H28a2.0023,2.0023,0,0,0,2-2V4A2.0023,2.0023,0,0,0,28,2Zm0,12H23V4h5ZM16,4h5V14H16ZM14,4V20H4V4ZM4,22H14v6H4Zm12,6V16H28V28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,sn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),lt||(lt=i.createElement("path",{d:"M20,6a9.92,9.92,0,0,0-4,.84A9.92,9.92,0,0,0,12,6a10,10,0,0,0,0,20,9.92,9.92,0,0,0,4-.84A9.92,9.92,0,0,0,20,26,10,10,0,0,0,20,6ZM12,24A8,8,0,0,1,12,8a7.91,7.91,0,0,1,1.76.2,10,10,0,0,0,0,15.6A7.91,7.91,0,0,1,12,24Zm8-8a8,8,0,0,1-4,6.92A8,8,0,0,1,16,9.08,8,8,0,0,1,20,16Zm0,8a7.91,7.91,0,0,1-1.76-.2,10,10,0,0,0,0-15.6A7.91,7.91,0,0,1,20,8a8,8,0,0,1,0,16Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,an);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),dt||(dt=i.createElement("path",{d:"M30,30H4a2,2,0,0,1-2-2V2H4V28H30Z"})),ot||(ot=i.createElement("path",{d:"M14.86 7.8232L13 4.7231V2H11V4.7231l-1.86 3.1A7.9986 7.9986 0 008 11.939v.122a7.9961 7.9961 0 001.14 4.1158l1.86 3.1V26h2V19.2769l1.86-3.1A7.9986 7.9986 0 0016 12.061v-.122A7.9961 7.9961 0 0014.86 7.8232zM12 6.9434l1.145 1.9087A6.0027 6.0027 0 0113.9185 11h-3.837a6.0086 6.0086 0 01.7735-2.1484zm0 10.1132l-1.145-1.9087A6.0027 6.0027 0 0110.0815 13h3.837a6.0086 6.0086 0 01-.7735 2.1484zM27.86 11.8232L26 8.7231V2H24V8.7231l-1.86 3.1A7.9986 7.9986 0 0021 15.939v.122a7.9961 7.9961 0 001.14 4.1158l1.86 3.1V26h2V23.2769l1.86-3.1A7.9986 7.9986 0 0029 16.061v-.122A7.9961 7.9961 0 0027.86 11.8232zm-2.86-.88l1.145 1.9087A6.0027 6.0027 0 0126.9185 15h-3.837a6.0086 6.0086 0 01.7735-2.1484zm0 10.1132l-1.145-1.9087A6.0027 6.0027 0 0123.0815 17h3.837a6.0086 6.0086 0 01-.7735 2.1484z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,nn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),mt||(mt=i.createElement("path",{d:"M28,28V18H26V28H22V4H20V28H10V14H8V28H4V2H2V28a2.0023,2.0023,0,0,0,2,2H30V28Z"})),vt||(vt=i.createElement("path",{d:"M14 4H16V18H14z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,rn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ct||(ct=i.createElement("path",{d:"M30,15H16V6a2.0023,2.0023,0,0,0-2-2H6A2.0023,2.0023,0,0,0,4,6v9H2v2H16v9a2.0023,2.0023,0,0,0,2,2h8a2.0023,2.0023,0,0,0,2-2V17h2ZM6,6h8v9H6ZM26,26H18V17h8Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ln);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ut||(ut=i.createElement("path",{d:"M17.74,30,16,29l4-7h6a2,2,0,0,0,2-2V8a2,2,0,0,0-2-2H6A2,2,0,0,0,4,8V20a2,2,0,0,0,2,2h9v2H6a4,4,0,0,1-4-4V8A4,4,0,0,1,6,4H26a4,4,0,0,1,4,4V20a4,4,0,0,1-4,4H21.16Z"})),ft||(ft=i.createElement("path",{d:"M8 10H24V12H8zM8 16H18V18H8z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,dn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),bt||(bt=i.createElement("path",{d:"M22 4L22 6 26.586 6 20 12.586 21.414 14 28 7.414 28 12 30 12 30 4 22 4zM28 16v4a1.9965 1.9965 0 01-2 2H20l-4 7 1.7358 1 3.4288-6H26a3.9992 3.9992 0 004-4V16zM4 20V8A1.9965 1.9965 0 016 6H18V4H6A3.9986 3.9986 0 002 8V20a3.9992 3.9992 0 004 4h9V22H6A1.9965 1.9965 0 014 20z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,on);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),pt||(pt=i.createElement("path",{d:"M28 8V21h2V8a3.9986 3.9986 0 00-4-4H8.2429l2 2H26A1.9965 1.9965 0 0128 8zM30 28.5859L3.4141 2 2 3.4141 3.5039 4.918A3.9181 3.9181 0 002 8V20a3.9992 3.9992 0 004 4h6V22H6a1.9965 1.9965 0 01-2-2V8a1.9814 1.9814 0 01.9194-1.6665L20.5859 22H17l-4 7 1.7358 1 3.4288-6h4.4213l6 6z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,mn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),gt||(gt=i.createElement("path",{d:"M15.586 10.414L19.166 14 19.166 14 15.584 17.587 17 19 22 14 17 9 15.586 10.414z"})),Et||(Et=i.createElement("path",{d:"M20.586 10.414L24.166 14 24.166 14 20.584 17.587 22 19 27 14 22 9 20.586 10.414zM10 9L11.593 12 15 12.414 12.5 14.667 13 18 10 16.125 7 18 7.5 14.667 5 12.414 8.5 12 10 9z"})),wt||(wt=i.createElement("path",{d:"M17.7358,30,16,29l4-7h6a1.9966,1.9966,0,0,0,2-2V8a1.9966,1.9966,0,0,0-2-2H6A1.9966,1.9966,0,0,0,4,8V20a1.9966,1.9966,0,0,0,2,2h9v2H6a3.9993,3.9993,0,0,1-4-4V8A3.9988,3.9988,0,0,1,6,4H26a3.9988,3.9988,0,0,1,4,4V20a3.9993,3.9993,0,0,1-4,4H21.1646Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,vn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ht||(ht=i.createElement("path",{d:"M16 19a6.9908 6.9908 0 01-5.833-3.1287l1.666-1.1074a5.0007 5.0007 0 008.334 0l1.666 1.1074A6.9908 6.9908 0 0116 19zM20 8a2 2 0 102 2A1.9806 1.9806 0 0020 8zM12 8a2 2 0 102 2A1.9806 1.9806 0 0012 8z"})),xt||(xt=i.createElement("path",{d:"M17.7358,30,16,29l4-7h6a1.9966,1.9966,0,0,0,2-2V6a1.9966,1.9966,0,0,0-2-2H6A1.9966,1.9966,0,0,0,4,6V20a1.9966,1.9966,0,0,0,2,2h9v2H6a3.9993,3.9993,0,0,1-4-4V6A3.9988,3.9988,0,0,1,6,2H26a3.9988,3.9988,0,0,1,4,4V20a3.9993,3.9993,0,0,1-4,4H21.1646Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,cn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),zt||(zt=i.createElement("path",{d:"M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM6,26V6H26V26Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,un);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Lt||(Lt=i.createElement("path",{d:"M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM6,26V6H26V26Z"})),Mt||(Mt=i.createElement("path",{d:"M14 21.5L9 16.54 10.59 15 14 18.35 21.41 11 23 12.58 14 21.5z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,fn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Rt||(Rt=i.createElement("path",{d:"M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM14,21.5,9,16.5427,10.5908,15,14,18.3456,21.4087,11l1.5918,1.5772Z"})),St||(St=i.createElement("path",{fill:"none",d:"M14,21.5,9,16.5427,10.5908,15,14,18.3456,21.4087,11l1.5918,1.5772Z","data-icon-path":"inner-path"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,bn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Dt||(Dt=i.createElement("path",{d:"M10 14H22V18H10z"})),yt||(yt=i.createElement("path",{d:"M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM6,26V6H26V26Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,pn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Vt||(Vt=i.createElement("path",{d:"M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM22,18H10V14H22Z"})),At||(At=i.createElement("path",{fill:"none",d:"M22,18H10V14H22Z","data-icon-path":"inner-path"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,gn);return 20===a||"20"===a||"20px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor"},n),Tt||(Tt=i.createElement("path",{d:"M8 13.2L3.6 8.8 2.7 9.7 7.1 14.1 8 15 16.5 6.5 15.6 5.6z"})),Wt||(Wt=i.createElement("path",{d:"M15.6 5.6L8 13.2 3.6 8.8 2.7 9.7 7.1 14.1 8 15 16.5 6.5 15.6 5.6z"})),_):24===a||"24"===a||"24px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor"},n),Ut||(Ut=i.createElement("path",{d:"M10 15.9L4.7 10.6 3.6 11.6 8.9 16.9 10 18 20.6 7.4 19.5 6.3z"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),It||(It=i.createElement("path",{d:"M13 24L4 15 5.414 13.586 13 21.171 26.586 7.586 28 9 13 24z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,En);return 16===a||"16"===a||"16px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),Bt||(Bt=i.createElement("path",{d:"M8,1C4.1,1,1,4.1,1,8c0,3.9,3.1,7,7,7s7-3.1,7-7C15,4.1,11.9,1,8,1z M7,11L4.3,8.3l0.9-0.8L7,9.3l4-3.9l0.9,0.8L7,11z"})),Ot||(Ot=i.createElement("path",{d:"M7,11L4.3,8.3l0.9-0.8L7,9.3l4-3.9l0.9,0.8L7,11z","data-icon-path":"inner-path",opacity:"0"})),_):20===a||"20"===a||"20px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor"},n),Ft||(Ft=i.createElement("path",{d:"M10,1c-4.9,0-9,4.1-9,9s4.1,9,9,9s9-4,9-9S15,1,10,1z M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z"})),qt||(qt=i.createElement("path",{fill:"none",d:"M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z","data-icon-path":"inner-path",opacity:"0"})),_):24===a||"24"===a||"24px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor"},n),Xt||(Xt=i.createElement("path",{d:"M12,1C6,1,1,6,1,12s5,11,11,11s11-4.9,11-11S18.1,1,12,1z M10.4,16.3l-3.9-3.9l1.3-1.2l2.7,2.7l5.8-5.8l1.3,1.3L10.4,16.3z"})),Ct||(Ct=i.createElement("path",{fill:"none",d:"M10.4,16.3l-3.9-3.9l1.3-1.2l2.7,2.7l5.8-5.8l1.3,1.3L10.4,16.3z","data-icon-path":"inner-path",opacity:"0"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ht||(Ht=i.createElement("path",{d:"M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2ZM14,21.5908l-5-5L10.5906,15,14,18.4092,21.41,11l1.5957,1.5859Z"})),kt||(kt=i.createElement("path",{fill:"none",d:"M14 21.591L9 16.591 10.591 15 14 18.409 21.41 11 23.005 12.585 14 21.591z","data-icon-path":"inner-path"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,wn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Nt||(Nt=i.createElement("path",{d:"M30,24a6,6,0,1,0-6,6A6.0066,6.0066,0,0,0,30,24Zm-2,0a3.9521,3.9521,0,0,1-.5669,2.019L21.981,20.5669A3.9529,3.9529,0,0,1,24,20,4.0045,4.0045,0,0,1,28,24Zm-8,0a3.9521,3.9521,0,0,1,.5669-2.019l5.4521,5.4521A3.9529,3.9529,0,0,1,24,28,4.0045,4.0045,0,0,1,20,24Z"})),Zt||(Zt=i.createElement("path",{d:"M14,2a12,12,0,1,0,2,23.82V24a8,8,0,0,1,8-8h1.82A11.9348,11.9348,0,0,0,14,2ZM12,18.5908l-4-4L9.5908,13,12,15.4092,17.4092,10,19,11.5908Z"})),Yt||(Yt=i.createElement("path",{fill:"none",d:"M12 18.591L8 14.591 9.591 13 12 15.409 17.409 10 19 11.591 12 18.591z","data-icon-path":"inner-path"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,hn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Pt||(Pt=i.createElement("path",{d:"M14,2a12,12,0,1,0,3.3928,23.5059l3.9246-7.8492A2.9846,2.9846,0,0,1,24,16h1.82A11.9348,11.9348,0,0,0,14,2ZM12,18.5908l-4-4L9.5908,13,12,15.4092,17.4092,10,19,11.5908Z"})),jt||(jt=i.createElement("path",{d:"M27.38,28H20.6178L24,21.2358ZM24,18a1,1,0,0,0-.8947.5527l-5,10A1.0005,1.0005,0,0,0,19,30H29a1,1,0,0,0,.9214-1.3892L24.8946,18.5527A1,1,0,0,0,24,18Z"})),Kt||(Kt=i.createElement("path",{fill:"none",d:"M12 18.591L8 14.591 9.591 13 12 15.409 17.409 10 19 11.591 12 18.591z","data-icon-path":"inner-path"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,xn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Gt||(Gt=i.createElement("path",{d:"M14 21.414L9 16.413 10.413 15 14 18.586 21.585 11 23 12.415 14 21.414z"})),Qt||(Qt=i.createElement("path",{d:"M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,26A12,12,0,1,1,28,16,12,12,0,0,1,16,28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,zn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Jt||(Jt=i.createElement("path",{d:"M14,24A10,10,0,1,1,24,14h2A12,12,0,1,0,14,26Z"})),$t||($t=i.createElement("path",{d:"M12 15.59L9.41 13 8 14.41 12 18.41 19 11.41 17.59 10 12 15.59zM30 24a6 6 0 10-6 6A6.0066 6.0066 0 0030 24zm-2 0a3.9521 3.9521 0 01-.5669 2.019L21.981 20.5669A3.9529 3.9529 0 0124 20 4.0045 4.0045 0 0128 24zm-8 0a3.9521 3.9521 0 01.5669-2.019l5.4521 5.4521A3.9529 3.9529 0 0124 28 4.0045 4.0045 0 0120 24z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ln);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),e_||(e_=i.createElement("path",{d:"M14,24A10,10,0,1,1,24,14h2A12,12,0,1,0,14,26Z"})),i_||(i_=i.createElement("path",{d:"M12 15.59L9.41 13 8 14.41 12 18.41 19 11.41 17.59 10 12 15.59zM27.38 28H20.6178L24 21.2358zM24 18a1 1 0 00-.8947.5527l-5 10A1.0005 1.0005 0 0019 30H29a1 1 0 00.9214-1.3892L24.8946 18.5527A1 1 0 0024 18z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Mn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),t_||(t_=i.createElement("path",{d:"M27.2314,23.6182,20,13.6748V4h2V2H10V4h2v9.6748L4.7686,23.6182A4.0183,4.0183,0,0,0,8.0186,30H23.9814a4.0183,4.0183,0,0,0,3.25-6.3818ZM14,14.3252V4h4V14.3252L20.6728,18H11.3272ZM23.9814,28H8.0186a2.0192,2.0192,0,0,1-1.6329-3.2061L9.8726,20H22.1274l3.4869,4.7939A2.0192,2.0192,0,0,1,23.9814,28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Rn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),__||(__=i.createElement("path",{d:"M4 20L4 22 8.586 22 2 28.586 3.414 30 10 23.414 10 28 12 28 12 20 4 20z"})),s_||(s_=i.createElement("path",{d:"M20,13.67V4h2V2H10V4h2v9.67L9.58,17h2.4767L14,14.33V4h4V14.33l7.61,10.46a2.0133,2.0133,0,0,1-.44,2.82,2.0406,2.0406,0,0,1-1.19.39H15v2h8.98a4.0154,4.0154,0,0,0,3.25-6.38Z"})),_)})).propTypes=da;var Dr=i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Sn);return"glyph"===a||"glyph"===a||"glyphpx"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 10 6",fill:"currentColor"},n),a_||(a_=i.createElement("path",{d:"M5 6L0 1 0.7 0.3 5 4.6 9.3 0.3 10 1z"})),_):16===a||"16"===a||"16px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),n_||(n_=i.createElement("path",{d:"M8 11L3 6 3.7 5.3 8 9.6 12.3 5.3 13 6z"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),r_||(r_=i.createElement("path",{d:"M16 22L6 12 7.4 10.6 16 19.2 24.6 10.6 26 12z"})),_)}));Dr.propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Dn);return"glyph"===a||"glyph"===a||"glyphpx"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 6 10",fill:"currentColor"},n),l_||(l_=i.createElement("path",{d:"M0 5L5 0 5.7 0.7 1.4 5 5.7 9.3 5 10z"})),_):16===a||"16"===a||"16px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),d_||(d_=i.createElement("path",{d:"M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),o_||(o_=i.createElement("path",{d:"M10 16L20 6 21.4 7.4 12.8 16 21.4 24.6 20 26z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,yn);return 16===a||"16"===a||"16px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),m_||(m_=i.createElement("path",{d:"M15 9L15 15 9 15z"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),v_||(v_=i.createElement("path",{d:"M31 19L31 31 19 31 31 19z"})),_)})).propTypes=da;var yr=i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Vn);return"glyph"===a||"glyph"===a||"glyphpx"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 6 10",fill:"currentColor"},n),c_||(c_=i.createElement("path",{d:"M6 5L1 10 0.3 9.3 4.6 5 0.3 0.7 1 0z"})),_):16===a||"16"===a||"16px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),u_||(u_=i.createElement("path",{d:"M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),f_||(f_=i.createElement("path",{d:"M22 16L12 26 10.6 24.6 19.2 16 10.6 7.4 12 6z"})),_)}));yr.propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,An);return 16===a||"16"===a||"16px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),b_||(b_=i.createElement("path",{d:"M8 14L4.5 10.5 5.2 9.8 8 12.6 10.8 9.8 11.5 10.5zM8 2L11.5 5.5 10.8 6.2 8 3.4 5.2 6.2 4.5 5.5z"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),p_||(p_=i.createElement("path",{d:"M16 28L9 21 10.41 19.59 16 25.17 21.59 19.59 23 21 16 28zM16 4L23 11 21.59 12.41 16 6.83 10.41 12.41 9 11 16 4z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Tn);return 16===a||"16"===a||"16px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),g_||(g_=i.createElement("path",{d:"M8 14L4.5 10.5 5.2 9.8 8 12.6 10.8 9.8 11.5 10.5z"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),E_||(E_=i.createElement("path",{d:"M16 28L9 21 10.4 19.6 16 25.2 21.6 19.6 23 21z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Wn);return 16===a||"16"===a||"16px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),w_||(w_=i.createElement("path",{d:"M8 2L11.5 5.5 10.8 6.2 8 3.4 5.2 6.2 4.5 5.5z"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),h_||(h_=i.createElement("path",{d:"M16 4L23 11 21.6 12.4 16 6.8 10.4 12.4 9 11z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Un);return"glyph"===a||"glyph"===a||"glyphpx"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 10 6",fill:"currentColor"},n),x_||(x_=i.createElement("path",{d:"M5 0L10 5 9.3 5.7 5 1.4 0.7 5.7 0 5z"})),_):16===a||"16"===a||"16px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),z_||(z_=i.createElement("path",{d:"M8 5L13 10 12.3 10.7 8 6.4 3.7 10.7 3 10z"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),L_||(L_=i.createElement("path",{d:"M16 10L26 20 24.6 21.4 16 12.8 7.4 21.4 6 20z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,In);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),M_||(M_=i.createElement("path",{d:"M11,11V21H21V11Zm8,8H13V13h6Z"})),R_||(R_=i.createElement("path",{d:"M30,13V11H26V8a2,2,0,0,0-2-2H21V2H19V6H13V2H11V6H8A2,2,0,0,0,6,8v3H2v2H6v6H2v2H6v3a2,2,0,0,0,2,2h3v4h2V26h6v4h2V26h3a2,2,0,0,0,2-2V21h4V19H26V13ZM24,24H8V8H24Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Bn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),S_||(S_=i.createElement("path",{d:"M28 13L28 4 19 4 19 6 24.586 6 16 14.586 7.414 6 13 6 13 4 4 4 4 13 6 13 6 7.414 15 16.414 15 26 4 26 4 28 28 28 28 26 17 26 17 16.414 26 7.414 26 13 28 13z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,On);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),D_||(D_=i.createElement("path",{d:"M28 6H30V26H28zM17 6L15.57 7.393 23.15 15 2 15 2 17 23.15 17 15.57 24.573 17 26 27 16 17 6z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Fn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),y_||(y_=i.createElement("path",{d:"M29.2427,4.03l-8-2a1.0065,1.0065,0,0,0-.6143.0415l-9.7,3.88L3.2427,4.03A1,1,0,0,0,2,5V27a1,1,0,0,0,.7573.97l8,2A1.0244,1.0244,0,0,0,11,30a.9953.9953,0,0,0,.3716-.0718l9.7-3.88,7.686,1.9219A1,1,0,0,0,30,27V5A1,1,0,0,0,29.2427,4.03ZM28,11H22V4.2806l6,1.5ZM10,19H4V13h6Zm2-8V7.6771l8-3.2V11Zm8,2v6H12V13Zm-8,8h8v3.3227l-8,3.2Zm10-8h6v6H22ZM10,7.7806V11H4V6.2806ZM4,21h6v6.7192l-6-1.5Zm18,3.2187V21h6v4.7192Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,qn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),V_||(V_=i.createElement("path",{d:"M30.3335 30H26V28h4V26H28a2.002 2.002 0 01-2-2V21.6665A1.6684 1.6684 0 0127.6665 20H32v2H28v2h2a2.002 2.002 0 012 2v2.3335A1.6684 1.6684 0 0130.3335 30zM22.3335 20h-2.667A1.6665 1.6665 0 0018 21.6665V30h2V26h2v4h2V21.6665A1.6665 1.6665 0 0022.3335 20zM20 24V22h2v2zM12.5 24L11 20 9 20 9 30 11 30 11 23 12.5 27 14 23 14 30 16 30 16 20 14 20 12.5 24zM1 22v6.5A1.4727 1.4727 0 002.5 30H7V28H3V22H7V20H3A2.0059 2.0059 0 001 22zM13 8L11 8 11 11 8 11 8 13 11 13 11 16 13 16 13 13 16 13 16 11 13 11 13 8z"})),A_||(A_=i.createElement("path",{d:"M6,6H26V18h2V6a2.0059,2.0059,0,0,0-2-2H6A2.0059,2.0059,0,0,0,4,6V18H6Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Xn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),T_||(T_=i.createElement("path",{d:"M24 16L19.4 14.6 21.7 10.3 17.4 12.6 16 8 14.6 12.6 10.3 10.3 12.6 14.6 8 16 12.6 17.4 10.3 21.7 14.6 19.4 16 24 17.4 19.4 21.7 21.7 19.4 17.4 24 16z"})),W_||(W_=i.createElement("path",{d:"M16,30A14,14,0,1,1,30,16,14.0158,14.0158,0,0,1,16,30ZM16,4A12,12,0,1,0,28,16,12.0137,12.0137,0,0,0,16,4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Cn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),U_||(U_=i.createElement("path",{d:"M28 2H23V4h5V28H23v2h5a2.0059 2.0059 0 002-2V4A2.0059 2.0059 0 0028 2zM14 17H8a.9448.9448 0 00-1 1v6a.9448.9448 0 001 1h6a.9448.9448 0 001-1V18A.9448.9448 0 0014 17zm-1 6H9V19h4z"})),I_||(I_=i.createElement("path",{d:"M25 24V18a.9448.9448 0 00-1-1H18a.9448.9448 0 00-1 1v6a.9448.9448 0 001 1h6A1.0021 1.0021 0 0025 24zm-2-1H19V19h4zM14 7H8A.9448.9448 0 007 8v6a.9448.9448 0 001 1h6a.9448.9448 0 001-1V8A.9448.9448 0 0014 7zm-1 6H9V9h4zM18 15h6a.9448.9448 0 001-1V8a.9448.9448 0 00-1-1H18a.9448.9448 0 00-1 1v6A1.0021 1.0021 0 0018 15zm1-6h4v4H19z"})),B_||(B_=i.createElement("path",{d:"M4,4H9V2H4A2.0059,2.0059,0,0,0,2,4V28a2.0059,2.0059,0,0,0,2,2H9V28H4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Hn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),O_||(O_=i.createElement("path",{d:"M22 22L24 22 24 28 22 28 22 30 28 30 28 28 26 28 26 22 28 22 28 20 22 20 22 22zM18 28H16V20H14v8.6A1.4529 1.4529 0 0015.5 30h3A1.4529 1.4529 0 0020 28.6V20H18zM10.2 20L10 28.5 9 22 7 22 6 28.5 5.8 20 4 20 4.72 30 7 30 8 23.5 9 30 11.28 30 12 20 10.2 20zM16 11L13 11 13 8 11 8 11 11 8 11 8 13 11 13 11 16 13 16 13 13 16 13 16 11z"})),F_||(F_=i.createElement("path",{d:"M26,4H6A2.0059,2.0059,0,0,0,4,6V18H6V6H26V18h2V6A2.0059,2.0059,0,0,0,26,4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,kn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),q_||(q_=i.createElement("path",{d:"M23.5 18L21 18.7 21 16 19 16 19 18.7 16.5 18 16 19.9 18.4 20.6 17 23 18.7 24 20 21.8 21.3 24 23 23 21.6 20.6 24 19.9 23.5 18zM16 13L16 11 13 11 13 8 11 8 11 11 8 11 8 13 11 13 11 16 13 16 13 13 16 13z"})),X_||(X_=i.createElement("path",{d:"M26,4H6A2.0059,2.0059,0,0,0,4,6V26a2.0059,2.0059,0,0,0,2,2H26a2.0059,2.0059,0,0,0,2-2V6A2.0059,2.0059,0,0,0,26,4ZM6,26V6H26V26Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Nn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),C_||(C_=i.createElement("path",{d:"M22 2L22 4 26.6 4 20 10.6 21.4 12 28 5.4 28 10 30 10 30 2 22 2zM19 16L19 18.7 16.5 18 16 19.9 18.4 20.6 17 23 18.7 24 20 21.8 21.3 24 23 23 21.6 20.6 24 19.9 23.5 18 21 18.7 21 16 19 16zM13 16L13 13 16 13 16 11 13 11 13 8 11 8 11 11 8 11 8 13 11 13 11 16 13 16z"})),H_||(H_=i.createElement("path",{d:"M26,26H6V6H19V4H6A2.0059,2.0059,0,0,0,4,6V26a2.0059,2.0059,0,0,0,2,2H26a2.0059,2.0059,0,0,0,2-2V13H26Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Zn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),k_||(k_=i.createElement("path",{d:"M26 7H28V10H26zM29 4H32V6H29zM26 0H28V3H26zM22 4H25V6H22zM19 16L19 18.7 16.5 18 16 19.9 18.4 20.6 17 23 18.7 24 20 21.8 21.3 24 23 23 21.6 20.6 24 19.9 23.5 18 21 18.7 21 16 19 16zM13 16L13 13 16 13 16 11 13 11 13 8 11 8 11 11 8 11 8 13 11 13 11 16 13 16z"})),N_||(N_=i.createElement("path",{d:"M26,26H6V6H19V4H6A2.0059,2.0059,0,0,0,4,6V26a2.0059,2.0059,0,0,0,2,2H26a2.0059,2.0059,0,0,0,2-2V13H26Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Yn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Z_||(Z_=i.createElement("path",{d:"M8 18.6V17H6v1.6A7.3833 7.3833 0 0013.4 26H15V24H13.4A5.3775 5.3775 0 018 18.6zM28 18H20a2.0059 2.0059 0 00-2 2v8a2.0059 2.0059 0 002 2h8a2.0059 2.0059 0 002-2V20A2.0059 2.0059 0 0028 18zM20 28V20h8v8zM24 13.4V15h2V13.4A7.3833 7.3833 0 0018.6 6H17V8h1.6A5.3775 5.3775 0 0124 13.4zM12 2H4A2.0059 2.0059 0 002 4v8a2.0059 2.0059 0 002 2h8a2.0059 2.0059 0 002-2V4A2.0059 2.0059 0 0012 2zM4 12V4h8v8z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Pn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Y_||(Y_=i.createElement("circle",{cx:"16",cy:"16",r:"10"})),P_||(P_=i.createElement("path",{d:"M16,30A14,14,0,1,1,30,16,14.0158,14.0158,0,0,1,16,30ZM16,4A12,12,0,1,0,28,16,12.0137,12.0137,0,0,0,16,4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,jn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),j_||(j_=i.createElement("circle",{cx:"16",cy:"16",r:"14"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Kn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),K_||(K_=i.createElement("path",{d:"M7.7 4.7a14.7 14.7 0 00-3 3.1L6.3 9A13.26 13.26 0 018.9 6.3zM4.6 12.3l-1.9-.6A12.51 12.51 0 002 16H4A11.48 11.48 0 014.6 12.3zM2.7 20.4a14.4 14.4 0 002 3.9l1.6-1.2a12.89 12.89 0 01-1.7-3.3zM7.8 27.3a14.4 14.4 0 003.9 2l.6-1.9A12.89 12.89 0 019 25.7zM11.7 2.7l.6 1.9A11.48 11.48 0 0116 4V2A12.51 12.51 0 0011.7 2.7zM24.2 27.3a15.18 15.18 0 003.1-3.1L25.7 23A11.53 11.53 0 0123 25.7zM27.4 19.7l1.9.6A15.47 15.47 0 0030 16H28A11.48 11.48 0 0127.4 19.7zM29.2 11.6a14.4 14.4 0 00-2-3.9L25.6 8.9a12.89 12.89 0 011.7 3.3zM24.1 4.6a14.4 14.4 0 00-3.9-2l-.6 1.9a12.89 12.89 0 013.3 1.7zM20.3 29.3l-.6-1.9A11.48 11.48 0 0116 28v2A21.42 21.42 0 0020.3 29.3z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Gn);return"glyph"===a||"glyph"===a||"glyphpx"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),G_||(G_=i.createElement("circle",{cx:"8",cy:"8",r:"6"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),Q_||(Q_=i.createElement("circle",{cx:"8",cy:"8",r:"6"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Qn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),J_||(J_=i.createElement("path",{d:"M16,30A14,14,0,1,1,30,16,14,14,0,0,1,16,30ZM16,4A12,12,0,1,0,28,16,12,12,0,0,0,16,4Z"})),$_||($_=i.createElement("path",{d:"M21,12.41V16h2V9H16v2h3.59L11,19.59V16H9v7h7V21H12.41Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Jn);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),es||(es=i.createElement("path",{d:"M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm7.5,7A3.5,3.5,0,1,1,20,12.5,3.5041,3.5041,0,0,1,23.5,9Zm.4348-1.978C23.791,7.0107,23.6467,7,23.5,7a5.4826,5.4826,0,0,0-4.1323,1.8784,8.0109,8.0109,0,0,0-5.5664-4.6675A11.8554,11.8554,0,0,1,23.9348,7.022ZM16,28a4,4,0,1,1,4-4A4.0045,4.0045,0,0,1,16,28ZM12,18a6,6,0,1,1,6-6A6.0067,6.0067,0,0,1,12,18ZM4,16a11.97,11.97,0,0,1,.2112-2.1987,7.9921,7.9921,0,0,0,7.3459,6.1762,5.9581,5.9581,0,0,0-.89,6.7564A12.0025,12.0025,0,0,1,4,16ZM21.3325,26.7339a5.9834,5.9834,0,0,0-4.1782-8.6206,8.02,8.02,0,0,0,1.9126-2.3672,5.4883,5.4883,0,0,0,8.9167-.0679c.003.1079.0164.2134.0164.3218A12.0025,12.0025,0,0,1,21.3325,26.7339Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,$n);return"glyph"===a||"glyph"===a||"glyphpx"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),is||(is=i.createElement("path",{d:"M8,4A4,4,0,1,1,4,8,4.0045,4.0045,0,0,1,8,4M8,2a6,6,0,1,0,6,6A6,6,0,0,0,8,2Z"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),ts||(ts=i.createElement("path",{d:"M8,4A4,4,0,1,1,4,8,4.0045,4.0045,0,0,1,8,4M8,2a6,6,0,1,0,6,6A6,6,0,0,0,8,2Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,er);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),_s||(_s=i.createElement("path",{d:"M18 9L18 15 14 15 14 9 12 9 12 23 14 23 14 17 18 17 18 23 20 23 20 9 18 9z"})),ss||(ss=i.createElement("path",{d:"M30,15H26V6a2,2,0,0,0-2-2H8A2,2,0,0,0,6,6v9H2v2H6v9a2,2,0,0,0,2,2H24a2,2,0,0,0,2-2V17h4ZM8,26V6H24V26Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ir);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),as||(as=i.createElement("circle",{cx:"15",cy:"19",r:"1"})),ns||(ns=i.createElement("path",{d:"M27.7,9.3l-7-7A.9087.9087,0,0,0,20,2H10A2.0058,2.0058,0,0,0,8,4V14H6a2.0023,2.0023,0,0,0-2,2v6a2.0023,2.0023,0,0,0,2,2H8v4a2.0058,2.0058,0,0,0,2,2H26a2.0058,2.0058,0,0,0,2-2V10A.9092.9092,0,0,0,27.7,9.3ZM20,4.4,25.6,10H20ZM6,16h9.5972L19,19l-3.3926,3H6ZM26,28H10V24h5.6089a2.0076,2.0076,0,0,0,1.3135-.4927l3.3833-2.9917a2.0015,2.0015,0,0,0,.01-3.0229l-3.4033-3.0083A1.9961,1.9961,0,0,0,15.6089,14H10V4h8v6a2.0058,2.0058,0,0,0,2,2h6Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,tr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),rs||(rs=i.createElement("path",{d:"M30 10V2H22v8h3v4H23v2h7V14H27V10zM24 4h4V8H24zM20 23.41L18.59 22 16 24.59 13.41 22 12 23.41 14.59 26 12 28.59 13.41 30 16 27.41 18.59 30 20 28.59 17.41 26 20 23.41zM20 14L12 14 12 16 15 16 15 21 17 21 17 16 20 16 20 14zM7 9.86a4 4 0 10-2 0V14H2v2H9V14H7zM4 6A2 2 0 116 8 2 2 0 014 6z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,_r);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ls||(ls=i.createElement("path",{d:"M20 18H26V20H20z",transform:"rotate(-180 23 19)"})),ds||(ds=i.createElement("path",{d:"M24 26H30V28H24z",transform:"rotate(-180 27 27)"})),os||(os=i.createElement("path",{d:"M22 22H28V24H22z",transform:"rotate(-180 25 23)"})),ms||(ms=i.createElement("path",{d:"M17.0029,20a4.8952,4.8952,0,0,0-2.4044-4.1729L22,3,20.2691,2,12.6933,15.126A5.6988,5.6988,0,0,0,7.45,16.6289C3.7064,20.24,3.9963,28.6821,4.01,29.04a1,1,0,0,0,1,.96H20.0012a1,1,0,0,0,.6-1.8C17.0615,25.5439,17.0029,20.0537,17.0029,20ZM11.93,16.9971A3.11,3.11,0,0,1,15.0041,20c0,.0381.0019.208.0168.4688L9.1215,17.8452A3.8,3.8,0,0,1,11.93,16.9971ZM15.4494,28A5.2,5.2,0,0,1,14,25H12a6.4993,6.4993,0,0,0,.9684,3H10.7451A16.6166,16.6166,0,0,1,10,24H8a17.3424,17.3424,0,0,0,.6652,4H6c.031-1.8364.29-5.8921,1.8027-8.5527l7.533,3.35A13.0253,13.0253,0,0,0,17.5968,28Z"})),_)})).propTypes=da;var Vr=i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,sr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),vs||(vs=i.createElement("path",{d:"M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"})),_)}));Vr.propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ar);return 16===a||"16"===a||"16px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),cs||(cs=i.createElement("path",{d:"M8,1C4.1,1,1,4.1,1,8s3.1,7,7,7s7-3.1,7-7S11.9,1,8,1z M10.7,11.5L8,8.8l-2.7,2.7l-0.8-0.8L7.2,8L4.5,5.3l0.8-0.8L8,7.2 l2.7-2.7l0.8,0.8L8.8,8l2.7,2.7L10.7,11.5z"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),us||(us=i.createElement("path",{d:"M16,2C8.2,2,2,8.2,2,16s6.2,14,14,14s14-6.2,14-14S23.8,2,16,2z M21.4,23L16,17.6L10.6,23L9,21.4l5.4-5.4L9,10.6L10.6,9 l5.4,5.4L21.4,9l1.6,1.6L17.6,16l5.4,5.4L21.4,23z"})),fs||(fs=i.createElement("path",{d:"M14.4 16L9 10.6 10.6 9 16 14.4 21.4 9 23 10.6 17.6 16 23 21.4 21.4 23 16 17.6 10.6 23 9 21.4 14.4 16","data-icon-path":"inner-path",opacity:"0"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,nr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),bs||(bs=i.createElement("path",{d:"M16,2C8.2,2,2,8.2,2,16s6.2,14,14,14s14-6.2,14-14S23.8,2,16,2z M16,28C9.4,28,4,22.6,4,16S9.4,4,16,4s12,5.4,12,12 S22.6,28,16,28z"})),ps||(ps=i.createElement("path",{d:"M21.4 23L16 17.6 10.6 23 9 21.4 14.4 16 9 10.6 10.6 9 16 14.4 21.4 9 23 10.6 17.6 16 23 21.4z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,rr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),gs||(gs=i.createElement("path",{d:"M15 21H10a2 2 0 01-2-2V13a2 2 0 012-2h5v2H10v6h5zM25 21H20a2 2 0 01-2-2V13a2 2 0 012-2h5v2H20v6h5z"})),Es||(Es=i.createElement("path",{d:"M28,26H4a2,2,0,0,1-2-2V8A2,2,0,0,1,4,6H28a2,2,0,0,1,2,2V24A2,2,0,0,1,28,26ZM4,8V24H28V8Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,lr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ws||(ws=i.createElement("path",{d:"M19 17H25V19H19zM11 17H17V19H11zM6 17H9V19H6zM22 13H26V15H22zM13 13H20V15H13zM6 13H11V15H6z"})),hs||(hs=i.createElement("path",{d:"M17.7358,30,16,29l4-7h6a1.9966,1.9966,0,0,0,2-2V8a1.9966,1.9966,0,0,0-2-2H6A1.9966,1.9966,0,0,0,4,8V20a1.9966,1.9966,0,0,0,2,2h9v2H6a3.9993,3.9993,0,0,1-4-4V8A3.9988,3.9988,0,0,1,6,4H26a3.9988,3.9988,0,0,1,4,4V20a3.9993,3.9993,0,0,1-4,4H21.1646Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,dr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),xs||(xs=i.createElement("path",{d:"M28,6H4A2,2,0,0,0,2,8V24a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V8A2,2,0,0,0,28,6ZM15,13H10v6h5v2H10a2,2,0,0,1-2-2V13a2,2,0,0,1,2-2h5Zm10,0H20v6h5v2H20a2,2,0,0,1-2-2V13a2,2,0,0,1,2-2h5Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,or);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),zs||(zs=i.createElement("path",{d:"M16,7h0a7.66,7.66,0,0,1,1.51.15,8,8,0,0,1,6.35,6.34l.26,1.35,1.35.24a5.5,5.5,0,0,1-1,10.92H7.5a5.5,5.5,0,0,1-1-10.92l1.34-.24.26-1.35A8,8,0,0,1,16,7m0-2a10,10,0,0,0-9.83,8.12A7.5,7.5,0,0,0,7.49,28h17a7.5,7.5,0,0,0,1.32-14.88,10,10,0,0,0-7.94-7.94A10.27,10.27,0,0,0,16,5Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,mr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ls||(Ls=i.createElement("path",{d:"M28,17v5H4V6H15V4H4A2,2,0,0,0,2,6V22a2,2,0,0,0,2,2h8v4H8v2H24V28H20V24h8a2,2,0,0,0,2-2V17ZM18,28H14V24h4Z"})),Ms||(Ms=i.createElement("path",{d:"M29,14H17a1,1,0,0,1-.8574-1.5144l6-10a1,1,0,0,1,1.7154,0l6,10A1,1,0,0,1,29,14ZM18.7661,12h8.4678L23,4.9436Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,vr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Rs||(Rs=i.createElement("path",{d:"M28,16v6H4V6H16V4H4A2,2,0,0,0,2,6V22a2,2,0,0,0,2,2h8v4H8v2H24V28H20V24h8a2,2,0,0,0,2-2V16ZM18,28H14V24h4Z"})),Ss||(Ss=i.createElement("path",{d:"M21 15L16 10.04 17.59 8.47 21 11.85 28.41 4.5 30 6.08 21 15z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,cr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ds||(Ds=i.createElement("path",{d:"M28 18H30V28H28zM24 14H26V28H24zM20 22H22V28H20zM22.175 10L23.76 8.7339A9.9522 9.9522 0 0017.89 5.1816 10.0025 10.0025 0 006.17 13.1152 7.5054 7.5054 0 00.0544 21.4087 7.6843 7.6843 0 007.7692 28H16V26H7.6945a5.632 5.632 0 01-5.6023-4.4858 5.5064 5.5064 0 014.4339-6.4307l1.3486-.2441.2139-1.11a8.206 8.206 0 016.7426-6.6426 7.9666 7.9666 0 013.0137.13A7.8037 7.8037 0 0122.175 10z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ur);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ys||(ys=i.createElement("path",{d:"M23.5,22H23V20h.5a4.5,4.5,0,0,0,.36-9L23,11l-.1-.82a7,7,0,0,0-13.88,0L9,11,8.14,11a4.5,4.5,0,0,0,.36,9H9v2H8.5A6.5,6.5,0,0,1,7.2,9.14a9,9,0,0,1,17.6,0A6.5,6.5,0,0,1,23.5,22Z"})),Vs||(Vs=i.createElement("path",{d:"M17 26.17L17 14 15 14 15 26.17 12.41 23.59 11 25 16 30 21 25 19.59 23.59 17 26.17z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,fr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),As||(As=i.createElement("path",{d:"M28 16v6H4V6H15V4H4A2 2 0 002 6V22a2 2 0 002 2h8v4H8v2H24V28H20V24h8a2 2 0 002-2V16zM18 28H14V24h4zM18 4H30V6H18z"})),Ts||(Ts=i.createElement("path",{d:"M18 8H30V10H18zM18 12H24V14H18z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,br);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ws||(Ws=i.createElement("path",{d:"M28,16v6H4V6h7V4H4A2,2,0,0,0,2,6V22a2,2,0,0,0,2,2h8v4H8v2H24V28H20V24h8a2,2,0,0,0,2-2V16ZM18,28H14V24h4Z"})),Us||(Us=i.createElement("path",{d:"M18,18h-.01a1,1,0,0,1-.9511-.7253L15.2456,11H11V9h5a1,1,0,0,1,.9615.7252l1.0742,3.7589,3.0088-9.7783A1.0142,1.0142,0,0,1,22,3a.98.98,0,0,1,.9487.6838L24.7207,9H30v2H24a1,1,0,0,1-.9487-.6838l-1.0132-3.04L18.9556,17.2942A1,1,0,0,1,18,18Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,pr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Is||(Is=i.createElement("path",{d:"M24.8008 12.1362a8.8694 8.8694 0 00-.9795-2.5434L30 3.4142 28.5872 2 2 28.5872 3.4142 30l5-5H23.5a6.4974 6.4974 0 001.3008-12.8638zM23.5 23H10.4141L22.3418 11.0723a6.9049 6.9049 0 01.6006 2.0708l.0986.812.8154.0639A4.4975 4.4975 0 0123.5 23zM4.2964 23.4487l1.4313-1.4311A4.4774 4.4774 0 018.144 14.019l.8155-.0639.0991-.812a6.9867 6.9867 0 0110.63-5.0865l1.4431-1.4428A8.9859 8.9859 0 007.2 12.1362 6.4891 6.4891 0 004.2964 23.4487z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,gr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Bs||(Bs=i.createElement("path",{d:"M28,17v5H4V6H14V4H4A2,2,0,0,0,2,6V22a2,2,0,0,0,2,2h8v4H8v2H24V28H20V24h8a2,2,0,0,0,2-2V17ZM18,28H14V24h4Z"})),Os||(Os=i.createElement("path",{d:"M30,10V8H27.8989a4.9678,4.9678,0,0,0-.7319-1.7529l1.49-1.49-1.414-1.414-1.49,1.49A4.9678,4.9678,0,0,0,24,4.1011V2H22V4.1011a4.9678,4.9678,0,0,0-1.7529.7319l-1.49-1.49-1.414,1.414,1.49,1.49A4.9678,4.9678,0,0,0,18.1011,8H16v2h2.1011a4.9678,4.9678,0,0,0,.7319,1.7529l-1.49,1.49,1.414,1.414,1.49-1.49A4.9678,4.9678,0,0,0,22,13.8989V16h2V13.8989a4.9678,4.9678,0,0,0,1.7529-.7319l1.49,1.49,1.414-1.414-1.49-1.49A4.9678,4.9678,0,0,0,27.8989,10Zm-7,2a3,3,0,1,1,3-3A3.0033,3.0033,0,0,1,23,12Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Er);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Fs||(Fs=i.createElement("path",{d:"M11 18L12.41 19.41 15 16.83 15 29 17 29 17 16.83 19.59 19.41 21 18 16 13 11 18z"})),qs||(qs=i.createElement("path",{d:"M23.5,22H23V20h.5a4.5,4.5,0,0,0,.36-9L23,11l-.1-.82a7,7,0,0,0-13.88,0L9,11,8.14,11a4.5,4.5,0,0,0,.36,9H9v2H8.5A6.5,6.5,0,0,1,7.2,9.14a9,9,0,0,1,17.6,0A6.5,6.5,0,0,1,23.5,22Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,wr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Xs||(Xs=i.createElement("path",{d:"M25.8289 13.1155A10.02 10.02 0 0016 5.0005V7a8.0233 8.0233 0 017.8649 6.4934l.2591 1.346 1.3488.2441A5.5019 5.5019 0 0124.5076 26H16v2h8.5076a7.5019 7.5019 0 001.3213-14.8845zM8 24H14V26H8zM4 24H6V26H4zM6 20H14V22H6zM2 20H4V22H2zM8 16H14V18H8zM4 16H6V18H4zM10 12H14V14H10zM6 12H8V14H6zM12 8H14V10H12z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,hr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Cs||(Cs=i.createElement("path",{d:"M2 28H11V30H2zM21 28H30V30H21zM17 26.167L17 17.832 19.586 20.414 21 19 16 14 11 19 12.413 20.415 15 17.832 15 26.167 12.413 23.584 11 25 16 30 21 25 19.586 23.586 17 26.167z"})),Hs||(Hs=i.createElement("path",{d:"M23,16H21V14h2a3,3,0,0,0,0-6c-.0938.0144-.1538.0219-.2153.0263l-.8037.0572L21.7544,7.31a5.9927,5.9927,0,0,0-11.1758-.8655l-.2832.5994-.8423-.0455A3.5008,3.5008,0,0,0,9.5,14H11v2H9.5A5.5,5.5,0,0,1,9.07,5.0166,7.9909,7.9909,0,0,1,23.42,6.0175,5,5,0,0,1,23,16Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,xr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ks||(ks=i.createElement("path",{d:"M16,7h0a7.66,7.66,0,0,1,1.51.15,8,8,0,0,1,6.35,6.34l.26,1.35,1.35.24a5.5,5.5,0,0,1-1,10.92H7.5a5.5,5.5,0,0,1-1-10.92l1.34-.24.26-1.35A8,8,0,0,1,16,7m0-2a10,10,0,0,0-9.83,8.12A7.5,7.5,0,0,0,7.49,28h17a7.5,7.5,0,0,0,1.32-14.88,10,10,0,0,0-7.94-7.94A10.27,10.27,0,0,0,16,5Z"})),Ns||(Ns=i.createElement("path",{d:"M14 24H11a2 2 0 01-2-2V19a2 2 0 012-2h3v2H11v3h3zM21 15V13H19a2 2 0 00-2 2v2H16v2h1v5h2V19h2V17H19V15z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,zr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Zs||(Zs=i.createElement("path",{d:"M25 11L25 9 17 9 17 23 19 23 19 17 24 17 24 15 19 15 19 11 25 11zM15 23H9a2 2 0 01-2-2V11A2 2 0 019 9h6v2H9V21h6z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Lr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ys||(Ys=i.createElement("path",{d:"M28 30H23a2.0023 2.0023 0 01-2-2V23a2.0023 2.0023 0 012-2h5a2.0023 2.0023 0 012 2v5A2.0023 2.0023 0 0128 30zm-5-7h-.0012L23 28h5V23zM16 23H11a2.0023 2.0023 0 01-2-2V11a2.0023 2.0023 0 012-2H21a2.0023 2.0023 0 012 2v5H21V11H11V21h5z"})),Ps||(Ps=i.createElement("path",{d:"M16,30H4a2.0023,2.0023,0,0,1-2-2V4A2.0023,2.0023,0,0,1,4,2H28a2.0023,2.0023,0,0,1,2,2V16H28V4H4V28H16Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Mr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),js||(js=i.createElement("circle",{cx:"9",cy:"20",r:"2"})),Ks||(Ks=i.createElement("path",{d:"M16,20a4,4,0,1,1,4-4A4.0118,4.0118,0,0,1,16,20Zm0-6a2,2,0,1,0,2,2A2.0059,2.0059,0,0,0,16,14Z"})),Gs||(Gs=i.createElement("circle",{cx:"23",cy:"12",r:"2"})),Qs||(Qs=i.createElement("path",{d:"M16,31a.9988.9988,0,0,1-.5039-.1357l-12-7A1.0008,1.0008,0,0,1,3,23V9a.9994.9994,0,0,1,.4961-.8638l12-7a1,1,0,0,1,1.0078,0l12,7L27.4961,9.8638,16,3.1577,5,9.5742V22.4258l11,6.417,11-6.417V15h2v8a1.0008,1.0008,0,0,1-.4961.8643l-12,7A.9988.9988,0,0,1,16,31Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Rr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Js||(Js=i.createElement("path",{d:"M32,26V24H29.8989a4.9678,4.9678,0,0,0-.7319-1.7529l1.49-1.49-1.414-1.414-1.49,1.49A4.9678,4.9678,0,0,0,26,20.1011V18H24v2.1011a4.9678,4.9678,0,0,0-1.7529.7319l-1.49-1.49-1.414,1.414,1.49,1.49A4.9678,4.9678,0,0,0,20.1011,24H18v2h2.1011a4.9678,4.9678,0,0,0,.7319,1.7529l-1.49,1.49,1.414,1.414,1.49-1.49A4.9678,4.9678,0,0,0,24,29.8989V32h2V29.8989a4.9678,4.9678,0,0,0,1.7529-.7319l1.49,1.49,1.414-1.414-1.49-1.49A4.9678,4.9678,0,0,0,29.8989,26Zm-7,2a3,3,0,1,1,3-3A3.0033,3.0033,0,0,1,25,28Z"})),$s||($s=i.createElement("circle",{cx:"7",cy:"20",r:"2"})),ea||(ea=i.createElement("path",{d:"M14,20a4,4,0,1,1,4-4A4.0118,4.0118,0,0,1,14,20Zm0-6a2,2,0,1,0,2,2A2.0059,2.0059,0,0,0,14,14Z"})),ia||(ia=i.createElement("circle",{cx:"21",cy:"12",r:"2"})),ta||(ta=i.createElement("path",{d:"M13.0205,28.2715,3,22.4258V9.5742L14,3.1577,25.4961,9.8638l1.0078-1.7276-12-7a1,1,0,0,0-1.0078,0l-12,7A.9994.9994,0,0,0,1,9V23a1.0008,1.0008,0,0,0,.4961.8643L12.0127,30Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Sr);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),_a||(_a=i.createElement("path",{d:"M30.9763,24.9748l-5.0015,5.0015a3.501,3.501,0,0,1-4.9511-4.9511L22.4383,26.44A1.5,1.5,0,0,0,24.56,28.5617L29.5617,23.56A1.5,1.5,0,0,0,27.44,21.4383l-1.4146-1.4146a3.501,3.501,0,0,1,4.9511,4.9511Z"})),sa||(sa=i.createElement("path",{d:"M20.0252,21.0237l-5.0015,5.0015a3.501,3.501,0,0,0,4.9511,4.9511L18.56,29.5617A1.5,1.5,0,0,1,16.4383,27.44L21.44,22.4383A1.5,1.5,0,0,1,23.5617,24.56l1.4146,1.4146a3.501,3.501,0,0,0-4.9511-4.9511Z"})),aa||(aa=i.createElement("circle",{cx:"7",cy:"20",r:"2"})),na||(na=i.createElement("path",{d:"M14,20a4,4,0,1,1,4-4A4.0118,4.0118,0,0,1,14,20Zm0-6a2,2,0,1,0,2,2A2.0059,2.0059,0,0,0,14,14Z"})),ra||(ra=i.createElement("circle",{cx:"21",cy:"12",r:"2"})),la||(la=i.createElement("path",{d:"M11.3076,27.2725,3,22.4258V9.5742L14,3.1577,25.4961,9.8638l1.0078-1.7276-12-7a1,1,0,0,0-1.0078,0l-12,7A.9994.9994,0,0,0,1,9V23a1.0008,1.0008,0,0,0,.4961.8643L10.3,29Z"})),_)})).propTypes=da;var Ar=!("undefined"===typeof window||!window.document||!window.document.createElement),Tr=function(){var e=0;return function(){return++e}}(),Wr=Ar?i.useLayoutEffect:i.useEffect,Ur=!1;function Ir(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"id",t=q((0,i.useState)((function(){return Ur?"".concat(e,"-").concat(Tr()):null})),2),_=t[0],s=t[1];return Wr((function(){null===_&&s("".concat(e,"-").concat(Tr()))}),[Tr]),(0,i.useEffect)((function(){!1===Ur&&(Ur=!0)}),[]),_}var Br={};function Or(e,i){return function(i,t,_){if(void 0!==i[t]){Br[_]&&Br[_][t]||(Br[_]=R(R({},Br[_]),{},A({},t,!0)));for(var s=arguments.length,a=new Array(s>3?s-3:0),n=3;n<s;n++)a[n-3]=arguments[n];return e.apply(void 0,[i,t,_].concat(a))}}}var Fr=(0,i.createContext)(null),qr=["as","children","dir"];function Xr(e){var t=e.as,_=void 0===t?"span":t,s=e.children,a=e.dir,n=void 0===a?"auto":a,r=B(e,qr),l=(0,i.useContext)(Fr),d={},o=R({},l);if(l){var m=l.direction,v=l.getTextDirection;if(v&&v.current){var c=function(e){if("string"===typeof e)return e;var t=i.Children.map(e,(function(e){return"string"===typeof e?e:null})).filter((function(e){return null!==e}));if(1===t.length)return t[0];return t}(s),u=v.current(c);m!==u?(d.dir=u,o.direction=u):"auto"===m&&(d.dir=u)}else m!==n?(d.dir=n,o.direction=n):"auto"===m&&(d.dir=n)}else d.dir=n,o.direction=n;return i.createElement(Fr.Provider,{value:o},i.createElement(_,T({},r,d),s))}function Cr(e){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=i.key,_=i.which,s=i.keyCode;return"string"===typeof e?e===t:"number"===typeof e?e===_||e===s:e.key&&Array.isArray(t)?-1!==t.indexOf(e.key):e.key===t||e.which===_||e.keyCode===s}Xr.propTypes={as:P().oneOfType([P().func,P().string,P().elementType]),children:P().node.isRequired,dir:P().oneOf(["ltr","rtl","auto"])};var Hr={key:["Escape","Esc"],which:27,keyCode:27},kr=["children","className","iconDescription","open","onHeadingClick","renderExpando","renderToggle","title","disabled"],Nr=function(e){return i.createElement("button",T({type:"button"},e))};function Zr(e){var t,_=e.children,s=e.className;e.iconDescription;var a=e.open,n=void 0!==a&&a,r=e.onHeadingClick,l=e.renderExpando,d=void 0===l?Nr:l,o=e.renderToggle,m=e.title,v=void 0===m?"title":m,c=e.disabled,u=B(e,kr),f=q((0,i.useState)(n),2),b=f[0],p=f[1],g=q((0,i.useState)(n),2),E=g[0],w=g[1],h=q((0,i.useState)(""),2),x=h[0],z=h[1],L=Ir("accordion-item"),M=Z(),R=k()((A(t={},"".concat(M,"--accordion__item"),!0),A(t,"".concat(M,"--accordion__item--active"),b),A(t,"".concat(M,"--accordion__item--").concat(x),x),A(t,"".concat(M,"--accordion__item--disabled"),c),A(t,s,!!s),t)),S=o||d;return n!==E&&(z(b?"collapsing":"expanding"),p(n),w(n)),i.createElement("li",T({className:R},u,{onAnimationEnd:function(e){u.handleAnimationEnd&&u.handleAnimationEnd(e),z("")}}),i.createElement(S,{disabled:c,"aria-controls":L,"aria-expanded":b,className:"".concat(M,"--accordion__heading"),onClick:function(e){var i=!b;z(b?"collapsing":"expanding"),p(i),r&&r({isOpen:i,event:e})},onKeyDown:function(e){b&&Cr(e,Hr)&&p(!1)},type:"button"},i.createElement(yr,{className:"".concat(M,"--accordion__arrow")}),i.createElement(Xr,{as:"div",className:"".concat(M,"--accordion__title")},v)),i.createElement("div",{id:L,className:"".concat(M,"--accordion__content")},_))}Zr.propTypes={children:P().node,className:P().string,disabled:P().bool,onClick:P().func,onHeadingClick:P().func,open:P().bool,renderExpando:Or(P().func),renderToggle:P().func,title:P().node};var Yr=["className","id","labelText","onChange","indeterminate","hideLabel","title"],Pr=i.forwardRef((function(e,t){var _=e.className,s=e.id,a=e.labelText,n=e.onChange,r=e.indeterminate,l=e.hideLabel,d=e.title,o=void 0===d?"":d,m=B(e,Yr),v=Z(),c=k()("".concat(v,"--checkbox-label"),[_]),u=k()("".concat(v,"--checkbox-label-text"),A({},"".concat(v,"--visually-hidden"),l)),f=k()("".concat(v,"--form-item"),"".concat(v,"--checkbox-wrapper"),[_]);return i.createElement("div",{className:f},i.createElement("input",T({},m,{type:"checkbox",onChange:function(e){n(e,{checked:e.target.checked,id:s})},className:"".concat(v,"--checkbox"),id:s,ref:function(e){e&&(e.indeterminate=r),"function"===typeof t?t(e):Object(t)===t&&(t.current=e)}})),i.createElement("label",{htmlFor:s,className:c,title:o||null},i.createElement(Xr,{className:u},a)))}));Pr.propTypes={checked:P().bool,className:P().string,defaultChecked:P().bool,disabled:P().bool,hideLabel:P().bool,id:P().string.isRequired,indeterminate:P().bool,labelText:P().node.isRequired,onChange:P().func,title:P().string},Pr.defaultProps={onChange:function(){},indeterminate:!1},Pr.displayName="Checkbox";var jr=Pr;"undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof t.g?t.g:"undefined"!==typeof self&&self;function Kr(e){if(e.__esModule)return e;var i=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(e).forEach((function(t){var _=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(i,t,_.get?_:{enumerable:!0,get:function(){return e[t]}})})),i}var Gr=function(){if("undefined"!==typeof Map)return Map;function e(e,i){var t=-1;return e.some((function(e,_){return e[0]===i&&(t=_,!0)})),t}return function(){function i(){this.__entries__=[]}return Object.defineProperty(i.prototype,"size",{get:function(){return this.__entries__.length},enumerable:!0,configurable:!0}),i.prototype.get=function(i){var t=e(this.__entries__,i),_=this.__entries__[t];return _&&_[1]},i.prototype.set=function(i,t){var _=e(this.__entries__,i);~_?this.__entries__[_][1]=t:this.__entries__.push([i,t])},i.prototype.delete=function(i){var t=this.__entries__,_=e(t,i);~_&&t.splice(_,1)},i.prototype.has=function(i){return!!~e(this.__entries__,i)},i.prototype.clear=function(){this.__entries__.splice(0)},i.prototype.forEach=function(e,i){void 0===i&&(i=null);for(var t=0,_=this.__entries__;t<_.length;t++){var s=_[t];e.call(i,s[1],s[0])}},i}()}(),Qr="undefined"!==typeof window&&"undefined"!==typeof document&&window.document===document,Jr="undefined"!==typeof t.g&&t.g.Math===Math?t.g:"undefined"!==typeof self&&self.Math===Math?self:"undefined"!==typeof window&&window.Math===Math?window:Function("return this")(),$r="function"===typeof requestAnimationFrame?requestAnimationFrame.bind(Jr):function(e){return setTimeout((function(){return e(Date.now())}),1e3/60)};var el=["top","right","bottom","left","width","height","size","weight"],il="undefined"!==typeof MutationObserver,tl=function(){function e(){this.connected_=!1,this.mutationEventsAdded_=!1,this.mutationsObserver_=null,this.observers_=[],this.onTransitionEnd_=this.onTransitionEnd_.bind(this),this.refresh=function(e,i){var t=!1,_=!1,s=0;function a(){t&&(t=!1,e()),_&&r()}function n(){$r(a)}function r(){var e=Date.now();if(t){if(e-s<2)return;_=!0}else t=!0,_=!1,setTimeout(n,i);s=e}return r}(this.refresh.bind(this),20)}return e.prototype.addObserver=function(e){~this.observers_.indexOf(e)||this.observers_.push(e),this.connected_||this.connect_()},e.prototype.removeObserver=function(e){var i=this.observers_,t=i.indexOf(e);~t&&i.splice(t,1),!i.length&&this.connected_&&this.disconnect_()},e.prototype.refresh=function(){this.updateObservers_()&&this.refresh()},e.prototype.updateObservers_=function(){var e=this.observers_.filter((function(e){return e.gatherActive(),e.hasActive()}));return e.forEach((function(e){return e.broadcastActive()})),e.length>0},e.prototype.connect_=function(){Qr&&!this.connected_&&(document.addEventListener("transitionend",this.onTransitionEnd_),window.addEventListener("resize",this.refresh),il?(this.mutationsObserver_=new MutationObserver(this.refresh),this.mutationsObserver_.observe(document,{attributes:!0,childList:!0,characterData:!0,subtree:!0})):(document.addEventListener("DOMSubtreeModified",this.refresh),this.mutationEventsAdded_=!0),this.connected_=!0)},e.prototype.disconnect_=function(){Qr&&this.connected_&&(document.removeEventListener("transitionend",this.onTransitionEnd_),window.removeEventListener("resize",this.refresh),this.mutationsObserver_&&this.mutationsObserver_.disconnect(),this.mutationEventsAdded_&&document.removeEventListener("DOMSubtreeModified",this.refresh),this.mutationsObserver_=null,this.mutationEventsAdded_=!1,this.connected_=!1)},e.prototype.onTransitionEnd_=function(e){var i=e.propertyName,t=void 0===i?"":i;el.some((function(e){return!!~t.indexOf(e)}))&&this.refresh()},e.getInstance=function(){return this.instance_||(this.instance_=new e),this.instance_},e.instance_=null,e}(),_l=function(e,i){for(var t=0,_=Object.keys(i);t<_.length;t++){var s=_[t];Object.defineProperty(e,s,{value:i[s],enumerable:!1,writable:!1,configurable:!0})}return e},sl=function(e){return e&&e.ownerDocument&&e.ownerDocument.defaultView||Jr},al=ml(0,0,0,0);function nl(e){return parseFloat(e)||0}function rl(e){for(var i=[],t=1;t<arguments.length;t++)i[t-1]=arguments[t];return i.reduce((function(i,t){return i+nl(e["border-"+t+"-width"])}),0)}function ll(e){var i=e.clientWidth,t=e.clientHeight;if(!i&&!t)return al;var _=sl(e).getComputedStyle(e),s=function(e){for(var i={},t=0,_=["top","right","bottom","left"];t<_.length;t++){var s=_[t],a=e["padding-"+s];i[s]=nl(a)}return i}(_),a=s.left+s.right,n=s.top+s.bottom,r=nl(_.width),l=nl(_.height);if("border-box"===_.boxSizing&&(Math.round(r+a)!==i&&(r-=rl(_,"left","right")+a),Math.round(l+n)!==t&&(l-=rl(_,"top","bottom")+n)),!function(e){return e===sl(e).document.documentElement}(e)){var d=Math.round(r+a)-i,o=Math.round(l+n)-t;1!==Math.abs(d)&&(r-=d),1!==Math.abs(o)&&(l-=o)}return ml(s.left,s.top,r,l)}var dl="undefined"!==typeof SVGGraphicsElement?function(e){return e instanceof sl(e).SVGGraphicsElement}:function(e){return e instanceof sl(e).SVGElement&&"function"===typeof e.getBBox};function ol(e){return Qr?dl(e)?function(e){var i=e.getBBox();return ml(0,0,i.width,i.height)}(e):ll(e):al}function ml(e,i,t,_){return{x:e,y:i,width:t,height:_}}var vl=function(){function e(e){this.broadcastWidth=0,this.broadcastHeight=0,this.contentRect_=ml(0,0,0,0),this.target=e}return e.prototype.isActive=function(){var e=ol(this.target);return this.contentRect_=e,e.width!==this.broadcastWidth||e.height!==this.broadcastHeight},e.prototype.broadcastRect=function(){var e=this.contentRect_;return this.broadcastWidth=e.width,this.broadcastHeight=e.height,e},e}(),cl=function(e,i){var t=function(e){var i=e.x,t=e.y,_=e.width,s=e.height,a="undefined"!==typeof DOMRectReadOnly?DOMRectReadOnly:Object,n=Object.create(a.prototype);return _l(n,{x:i,y:t,width:_,height:s,top:t,right:i+_,bottom:s+t,left:i}),n}(i);_l(this,{target:e,contentRect:t})},ul=function(){function e(e,i,t){if(this.activeObservations_=[],this.observations_=new Gr,"function"!==typeof e)throw new TypeError("The callback provided as parameter 1 is not a function.");this.callback_=e,this.controller_=i,this.callbackCtx_=t}return e.prototype.observe=function(e){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("undefined"!==typeof Element&&Element instanceof Object){if(!(e instanceof sl(e).Element))throw new TypeError('parameter 1 is not of type "Element".');var i=this.observations_;i.has(e)||(i.set(e,new vl(e)),this.controller_.addObserver(this),this.controller_.refresh())}},e.prototype.unobserve=function(e){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("undefined"!==typeof Element&&Element instanceof Object){if(!(e instanceof sl(e).Element))throw new TypeError('parameter 1 is not of type "Element".');var i=this.observations_;i.has(e)&&(i.delete(e),i.size||this.controller_.removeObserver(this))}},e.prototype.disconnect=function(){this.clearActive(),this.observations_.clear(),this.controller_.removeObserver(this)},e.prototype.gatherActive=function(){var e=this;this.clearActive(),this.observations_.forEach((function(i){i.isActive()&&e.activeObservations_.push(i)}))},e.prototype.broadcastActive=function(){if(this.hasActive()){var e=this.callbackCtx_,i=this.activeObservations_.map((function(e){return new cl(e.target,e.broadcastRect())}));this.callback_.call(e,i,e),this.clearActive()}},e.prototype.clearActive=function(){this.activeObservations_.splice(0)},e.prototype.hasActive=function(){return this.activeObservations_.length>0},e}(),fl="undefined"!==typeof WeakMap?new WeakMap:new Gr,bl=function e(i){if(!(this instanceof e))throw new TypeError("Cannot call a class as a function.");if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");var t=tl.getInstance(),_=new ul(i,t,this);fl.set(this,_)};["observe","unobserve","disconnect"].forEach((function(e){bl.prototype[e]=function(){var i;return(i=fl.get(this))[e].apply(i,arguments)}}));var pl="undefined"!==typeof Jr.ResizeObserver?Jr.ResizeObserver:bl;var gl,El=(gl=Kr(e))&&"object"===S(gl)&&"default"in gl?gl.default:gl,wl=i;var hl=function(e){void 0===e&&(e={});var i=wl.useRef(null),t=e.onResize,_=wl.useRef(void 0);_.current=t;var s=wl.useRef(),a=e.ref||i,n=wl.useState({width:void 0,height:void 0}),r=n[0],l=n[1],d=wl.useRef({width:void 0,height:void 0});return wl.useEffect((function(){s.current||(s.current=new El((function(e){if(Array.isArray(e)&&e.length){var i=e[0],t=Math.round(i.contentRect.width),s=Math.round(i.contentRect.height);if(d.current.width!==t||d.current.height!==s){var a={width:t,height:s};_.current?_.current(a):(d.current.width=t,d.current.height=s,l(a))}}})))}),[]),wl.useEffect((function(){if("object"===S(a)&&null!==a&&a.current instanceof Element){var e=a.current;return s.current.observe(e),function(){return s.current.unobserve(e)}}}),[a]),wl.useMemo((function(){return{ref:a,width:r.width,height:r.height}}),[a,r?r.width:null,r?r.height:null])},xl=t(95),zl=t.n(xl),Ll=function(e){return function(i){for(var t=arguments.length,_=new Array(t>1?t-1:0),s=1;s<t;s++)_[s-1]=arguments[s];for(var a=0;a<e.length&&!i.defaultPrevented;a++)"function"===typeof e[a]&&e[a].apply(e,[i].concat(_))}},Ml=["as","children","className","dangerDescription","disabled","hasIconOnly","href","iconDescription","isExpressive","isSelected","kind","onBlur","onClick","onFocus","onMouseEnter","onMouseLeave","renderIcon","size","tabIndex","tooltipAlignment","tooltipPosition","type"],Rl=i.forwardRef((function(e,t){var _,s,a=e.as,n=e.children,r=e.className,l=e.dangerDescription,d=void 0===l?"danger":l,o=e.disabled,m=void 0!==o&&o,v=e.hasIconOnly,c=void 0!==v&&v,u=e.href,f=e.iconDescription,b=e.isExpressive,p=void 0!==b&&b,g=e.isSelected,E=e.kind,w=void 0===E?"primary":E,h=e.onBlur,x=e.onClick,z=e.onFocus,L=e.onMouseEnter,M=e.onMouseLeave,S=e.renderIcon,D=e.size,y=void 0===D?"lg":D,V=e.tabIndex,W=void 0===V?0:V,U=e.tooltipAlignment,I=void 0===U?"center":U,O=e.tooltipPosition,F=void 0===O?"top":O,q=e.type,X=void 0===q?"button":q,C=B(e,Ml),H=(0,i.useRef)(null),N=Z(),Y={tabIndex:W,className:k()(r,(A(_={},"".concat(N,"--btn"),!0),A(_,"".concat(N,"--btn--sm"),"sm"===y&&!p),A(_,"".concat(N,"--btn--md"),"md"===y&&!p),A(_,"".concat(N,"--btn--xl"),"xl"===y),A(_,"".concat(N,"--btn--2xl"),"2xl"===y),A(_,"".concat(N,"--btn--").concat(w),w),A(_,"".concat(N,"--btn--disabled"),m),A(_,"".concat(N,"--btn--expressive"),p),A(_,"".concat(N,"--btn--icon-only"),c),A(_,"".concat(N,"--btn--selected"),c&&g&&"ghost"===w),_)),ref:t},P=S?i.createElement(S,{"aria-label":f,className:"".concat(N,"--btn__icon"),"aria-hidden":"true"}):null,j=S?i.createElement(S,null):null,K=["danger","danger--tertiary","danger--ghost"],G="button",Q=Ir("danger-description"),J={disabled:m,type:X,"aria-describedby":K.includes(w)?Q:null,"aria-pressed":c&&"ghost"===w?g:null},$={href:u};s=K.includes(w)?i.createElement("span",{id:Q,className:"".concat(N,"--visually-hidden")},d):null,a?(G=a,J=R(R({},J),$)):u&&!m&&(G="a",J=$);var ee,ie=i.createElement(G,R(R(R({onMouseEnter:L,onMouseLeave:M,onFocus:z,onBlur:h,onClick:x},C),Y),J),s,n,P);return c?("top"!==F&&"bottom"!==F||("center"===I&&(ee=F),"end"===I&&(ee="".concat(F,"-right")),"start"===I&&(ee="".concat(F,"-left"))),"right"!==F&&"left"!==F||(ee=F),i.createElement(Bl,T({align:ee,label:f,kind:w,size:y,onMouseEnter:L,onMouseLeave:M,onFocus:z,onBlur:h,onClick:Ll([x,function(e){e.target!==H.current||e.preventDefault()}])},C,Y,J),j||n)):ie}));Rl.displayName="Button",Rl.propTypes={as:P().oneOfType([P().func,P().string,P().elementType]),children:P().node,className:P().string,dangerDescription:P().string,disabled:P().bool,hasIconOnly:P().bool,href:P().string,iconDescription:function(e){if(e.renderIcon&&!e.children&&!e.iconDescription)return new Error("renderIcon property specified without also providing an iconDescription property.")},isExpressive:P().bool,isSelected:P().bool,kind:P().oneOf(["primary","secondary","danger","ghost","danger--primary","danger--ghost","danger--tertiary","tertiary"]),onBlur:P().func,onClick:P().func,onFocus:P().func,onMouseEnter:P().func,onMouseLeave:P().func,renderIcon:P().oneOfType([P().func,P().object]),role:P().string,size:P().oneOf(["sm","md","lg","xl","2xl"]),tabIndex:P().number,tooltipAlignment:P().oneOf(["start","center","end"]),tooltipPosition:P().oneOf(["top","right","bottom","left"]),type:P().oneOf(["button","reset","submit"])};var Sl=Rl,Dl=["align","as","caret","className","children","dropShadow","highContrast","open"],yl=["className","children"],Vl=i.forwardRef((function(e,t){var _,s=e.align,a=void 0===s?"bottom":s,n=e.as,r=void 0===n?"span":n,l=e.caret,d=void 0===l||l,o=e.className,m=e.children,v=e.dropShadow,c=void 0===v||v,u=e.highContrast,f=void 0!==u&&u,b=e.open,p=B(e,Dl),g=Z(),E=k()((A(_={},"".concat(g,"--popover-container"),!0),A(_,"".concat(g,"--popover--caret"),d),A(_,"".concat(g,"--popover--drop-shadow"),c),A(_,"".concat(g,"--popover--high-contrast"),f),A(_,"".concat(g,"--popover--open"),b),A(_,"".concat(g,"--popover--").concat(a),!0),A(_,o,!!o),_));return i.createElement(r,T({},p,{className:E,ref:t}),m)}));Vl.propTypes={align:P().oneOf(["top","top-left","top-right","bottom","bottom-left","bottom-right","left","left-bottom","left-top","right","right-bottom","right-top"]),as:P().oneOfType([P().string,P().elementType]),caret:P().bool,children:P().node,className:P().string,dropShadow:P().bool,highContrast:P().bool,open:P().bool.isRequired};var Al=i.forwardRef((function(e,t){var _=e.className,s=e.children,a=B(e,yl),n=Z();return i.createElement("span",T({},a,{className:"".concat(n,"--popover")}),i.createElement("span",{className:k()("".concat(n,"--popover-content"),_),ref:t},s),i.createElement("span",{className:"".concat(n,"--popover-caret")}))}));function Tl(e){if(function(e){if(e.tabIndex<0)return!1;if(e.disabled)return!1;switch(e.nodeName){case"A":return!!e.href&&"ignore"!==e.rel;case"INPUT":return"hidden"!==e.type;case"BUTTON":case"SELECT":case"TEXTAREA":return!0;default:return!1}}(e))return e;var i,t=function(e,i){var t="undefined"!==typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!t){if(Array.isArray(e)||(t=X(e))||i&&e&&"number"===typeof e.length){t&&(e=t);var _=0,s=function(){};return{s:s,n:function(){return _>=e.length?{done:!0}:{done:!1,value:e[_++]}},e:function(e){throw e},f:s}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,n=!0,r=!1;return{s:function(){t=t.call(e)},n:function(){var e=t.next();return n=e.done,e},e:function(e){r=!0,a=e},f:function(){try{n||null==t.return||t.return()}finally{if(r)throw a}}}}(e.childNodes);try{for(t.s();!(i=t.n()).done;){var _=Tl(i.value);if(_)return _}}catch(s){t.e(s)}finally{t.f()}return null}Al.propTypes={children:P().node,className:P().string};var Wl=["align","className","children","label","description","enterDelayMs","leaveDelayMs","defaultOpen"];function Ul(e){var t=e.align,_=void 0===t?"top":t,s=e.className,a=e.children,n=e.label,r=e.description,l=e.enterDelayMs,d=void 0===l?100:l,o=e.leaveDelayMs,m=void 0===o?300:o,v=e.defaultOpen,c=void 0!==v&&v,u=B(e,Wl),f=(0,i.useRef)(null),b=(0,i.useRef)(null),p=function(e){var t=q((0,i.useState)(e),2),_=t[0],s=t[1],a=(0,i.useRef)(null),n=(0,i.useCallback)((function(e){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;clearTimeout(a.current),a.current=null,0!==i?a.current=setTimeout((function(){s(e),a.current=null}),i):s(e)}),[]);return(0,i.useEffect)((function(){return function(){clearTimeout(a.current)}}),[]),[_,n]}(c),g=q(p,2),E=g[0],w=g[1],h=Ir("tooltip"),x=Z(),z=i.Children.only(a),L={onFocus:function(){return w(!0)},onBlur:function(){return w(!1)},onMouseEnter:function(){w(!0,d)}};return n?L["aria-labelledby"]=h:L["aria-describedby"]=h,(0,i.useEffect)((function(){Tl(f.current)||w(!1)})),i.createElement(Vl,T({},u,{align:_,className:k()("".concat(x,"--tooltip"),s),dropShadow:!1,highContrast:!0,onKeyDown:function(e){E&&Cr(e,Hr)&&(e.stopPropagation(),w(!1))},onMouseLeave:function(){w(!1,m)},open:E,ref:f}),i.cloneElement(z,L),i.createElement(Al,{"aria-hidden":"true",className:"".concat(x,"--tooltip-content"),id:h,ref:b,role:"tooltip"},n||r))}Ul.propTypes={align:P().oneOf(["top","top-left","top-right","bottom","bottom-left","bottom-right","left","left-bottom","left-top","right","right-bottom","right-top"]),children:P().node,className:P().string,defaultOpen:P().bool,description:P().node,enterDelayMs:P().number,label:P().node,leaveDelayMs:P().number};var Il=["align","children","defaultOpen","enterDelayMs","kind","label","leaveDelayMs","size"],Bl=i.forwardRef((function(e,t){var _=e.align,s=e.children,a=e.defaultOpen,n=void 0!==a&&a,r=e.enterDelayMs,l=e.kind,d=e.label,o=e.leaveDelayMs,m=e.size,v=void 0===m?"md":m,c=B(e,Il),u=Z();return i.createElement(Ul,{align:_,className:"".concat(u,"--icon-tooltip"),defaultOpen:n,enterDelayMs:r,label:d,leaveDelayMs:o},i.createElement(Sl,T({},c,{kind:l,ref:t,size:v}),s))}));Bl.propTypes={align:P().oneOf(["top","top-left","top-right","bottom","bottom-left","bottom-right","left","right"]),children:P().node,defaultOpen:P().bool,enterDelayMs:P().number,kind:P().oneOf(["primary","secondary","ghost","tertiary"]),label:P().node.isRequired,leaveDelayMs:P().number,size:P().oneOf(["sm","md","lg"])};var Ol,Fl,ql,Xl,Cl,Hl,kl,Nl,Zl,Yl,Pl,jl,Kl,Gl,Ql,Jl,$l,ed,id,td,_d,sd,ad,nd,rd,ld,dd,od,md,vd,cd,ud,fd,bd,pd,gd,Ed,wd,hd,xd,zd,Ld,Md,Rd,Sd,Dd,yd,Vd,Ad,Td,Wd,Ud,Id,Bd,Od,Fd,qd,Xd,Cd,Hd,kd,Nd,Zd,Yd,Pd,jd,Kd,Gd,Qd,Jd,$d,eo,io,to,_o,so,ao,no,ro,lo,oo,mo,vo,co,uo,fo,bo,po,go,Eo,wo,ho,xo,zo,Lo,Mo,Ro,So,Do,yo,Vo,Ao,To,Wo,Uo,Io,Bo,Oo,Fo,qo,Xo,Co,Ho,ko,No,Zo,Yo,Po,jo,Ko,Go,Qo,Jo,$o,em,im,tm,_m,sm,am,nm,rm,lm,dm,om,mm,vm,cm,um,fm,bm,pm,gm,Em,wm,hm,xm,zm,Lm,Mm,Rm,Sm,Dm,ym,Vm,Am,Tm,Wm,Um,Im,Bm,Om,Fm,qm,Xm,Cm,Hm,km,Nm,Zm,Ym,Pm,jm,Km,Gm,Qm,Jm,$m,ev,iv,tv,_v,sv,av,nv,rv,lv,dv,ov,mv,vv,cv,uv,fv,bv,pv,gv,Ev,wv,hv,xv,zv,Lv,Mv,Rv,Sv,Dv,yv,Vv,Av,Tv,Wv,Uv,Iv,Bv,Ov,Fv,qv,Xv,Cv,Hv,kv,Nv,Zv,Yv,Pv,jv,Kv,Gv,Qv,Jv,$v,ec,ic,tc,_c,sc,ac,nc,rc,lc,dc,oc,mc,vc,cc,uc,fc,bc,pc=["children","className","feedback","feedbackTimeout","onAnimationEnd","onClick"];function gc(e){var t,_=e.children,s=e.className,a=e.feedback,n=e.feedbackTimeout,r=e.onAnimationEnd,l=e.onClick,d=B(e,pc),o=q((0,i.useState)(""),2),m=o[0],v=o[1],c=Z(),u=k()(s,"".concat(c,"--copy"),(A(t={},"".concat(c,"--copy-btn--animating"),m),A(t,"".concat(c,"--copy-btn--").concat(m),m),t)),f=(0,i.useCallback)(zl()((function(){v("fade-out")}),n),[n]),b=(0,i.useCallback)((function(){v("fade-in"),f()}),[f]),p=function(e){"hide-feedback"===e.animationName&&v("")};return(0,i.useEffect)((function(){return function(){f.cancel()}}),[f]),L("enable-v11-release")?i.createElement(Bl,T({align:"bottom",className:u,label:m?a:d["aria-label"],onClick:Ll([l,b]),onAnimationEnd:Ll([r,p])},d,{"aria-live":"polite","aria-label":!_&&(m?a:d["aria-label"])||null}),_):i.createElement("button",T({type:"button",className:u,onClick:Ll([l,b]),onAnimationEnd:Ll([r,p])},d,{"aria-live":"polite","aria-label":!_&&(m?a:d["aria-label"])||null}),_,m?a:d["aria-label"],i.createElement("span",{"aria-hidden":"true",className:"".concat(c,"--assistive-text ").concat(c,"--copy-btn__feedback")},a))}gc.propTypes={children:P().node,className:P().string,feedback:P().string,feedbackTimeout:P().number,onAnimationEnd:P().func,onClick:P().func},gc.defaultProps={feedback:"Copied!",feedbackTimeout:2e3,onClick:function(){}};var Ec=["children","size"],wc=["children","size"],hc=["children","size"],xc=["children","size"],zc=["children","size"],Lc=["children","size"],Mc=["children","size"],Rc=["children","size"],Sc=["children","size"],Dc=["children","size"],yc=["children","size"],Vc=["children","size"],Ac=["children","size"],Tc=["children","size"],Wc=["children","size"],Uc=["children","size"],Ic=["children","size"],Bc=["children","size"],Oc=["children","size"],Fc=["children","size"],qc=["children","size"],Xc=["children","size"],Cc=["children","size"],Hc=["children","size"],kc=["children","size"],Nc=["children","size"],Zc=["children","size"],Yc=["children","size"],Pc=["children","size"],jc=["children","size"],Kc=["children","size"],Gc=["children","size"],Qc=["children","size"],Jc=["children","size"],$c=["children","size"],eu=["children","size"],iu=["children","size"],tu=["children","size"],_u=["children","size"],su=["children","size"],au=["children","size"],nu=["children","size"],ru=["children","size"],lu=["children","size"],du=["children","size"],ou=["children","size"],mu=["children","size"],vu=["children","size"],cu=["children","size"],uu=["children","size"],fu=["children","size"],bu=["children","size"],pu=["children","size"],gu=["children","size"],Eu=["children","size"],wu=["children","size"],hu=["children","size"],xu=["children","size"],zu=["children","size"],Lu=["children","size"],Mu=["children","size"],Ru=["children","size"],Su=["children","size"],Du=["children","size"],yu=["children","size"],Vu=["children","size"],Au=["children","size"],Tu=["children","size"],Wu=["children","size"],Uu=["children","size"],Iu=["children","size"],Bu=["children","size"],Ou=["children","size"],Fu=["children","size"],qu=["children","size"],Xu=["children","size"],Cu=["children","size"],Hu=["children","size"],ku=["children","size"],Nu=["children","size"],Zu=["children","size"],Yu=["children","size"],Pu=["children","size"],ju=["children","size"],Ku=["children","size"],Gu=["children","size"],Qu=["children","size"],Ju=["children","size"],$u=["children","size"],ef=["children","size"],tf=["children","size"],_f=["children","size"],sf=["children","size"],af=["children","size"],nf=["children","size"],rf=["children","size"],lf=["children","size"],df=["children","size"],of=["children","size"],mf=["children","size"],vf=["children","size"],cf=["children","size"],uf=["children","size"],ff=["children","size"],bf=["children","size"],pf=["children","size"],gf=["children","size"],Ef=["children","size"],wf=["children","size"],hf=["children","size"],xf=["children","size"],zf=["children","size"],Lf=["children","size"],Mf=["children","size"],Rf=["children","size"],Sf=["children","size"],Df=["children","size"],yf=["children","size"],Vf=["children","size"],Af=["children","size"],Tf=["children","size"],Wf=["children","size"],Uf=["children","size"],If=["children","size"],Bf=["children","size"];i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ec);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ol||(Ol=i.createElement("path",{d:"M29,26a2.97,2.97,0,0,0-1.8551.6607L25,25.4224V23.8157a3,3,0,1,0-2,0v1.6067l-2.1449,1.2383A2.97,2.97,0,0,0,19,26a3.02,3.02,0,1,0,2.9254,2.3525L24,27.1548l2.0746,1.1977A2.9978,2.9978,0,1,0,29,26ZM19,30a1,1,0,1,1,1-1A1.0006,1.0006,0,0,1,19,30Zm5-10a1,1,0,1,1-1,1A1.0009,1.0009,0,0,1,24,20Zm5,10a1,1,0,1,1,1-1A1.0006,1.0006,0,0,1,29,30Z"})),Fl||(Fl=i.createElement("circle",{cx:"7",cy:"20",r:"2"})),ql||(ql=i.createElement("path",{d:"M14,20a4,4,0,1,1,4-4A4.0118,4.0118,0,0,1,14,20Zm0-6a2,2,0,1,0,2,2A2.0059,2.0059,0,0,0,14,14Z"})),Xl||(Xl=i.createElement("circle",{cx:"21",cy:"12",r:"2"})),Cl||(Cl=i.createElement("path",{d:"M13.0205,28.2715,3,22.4258V9.5742L14,3.1577,25.4961,9.8638l1.0078-1.7276-12-7a1,1,0,0,0-1.0078,0l-12,7A.9994.9994,0,0,0,1,9V23a1.0008,1.0008,0,0,0,.4961.8643L12.0127,30Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,wc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Hl||(Hl=i.createElement("path",{d:"M25.8218,10.124a9.9991,9.9991,0,0,0-19.6435,0A7.4964,7.4964,0,0,0,7.5,25H8V23H7.5a5.4961,5.4961,0,0,1-.3769-10.9795l.8364-.0571.09-.8335a7.9979,7.9979,0,0,1,15.9013,0l.09.8335.8364.0571A5.4961,5.4961,0,0,1,24.5,23H24v2h.5a7.4964,7.4964,0,0,0,1.3218-14.876Z"})),kl||(kl=i.createElement("path",{d:"M23,22V20H20.8989a4.9678,4.9678,0,0,0-.7319-1.7529l1.49-1.49-1.414-1.414-1.49,1.49A4.9678,4.9678,0,0,0,17,16.1011V14H15v2.1011a4.9678,4.9678,0,0,0-1.7529.7319l-1.49-1.49-1.414,1.414,1.49,1.49A4.9678,4.9678,0,0,0,11.1011,20H9v2h2.1011a4.9678,4.9678,0,0,0,.7319,1.7529l-1.49,1.49,1.414,1.414,1.49-1.49A4.9678,4.9678,0,0,0,15,25.8989V28h2V25.8989a4.9678,4.9678,0,0,0,1.7529-.7319l1.49,1.49,1.414-1.414-1.49-1.49A4.9678,4.9678,0,0,0,20.8989,22Zm-7,2a3,3,0,1,1,3-3A3.0033,3.0033,0,0,1,16,24Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,hc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Nl||(Nl=i.createElement("path",{d:"M30.0005,15.5005a6.5324,6.5324,0,0,0-5.1992-6.3638,8.9943,8.9943,0,0,0-17.6006,0,6.5321,6.5321,0,0,0-5.2,6.3638,6.4543,6.4543,0,0,0,1.6887,4.35A5.9829,5.9829,0,0,0,8,30H19a5.9764,5.9764,0,0,0,5.6094-8.1016A6.5051,6.5051,0,0,0,30.0005,15.5005ZM19,28H8a3.9925,3.9925,0,0,1-.6731-7.9292L7.99,19.958l.1458-.6562a5.496,5.496,0,0,1,10.7294,0l.1458.6562.6626.1128A3.9925,3.9925,0,0,1,19,28Zm4.5-8h-.0554a5.9562,5.9562,0,0,0-2.7959-1.7564,7.4952,7.4952,0,0,0-14.2984,0,5.9877,5.9877,0,0,0-1.0315.4073A4.4446,4.4446,0,0,1,4,15.5005a4.5171,4.5171,0,0,1,4.144-4.481l.8155-.0639.0991-.812a6.9938,6.9938,0,0,1,13.8838,0l.0986.812.8154.0639a4.4975,4.4975,0,0,1-.3564,8.981Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,xc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Zl||(Zl=i.createElement("path",{d:"M20 17V15a2 2 0 00-2-2H10a2 2 0 00-2 2v2a2 2 0 002 2h8A2 2 0 0020 17zM10 15h8v2H10zM23.42 24.48A2 2 0 0021 23.06l-7.73 2.07a2 2 0 00-1.42 2.44h0l.52 1.93A2 2 0 0014.27 31a3 3 0 00.52-.07l7.73-2.07h0a2 2 0 001.41-2.45zM14.27 29l-.51-1.94L21.48 25 22 26.92zM13.24 6.86L21 8.93h0a2.24 2.24 0 00.51.07 2 2 0 001.94-1.48L24 5.58a2 2 0 00-1.41-2.45L14.79 1.06a2 2 0 00-2.45 1.41h0l-.52 1.93a2 2 0 001.42 2.44zm1-3.86L22 5.07 21.48 7 13.76 4.93zM14 21H16V23H14zM14 9H16V11H14z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,zc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Yl||(Yl=i.createElement("path",{d:"M31 16L24 23 22.59 21.59 28.17 16 22.59 10.41 24 9 31 16zM1 16L8 9 9.41 10.41 3.83 16 9.41 21.59 8 23 1 16z"})),Pl||(Pl=i.createElement("path",{d:"M5.91 15H26.080000000000002V17H5.91z",transform:"rotate(-75 15.996 16)"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Lc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),jl||(jl=i.createElement("path",{d:"M17.713 13.471L19.576 6.518 17.645 6 16.08 11.838 17.713 13.471zM24.207 19.965L25.621 21.379 31 16 24 9 22.586 10.414 28.172 16 24.207 19.965zM30 28.586L3.414 2 2 3.414 7.793 9.207 1 16 8 23 9.414 21.586 3.828 16 9.207 10.621 14.884 16.298 12.423 25.482 14.355 26 16.517 17.931 28.586 30 30 28.586z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Mc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Kl||(Kl=i.createElement("path",{d:"M4 20L4 22 8.586 22 2 28.586 3.414 30 10 23.414 10 28 12 28 12 20 4 20zM30 10L24 4 22.586 5.414 27.172 10 22.586 14.586 24 16 30 10z"})),Gl||(Gl=i.createElement("path",{d:"M8.944 9.001H24.974000000000004V11.001H8.944z",transform:"rotate(-74.995 16.96 10)"})),Ql||(Ql=i.createElement("path",{d:"M4 10L10 4 11.414 5.414 6.828 10 11.414 14.586 10 16 4 10z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Rc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Jl||(Jl=i.createElement("circle",{cx:"25",cy:"20",r:"1"})),$l||($l=i.createElement("path",{d:"M19.4141 30H15V25.5857l5.0337-5.0337A4.6069 4.6069 0 0120 20a5 5 0 114.4478 4.9663zM17 28h1.5859l5.2061-5.2063.5395.1238a3.0351 3.0351 0 10-2.249-2.2488l.1236.5393L17 26.4143zM6 8H8V16H6zM2 8H4V16H2zM18 8H20V14H18zM14 16H12a2 2 0 01-2-2V10a2 2 0 012-2h2a2 2 0 012 2v4A2 2 0 0114 16zm-2-2h2V10H12zM2 18H4V26H2zM14 18H16V22H14zM10 26H8a2 2 0 01-2-2V20a2 2 0 012-2h2a2 2 0 012 2v4A2 2 0 0110 26zM8 24h2V20H8zM2 2H4V6H2zM14 2H16V6H14zM18 2H20V6H18zM10 6H8A2 2 0 016 4V2H8V4h2V2h2V4A2 2 0 0110 6z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Sc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ed||(ed=i.createElement("path",{d:"M30,13A11,11,0,0,0,19,2H11a9,9,0,0,0-9,9v3a5,5,0,0,0,5,5H8.1A5,5,0,0,0,13,23h1.38l4,7,1.73-1-4-6.89A2,2,0,0,0,14.38,21H13a3,3,0,0,1,0-6h1V13H13a5,5,0,0,0-4.9,4H7a3,3,0,0,1-3-3V12H6A3,3,0,0,0,9,9V8H7V9a1,1,0,0,1-1,1H4.08A7,7,0,0,1,11,4h6V6a1,1,0,0,1-1,1H14V9h2a3,3,0,0,0,3-3V4a9,9,0,0,1,8.05,5H26a3,3,0,0,0-3,3v1h2V12a1,1,0,0,1,1-1h1.77A8.76,8.76,0,0,1,28,13v1a5,5,0,0,1-5,5H20v2h3a7,7,0,0,0,3-.68V21a3,3,0,0,1-3,3H22v2h1a5,5,0,0,0,5-5V18.89A7,7,0,0,0,30,14Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Dc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),id||(id=i.createElement("path",{d:"M6 21V20H4v1a7 7 0 007 7h3V26H11A5 5 0 016 21zM24 11v1h2V11a7 7 0 00-7-7H16V6h3A5 5 0 0124 11zM11 11H5a3 3 0 00-3 3v2H4V14a1 1 0 011-1h6a1 1 0 011 1v2h2V14A3 3 0 0011 11zM8 10A4 4 0 104 6 4 4 0 008 10zM8 4A2 2 0 116 6 2 2 0 018 4zM27 25H21a3 3 0 00-3 3v2h2V28a1 1 0 011-1h6a1 1 0 011 1v2h2V28A3 3 0 0027 25zM20 20a4 4 0 104-4A4 4 0 0020 20zm6 0a2 2 0 11-2-2A2 2 0 0126 20z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,yc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),td||(td=i.createElement("path",{d:"M30,15H28V7H13V5H28a2.0023,2.0023,0,0,1,2,2Z"})),_d||(_d=i.createElement("path",{d:"M25,20H23V12H8V10H23a2.0023,2.0023,0,0,1,2,2Z"})),sd||(sd=i.createElement("path",{d:"M18,27H4a2.0023,2.0023,0,0,1-2-2V17a2.0023,2.0023,0,0,1,2-2H18a2.0023,2.0023,0,0,1,2,2v8A2.0023,2.0023,0,0,1,18,27ZM4,17v8H18.0012L18,17Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Vc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ad||(ad=i.createElement("path",{d:"M14 25H28V27H14zM7.17 26L4.59 28.58 6 30 10 26 6 22 4.58 23.41 7.17 26zM14 15H28V17H14zM7.17 16L4.59 18.58 6 20 10 16 6 12 4.58 13.41 7.17 16zM14 5H28V7H14zM7.17 6L4.59 8.58 6 10 10 6 6 2 4.58 3.41 7.17 6z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ac);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),nd||(nd=i.createElement("circle",{cx:"10",cy:"12",r:"2"})),rd||(rd=i.createElement("circle",{cx:"16",cy:"9",r:"2"})),ld||(ld=i.createElement("circle",{cx:"22",cy:"12",r:"2"})),dd||(dd=i.createElement("circle",{cx:"23",cy:"18",r:"2"})),od||(od=i.createElement("circle",{cx:"19",cy:"23",r:"2"})),md||(md=i.createElement("path",{d:"M16.54,2A14,14,0,0,0,2,16a4.82,4.82,0,0,0,6.09,4.65l1.12-.31A3,3,0,0,1,13,23.24V27a3,3,0,0,0,3,3A14,14,0,0,0,30,15.46,14.05,14.05,0,0,0,16.54,2Zm8.11,22.31A11.93,11.93,0,0,1,16,28a1,1,0,0,1-1-1V23.24a5,5,0,0,0-5-5,5.07,5.07,0,0,0-1.33.18l-1.12.31A2.82,2.82,0,0,1,4,16,12,12,0,0,1,16.47,4,12.18,12.18,0,0,1,28,15.53,11.89,11.89,0,0,1,24.65,24.32Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Tc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),vd||(vd=i.createElement("path",{d:"M26,4H6A2.0025,2.0025,0,0,0,4,6V26a2.0025,2.0025,0,0,0,2,2H26a2.0025,2.0025,0,0,0,2-2V6A2.0025,2.0025,0,0,0,26,4ZM6,26,26,6V26Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Wc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),cd||(cd=i.createElement("path",{d:"M24 4H26V28H24zM18 6V26H14V6h4m0-2H14a2 2 0 00-2 2V26a2 2 0 002 2h4a2 2 0 002-2V6a2 2 0 00-2-2zM6 4H8V28H6z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Uc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ud||(ud=i.createElement("path",{d:"M30 3.41L28.59 2 25 5.59 21.41 2 20 3.41 23.59 7 20 10.59 21.41 12 25 8.41 28.59 12 30 10.59 26.41 7 30 3.41z"})),fd||(fd=i.createElement("path",{d:"M24 14V28H18V6H16V28a2.0023 2.0023 0 002 2h6a2.0023 2.0023 0 002-2V14zM10 30H4a2.0021 2.0021 0 01-2-2V8A2.0021 2.0021 0 014 6h6a2.0021 2.0021 0 012 2V28A2.0021 2.0021 0 0110 30zM4 8V28h6V8z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ic);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),bd||(bd=i.createElement("path",{d:"M28 30H22a2.0021 2.0021 0 01-2-2V10a2.0021 2.0021 0 012-2h6a2.0021 2.0021 0 012 2V28A2.0021 2.0021 0 0128 30zM22 10V28h6V10zM16 9L21.586 3.414 20.172 2 16 6.172 11.828 2 10.414 3.414 16 9zM10 30H4a2.0021 2.0021 0 01-2-2V10A2.0021 2.0021 0 014 8h6a2.0021 2.0021 0 012 2V28A2.0021 2.0021 0 0110 30zM4 10V28h6V10z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Bc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),pd||(pd=i.createElement("path",{d:"M30,10V2H22V5H17a2.0023,2.0023,0,0,0-2,2v8H10V12H2v8h8V17h5v8a2.0023,2.0023,0,0,0,2,2h5v3h8V22H22v3H17V17h5v3h8V12H22v3H17V7h5v3ZM8,18H4V14H8Zm16,6h4v4H24Zm0-10h4v4H24ZM24,4h4V8H24Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Oc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),gd||(gd=i.createElement("path",{d:"M30,15H21.91A5.9925,5.9925,0,0,0,10.09,15H2v2h8.09A5.9925,5.9925,0,0,0,21.91,17H30ZM16,20a4,4,0,1,1,4-4A4.0045,4.0045,0,0,1,16,20Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Fc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ed||(Ed=i.createElement("path",{d:"M28 17H18a2.0025 2.0025 0 00-2 2v6a2.0025 2.0025 0 002 2h4V25H18V19H28v6H25.4648l-2.5937 3.8906L24.5352 30l2-3H28a2.0025 2.0025 0 002-2V19A2.0025 2.0025 0 0028 17zM8.6667 24.1086l.8614-.8615a.8334.8334 0 01.8988-.1844l1.0493.42A.8334.8334 0 0112 24.2561v1.9082a.8334.8334 0 01-.8786.8341c-7.3546-.4578-8.84-6.6863-9.1158-9.0723A.8316.8316 0 012.8343 17H4.7085a.8335.8335 0 01.7737.5238l.42 1.0493a.8332.8332 0 01-.1845.8988l-.8614.8614A4.5267 4.5267 0 008.6667 24.1086zM21 9H28V11H21zM21 5H30V7H21zM17 6L14 8.2V6a2.0024 2.0024 0 00-2-2H4A2.0024 2.0024 0 002 6v6a2.0024 2.0024 0 002 2h8a2.0024 2.0024 0 002-2V9.8L17 12zM4 12V6h8v6z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,qc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),wd||(wd=i.createElement("path",{d:"M28,6H18V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V24a2,2,0,0,0,2,2H14v2a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V8A2,2,0,0,0,28,6ZM4,15h6.17L7.59,17.59,9,19l5-5L9,9,7.59,10.41,10.17,13H4V4H16V24H4ZM16,28V26a2,2,0,0,0,2-2V8H28v9H21.83l2.58-2.59L23,13l-5,5,5,5,1.41-1.41L21.83,19H28v9Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Xc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),hd||(hd=i.createElement("path",{d:"M16,4A12,12,0,1,1,4,16,12,12,0,0,1,16,4m0-2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Z"})),xd||(xd=i.createElement("path",{d:"M23,10.41,21.59,9l-4.3,4.3a3,3,0,0,0-4,4L9,21.59,10.41,23l4.3-4.3a3,3,0,0,0,4-4ZM17,16a1,1,0,1,1-1-1A1,1,0,0,1,17,16Z"})),zd||(zd=i.createElement("circle",{cx:"16",cy:"7.5",r:"1.5"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Cc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ld||(Ld=i.createElement("path",{d:"M25.82,10H30V8H25.82a3,3,0,0,0-5.64,0H13V5H5V8H2v2H5v3h8V10h7.18A3,3,0,0,0,22,11.82v7.32A4,4,0,0,0,19.14,22H2v2H19.14a4,4,0,0,0,7.72,0H30V22H26.86A4,4,0,0,0,24,19.14V11.82A3,3,0,0,0,25.82,10ZM11,11H7V7h4ZM25,23a2,2,0,1,1-2-2A2,2,0,0,1,25,23Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Hc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Md||(Md=i.createElement("path",{d:"M20.8851,19.4711a5.9609,5.9609,0,0,0,0-6.9422L23,10.4141l1.293,1.2929a.9995.9995,0,0,0,1.414,0l4-4a.9994.9994,0,0,0,0-1.414l-4-4a.9994.9994,0,0,0-1.414,0l-4,4a.9994.9994,0,0,0,0,1.414L21.5859,9l-2.1148,2.1149a5.9609,5.9609,0,0,0-6.9422,0L10,8.5859V2H2v8H8.5859l2.529,2.5289a5.9609,5.9609,0,0,0,0,6.9422L9,21.5859,7.707,20.293a.9994.9994,0,0,0-1.414,0l-4,4a.9994.9994,0,0,0,0,1.414l4,4a.9995.9995,0,0,0,1.414,0l4-4a.9994.9994,0,0,0,0-1.414L10.4141,23l2.1148-2.1149a5.9609,5.9609,0,0,0,6.9422,0L22,23.4141V30h8V22H23.4141ZM25,4.4141,27.5859,7,25,9.5859,22.4141,7ZM7,27.5859,4.4141,25,7,22.4141,9.5859,25ZM8,8H4V4H8Zm4,8a4,4,0,1,1,4,4A4.0045,4.0045,0,0,1,12,16Zm12,8h4v4H24Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,kc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Rd||(Rd=i.createElement("path",{d:"M10.343 10.343H21.657V21.657H10.343z",transform:"rotate(-45 16 16)"})),Sd||(Sd=i.createElement("path",{d:"M29.3906,14.5269,17.4731,2.6094a2.0852,2.0852,0,0,0-2.9462,0L2.6094,14.5269a2.0852,2.0852,0,0,0,0,2.9462L14.5269,29.3906a2.0852,2.0852,0,0,0,2.9462,0L29.3906,17.4731a2.0852,2.0852,0,0,0,0-2.9462ZM16,28.0356,3.9646,16,16,3.9644,28.0356,16Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Nc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Dd||(Dd=i.createElement("path",{d:"M10.343 10.343H21.657V21.657H10.343z",transform:"rotate(-45 16 16)"})),yd||(yd=i.createElement("path",{d:"M16,4A12,12,0,1,1,4,16,12.0136,12.0136,0,0,1,16,4m0-2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Zc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Vd||(Vd=i.createElement("path",{d:"M23,16a7,7,0,0,0-4.18,1.39L14.6,13.17A6.86,6.86,0,0,0,16,9a7,7,0,1,0-2.81,5.59l4.21,4.22A7,7,0,1,0,23,16ZM4,9a5,5,0,1,1,5,5A5,5,0,0,1,4,9Z",transform:"translate(0 .01)"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Yc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ad||(Ad=i.createElement("path",{d:"M28,7H13.8281l3.586-3.5859L16,2,10,8l6,6,1.4141-1.4141L13.8281,9H28V20H11.8989A5.0145,5.0145,0,0,0,8,16.1011V2H6V16.1011a5,5,0,0,0,0,9.7978V30H8V25.8989A5.0145,5.0145,0,0,0,11.8989,22H28a2.0023,2.0023,0,0,0,2-2V9A2.0023,2.0023,0,0,0,28,7ZM7,24a3,3,0,1,1,3-3A3.0033,3.0033,0,0,1,7,24Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Pc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Td||(Td=i.createElement("path",{d:"M24,10l-1.4141,1.4141L26.1719,15H11.8989A5.0145,5.0145,0,0,0,8,11.1011V2H6v9.1011a5,5,0,0,0,0,9.7978V30H8V20.8989A5.0145,5.0145,0,0,0,11.8989,17h14.273l-3.586,3.5859L24,22l6-6ZM7,19a3,3,0,1,1,3-3A3.0033,3.0033,0,0,1,7,19Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,jc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Wd||(Wd=i.createElement("path",{d:"M28 2H30V30H28zM20 10l-1.4141 1.4141L22.1719 15H11.8989a5 5 0 100 2h10.273l-3.586 3.5859L20 22l6-6zM7 19a3 3 0 113-3A3.0033 3.0033 0 017 19z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Kc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ud||(Ud=i.createElement("path",{d:"M8 8H10V12H8zM8 14H10V18H8zM14 8H16V12H14zM14 14H16V18H14zM8 20H10V24H8zM14 20H16V24H14zM30 14L21.83 14 24.41 16.59 23 18 18 13 23 8 24.41 9.41 21.83 12 30 12 30 14z"})),Id||(Id=i.createElement("path",{d:"M28,20v8H22V20H20v8H4V4H20V6h2V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V30H30V20Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Gc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Bd||(Bd=i.createElement("path",{d:"M8 8H10V12H8zM8 14H10V18H8zM14 8H16V12H14zM14 14H16V18H14zM8 20H10V24H8zM14 20H16V24H14zM18 14L26.17 14 23.59 16.59 25 18 30 13 25 8 23.59 9.41 26.17 12 18 12 18 14z"})),Od||(Od=i.createElement("path",{d:"M28,20v8H22V20H20v8H4V4H20V6h2V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V30H30V20Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Qc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Fd||(Fd=i.createElement("path",{d:"M8 8H10V12H8zM8 14H10V18H8zM14 8H16V12H14zM14 14H16V18H14zM8 20H10V24H8zM14 20H16V24H14zM30 22L21.83 22 24.41 24.59 23 26 18 21 23 16 24.41 17.41 21.83 20 30 20 30 22zM19 12L27.17 12 24.59 14.59 26 16 31 11 26 6 24.59 7.41 27.17 10 19 10 19 12z"})),qd||(qd=i.createElement("path",{d:"M28,26v2H4V4H20V6h2V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V30H30V26Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Jc);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Xd||(Xd=i.createElement("path",{d:"M15 12H17V30H15zM11.33 18.22a7 7 0 010-10.44l1.34 1.49a5 5 0 000 7.46zM20.67 18.22l-1.34-1.49a5 5 0 000-7.46l1.34-1.49a7 7 0 010 10.44z"})),Cd||(Cd=i.createElement("path",{d:"M8.4 21.8a11 11 0 010-17.6L9.6 5.8a9 9 0 000 14.4zM23.6 21.8l-1.2-1.6a9 9 0 000-14.4l1.2-1.6a11 11 0 010 17.6z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,$c);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Hd||(Hd=i.createElement("path",{d:"M26,13a8.9089,8.9089,0,0,1-2.5249,6.2339l1.4133,1.4131A10.9795,10.9795,0,0,0,23.6006,4.2l-1.2012,1.6A8.932,8.932,0,0,1,26,13Z"})),kd||(kd=i.createElement("path",{d:"M21 13a5.0022 5.0022 0 01-.9023 2.8564l1.4277 1.4278a6.9831 6.9831 0 00-.8584-9.5015l-1.334 1.49A5.0077 5.0077 0 0121 13zM30 28.5859L3.4143 2 2 3.4141l3.71 3.71A10.9824 10.9824 0 008.3994 21.8008l1.2012-1.6A8.9678 8.9678 0 017.1714 8.5854l2.1963 2.1963a6.9664 6.9664 0 001.9648 7.4351l1.334-1.49A5.0072 5.0072 0 0111 13a4.8854 4.8854 0 01.0393-.5464L15 16.4141V30h2V18.4141L28.5857 30z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,eu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Nd||(Nd=i.createElement("path",{d:"M29.34 16.06a1.0007 1.0007 0 00-1.1084.3L24.46 20.8857l-5.4355-.9882-3.602-8.9512A3.014 3.014 0 0012.6138 9h-4.06A3.0018 3.0018 0 007.01 9.4277L2 12.4336v6.4009l5 .9092V30H9V20.1074l3.5652.648L14 24.2V30h2V23.8l-1.0911-2.6182L22.99 22.6509 18.2319 28.36A1 1 0 0019 30H29a1 1 0 001-1V17A1 1 0 0029.34 16.06zM4 17.1655V13.5664l3-1.8v5.9448zm5 .9092V11h3.6138a1.0141 1.0141 0 01.9453.6709l3.14 7.8037zM28 28H21.1353L28 19.7617zM12.5 8A3.5 3.5 0 1116 4.5 3.5042 3.5042 0 0112.5 8zm0-5A1.5 1.5 0 1014 4.5 1.5017 1.5017 0 0012.5 3z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,iu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Zd||(Zd=i.createElement("path",{d:"M17,13V6H8V22H24V13ZM10,8h5v5H10Zm0,7h5v5H10Zm12,5H17V15h5Z"})),Yd||(Yd=i.createElement("path",{d:"M28 11H19V2h9zM21 9h5V4H21zM28 20H26v2h2v6H4V22H6V20H4a2.0024 2.0024 0 00-2 2v6a2.0024 2.0024 0 002 2H28a2.0024 2.0024 0 002-2V22A2.0024 2.0024 0 0028 20z"})),Pd||(Pd=i.createElement("circle",{cx:"7",cy:"25",r:"1"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,tu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),jd||(jd=i.createElement("path",{d:"M27,22V17a2.0023,2.0023,0,0,0-2-2H17V10h3a2.0023,2.0023,0,0,0,2-2V4a2.0023,2.0023,0,0,0-2-2H12a2.0023,2.0023,0,0,0-2,2V8a2.0023,2.0023,0,0,0,2,2h3v5H7a2.0023,2.0023,0,0,0-2,2v5H2v8h8V22H7V17h8v5H12v8h8V22H17V17h8v5H22v8h8V22ZM12,4h8V8H12ZM8,28H4V24H8Zm10,0H14V24h4Zm10,0H24V24h4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,_u);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Kd||(Kd=i.createElement("path",{d:"M28,12H20V4h8Zm-6-2h4V6H22Z"})),Gd||(Gd=i.createElement("path",{d:"M17,15V9H9V23H23V15Zm-6-4h4v4H11Zm4,10H11V17h4Zm6,0H17V17h4Z"})),Qd||(Qd=i.createElement("path",{d:"M26,28H6a2.0023,2.0023,0,0,1-2-2V6A2.0023,2.0023,0,0,1,6,4H16V6H6V26H26V16h2V26A2.0023,2.0023,0,0,1,26,28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,su);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Jd||(Jd=i.createElement("circle",{cx:"21",cy:"21",r:"2"})),$d||($d=i.createElement("circle",{cx:"7",cy:"7",r:"2"})),eo||(eo=i.createElement("path",{d:"M27,31a4,4,0,1,1,4-4A4.0118,4.0118,0,0,1,27,31Zm0-6a2,2,0,1,0,2,2A2.0059,2.0059,0,0,0,27,25Z"})),io||(io=i.createElement("path",{d:"M30,16A14.0412,14.0412,0,0,0,16,2,13.0426,13.0426,0,0,0,9.2,3.8l1.1,1.7a24.4254,24.4254,0,0,1,2.4-1A25.1349,25.1349,0,0,0,10,15H4a11.1489,11.1489,0,0,1,1.4-4.7L3.9,9A13.8418,13.8418,0,0,0,2,16,13.9983,13.9983,0,0,0,16,30a13.3656,13.3656,0,0,0,5.2-1l-.6-1.9a11.4416,11.4416,0,0,1-5.2.9h0A21.0713,21.0713,0,0,1,12,17H29.9A3.4019,3.4019,0,0,0,30,16ZM12.8,27.6h0a13.02,13.02,0,0,1-5.3-3.1A12.5053,12.5053,0,0,1,4,17h6A25.0022,25.0022,0,0,0,12.8,27.6ZM12,15A21.4461,21.4461,0,0,1,15.3,4h1.4A21.4461,21.4461,0,0,1,20,15Zm10,0A23.2777,23.2777,0,0,0,19.2,4.4,12.0919,12.0919,0,0,1,27.9,15Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,au);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),to||(to=i.createElement("circle",{cx:"16",cy:"19",r:"2"})),_o||(_o=i.createElement("path",{d:"M23.7769,18.4785A8.64,8.64,0,0,0,16,13a8.64,8.64,0,0,0-7.7769,5.4785L8,19l.2231.5215A8.64,8.64,0,0,0,16,25a8.64,8.64,0,0,0,7.7769-5.4785L24,19ZM16,23a4,4,0,1,1,4-4A4.0045,4.0045,0,0,1,16,23Z"})),so||(so=i.createElement("path",{d:"M27,3H5A2,2,0,0,0,3,5V27a2,2,0,0,0,2,2H27a2,2,0,0,0,2-2V5A2,2,0,0,0,27,3ZM5,5H27V9H5ZM5,27V11H27V27Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,nu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ao||(ao=i.createElement("path",{d:"M10 28a1 1 0 01-1-1V5a1 1 0 011.501-.8652l19 11a1 1 0 010 1.73l-19 11A.9975.9975 0 0110 28zM11 6.7344V25.2656L27 16zM4 4H6V28H4z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ru);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),no||(no=i.createElement("path",{d:"M10 28a1 1 0 01-1-1V5a1 1 0 011.501-.8652l19 11a1 1 0 010 1.73l-19 11A.9975.9975 0 0110 28zM4 4H6V28H4z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,lu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ro||(ro=i.createElement("path",{d:"M7.7 4.7a14.7029 14.7029 0 00-3 3.1L6.3 9A13.2634 13.2634 0 018.9 6.3zM4.6 12.3l-1.9-.6A12.5111 12.5111 0 002 16H4A11.4756 11.4756 0 014.6 12.3zM11.7 2.7l.6 1.9A11.4756 11.4756 0 0116 4V2A12.5111 12.5111 0 0011.7 2.7zM24.2 27.3a15.18 15.18 0 003.1-3.1L25.7 23A11.526 11.526 0 0123 25.7zM27.4 19.7l1.9.6A15.4747 15.4747 0 0030 16H28A11.4756 11.4756 0 0127.4 19.7zM29.2 11.6a14.4029 14.4029 0 00-2-3.9L25.6 8.9a12.8867 12.8867 0 011.7 3.3zM24.1 4.6a14.4029 14.4029 0 00-3.9-2l-.6 1.9a12.8867 12.8867 0 013.3 1.7zM20.3 29.3l-.6-1.9A11.4756 11.4756 0 0116 28v2A21.4206 21.4206 0 0020.3 29.3zM15.4023 24.248a11.9488 11.9488 0 00-1.7182-3.3354L15.2974 19.73a13.9486 13.9486 0 012.0044 3.893zM11.02 18.2668a11.9215 11.9215 0 00-3.3467-1.6943l.6114-1.9043a13.9242 13.9242 0 013.9072 1.978z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,du);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),lo||(lo=i.createElement("path",{d:"M16 30V28A12.0021 12.0021 0 0019.6924 4.5786l.6152-1.9033A14.0022 14.0022 0 0116 30zM7.7 4.7a14.7029 14.7029 0 00-3 3.1L6.3 9A13.2634 13.2634 0 018.9 6.3zM4.6 12.3l-1.9-.6A12.5111 12.5111 0 002 16H4A11.4756 11.4756 0 014.6 12.3zM11.7 2.7l.6 1.9A11.4756 11.4756 0 0116 4V2A12.5111 12.5111 0 0011.7 2.7z"})),oo||(oo=i.createElement("path",{d:"M15.4023 24.248a11.9488 11.9488 0 00-1.7182-3.3354L15.2974 19.73a13.9486 13.9486 0 012.0044 3.893zM11.02 18.2668a11.9215 11.9215 0 00-3.3467-1.6943l.6114-1.9043a13.9242 13.9242 0 013.9072 1.978z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ou);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),mo||(mo=i.createElement("path",{d:"M7.7 4.7a14.7029 14.7029 0 00-3 3.1L6.3 9A13.2634 13.2634 0 018.9 6.3zM4.6 12.3l-1.9-.6A12.5111 12.5111 0 002 16H4A11.4756 11.4756 0 014.6 12.3zM2.7 20.4a14.4029 14.4029 0 002 3.9l1.6-1.2a12.8867 12.8867 0 01-1.7-3.3zM7.8 27.3a14.4029 14.4029 0 003.9 2l.6-1.9A12.8867 12.8867 0 019 25.7zM11.7 2.7l.6 1.9A11.4756 11.4756 0 0116 4V2A12.5111 12.5111 0 0011.7 2.7zM24.2 27.3a15.18 15.18 0 003.1-3.1L25.7 23A11.526 11.526 0 0123 25.7zM27.4 19.7l1.9.6A15.4747 15.4747 0 0030 16H28A11.4756 11.4756 0 0127.4 19.7zM29.2 11.6a14.4029 14.4029 0 00-2-3.9L25.6 8.9a12.8867 12.8867 0 011.7 3.3zM24.1 4.6a14.4029 14.4029 0 00-3.9-2l-.6 1.9a12.8867 12.8867 0 013.3 1.7zM20.3 29.3l-.6-1.9A11.4756 11.4756 0 0116 28v2A21.4206 21.4206 0 0020.3 29.3zM16 26A10 10 0 1126 16 10.0115 10.0115 0 0116 26zM16 8a8 8 0 108 8A8.0092 8.0092 0 0016 8z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,mu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),vo||(vo=i.createElement("path",{d:"M29.37,11.84a13.6,13.6,0,0,0-1.06-2.51A14.17,14.17,0,0,0,25.9,6.1a14,14,0,1,0,0,19.8,14.17,14.17,0,0,0,2.41-3.23,13.6,13.6,0,0,0,1.06-2.51,14,14,0,0,0,0-8.32ZM4,16A12,12,0,0,1,16,4V28A12,12,0,0,1,4,16Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,vu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),co||(co=i.createElement("path",{d:"M26.5 12H19a4 4 0 010-8h.0835A4.7864 4.7864 0 0123 2a4.9816 4.9816 0 014.6543 3.2034A3.4667 3.4667 0 0130 8.5 3.5041 3.5041 0 0126.5 12zM19 6a2 2 0 000 4h7.5A1.5017 1.5017 0 0028 8.5a1.4855 1.4855 0 00-1.2778-1.4739L26.061 6.927l-.1616-.6487a2.9568 2.9568 0 00-5.4873-.7121L20.1143 6zM23 14l-5 5 1.4141 1.4141L22 17.8325V24H16v2h6a2.0025 2.0025 0 002-2V17.8325l2.5874 2.583L28 19zM2 20H12V22H2zM2 24H12V26H2zM2 28H12V30H2z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,cu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),uo||(uo=i.createElement("circle",{cx:"10",cy:"21",r:"2"})),fo||(fo=i.createElement("circle",{cx:"23",cy:"20",r:"2"})),bo||(bo=i.createElement("circle",{cx:"13",cy:"10",r:"2"})),po||(po=i.createElement("circle",{cx:"14",cy:"15",r:"1"})),go||(go=i.createElement("circle",{cx:"23",cy:"5",r:"2"})),Eo||(Eo=i.createElement("circle",{cx:"29",cy:"3",r:"1"})),wo||(wo=i.createElement("circle",{cx:"16",cy:"23",r:"1"})),ho||(ho=i.createElement("path",{d:"M16,30C8.3,30,2,23.7,2,16S8.3,2,16,2c0.1,0,0.2,0,0.3,0l1.4,0.1l-0.3,1.2c-0.1,0.4-0.2,0.9-0.2,1.3c0,2.8,2.2,5,5,5 c1,0,2-0.3,2.9-0.9l1.3,1.5c-0.4,0.4-0.6,0.9-0.6,1.4c0,1.3,1.3,2.4,2.7,1.9l1.2-0.5l0.2,1.3C30,14.9,30,15.5,30,16 C30,23.7,23.7,30,16,30z M15.3,4C9,4.4,4,9.6,4,16c0,6.6,5.4,12,12,12s12-5.4,12-12c0-0.1,0-0.3,0-0.4c-2.3,0.1-4.2-1.7-4.2-4 c0-0.1,0-0.1,0-0.2c-0.5,0.1-1,0.2-1.6,0.2c-3.9,0-7-3.1-7-7C15.2,4.4,15.2,4.2,15.3,4z"})),_)})).propTypes=da;var Of=i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,uu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),xo||(xo=i.createElement("path",{d:"M28,10V28H10V10H28m0-2H10a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V10a2,2,0,0,0-2-2Z"})),zo||(zo=i.createElement("path",{d:"M4,18H2V4A2,2,0,0,1,4,2H18V4H4Z"})),_)}));Of.propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,fu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Lo||(Lo=i.createElement("path",{d:"M27.4,14.7l-6.1-6.1C21,8.2,20.5,8,20,8h-8c-1.1,0-2,0.9-2,2v18c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V16.1 C28,15.6,27.8,15.1,27.4,14.7z M20,10l5.9,6H20V10z M12,28V10h6v6c0,1.1,0.9,2,2,2h6l0,10H12z"})),Mo||(Mo=i.createElement("path",{d:"M6,18H4V4c0-1.1,0.9-2,2-2h14v2H6V18z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,bu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ro||(Ro=i.createElement("path",{d:"M11.9474,19a4.9476,4.9476,0,0,1-3.4991-8.4465l5.1053-5.1043a4.9482,4.9482,0,0,1,6.9981,6.9976l-.5523.5526-1.4158-1.4129.5577-.5579a2.95,2.95,0,0,0-.0039-4.1653,3.02,3.02,0,0,0-4.17,0l-5.1047,5.104a2.9474,2.9474,0,0,0,0,4.1692,3.02,3.02,0,0,0,4.17,0l1.4143,1.4145A4.9176,4.9176,0,0,1,11.9474,19Z"})),So||(So=i.createElement("path",{d:"M19.9474,17a4.9476,4.9476,0,0,1-3.4991-8.4465l.5526-.5526,1.4143,1.4146-.5526.5523a2.9476,2.9476,0,0,0,0,4.1689,3.02,3.02,0,0,0,4.17,0c.26-.26,4.7293-4.7293,5.1053-5.1045a2.951,2.951,0,0,0,0-4.1687,3.02,3.02,0,0,0-4.17,0L21.5536,3.449a4.9483,4.9483,0,0,1,6.9981,6.9978c-.3765.376-4.844,4.8428-5.1038,5.1035A4.9193,4.9193,0,0,1,19.9474,17Z"})),Do||(Do=i.createElement("path",{d:"M24,30H4a2.0021,2.0021,0,0,1-2-2V8A2.0021,2.0021,0,0,1,4,6H8V8H4V28H24V18h2V28A2.0021,2.0021,0,0,1,24,30Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,pu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),yo||(yo=i.createElement("path",{d:"M23,16c-.3374,0-.67.02-1,.0508V16C22,8.115,19.0435,2,16.5,2S11,8.115,11,16v5H6v3a6.0067,6.0067,0,0,0,6,6h3A11.0125,11.0125,0,0,0,26,19V16ZM13,16h2V14H13.0728a25.8942,25.8942,0,0,1,.5654-4H16V8H14.2c.81-2.4058,1.8149-3.7715,2.3-3.9863.66.2919,2.2842,2.7036,3.0654,6.9863H18v2h1.8442A29.1625,29.1625,0,0,1,20,16v.4263A11.0554,11.0554,0,0,0,13.79,21H13ZM12,28a4.0045,4.0045,0,0,1-4-4V23h4.7639A10.9033,10.9033,0,0,0,12,27Zm12-9a9.01,9.01,0,0,1-9,9H14V27a9.01,9.01,0,0,1,9-9h1Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,gu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Vo||(Vo=i.createElement("path",{d:"M28,9H14V6H6v8H9V28h2V14h3V11H28ZM12,12H8V8h4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Eu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ao||(Ao=i.createElement("circle",{cx:"15.5",cy:"11.5",r:"1.5"})),To||(To=i.createElement("circle",{cx:"20.5",cy:"15.5",r:"1.5"})),Wo||(Wo=i.createElement("circle",{cx:"16",cy:"16",r:"1"})),Uo||(Uo=i.createElement("circle",{cx:"16.5",cy:"20.5",r:"1.5"})),Io||(Io=i.createElement("circle",{cx:"11.5",cy:"16.5",r:"1.5"})),Bo||(Bo=i.createElement("path",{d:"M28,13v2H25.9492a9.9476,9.9476,0,0,0-2.2143-5.3213l1.4367-1.4365,1.4143,1.4145L28,8.2427,23.7578,4l-1.414,1.4141,1.414,1.414-1.437,1.4365A9.9464,9.9464,0,0,0,17,6.0508V4h2V2H13V4h2V6.0508A9.9464,9.9464,0,0,0,9.6792,8.2646L8.2422,6.8281l1.414-1.414L8.2422,4,4,8.2427l1.4141,1.414L6.8284,8.2422,8.2651,9.6787A9.9476,9.9476,0,0,0,6.0508,15H4V13H2v6H4V17H6.0508a9.9476,9.9476,0,0,0,2.2143,5.3213L6.8284,23.7578,5.4141,22.3433,4,23.7573,8.2422,28l1.414-1.4141-1.414-1.414,1.437-1.4365A9.9464,9.9464,0,0,0,15,25.9492V28H13v2h6V28H17V25.9492a9.9464,9.9464,0,0,0,5.3208-2.2138l1.437,1.4365-1.414,1.414L23.7578,28,28,23.7573l-1.4141-1.414-1.4143,1.4145-1.4367-1.4365A9.9476,9.9476,0,0,0,25.9492,17H28v2h2V13ZM16,24a8,8,0,1,1,8-8A8.0092,8.0092,0,0,1,16,24Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,wu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Oo||(Oo=i.createElement("path",{d:"M16,23a7,7,0,1,1,7-7A7.0078,7.0078,0,0,1,16,23Zm0-12a5,5,0,1,0,5,5A5.0057,5.0057,0,0,0,16,11Z"})),Fo||(Fo=i.createElement("path",{d:"M30,6.4141,28.5859,5l-3.35,3.35A12.0812,12.0812,0,0,0,23.65,6.7637L27,3.4141,25.5859,2,21.9766,5.6094A11.9792,11.9792,0,0,0,5.6094,21.9766L2,25.5859,3.4141,27l3.35-3.35A12.0812,12.0812,0,0,0,8.35,25.2363L5,28.5859,6.4141,30l3.6093-3.6094A11.9792,11.9792,0,0,0,26.3906,10.0234ZM16,26A10,10,0,1,1,26,16,10.0114,10.0114,0,0,1,16,26Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,hu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),qo||(qo=i.createElement("path",{d:"M10 13H22V15H10zM10 18H22V20H10z"})),Xo||(Xo=i.createElement("path",{d:"M30,6.4141,28.5859,5l-3.35,3.35A12.0812,12.0812,0,0,0,23.65,6.7637L27,3.4141,25.5859,2,21.9766,5.6094A11.9792,11.9792,0,0,0,5.6094,21.9766L2,25.5859,3.4141,27l3.35-3.35A12.0812,12.0812,0,0,0,8.35,25.2363L5,28.5859,6.4141,30l3.6093-3.6094A11.9792,11.9792,0,0,0,26.3906,10.0234ZM16,26A10,10,0,1,1,26,16,10.0114,10.0114,0,0,1,16,26Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,xu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Co||(Co=i.createElement("path",{d:"M26,30H24V27H20a5.0055,5.0055,0,0,1-5-5V20.7207l-2.3162-.772a1,1,0,0,1-.5412-1.4631L15,13.7229V11a9.01,9.01,0,0,1,9-9h5V4H24a7.0078,7.0078,0,0,0-7,7v3a.9991.9991,0,0,1-.1426.5144l-2.3586,3.9312,1.8174.6057A1,1,0,0,1,17,20v2a3.0033,3.0033,0,0,0,3,3h5a1,1,0,0,1,1,1Z"})),Ho||(Ho=i.createElement("circle",{cx:"9",cy:"23",r:"1"})),ko||(ko=i.createElement("circle",{cx:"6",cy:"20",r:"1"})),No||(No=i.createElement("circle",{cx:"6",cy:"26",r:"1"})),Zo||(Zo=i.createElement("circle",{cx:"3",cy:"17",r:"1"})),Yo||(Yo=i.createElement("circle",{cx:"3",cy:"29",r:"1"})),Po||(Po=i.createElement("circle",{cx:"3",cy:"23",r:"1"})),jo||(jo=i.createElement("path",{d:"M19 12H23V14H19z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,zu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ko||(Ko=i.createElement("path",{d:"M24,30H8a2.0023,2.0023,0,0,1-2-2V4A2.002,2.002,0,0,1,8,2H24a2.0023,2.0023,0,0,1,2,2V20.6182l-5-2.5-5,2.5V4H8V28H24V24h2v4A2.0027,2.0027,0,0,1,24,30ZM21,15.8818l3,1.5V4H18V17.3818Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Lu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Go||(Go=i.createElement("circle",{cx:"8",cy:"16",r:"2"})),Qo||(Qo=i.createElement("circle",{cx:"14",cy:"8",r:"2"})),Jo||(Jo=i.createElement("circle",{cx:"28",cy:"12",r:"2"})),$o||($o=i.createElement("circle",{cx:"21",cy:"18",r:"2"})),em||(em=i.createElement("path",{d:"M30,3.4141,28.5859,2,4,26.5859V2H2V28a2,2,0,0,0,2,2H30V28H5.4141ZM4,28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Mu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),im||(im=i.createElement("path",{d:"M16 22a4 4 0 10-4-4A4 4 0 0016 22zm0-6a2 2 0 11-2 2A2 2 0 0116 16zM14 6H18V8H14z"})),tm||(tm=i.createElement("path",{d:"M24,2H8A2.002,2.002,0,0,0,6,4V28a2.0023,2.0023,0,0,0,2,2H24a2.0027,2.0027,0,0,0,2-2V4A2.0023,2.0023,0,0,0,24,2ZM20,28H12V26a1,1,0,0,1,1-1h6a1,1,0,0,1,1,1Zm2,0V26a3,3,0,0,0-3-3H13a3,3,0,0,0-3,3v2H8V4H24V28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ru);return"glyph"===a||"glyph"===a||"glyphpx"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),_m||(_m=i.createElement("path",{d:"M12.887 11.4727a5.9936 5.9936 0 00-8.36-8.3594zM3.113 4.5273a5.9936 5.9936 0 008.36 8.3594z"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),sm||(sm=i.createElement("path",{d:"M12.887 11.4727a5.9936 5.9936 0 00-8.36-8.3594zM3.113 4.5273a5.9936 5.9936 0 008.36 8.3594z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Su);return"glyph"===a||"glyph"===a||"glyphpx"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),am||(am=i.createElement("path",{d:"M13 13L3 13 3 3 13 13z"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),nm||(nm=i.createElement("path",{d:"M13 13L3 13 3 3 13 13z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Du);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),rm||(rm=i.createElement("path",{d:"M25,20H23V9H12V7H23a2,2,0,0,1,2,2Z"})),lm||(lm=i.createElement("path",{d:"M9,23V2H7V7H2V9H7V23a2,2,0,0,0,2,2H23v5h2V25h5V23Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,yu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),dm||(dm=i.createElement("path",{d:"M26,13a4.0045,4.0045,0,0,0,4-4V6H27a3.979,3.979,0,0,0-2.7468,1.1064A6.0041,6.0041,0,0,0,19,4H16V7a6.0066,6.0066,0,0,0,6,6h1V26H11V21h1a4.0045,4.0045,0,0,0,4-4V14H13a3.979,3.979,0,0,0-2.7468,1.1064A6.0041,6.0041,0,0,0,5,12H2v3a6.0066,6.0066,0,0,0,6,6H9v5H2v2H30V26H25V13Zm-1-3a2.002,2.002,0,0,1,2-2h1V9a2.002,2.002,0,0,1-2,2H25ZM11,18a2.002,2.002,0,0,1,2-2h1v1a2.002,2.002,0,0,1-2,2H11ZM9,19H8a4.0045,4.0045,0,0,1-4-4V14H5a4.0045,4.0045,0,0,1,4,4Zm14-8H22a4.0045,4.0045,0,0,1-4-4V6h1a4.0045,4.0045,0,0,1,4,4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Vu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),om||(om=i.createElement("path",{d:"M2 28H10V30H2zM17 29a1 1 0 01-.7808-.3752L12.52 24H2V22H13a1 1 0 01.7808.3752l3.146 3.9322 5.2412-7.8621A1 1 0 0123.8 18.4L26.5 22H30v2H26a.9991.9991 0 01-.8-.4l-2.1523-2.8694-5.2159 7.824a.9986.9986 0 01-.7885.4443zM11 16V11h1a4.0045 4.0045 0 004-4V4H13a3.9779 3.9779 0 00-2.7468 1.1067A6.0034 6.0034 0 005 2H2V5a6.0066 6.0066 0 006 6H9v5H2v2H16V16zM13 6h1V7a2.002 2.002 0 01-2 2H11V8A2.002 2.002 0 0113 6zM8 9A4.0045 4.0045 0 014 5V4H5A4.0045 4.0045 0 019 8V9z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Au);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),mm||(mm=i.createElement("path",{d:"M11 24H15V26H11zM5 24H9V26H5zM23 24H27V26H23zM17 24H21V26H17zM9 22a4.92 4.92 0 014-2h6a5.22 5.22 0 014 2h2.3A6.87 6.87 0 0019 18H13a6.87 6.87 0 00-6.3 4zM24 28H26V30H24zM6 28H8V30H6zM16 16a7 7 0 117-7A7 7 0 0116 16zM16 4a5 5 0 00-5 5A5 5 0 0021 9 5 5 0 0016 4z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Tu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),vm||(vm=i.createElement("path",{d:"M28,2H10A2.0023,2.0023,0,0,0,8,4V7H4A2.0023,2.0023,0,0,0,2,9V28a2.0023,2.0023,0,0,0,2,2H28a2.0023,2.0023,0,0,0,2-2V4A2.0023,2.0023,0,0,0,28,2ZM10,4H28V7H10ZM28,14H20V9h8ZM10,21V16h8v5Zm8,2v5H10V23ZM8,21H4V16H8ZM18,9v5H10V9Zm2,7h8v5H20ZM8,9v5H4V9ZM4,23H8v5H4Zm16,5V23h8v5Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Wu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),cm||(cm=i.createElement("path",{d:"M26.5859,6.5859A1.9862,1.9862,0,0,0,25.1719,6H17V2H15V12H6.8281a1.9862,1.9862,0,0,0-1.414.5859L2,16l3.4141,3.4141A1.9862,1.9862,0,0,0,6.8281,20H15V30h2V14h8.1719a1.9862,1.9862,0,0,0,1.414-.5859L30,10ZM6.8281,18l-2-2,2-2H15v4Zm18.3438-6H17V8h8.1719l2,2Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Uu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),um||(um=i.createElement("path",{d:"M16.832,19.5547l-1.664-1.1094L17.4648,15H20V10H12v5h2v2H12a2.0021,2.0021,0,0,1-2-2V10a2.0021,2.0021,0,0,1,2-2h8a2.0021,2.0021,0,0,1,2,2v5a2.0021,2.0021,0,0,1-2,2H18.5352Z"})),fm||(fm=i.createElement("path",{d:"M16,30,7.5645,20.0513c-.0479-.0571-.3482-.4515-.3482-.4515A10.8888,10.8888,0,0,1,5,13a11,11,0,0,1,22,0,10.8844,10.8844,0,0,1-2.2148,6.5973l-.0015.0025s-.3.3944-.3447.4474ZM8.8125,18.395c.001.0007.2334.3082.2866.3744L16,26.9079l6.91-8.15c.0439-.0552.2783-.3649.2788-.3657A8.901,8.901,0,0,0,25,13,9,9,0,0,0,7,13a8.9054,8.9054,0,0,0,1.8125,5.395Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Iu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),bm||(bm=i.createElement("path",{fill:"none",d:"M16.832,19.5547l-1.664-1.1094L17.4648,15H20V10H12v5h2v2H12a2.0021,2.0021,0,0,1-2-2V10a2.0021,2.0021,0,0,1,2-2h8a2.0021,2.0021,0,0,1,2,2v5a2.0021,2.0021,0,0,1-2,2H18.5352Z"})),pm||(pm=i.createElement("path",{d:"M16,2A11.0134,11.0134,0,0,0,5,13a10.8885,10.8885,0,0,0,2.2163,6.6s.3.3945.3482.4517L16,30l8.439-9.9526c.0444-.0533.3447-.4478.3447-.4478l.0015-.0024A10.8846,10.8846,0,0,0,27,13,11.0134,11.0134,0,0,0,16,2Zm6,13a2.0023,2.0023,0,0,1-2,2H18.5352L16.832,19.5547l-1.664-1.1094L17.4648,15H20V10H12v5h2v2H12a2.0023,2.0023,0,0,1-2-2V10a2.0023,2.0023,0,0,1,2-2h8a2.0023,2.0023,0,0,1,2,2Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Bu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),gm||(gm=i.createElement("path",{d:"M28 9L26 22 24 9 22 9 24.516 23 27.484 23 30 9 28 9zM18 23H12V21h6V17H14a2.002 2.002 0 01-2-2V11a2.002 2.002 0 012-2h6v2H14v4h4a2.002 2.002 0 012 2v4A2.002 2.002 0 0118 23zM10 23H4a2.0023 2.0023 0 01-2-2V11A2.002 2.002 0 014 9h6v2H4V21h6z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ou);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Em||(Em=i.createElement("path",{d:"M10 23H5a2 2 0 01-2-2V15a2 2 0 012-2h5v2H5v6h5zM18 23H14a2 2 0 01-2-2V9h2V21h4V9h2V21A2 2 0 0118 23zM27 21L27 9.01 22 9.01 22 11.01 25 11.01 25 21 22 21 22 23 30 23 30 21 27 21z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Fu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),wm||(wm=i.createElement("path",{d:"M10 23H5a2 2 0 01-2-2V15a2 2 0 012-2h5v2H5v6h5zM18 23H14a2 2 0 01-2-2V9h2V21h4V9h2V21A2 2 0 0118 23zM28 9H22v2h6v4H23v2h5v4H22v2h6a2 2 0 002-2V11A2 2 0 0028 9z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,qu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),hm||(hm=i.createElement("path",{d:"M28.5039,8.1362l-12-7a1,1,0,0,0-1.0078,0l-12,7A1,1,0,0,0,3,9V23a1,1,0,0,0,.4961.8638l12,7a1,1,0,0,0,1.0078,0l12-7A1,1,0,0,0,29,23V9A1,1,0,0,0,28.5039,8.1362ZM16,3.1577,26.0156,9,16,14.8423,5.9844,9ZM5,10.7412l10,5.833V28.2588L5,22.4258ZM17,28.2588V16.5742l10-5.833V22.4258Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Xu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),xm||(xm=i.createElement("circle",{cx:"16",cy:"16",r:"2"})),zm||(zm=i.createElement("path",{d:"M23.7769,15.4785A8.64,8.64,0,0,0,16,10a8.64,8.64,0,0,0-7.7769,5.4785L8,16l.2231.5215A8.64,8.64,0,0,0,16,22a8.64,8.64,0,0,0,7.7769-5.4785L24,16ZM16,20a4,4,0,1,1,4-4A4.0045,4.0045,0,0,1,16,20Z"})),Lm||(Lm=i.createElement("path",{d:"M28.5039,8.1362l-12-7a1,1,0,0,0-1.0078,0l-12,7A1,1,0,0,0,3,9V23a1,1,0,0,0,.4961.8638l12,7a1,1,0,0,0,1.0078,0l12-7A1,1,0,0,0,29,23V9A1,1,0,0,0,28.5039,8.1362ZM27,22.4258,16,28.8423,5,22.4258V9.5742L16,3.1577,27,9.5742Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Cu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Mm||(Mm=i.createElement("path",{d:"M21,12V10H17V7H15v3H13a2.002,2.002,0,0,0-2,2v3a2.002,2.002,0,0,0,2,2h6v3H11v2h4v3h2V22h2a2.0023,2.0023,0,0,0,2-2V17a2.002,2.002,0,0,0-2-2H13V12Z"})),Rm||(Rm=i.createElement("path",{d:"M16,4A12,12,0,1,1,4,16,12.0353,12.0353,0,0,1,16,4m0-2A14,14,0,1,0,30,16,14.0412,14.0412,0,0,0,16,2Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Hu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Sm||(Sm=i.createElement("path",{d:"M21.4023,15.6426A4.9727,4.9727,0,0,0,23,12V11a5.0059,5.0059,0,0,0-5-5H17V3H15V6H10V26h5v3h2V26h2a5.0059,5.0059,0,0,0,5-5V20A4.9834,4.9834,0,0,0,21.4023,15.6426ZM12,8h6a3.0033,3.0033,0,0,1,3,3v1a3.0033,3.0033,0,0,1-3,3H12ZM22,21a3.0033,3.0033,0,0,1-3,3H12V17h7a3.0033,3.0033,0,0,1,3,3Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ku);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Dm||(Dm=i.createElement("path",{d:"M23,20.5151c0-4.6152-3.78-5.1411-6.8171-5.563-3.31-.4609-5.1829-.86-5.1829-3.71C11,8.8491,13.5071,8,15.6538,8a6.7538,6.7538,0,0,1,5.5681,2.6279l1.5562-1.2558A8.6508,8.6508,0,0,0,17,6.0962V3H15V6.022c-3.6152.2192-6,2.26-6,5.22,0,4.73,3.83,5.2627,6.9075,5.69C19.16,17.3848,21,17.7744,21,20.5151,21,23.5474,17.8674,24,16,24c-3.4294,0-4.8782-.9639-6.2219-2.6279L8.2219,22.6279A8.4382,8.4382,0,0,0,15,25.9648V29h2V25.9551C20.7256,25.6509,23,23.6279,23,20.5151Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Nu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ym||(ym=i.createElement("path",{d:"M17,26c-3.6162,0-6.3328-2.2974-7.4456-6H19V18H9.1321A15.2782,15.2782,0,0,1,9,16c0-.33.01-.6641.0259-1H19V13H9.2371C9.8447,9.3525,11.81,6,17,6c3.8533,0,5.5315,1.6465,7.1282,4.4893l1.7436-.9786C24.2649,6.6484,22.0779,4,17,4,10.6448,4,7,8.374,7,16c0,7.0654,4.1121,12,10,12,5.0779,0,7.2649-2.6484,8.8718-5.5107l-1.7436-.9786C22.5315,24.3535,20.8533,26,17,26Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Zu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Vm||(Vm=i.createElement("path",{d:"M23,19a6.0066,6.0066,0,0,1-6,6H13V18.1079L21.2139,15V13L13,16.1079v-3L21.2139,10V8L13,11.1079V5H11v6.8647L8,13v2l3-1.1353v3L8,18v2l3-1.1353V27h6a8.0092,8.0092,0,0,0,8-8Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Yu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Am||(Am=i.createElement("path",{d:"M12.4531,25A8.7775,8.7775,0,0,0,14,20a10.6,10.6,0,0,0-.18-2H22V16H13.2175c-.0842-.2109-.17-.4194-.2556-.624A9.8586,9.8586,0,0,1,12,11a4.792,4.792,0,0,1,5-5,6.1234,6.1234,0,0,1,5.2222,2.6279l1.5556-1.2558A8.11,8.11,0,0,0,17,4a6.7781,6.7781,0,0,0-7,7,11.65,11.65,0,0,0,1.0559,5H8v2h3.7729A8.209,8.209,0,0,1,12,20c0,2.5234-1.4858,5-3,5v2H24V25Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Pu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Tm||(Tm=i.createElement("path",{d:"M19,4H10V15H7v2h3v3H7v2h3v6h2V22h9V20H12V17h7a6.0067,6.0067,0,0,0,6-6V10A6.0067,6.0067,0,0,0,19,4Zm4,7a4.0045,4.0045,0,0,1-4,4H12V6h7a4.0045,4.0045,0,0,1,4,4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ju);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Wm||(Wm=i.createElement("path",{d:"M24,7V5H8V7h5.5a4.4906,4.4906,0,0,1,4.45,4H8v2h9.95A4.4906,4.4906,0,0,1,13.5,17H8v2.3452L17.6169,28l1.3379-1.4863L10.606,19H13.5a6.5041,6.5041,0,0,0,6.4746-6H24V11H19.9746A6.4719,6.4719,0,0,0,18.18,7Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ku);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Um||(Um=i.createElement("path",{d:"M9,27H7V5h8a5.0057,5.0057,0,0,1,5,5V22H18V10a3.0033,3.0033,0,0,0-3-3H9Z"})),Im||(Im=i.createElement("path",{d:"M20,27H12V10h2V25h6a3.0033,3.0033,0,0,0,3-3V5h2V22A5.0057,5.0057,0,0,1,20,27Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Gu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Bm||(Bm=i.createElement("path",{d:"M28 14L28 12 23.045 12 24 5 22 5 20 23 17 8 15 8 12 23 10 5 8 5 8.955 12 4 12 4 14 9.227 14 9.636 17 4 17 4 19 9.909 19 11 27 13 27 16 12 19 27 21 27 22.091 19 28 19 28 17 22.364 17 22.773 14 28 14z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Qu);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Om||(Om=i.createElement("path",{d:"M24.271 5L22 5 16 16 10 5 7.729 5 13.794 16 8 16 8 18 15 18 15 21 8 21 8 23 15 23 15 27 17 27 17 23 24 23 24 21 17 21 17 18 24 18 24 16 18.206 16 24.271 5z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ju);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Fm||(Fm=i.createElement("path",{d:"M23,28a1,1,0,0,1-.71-.29l-6.13-6.14-3.33,5a1,1,0,0,1-1,.44,1,1,0,0,1-.81-.7l-6-20A1,1,0,0,1,6.29,5l20,6a1,1,0,0,1,.7.81,1,1,0,0,1-.44,1l-5,3.33,6.14,6.13a1,1,0,0,1,0,1.42l-4,4A1,1,0,0,1,23,28Zm0-2.41L25.59,23l-7.16-7.15,5.25-3.5L7.49,7.49l4.86,16.19,3.5-5.25Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,$u);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),qm||(qm=i.createElement("path",{d:"M27.34,12.06l-22-8A1,1,0,0,0,4.06,5.34l8,22A1,1,0,0,0,13,28h0a1,1,0,0,0,.93-.63l3.84-9.6,9.6-3.84a1,1,0,0,0,0-1.87Zm-10.71,4h0l-.4.16-.16.4h0L13,24.2,6.67,6.67,24.2,13Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ef);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Xm||(Xm=i.createElement("path",{d:"M26.5,19.63,20.24,16l6.26-3.63a5,5,0,0,0-1.21-9.2A5.19,5.19,0,0,0,24,3a5,5,0,0,0-4.33,7.53,5,5,0,0,0,2.39,2.1l-3.82,2.21L4,6.6,3,8.34,16.24,16,3,23.68l1,1.74,14.24-8.26,3.82,2.21a5,5,0,0,0-2.39,2.1A5,5,0,0,0,24,29a5.19,5.19,0,0,0,1.29-.17,5,5,0,0,0,1.21-9.2ZM21.4,9.53a3,3,0,0,1,1.1-4.12,3,3,0,0,1,4.1,1.11,3,3,0,0,1-1.1,4.11h0A3,3,0,0,1,21.4,9.53Zm5.2,16a3,3,0,0,1-4.1,1.11,3,3,0,0,1-1.1-4.12,3,3,0,0,1,4.1-1.1h0A3,3,0,0,1,26.6,25.48Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,tf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Cm||(Cm=i.createElement("path",{d:"M28,4H4A2.0023,2.0023,0,0,0,2,6V26a2.0023,2.0023,0,0,0,2,2H28a2.0023,2.0023,0,0,0,2-2V6A2.0023,2.0023,0,0,0,28,4ZM4,6H16V26H4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,_f);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Hm||(Hm=i.createElement("path",{d:"M19.05 13.7326L18.05 12 7.928 17.8457 6.9312 17.27a2.9524 2.9524 0 00.6672-.769A3 3 0 103.5 17.5986l2.428 1.4019L3.5 20.4023a3.0342 3.0342 0 103.4407.3223l.987-.5693L14.5914 24l1-1.7294-5.6634-3.27zM4.0344 15.26a1 1 0 11.4658.6069A.9929.9929 0 014.0344 15.26zM4.9988 22a1 1 0 11-.8645 1.5A1 1 0 014.9988 22zM17 26H21V28H17zM10 26H14V28H10z"})),km||(km=i.createElement("path",{d:"M28,28H24V26h4V4H7V8H5V4A2.0023,2.0023,0,0,1,7,2H28a2.0023,2.0023,0,0,1,2,2V26A2.0023,2.0023,0,0,1,28,28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,sf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Nm||(Nm=i.createElement("path",{d:"M15 23H10a2 2 0 01-2-2V15a2 2 0 012-2h5v2H10v6h5zM24 9L22 9 20 16 18 9 16 9 19 18 19 23 21 23 21 18 24 9z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,af);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Zm||(Zm=i.createElement("path",{d:"M25 30a6 6 0 116-6A6.0069 6.0069 0 0125 30zm0-10a4 4 0 104 4A4.0045 4.0045 0 0025 20zM7 30a6 6 0 116-6A6.0069 6.0069 0 017 30zM7 20a4 4 0 104 4A4.0045 4.0045 0 007 20z"})),Ym||(Ym=i.createElement("path",{d:"M17 27H15V20.4139L9.5849 15a2.003 2.003 0 010-2.8292l4.5859-4.5859a2.0024 2.0024 0 012.8286 0L21.414 12H27v1.9993L20.5853 14l-5-5L11 13.5849l6 6zM21.5 8A3.5 3.5 0 1125 4.5 3.5042 3.5042 0 0121.5 8zm0-5A1.5 1.5 0 1023 4.5 1.5017 1.5017 0 0021.5 3z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,nf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Pm||(Pm=i.createElement("path",{d:"M14 23H9a2 2 0 01-2-2V15a2 2 0 012-2h5v2H9v6h5zM24 9L16 9 16 11 22 11 16 21 16 23 24 23 24 21 18 21 24 11 24 9z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,rf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),jm||(jm=i.createElement("path",{d:"M24 21H26V26H24zM20 16H22V26H20zM11 26a5.0059 5.0059 0 01-5-5H8a3 3 0 103-3V16a5 5 0 010 10z"})),Km||(Km=i.createElement("path",{d:"M28,2H4A2.002,2.002,0,0,0,2,4V28a2.0023,2.0023,0,0,0,2,2H28a2.0027,2.0027,0,0,0,2-2V4A2.0023,2.0023,0,0,0,28,2Zm0,9H14V4H28ZM12,4v7H4V4ZM4,28V13H28.0007l.0013,15Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,lf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Gm||(Gm=i.createElement("path",{d:"M4 20L4 22 8.586 22 2 28.586 3.414 30 10 23.414 10 28 12 28 12 20 4 20zM24 21H26V26H24zM20 16H22V26H20zM16 18H18V26H16z"})),Qm||(Qm=i.createElement("path",{d:"M28,2H4A2.002,2.002,0,0,0,2,4V16H4V13H28.001l.001,15H16v2H28a2.0027,2.0027,0,0,0,2-2V4A2.0023,2.0023,0,0,0,28,2ZM12,11H4V4h8Zm2,0V4H28l.0007,7Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,df);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Jm||(Jm=i.createElement("path",{d:"M15 6H28V8H15zM15 24H28V26H15zM4 15H17V17H4zM7 11a4 4 0 114-4A4 4 0 017 11zM7 5A2 2 0 109 7 2 2 0 007 5zM7 29a4 4 0 114-4A4 4 0 017 29zm0-6a2 2 0 102 2A2 2 0 007 23zM25 20a4 4 0 114-4A4 4 0 0125 20zm0-6a2 2 0 102 2A2 2 0 0025 14z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,of);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),$m||($m=i.createElement("path",{d:"M4 6H15V8H4zM18 6H28V8H18zM21 12H28V14H21zM11 12H18V14H11zM4 12H8V14H4zM4 18H28V20H4zM4 24H21V26H4zM24 24H28V26H24z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,mf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ev||(ev=i.createElement("path",{d:"M24,3H8A2,2,0,0,0,6,5V27a2,2,0,0,0,2,2H24a2,2,0,0,0,2-2V5A2,2,0,0,0,24,3Zm0,2v6H8V5ZM8,19V13H24v6Zm0,8V21H24v6Z"})),iv||(iv=i.createElement("circle",{cx:"11",cy:"8",r:"1"})),tv||(tv=i.createElement("circle",{cx:"11",cy:"16",r:"1"})),_v||(_v=i.createElement("circle",{cx:"11",cy:"24",r:"1"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,vf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),sv||(sv=i.createElement("path",{d:"M7 8H12V10H7zM7 12H12V14H7zM7 16H12V18H7zM20 8H25V10H20zM20 12H25V14H20zM20 16H25V18H20z"})),av||(av=i.createElement("path",{d:"M28,4H4A2.0023,2.0023,0,0,0,2,6V28a2.0023,2.0023,0,0,0,2,2H28a2.0023,2.0023,0,0,0,2-2V6A2.0023,2.0023,0,0,0,28,4ZM4,6H15V28H4ZM17,28V6H28V28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,cf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),nv||(nv=i.createElement("path",{d:"M28,10H23V6a2.0023,2.0023,0,0,0-2-2H11A2.0023,2.0023,0,0,0,9,6v4H4a2.0023,2.0023,0,0,0-2,2V28a2.0023,2.0023,0,0,0,2,2H28a2.0023,2.0023,0,0,0,2-2V12A2.0023,2.0023,0,0,0,28,10ZM4,28V12H9v2H7v2H9v2H7v2H9v2H7v2H9v4Zm17,0H11V6H21Zm7,0H23V24h2V22H23V20h2V18H23V16h2V14H23V12h5Z"})),rv||(rv=i.createElement("path",{d:"M14 8H18V10H14zM14 12H18V14H14zM14 16H18V18H14z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,uf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),lv||(lv=i.createElement("path",{d:"M23 27.18L20.41 24.59 19 26 23 30 30 23 28.59 21.59 23 27.18z"})),dv||(dv=i.createElement("circle",{cx:"11",cy:"8",r:"1"})),ov||(ov=i.createElement("circle",{cx:"11",cy:"16",r:"1"})),mv||(mv=i.createElement("circle",{cx:"11",cy:"24",r:"1"})),vv||(vv=i.createElement("path",{d:"M24,3H8A2,2,0,0,0,6,5V27a2,2,0,0,0,2,2h8V27H8V21H26V5A2,2,0,0,0,24,3Zm0,16H8V13H24Zm0-8H8V5H24Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ff);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),cv||(cv=i.createElement("path",{d:"M30 30L24 30 24 28 28 28 28 4 24 4 24 2 30 2 30 30z"})),uv||(uv=i.createElement("path",{d:"M24.91,19.59a4.51,4.51,0,0,0-2.66-3.24,4.55,4.55,0,0,0-3.5,0,4.94,4.94,0,0,0-.64.35L15.3,13.89a4.53,4.53,0,1,0-1.41,1.41l2.81,2.81a4.48,4.48,0,0,0-.61,3.3,4.51,4.51,0,0,0,2.66,3.24,4.55,4.55,0,0,0,3.5,0,4.51,4.51,0,0,0,2.66-3.24,4.65,4.65,0,0,0,0-1.82ZM11.5,14A2.5,2.5,0,1,1,14,11.5,2.5,2.5,0,0,1,11.5,14Z"})),fv||(fv=i.createElement("path",{d:"M8 30L2 30 2 2 8 2 8 4 4 4 4 28 8 28 8 30z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,bf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),bv||(bv=i.createElement("circle",{cx:"11",cy:"8",r:"1"})),pv||(pv=i.createElement("circle",{cx:"11",cy:"16",r:"1"})),gv||(gv=i.createElement("circle",{cx:"11",cy:"24",r:"1"})),Ev||(Ev=i.createElement("path",{d:"M24,3H8A2,2,0,0,0,6,5V27a2,2,0,0,0,2,2H18V27H8V21H26V5A2,2,0,0,0,24,3Zm0,16H8V13H24Zm0-8H8V5H24Z"})),wv||(wv=i.createElement("path",{d:"M29 24.415L27.586 23 25 25.587 22.414 23 21 24.415 23.586 27 21 29.586 22.414 31 25 28.414 27.586 31 29 29.586 26.414 27 29 24.415z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,pf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),hv||(hv=i.createElement("path",{d:"M18 11H26V13H18zM6 19H14V21H6zM10 16a4 4 0 114-4A4.0045 4.0045 0 0110 16zm0-6a2 2 0 102 2A2.002 2.002 0 0010 10zM22 24a4 4 0 114-4A4.0045 4.0045 0 0122 24zm0-6a2 2 0 102 2A2.002 2.002 0 0022 18z"})),xv||(xv=i.createElement("path",{d:"M28,30H4a2.0021,2.0021,0,0,1-2-2V4A2.0021,2.0021,0,0,1,4,2H28a2.0021,2.0021,0,0,1,2,2V28A2.0021,2.0021,0,0,1,28,30ZM4,4V28H28V4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,gf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),zv||(zv=i.createElement("path",{d:"M25 13L25 4 23 4 23 6 20 6 20 8 23 8 23 13 20 13 20 15 28 15 28 13 25 13zM8.5 6A3.5 3.5 0 115 9.5 3.504 3.504 0 018.5 6m0-2A5.5 5.5 0 1014 9.5 5.5 5.5 0 008.5 4zM23.5 20A3.5 3.5 0 1120 23.5 3.504 3.504 0 0123.5 20m0-2A5.5 5.5 0 1029 23.5 5.5 5.5 0 0023.5 18zM6 19L6 21 9.586 21 4 26.586 5.414 28 11 22.414 11 26 13 26 13 19 6 19z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ef);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Lv||(Lv=i.createElement("path",{d:"M25 13L25 4 23 4 23 6 20 6 20 8 23 8 23 13 20 13 20 15 28 15 28 13 25 13zM8.5 6A3.5 3.5 0 115 9.5 3.5 3.5 0 018.5 6m0-2A5.5 5.5 0 1014 9.5 5.5 5.5 0 008.5 4zM8.5 20A3.5 3.5 0 115 23.5 3.5 3.5 0 018.5 20m0-2A5.5 5.5 0 1014 23.5 5.5 5.5 0 008.5 18zM23.5 20A3.5 3.5 0 1120 23.5 3.5 3.5 0 0123.5 20m0-2A5.5 5.5 0 1029 23.5 5.5 5.5 0 0023.5 18z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,wf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Mv||(Mv=i.createElement("circle",{cx:"9",cy:"7",r:"1"})),Rv||(Rv=i.createElement("path",{d:"M27,22.14V18a2,2,0,0,0-2-2H17V12h9a2,2,0,0,0,2-2V4a2,2,0,0,0-2-2H6A2,2,0,0,0,4,4v6a2,2,0,0,0,2,2h9v4H7a2,2,0,0,0-2,2v4.14a4,4,0,1,0,2,0V18h8v4H12v8h8V22H17V18h8v4.14a4,4,0,1,0,2,0ZM8,26a2,2,0,1,1-2-2A2,2,0,0,1,8,26Zm10-2v4H14V24ZM6,10V4H26v6ZM26,28a2,2,0,1,1,2-2A2,2,0,0,1,26,28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,hf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Sv||(Sv=i.createElement("path",{d:"M6 24a2 2 0 11-2 2 2 2 0 012-2m0-2a4 4 0 104 4A4 4 0 006 22zM16 4a2 2 0 11-2 2 2 2 0 012-2m0-2a4 4 0 104 4A4 4 0 0016 2zM26 4a2 2 0 11-2 2 2 2 0 012-2m0-2a4 4 0 104 4A4 4 0 0026 2zM18 24v4H14V24h4m2-2H12v8h8z"})),Dv||(Dv=i.createElement("path",{d:"M27,22.14V17a2,2,0,0,0-2-2H7V10h3V2H2v8H5v5a2,2,0,0,0,2,2H25v5.14a4,4,0,1,0,2,0ZM4,4H8V8H4ZM26,28a2,2,0,1,1,2-2A2,2,0,0,1,26,28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,xf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),yv||(yv=i.createElement("circle",{cx:"22",cy:"24",r:"2"})),Vv||(Vv=i.createElement("path",{d:"M29.7769,23.4785A8.64,8.64,0,0,0,22,18a8.64,8.64,0,0,0-7.7769,5.4785L14,24l.2231.5215A8.64,8.64,0,0,0,22,30a8.64,8.64,0,0,0,7.7769-5.4785L30,24ZM22,28a4,4,0,1,1,4-4A4.0045,4.0045,0,0,1,22,28Z"})),Av||(Av=i.createElement("circle",{cx:"8",cy:"8",r:"1"})),Tv||(Tv=i.createElement("circle",{cx:"8",cy:"16",r:"1"})),Wv||(Wv=i.createElement("circle",{cx:"8",cy:"24",r:"1"})),Uv||(Uv=i.createElement("path",{d:"M5,21h7V19H5V13H21v3h2V5a2,2,0,0,0-2-2H5A2,2,0,0,0,3,5V27a2,2,0,0,0,2,2h7V27H5ZM5,5H21v6H5Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,zf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Iv||(Iv=i.createElement("circle",{cx:"22",cy:"24",r:"2"})),Bv||(Bv=i.createElement("path",{d:"M29.7769 23.4785A8.64 8.64 0 0022 18a8.64 8.64 0 00-7.7769 5.4785L14 24l.2231.5215A8.64 8.64 0 0022 30a8.64 8.64 0 007.7769-5.4785L30 24zM22 28a4 4 0 114-4A4.0045 4.0045 0 0122 28zM7 17H12V19H7zM7 12H19V14H7zM7 7H19V9H7z"})),Ov||(Ov=i.createElement("path",{d:"M22,2,4,2A2.0058,2.0058,0,0,0,2,4V28a2.0058,2.0058,0,0,0,2,2h8V28H4V4H22V15h2V4A2.0058,2.0058,0,0,0,22,2Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Lf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Fv||(Fv=i.createElement("path",{d:"M28,20H26v2h2v6H4V22H6V20H4a2.0024,2.0024,0,0,0-2,2v6a2.0024,2.0024,0,0,0,2,2H28a2.0024,2.0024,0,0,0,2-2V22A2.0024,2.0024,0,0,0,28,20Z"})),qv||(qv=i.createElement("circle",{cx:"7",cy:"25",r:"1"})),Xv||(Xv=i.createElement("path",{d:"M21,13a2.9609,2.9609,0,0,0-1.2854.3008L17.4141,11l2.3-2.3008A2.9609,2.9609,0,0,0,21,9a3,3,0,1,0-3-3,2.9665,2.9665,0,0,0,.3,1.2852L16,9.5859,13.7,7.2852A2.9665,2.9665,0,0,0,14,6a3,3,0,1,0-3,3,2.9609,2.9609,0,0,0,1.2854-.3008L14.5859,11l-2.3005,2.3008A2.9609,2.9609,0,0,0,11,13a3,3,0,1,0,3,3,2.9665,2.9665,0,0,0-.3-1.2852L16,12.4141l2.3,2.3007A2.9665,2.9665,0,0,0,18,16a3,3,0,1,0,3-3Zm0-8a1,1,0,1,1-1,1A1.0009,1.0009,0,0,1,21,5ZM10,6a1,1,0,1,1,1,1A1.0009,1.0009,0,0,1,10,6Zm1,11a1,1,0,1,1,1-1A1.0009,1.0009,0,0,1,11,17Zm10,0a1,1,0,1,1,1-1A1.0009,1.0009,0,0,1,21,17Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Mf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Cv||(Cv=i.createElement("circle",{cx:"7",cy:"7",r:"1"})),Hv||(Hv=i.createElement("circle",{cx:"7",cy:"15",r:"1"})),kv||(kv=i.createElement("circle",{cx:"7",cy:"23",r:"1"})),Nv||(Nv=i.createElement("path",{d:"M12,26H4V20h8V18H4V12H22V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V26a2,2,0,0,0,2,2h8ZM4,4H20v6H4Z"})),Zv||(Zv=i.createElement("path",{d:"M28,17v2.4131A6.996,6.996,0,1,0,22,30V28a5,5,0,1,1,4.5762-7H24v2h6V17Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Rf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Yv||(Yv=i.createElement("path",{d:"M28 2H20a2.0023 2.0023 0 00-2 2V28a2.0023 2.0023 0 002 2h8a2.0023 2.0023 0 002-2V4A2.0023 2.0023 0 0028 2zm0 2v7H20V4zm0 9v6H20V13zM20 28V21h8v7zM12 15L10 15 10 13 8 13 8 15 6 15 6 17 8 17 8 19 10 19 10 17 12 17 12 15z"})),Pv||(Pv=i.createElement("path",{d:"M16,6V4H10A2.0023,2.0023,0,0,0,8,6V9.08A6.99,6.99,0,0,0,8,22.92V26a2.0023,2.0023,0,0,0,2,2h6V26H10V22.92A6.99,6.99,0,0,0,10,9.08V6ZM14,16a5,5,0,1,1-5-5A5.0059,5.0059,0,0,1,14,16Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Sf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),jv||(jv=i.createElement("path",{d:"M28,30H4a2.0021,2.0021,0,0,1-2-2V4A2.0021,2.0021,0,0,1,4,2H28a2.0021,2.0021,0,0,1,2,2V28A2.0021,2.0021,0,0,1,28,30ZM4,4V28H28V4Z"})),Kv||(Kv=i.createElement("path",{d:"M13 7H15V14H13zM8 7H10V14H8zM22 14H20a2.0021 2.0021 0 01-2-2V9a2.0021 2.0021 0 012-2h2a2.0021 2.0021 0 012 2v3A2.0021 2.0021 0 0122 14zM20 9v3h2V9zM22 18H24V25H22zM8 18H10V25H8zM17 25H15a2.0021 2.0021 0 01-2-2V20a2.0021 2.0021 0 012-2h2a2.0021 2.0021 0 012 2v3A2.0021 2.0021 0 0117 25zm-2-5v3h2V20z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Df);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Gv||(Gv=i.createElement("path",{d:"M26,16a3.9612,3.9612,0,0,0-2.02.5657l-2.8586-2.8585,2.293-2.293a2,2,0,0,0,0-2.8284l-6-6a2,2,0,0,0-2.8284,0l-6,6a2,2,0,0,0,0,2.8284l2.293,2.293L8.02,16.5657A4.043,4.043,0,1,0,9.4343,17.98l2.8585-2.8586,2.293,2.293A1.9773,1.9773,0,0,0,15,17.7233V22H12v8h8V22H17V17.7233a1.9773,1.9773,0,0,0,.4142-.3091l2.293-2.293L22.5657,17.98A3.9885,3.9885,0,1,0,26,16ZM8,20a2,2,0,1,1-2-2A2.0023,2.0023,0,0,1,8,20Zm10,4v4H14V24h4Zm-2-8-6-6,6-6,6,6Zm10,6a2,2,0,1,1,2-2A2.0023,2.0023,0,0,1,26,22Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,yf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Qv||(Qv=i.createElement("circle",{cx:"16",cy:"16",r:"2"})),Jv||(Jv=i.createElement("path",{d:"M30 17L30 15 23.83 15 26.41 12.41 25 11 20 16 25 21 26.41 19.59 23.83 17 30 17zM15 23.83L15 30 17 30 17 23.83 19.59 26.41 21 25 16 20 11 25 12.41 26.41 15 23.83zM7 11L5.59 12.41 8.17 15 2 15 2 17 8.17 17 5.59 19.59 7 21 12 16 7 11zM17 8.17L17 2 15 2 15 8.17 12.41 5.59 11 7 16 12 21 7 19.59 5.59 17 8.17z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Vf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),$v||($v=i.createElement("circle",{cx:"14",cy:"14",r:"2"})),ec||(ec=i.createElement("path",{d:"M20,30a.9967.9967,0,0,1-.707-.293L8.5859,19A2.0126,2.0126,0,0,1,8,17.5859V10a2.002,2.002,0,0,1,2-2h7.5859A1.9864,1.9864,0,0,1,19,8.5859L29.707,19.293a.9994.9994,0,0,1,0,1.414l-9,9A.9967.9967,0,0,1,20,30ZM10,10v7.5859l10,10L27.5859,20l-10-10Z"})),ic||(ic=i.createElement("path",{d:"M12,30H4a2.0021,2.0021,0,0,1-2-2V4A2.0021,2.0021,0,0,1,4,2H28a2.0021,2.0021,0,0,1,2,2v8H28V4H4V28h8Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Af);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),tc||(tc=i.createElement("path",{d:"M30,15H27V7H25v8H22V7H20v7.8262L7.5239,7.1484A1,1,0,0,0,6,8v7H2v2H6v7a1,1,0,0,0,1.5239.8516L20,17.1738V25h2V17h3v8h2V17h3ZM8,22.21V9.79L18.0918,16Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Tf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),_c||(_c=i.createElement("path",{d:"M28 13H30V15H28z"})),sc||(sc=i.createElement("path",{d:"M24.2 3.8H26.2V5.8H24.2z",transform:"rotate(-45.001 25.192 4.808)"})),ac||(ac=i.createElement("path",{d:"M15 0H17V2H15z"})),nc||(nc=i.createElement("path",{d:"M5.8 3.8H7.8V5.8H5.8z",transform:"rotate(-134.999 6.808 4.808)"})),rc||(rc=i.createElement("path",{d:"M2 13H4V15H2zM20 13L17 13 17 10 15 10 15 13 12 13 12 15 15 15 15 18 17 18 17 15 20 15zM13 30H19V32H13zM11 26H21V28H11z"})),lc||(lc=i.createElement("path",{d:"M16,4C10.5,4,6,8.5,6,14c0,4.4,2,6.3,3.5,7.6c1,0.9,1.5,1.5,1.5,2.4h2c0-1.8-1.1-2.9-2.2-3.9C9.4,18.9,8,17.5,8,14 c0-4.4,3.6-8,8-8s8,3.6,8,8c0,3.5-1.4,4.9-2.8,6.1c-1.1,1-2.2,2-2.2,3.9h2c0-0.9,0.5-1.5,1.5-2.4C24,20.3,26,18.4,26,14 C26,8.5,21.5,4,16,4z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Wf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),dc||(dc=i.createElement("path",{d:"M28 24v2H15.8164a2.983 2.983 0 00-5.6328 0H4V24H2v6H4V28h6.1836a2.983 2.983 0 005.6328 0H28v2h2V24zM13 7.5L13 16.499 13 16.499 21 12 13 7.5z"})),oc||(oc=i.createElement("path",{d:"M16,22A10,10,0,1,1,26,12,10.0113,10.0113,0,0,1,16,22ZM16,4a8,8,0,1,0,8,8A8.0092,8.0092,0,0,0,16,4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Uf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),mc||(mc=i.createElement("path",{d:"M7,30a5,5,0,1,1,5-5A5.0059,5.0059,0,0,1,7,30Zm0-8a3,3,0,1,0,3,3A3.0033,3.0033,0,0,0,7,22Z"})),vc||(vc=i.createElement("path",{d:"M24,26H14V24H24V17H8a2.0021,2.0021,0,0,1-2-2V8A2.0021,2.0021,0,0,1,8,6H18V8H8v7H24a2.0021,2.0021,0,0,1,2,2v7A2.0021,2.0021,0,0,1,24,26Z"})),cc||(cc=i.createElement("path",{d:"M28,12H22a2.0023,2.0023,0,0,1-2-2V4a2.0023,2.0023,0,0,1,2-2h6a2.0023,2.0023,0,0,1,2,2v6A2.0023,2.0023,0,0,1,28,12ZM22,4v6h6V4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,If);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),uc||(uc=i.createElement("path",{d:"M4 20L4 22 8.586 22 2 28.586 3.414 30 10 23.414 10 28 12 28 12 20 4 20zM28 12H22a2.0023 2.0023 0 01-2-2V4a2.0023 2.0023 0 012-2h6a2.0023 2.0023 0 012 2v6A2.0023 2.0023 0 0128 12zM22 4v6h6V4z"})),fc||(fc=i.createElement("path",{d:"M24,26H16V24h8V17H8a2.0021,2.0021,0,0,1-2-2V8A2.0021,2.0021,0,0,1,8,6H18V8H8v7H24a2.0021,2.0021,0,0,1,2,2v7A2.0021,2.0021,0,0,1,24,26Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Bf);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),bc||(bc=i.createElement("path",{d:"M5 25V15.8281l-3.5859 3.586L0 18l6-6 6 6-1.4141 1.4141L7 15.8281V25H19v2H7A2.0024 2.0024 0 015 25zM24 22h4a2.002 2.002 0 012 2v4a2.002 2.002 0 01-2 2H24a2.002 2.002 0 01-2-2V24A2.002 2.002 0 0124 22zm4 6V24H23.9985L24 28zM27 6v9.1719l3.5859-3.586L32 13l-6 6-6-6 1.4141-1.4141L25 15.1719V6H13V4H25A2.0024 2.0024 0 0127 6zM2 6H8V8H2zM2 2H10V4H2z"})),_)})).propTypes=da;var Ff=["iconDescription","className"];function qf(e){var t=e.iconDescription,_=e.className,s=B(e,Ff),a=Z();return i.createElement(gc,T({className:k()(_,"".concat(a,"--copy-btn")),"aria-label":t,title:t},s),i.createElement(Of,{className:"".concat(a,"--snippet__icon")}))}qf.propTypes={className:P().string,feedback:P().string,feedbackTimeout:P().number,iconDescription:P().string,onClick:P().func},qf.defaultProps={iconDescription:"Copy to clipboard",feedback:"Copied!",feedbackTimeout:2e3,onClick:function(){}};var Xf=0;var Cf,Hf,kf,Nf,Zf,Yf,Pf,jf,Kf,Gf,Qf,Jf,$f,eb,ib,tb,_b,sb,ab,nb,rb,lb,db,ob,mb,vb,cb,ub,fb,bb,pb,gb,Eb,wb,hb,xb,zb,Lb,Mb,Rb,Sb,Db,yb,Vb,Ab,Tb,Wb,Ub,Ib,Bb,Ob,Fb,qb,Xb,Cb,Hb,kb,Nb,Zb,Yb,Pb,jb,Kb,Gb,Qb,Jb,$b,ep,ip,tp,_p,sp,ap,np,rp,lp,dp,op,mp,vp,cp,up,fp,bp,pp,gp,Ep,wp,hp,xp,zp,Lp,Mp,Rp,Sp,Dp,yp,Vp,Ap,Tp,Wp,Up,Ip,Bp,Op,Fp,qp,Xp,Cp,Hp,kp,Np,Zp,Yp,Pp,jp,Kp,Gp,Qp,Jp,$p,eg,ig,tg,_g,sg,ag,ng,rg,lg,dg,og,mg,vg,cg,ug,fg,bg,pg,gg,Eg,wg,hg,xg,zg,Lg,Mg,Rg,Sg,Dg,yg,Vg,Ag,Tg,Wg,Ug,Ig,Bg,Og,Fg,qg,Xg,Cg,Hg,kg,Ng,Zg,Yg,Pg,jg,Kg,Gg,Qg,Jg,$g,eE,iE,tE,_E,sE,aE,nE,rE,lE,dE,oE,mE,vE,cE,uE,fE,bE,pE,gE,EE,wE,hE,xE,zE,LE,ME,RE,SE,DE,yE,VE,AE,TE,WE,UE,IE,BE,OE,FE,qE=t(998),XE=t.n(qE),CE=["className","type","children","disabled","feedback","feedbackTimeout","onClick","ariaLabel","copyText","copyButtonDescription","light","showMoreText","showLessText","hideCopyButton","wrapText","maxCollapsedNumberOfRows","maxExpandedNumberOfRows","minCollapsedNumberOfRows","minExpandedNumberOfRows"],HE=16;function kE(e){var t,_=e.className,s=e.type,a=e.children,n=e.disabled,r=e.feedback,l=e.feedbackTimeout,d=e.onClick,o=e.ariaLabel,m=e.copyText,v=e.copyButtonDescription,c=e.light,u=e.showMoreText,f=e.showLessText,b=e.hideCopyButton,p=e.wrapText,g=e.maxCollapsedNumberOfRows,E=void 0===g?15:g,w=e.maxExpandedNumberOfRows,h=void 0===w?0:w,x=e.minCollapsedNumberOfRows,z=void 0===x?3:x,L=e.minExpandedNumberOfRows,M=void 0===L?16:L,R=B(e,CE),S=q((0,i.useState)(!1),2),D=S[0],y=S[1],V=q((0,i.useState)(!1),2),W=V[0],U=V[1],I=(0,i.useRef)(function(){return Xf++,"".concat(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"id").concat(Xf)}()),O=I.current,F=(0,i.useRef)(),X=(0,i.useRef)(),C=(0,i.useRef)(),H=q((0,i.useState)(!1),2),N=H[0],Y=H[1],P=q((0,i.useState)(!1),2),j=P[0],K=P[1],G=(0,i.useCallback)((function(){return"single"===s?X:"multi"===s?F:void 0}),[s]),Q=Z(),J=(0,i.useCallback)((function(){var e=G().current,i=e.clientWidth,t=e.scrollLeft,_=e.scrollWidth;return{horizontalOverflow:_>i,codeClientWidth:i,codeScrollWidth:_,codeScrollLeft:t}}),[G]),$=(0,i.useCallback)((function(){if("inline"!==s&&("single"!==s||null!==X&&void 0!==X&&X.current)&&("multi"!==s||null!==F&&void 0!==F&&F.current)){var e=J(),i=e.horizontalOverflow,t=e.codeClientWidth,_=e.codeScrollWidth,a=e.codeScrollLeft;Y(i&&!!a),K(i&&a+t!==_)}}),[s,J]);hl({ref:G(),onResize:function(){if(null!==F&&void 0!==F&&F.current&&"multi"===s){var e=F.current.getBoundingClientRect().height;U(E>0&&(h<=0||h>E)&&e>E*HE),D&&M>0&&e<=M*HE&&y(!1)}(null!==F&&void 0!==F&&F.current&&"multi"===s||null!==X&&void 0!==X&&X.current&&"single"===s)&&$()}},[s,E,h,M,HE]),(0,i.useEffect)((function(){$()}),[$]);var ee=function(e){var i;(m||null!==C&&void 0!==C&&C.current)&&XE()(null!==m&&void 0!==m?m:null===C||void 0===C||null===(i=C.current)||void 0===i?void 0:i.innerText);d&&d(e)},ie=k()(_,"".concat(Q,"--snippet"),(A(t={},"".concat(Q,"--snippet--").concat(s),s),A(t,"".concat(Q,"--snippet--disabled"),"inline"!==s&&n),A(t,"".concat(Q,"--snippet--expand"),D),A(t,"".concat(Q,"--snippet--light"),c),A(t,"".concat(Q,"--snippet--no-copy"),b),A(t,"".concat(Q,"--snippet--wraptext"),p),t)),te=D?f:u;if("inline"===s)return b?i.createElement("span",{className:ie},i.createElement("code",{id:O,ref:C},a)):i.createElement(gc,T({},R,{onClick:ee,"aria-label":o,"aria-describedby":O,className:ie,feedback:r,feedbackTimeout:l}),i.createElement("code",{id:O,ref:C},a));var _e={};if("multi"===s){var se={};D?(h>0&&(se.maxHeight=h*HE),M>0&&(se.minHeight=M*HE)):(E>0&&(se.maxHeight=E*HE),z>0&&(se.minHeight=z*HE)),Object.keys(se).length&&(_e.style=se)}return i.createElement("div",T({},R,{className:ie}),i.createElement("div",T({ref:X,role:"single"===s?"textbox":null,tabIndex:"single"!==s||n?null:0,className:"".concat(Q,"--snippet-container"),"aria-label":o||"code-snippet",onScroll:"single"===s&&$||null},_e),i.createElement("pre",{ref:F,onScroll:"multi"===s&&$||null},i.createElement("code",{ref:C},a))),N&&i.createElement("div",{className:"".concat(Q,"--snippet__overflow-indicator--left")}),j&&i.createElement("div",{className:"".concat(Q,"--snippet__overflow-indicator--right")}),!b&&i.createElement(qf,{disabled:n,onClick:ee,feedback:r,feedbackTimeout:l,iconDescription:v}),W&&i.createElement(Sl,{kind:"ghost",size:"field",className:"".concat(Q,"--snippet-btn--expand"),disabled:n,onClick:function(){return y(!D)}},i.createElement("span",{className:"".concat(Q,"--snippet-btn--text")},te),i.createElement(Dr,{"aria-label":te,className:"".concat(Q,"--icon-chevron--down ").concat(Q,"--snippet__icon"),name:"chevron--down",role:"img"})))}kE.propTypes={ariaLabel:P().string,children:P().node,className:P().string,copyButtonDescription:P().string,copyText:P().string,disabled:P().bool,feedback:P().string,feedbackTimeout:P().number,hideCopyButton:P().bool,light:P().bool,maxCollapsedNumberOfRows:P().number,maxExpandedNumberOfRows:P().number,minCollapsedNumberOfRows:P().number,minExpandedNumberOfRows:P().number,onClick:P().func,showLessText:P().string,showMoreText:P().string,type:P().oneOf(["single","inline","multi"]),wrapText:P().bool},kE.defaultProps={ariaLabel:"Copy to clipboard",type:"single",showMoreText:"Show more",showLessText:"Show less",wrapText:!1};var NE=["children","size"],ZE=["children","size"],YE=["children","size"],PE=["children","size"],jE=["children","size"],KE=["children","size"],GE=["children","size"],QE=["children","size"],JE=["children","size"],$E=["children","size"],ew=["children","size"],iw=["children","size"],tw=["children","size"],_w=["children","size"],sw=["children","size"],aw=["children","size"],nw=["children","size"],rw=["children","size"],lw=["children","size"],dw=["children","size"],ow=["children","size"],mw=["children","size"],vw=["children","size"],cw=["children","size"],uw=["children","size"],fw=["children","size"],bw=["children","size"],pw=["children","size"],gw=["children","size"],Ew=["children","size"],ww=["children","size"],hw=["children","size"],xw=["children","size"],zw=["children","size"],Lw=["children","size"],Mw=["children","size"],Rw=["children","size"],Sw=["children","size"],Dw=["children","size"],yw=["children","size"],Vw=["children","size"],Aw=["children","size"],Tw=["children","size"],Ww=["children","size"],Uw=["children","size"],Iw=["children","size"],Bw=["children","size"],Ow=["children","size"],Fw=["children","size"],qw=["children","size"],Xw=["children","size"],Cw=["children","size"],Hw=["children","size"],kw=["children","size"],Nw=["children","size"],Zw=["children","size"],Yw=["children","size"],Pw=["children","size"],jw=["children","size"],Kw=["children","size"],Gw=["children","size"],Qw=["children","size"],Jw=["children","size"],$w=["children","size"],eh=["children","size"],ih=["children","size"],th=["children","size"],_h=["children","size"],sh=["children","size"],ah=["children","size"],nh=["children","size"],rh=["children","size"],lh=["children","size"],dh=["children","size"],oh=["children","size"],mh=["children","size"],vh=["children","size"],ch=["children","size"],uh=["children","size"],fh=["children","size"],bh=["children","size"],ph=["children","size"],gh=["children","size"],Eh=["children","size"],wh=["children","size"],hh=["children","size"],xh=["children","size"],zh=["children","size"],Lh=["children","size"],Mh=["children","size"],Rh=["children","size"],Sh=["children","size"],Dh=["children","size"],yh=["children","size"],Vh=["children","size"],Ah=["children","size"],Th=["children","size"],Wh=["children","size"],Uh=["children","size"],Ih=["children","size"],Bh=["children","size"],Oh=["children","size"],Fh=["children","size"],qh=["children","size"],Xh=["children","size"],Ch=["children","size"],Hh=["children","size"],kh=["children","size"],Nh=["children","size"],Zh=["children","size"],Yh=["children","size"],Ph=["children","size"],jh=["children","size"],Kh=["children","size"],Gh=["children","size"],Qh=["children","size"],Jh=["children","size"],$h=["children","size"],ex=["children","size"],ix=["children","size"],tx=["children","size"],_x=["children","size"],sx=["children","size"],ax=["children","size"],nx=["children","size"];i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,NE);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Cf||(Cf=i.createElement("path",{d:"M16 31H14v-.228a3.0135 3.0135 0 00-1.9468-2.8091L8.5215 26.6384A3.9034 3.9034 0 016 23H8a1.8946 1.8946 0 001.2236 1.7659L12.7554 26.09A5.0226 5.0226 0 0116 30.772zM30 31H28v-.228a3.0135 3.0135 0 00-1.9468-2.8091l-3.5317-1.3245A3.9034 3.9034 0 0120 23h2a1.8946 1.8946 0 001.2236 1.7659L26.7554 26.09A5.0226 5.0226 0 0130 30.772zM11 13H17V15H11z"})),Hf||(Hf=i.createElement("path",{d:"M23.4409,8,22.1687,3.45A2.009,2.009,0,0,0,20.2456,2H7.7544A2.0089,2.0089,0,0,0,5.8313,3.4507L4.5315,8H2v2H4v7a2.0025,2.0025,0,0,0,2,2v2H8V19H20v2h2V19a2.0025,2.0025,0,0,0,2-2V10h2V8ZM7.7544,4H20.2458l1.4285,5H6.3257ZM22,13H20v2h2v2H6V15H8V13H6V11H22Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ZE);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),kf||(kf=i.createElement("path",{d:"M12 30H4a2.0023 2.0023 0 01-2-2V24a2.0023 2.0023 0 012-2h8a2.0023 2.0023 0 012 2v4A2.0023 2.0023 0 0112 30zM4 24v4h8V24zM28 20H12a2.0023 2.0023 0 01-2-2V14a2.0023 2.0023 0 012-2H28a2.0023 2.0023 0 012 2v4A2.0023 2.0023 0 0128 20zM12 14v4H28V14zM16 10H4A2.0023 2.0023 0 012 8V4A2.0023 2.0023 0 014 2H16a2.0023 2.0023 0 012 2V8A2.0023 2.0023 0 0116 10zM4 4V8H16V4z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,YE);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Nf||(Nf=i.createElement("path",{d:"M6.34 19H17.65V21H6.34z",transform:"rotate(-45 11.995 20.002)"})),Zf||(Zf=i.createElement("path",{d:"M17,30a1,1,0,0,1-.37-.07,1,1,0,0,1-.62-.79l-1-7,2-.28.75,5.27L21,24.52V17a1,1,0,0,1,.29-.71l4.07-4.07A8.94,8.94,0,0,0,28,5.86V4H26.14a8.94,8.94,0,0,0-6.36,2.64l-4.07,4.07A1,1,0,0,1,15,11H7.48L4.87,14.26l5.27.75-.28,2-7-1a1,1,0,0,1-.79-.62,1,1,0,0,1,.15-1l4-5A1,1,0,0,1,7,9h7.59l3.77-3.78A10.92,10.92,0,0,1,26.14,2H28a2,2,0,0,1,2,2V5.86a10.92,10.92,0,0,1-3.22,7.78L23,17.41V25a1,1,0,0,1-.38.78l-5,4A1,1,0,0,1,17,30Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,PE);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Yf||(Yf=i.createElement("path",{d:"M17.91 26.82l.35 2a12.9 12.9 0 004.24-1.54l-1-1.73A10.88 10.88 0 0117.91 26.82zM24.42 23.07L26 24.35a13 13 0 002.24-3.91l-1.87-.68A11 11 0 0124.42 23.07zM9.5 27.25a12.9 12.9 0 004.24 1.54l.35-2a10.88 10.88 0 01-3.59-1.3zM5.67 19.76l-1.87.68A13 13 0 006 24.35l.32-.26 1.22-1h0a11 11 0 01-1.91-3.31zM29 16a12.85 12.85 0 00-.8-4.44l-1.87.68A11.18 11.18 0 0127 16zM26 7.65a13 13 0 00-20 0V4H4v8h8V10H6.81A11 11 0 0124.42 8.93z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,jE);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Pf||(Pf=i.createElement("path",{d:"M14.0913 26.8235l-.3467 1.968a12.8956 12.8956 0 01-4.24-1.5418l1-1.7307A10.9086 10.9086 0 0014.0913 26.8235zM7.5767 23.0682L6.0449 24.3533a12.9811 12.9811 0 01-2.25-3.9112l1.8775-.6834A10.9808 10.9808 0 007.5767 23.0682zM22.4951 27.25a12.8956 12.8956 0 01-4.24 1.5418l-.3467-1.968a10.9086 10.9086 0 003.5869-1.3045zM26.3271 19.7587l1.8775.6834a12.9811 12.9811 0 01-2.2495 3.9112l-.3115-.2614-1.22-1.0237h0a10.9822 10.9822 0 001.9038-3.3093zM13.6616 5.2559c-.1592.0346-.3144.08-.4712.1215-.2131.0562-.4258.1138-.6335.1822-.1643.0547-.325.1167-.4859.1782-.1926.0742-.3835.1509-.57.2349-.1611.0727-.3193.15-.4763.23q-.2677.1363-.5262.2867c-.153.0893-.3046.18-.4531.2758-.1679.1089-.3308.2242-.4922.3413-.1406.1026-.2817.2037-.417.3125-.1616.1294-.3156.2676-.47.4063-.1225.11-.2478.2168-.3652.332-.1668.1636-.3223.3379-.4785.5117A10.9438 10.9438 0 005 16H3A12.9363 12.9363 0 016.05 7.65l-.0047-.0039c.0918-.1094.197-.2061.2925-.3125.1841-.2051.3672-.41.5635-.603.1382-.1358.2856-.2613.43-.3907.1831-.1645.3657-.3286.5581-.4824.1592-.1279.3244-.2466.4895-.3667.1921-.14.3855-.2768.5854-.4062.1743-.1128.3523-.2188.5322-.3238q.3081-.1786.6253-.3408c.1846-.0942.37-.1846.56-.27.2224-.1.449-.1914.678-.2793.1894-.0723.3777-.1455.5713-.209.2463-.0815.498-.1494.7507-.2163.1848-.0493.3674-.1025.5554-.1431.29-.0634.5865-.1074.8833-.1508.159-.023.3145-.0552.4754-.0728A12.9331 12.9331 0 0126 7.7031V4h2v8H20V10h5.1885A10.961 10.961 0 0016 5a11.1114 11.1114 0 00-1.189.0669c-.1362.0146-.268.042-.4026.0615C14.1575 5.165 13.907 5.2026 13.6616 5.2559z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,KE);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),jf||(jf=i.createElement("path",{d:"M25.95,7.65l.0047-.0039c-.0918-.1094-.197-.2061-.2925-.3125-.1841-.2051-.3672-.41-.5635-.603-.1382-.1358-.2856-.2613-.43-.3907-.1831-.1645-.3657-.3286-.5581-.4824-.1592-.1279-.3244-.2466-.4895-.3667-.1921-.14-.3855-.2768-.5854-.4062-.1743-.1128-.3523-.2188-.5322-.3238q-.3081-.1786-.6253-.3408c-.1846-.0942-.37-.1846-.56-.27-.2224-.1-.449-.1914-.678-.2793-.1894-.0723-.3777-.1455-.5713-.209-.2463-.0815-.498-.1494-.7507-.2163-.1848-.0493-.3674-.1025-.5554-.1431-.29-.0634-.5865-.1074-.8833-.1508-.159-.023-.3145-.0552-.4754-.0728A12.9331,12.9331,0,0,0,6,7.7031V4H4v8h8V10H6.8115A10.961,10.961,0,0,1,16,5a11.1114,11.1114,0,0,1,1.189.0669c.1362.0146.268.042.4026.0615.2509.0366.5014.0742.7468.1275.1592.0346.3144.08.4712.1215.2131.0562.4258.1138.6335.1822.1643.0547.325.1167.4859.1782.1926.0742.3835.1509.5705.2349.1611.0727.3193.15.4763.23q.2677.1363.5262.2867c.153.0893.3046.18.4531.2758.1679.1089.3308.2242.4922.3413.1406.1026.2817.2037.417.3125.1616.1294.3156.2676.47.4063.1225.11.2478.2168.3652.332.1668.1636.3223.3379.4785.5117A10.9928,10.9928,0,1,1,5,16H3A13,13,0,1,0,25.95,7.65Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,GE);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Kf||(Kf=i.createElement("path",{d:"M28 30H16a2.0023 2.0023 0 01-2-2V16a2.0023 2.0023 0 012-2H28a2.0023 2.0023 0 012 2V28A2.0023 2.0023 0 0128 30zM16 16V28H28.0012L28 16zM15 2L13.59 3.41 16.17 6H11a7.0078 7.0078 0 00-7 7v5H6V13a5.0057 5.0057 0 015-5h5.17l-2.58 2.59L15 12l5-5z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,QE);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Gf||(Gf=i.createElement("path",{d:"M16 30H4a2.0023 2.0023 0 01-2-2V16a2.0023 2.0023 0 012-2H16a2.0023 2.0023 0 012 2V28A2.0023 2.0023 0 0116 30zM4 16V28H16.0012L16 16zM30 15l-1.41-1.41L26 16.17V11a7.0078 7.0078 0 00-7-7H14V6h5a5.0057 5.0057 0 015 5v5.17l-2.59-2.58L20 15l5 5z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,JE);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Qf||(Qf=i.createElement("path",{d:"M16 30H4a2.0023 2.0023 0 01-2-2V16a2.0023 2.0023 0 012-2H16a2.0023 2.0023 0 012 2V28A2.0023 2.0023 0 0116 30zM30 15l-1.41-1.41L26 16.17V11a7.0078 7.0078 0 00-7-7H14V6h5a5.0057 5.0057 0 015 5v5.17l-2.59-2.58L20 15l5 5z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,$E);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Jf||(Jf=i.createElement("path",{d:"M28 30H16a2.0023 2.0023 0 01-2-2V16a2.0023 2.0023 0 012-2H28a2.0023 2.0023 0 012 2V28A2.0023 2.0023 0 0128 30zM15 2L13.59 3.41 16.17 6H11a7.0078 7.0078 0 00-7 7v5H6V13a5.0057 5.0057 0 015-5h5.17l-2.58 2.59L15 12l5-5z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ew);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),$f||($f=i.createElement("path",{d:"M2 28V16a2.0023 2.0023 0 012-2H16a2.0023 2.0023 0 012 2V28a2.0023 2.0023 0 01-2 2H4A2.0023 2.0023 0 012 28zM4 16L3.9988 28H16V16zM17 2l1.41 1.41L15.83 6H21a7.0078 7.0078 0 017 7v5H26V13a5.0057 5.0057 0 00-5-5H15.83l2.58 2.59L17 12 12 7z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,iw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),eb||(eb=i.createElement("path",{d:"M14 28V16a2.0023 2.0023 0 012-2H28a2.0023 2.0023 0 012 2V28a2.0023 2.0023 0 01-2 2H16A2.0023 2.0023 0 0114 28zm2-12l-.0012 12H28V16zM2 15l1.41-1.41L6 16.17V11a7.0078 7.0078 0 017-7h5V6H13a5.0057 5.0057 0 00-5 5v5.17l2.59-2.58L12 15 7 20z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,tw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ib||(ib=i.createElement("path",{d:"M14 28V16a2.0023 2.0023 0 012-2H28a2.0023 2.0023 0 012 2V28a2.0023 2.0023 0 01-2 2H16A2.0023 2.0023 0 0114 28zM2 15l1.41-1.41L6 16.17V11a7.0078 7.0078 0 017-7h5V6H13a5.0057 5.0057 0 00-5 5v5.17l2.59-2.58L12 15 7 20z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,_w);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),tb||(tb=i.createElement("path",{d:"M2 28V16a2.0023 2.0023 0 012-2H16a2.0023 2.0023 0 012 2V28a2.0023 2.0023 0 01-2 2H4A2.0023 2.0023 0 012 28zM17 2l1.41 1.41L15.83 6H21a7.0078 7.0078 0 017 7v5H26V13a5.0057 5.0057 0 00-5-5H15.83l2.58 2.59L17 12 12 7z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,sw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),_b||(_b=i.createElement("path",{d:"M21 7L16 2 11 7 12.409 8.419 15 5.847 15 13 17 13 17 5.794 19.591 8.419 21 7zM21 25L16 30 11 25 12.409 23.581 15 26.153 15 19 17 19 17 26.206 19.591 23.581 21 25zM24 11L19 16 24 21 25.419 19.591 22.847 17 30 17 30 15 22.794 15 25.419 12.409 24 11zM8 11L13 16 8 21 6.581 19.591 9.153 17 2 17 2 15 9.206 15 6.581 12.409 8 11z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,aw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),sb||(sb=i.createElement("path",{d:"M21 25L16 30 11 25 12.409 23.581 15 26.153 15 19 17 19 17 26.206 19.591 23.581 21 25zM24 11L19 16 24 21 25.419 19.591 22.847 17 30 17 30 15 22.794 15 25.419 12.409 24 11zM8 11L13 16 8 21 6.581 19.591 9.153 17 2 17 2 15 9.206 15 6.581 12.409 8 11zM12.4289 5.8227v1.63a1.1269 1.1269 0 01-.6767 1.026l-1.39.5967A1.1218 1.1218 0 019.14 8.8424L7.3208 7.0233a1.1165 1.1165 0 01.0125-1.579l.0348-.0328c7.393-6.527 14.6913-2.0374 17.2127-.0473a1.1166 1.1166 0 01.1746 1.5693 1.1011 1.1011 0 01-.0873.0971L22.9108 8.7878a1.1114 1.1114 0 01-1.2225.2329l-1.39-.5967a1.1112 1.1112 0 01-.68-1.0223v-1.63S15.9726 3.0648 12.4289 5.8227z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,nw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ab||(ab=i.createElement("circle",{cx:"16",cy:"13.5",r:"1.5"})),nb||(nb=i.createElement("path",{d:"M19.5356,10.4648a5,5,0,0,0-7.0717,0L11.05,9.0508a6.9992,6.9992,0,0,1,9.9,0Z"})),rb||(rb=i.createElement("path",{d:"M23.0713 6.929a10 10 0 00-14.1426 0L7.5146 5.5144a12.0011 12.0011 0 0116.9708 0zM21 25L16 30 11 25 12.409 23.581 15 26.153 15 19 17 19 17 26.206 19.591 23.581 21 25zM24 11L19 16 24 21 25.419 19.591 22.847 17 30 17 30 15 22.794 15 25.419 12.409 24 11zM8 11L13 16 8 21 6.581 19.591 9.153 17 2 17 2 15 9.206 15 6.581 12.409 8 11z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,rw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),lb||(lb=i.createElement("path",{d:"M4 24H28V26H4zM26 18H6V14H26v4m2 0V14a2 2 0 00-2-2H6a2 2 0 00-2 2v4a2 2 0 002 2H26a2 2 0 002-2zM4 6H28V8H4z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,lw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),db||(db=i.createElement("path",{d:"M26 20H6a2 2 0 00-2 2v4a2 2 0 002 2H26a2 2 0 002-2V22A2 2 0 0026 20zm0 6H6V22H26zM17 7.828L19.586 10.414 21 9 16 4 11 9 12.414 10.414 15 7.828 15 14 4 14 4 16 28 16 28 14 17 14 17 7.828z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,dw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ob||(ob=i.createElement("path",{d:"M24 30H4a2.0021 2.0021 0 01-2-2V22a2.0021 2.0021 0 012-2H24a2.0021 2.0021 0 012 2v6A2.0021 2.0021 0 0124 30zM4 22H3.9985L4 28H24V22zM30 3.41L28.59 2 25 5.59 21.41 2 20 3.41 23.59 7 20 10.59 21.41 12 25 8.41 28.59 12 30 10.59 26.41 7 30 3.41z"})),mb||(mb=i.createElement("path",{d:"M4,14V8H18V6H4A2.0023,2.0023,0,0,0,2,8v6a2.0023,2.0023,0,0,0,2,2H26V14Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ow);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),vb||(vb=i.createElement("path",{d:"M4 18L15 18 15 24.172 12.414 21.586 11 23 16 28 21 23 19.586 21.586 17 24.172 17 18 28 18 28 16 4 16 4 18zM26 4H6A2 2 0 004 6v4a2 2 0 002 2H26a2 2 0 002-2V6A2 2 0 0026 4zm0 6H6V6H26z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,mw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),cb||(cb=i.createElement("path",{d:"M28 12H10a2.0021 2.0021 0 01-2-2V4a2.0021 2.0021 0 012-2H28a2.0021 2.0021 0 012 2v6A2.0021 2.0021 0 0128 12zM10 4v6H28V4zM28 30H10a2.0021 2.0021 0 01-2-2V22a2.0021 2.0021 0 012-2H28a2.0021 2.0021 0 012 2v6A2.0021 2.0021 0 0128 30zM10 22v6H28V22zM9 16L3.414 10.414 2 11.828 6.172 16 2 20.172 3.414 21.586 9 16z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,vw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ub||(ub=i.createElement("path",{d:"M8 18c-3.3 0-6 2.7-6 6s2.7 6 6 6 6-2.7 6-6C14 20.7 11.3 18 8 18zM8 28c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4C12 26.2 10.2 28 8 28zM30 24h-2C28 13 19 4 8 4V2C20.1 2 30 11.9 30 24z"})),fb||(fb=i.createElement("path",{d:"M22,24h-2c0-6.6-5.4-12-12-12v-2C15.7,10,22,16.3,22,24z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,cw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),bb||(bb=i.createElement("path",{d:"M10 16H22V18H10zM10 10H22V12H10z"})),pb||(pb=i.createElement("path",{d:"M16,30,9.8242,26.7071A10.9815,10.9815,0,0,1,4,17V4A2.0022,2.0022,0,0,1,6,2H26a2.0022,2.0022,0,0,1,2,2V17a10.9815,10.9815,0,0,1-5.8242,9.7069ZM6,4V17a8.9852,8.9852,0,0,0,4.7656,7.9423L16,27.7333l5.2344-2.791A8.9852,8.9852,0,0,0,26,17V4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,uw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),gb||(gb=i.createElement("path",{d:"M30 24a6 6 0 10-6 6A6.0066 6.0066 0 0030 24zm-2 0a3.9521 3.9521 0 01-.5669 2.019L21.981 20.5669A3.9529 3.9529 0 0124 20 4.0045 4.0045 0 0128 24zm-8 0a3.9521 3.9521 0 01.5669-2.019l5.4521 5.4521A3.9529 3.9529 0 0124 28 4.0045 4.0045 0 0120 24zM8 16H18V18H8zM8 10H20V12H8z"})),Eb||(Eb=i.createElement("path",{d:"M14,27.7334l-5.2344-2.791A8.9858,8.9858,0,0,1,4,17V4H24l0,11h2L26,4a2.0023,2.0023,0,0,0-2-2H4A2.0023,2.0023,0,0,0,2,4V17a10.9814,10.9814,0,0,0,5.8242,9.707L14,30Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,fw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),wb||(wb=i.createElement("path",{d:"M29.707 19.293l-3-3a.9994.9994 0 00-1.414 0L16 25.5859V30h4.4141l9.2929-9.293A.9994.9994 0 0029.707 19.293zM19.5859 28H18V26.4141l5-5L24.5859 23zM26 21.5859L24.4141 20 26 18.4141 27.5859 20zM8 16H18V18H8zM8 10H20V12H8z"})),hb||(hb=i.createElement("path",{d:"M26,4a2.0023,2.0023,0,0,0-2-2H4A2.0023,2.0023,0,0,0,2,4V17a10.9814,10.9814,0,0,0,5.8242,9.707L13,29.4668V27.2L8.7656,24.9424A8.9858,8.9858,0,0,1,4,17V4H24v9h2Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,bw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),xb||(xb=i.createElement("path",{fill:"none",d:"M9 16H23V18H9z","data-icon-path":"inner-path"})),zb||(zb=i.createElement("path",{fill:"none",d:"M9 10H23V12H9z"})),Lb||(Lb=i.createElement("path",{d:"M26,2H6A2.0023,2.0023,0,0,0,4,4V17a10.9814,10.9814,0,0,0,5.8242,9.707L16,30l6.1758-3.293A10.9814,10.9814,0,0,0,28,17V4A2.0023,2.0023,0,0,0,26,2ZM23,18H9V16H23Zm0-6H9V10H23Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,pw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Mb||(Mb=i.createElement("path",{d:"M23,30a7,7,0,1,1,7-7A7.0078,7.0078,0,0,1,23,30Zm0-12a5,5,0,1,0,5,5A5.0055,5.0055,0,0,0,23,18Z"})),Rb||(Rb=i.createElement("path",{d:"M26 24.586L24 22.586 24 20 22 20 22 23.414 24.586 26 26 24.586zM8 16H14V18H8zM8 10H20V12H8z"})),Sb||(Sb=i.createElement("path",{d:"M26,4a2.0023,2.0023,0,0,0-2-2H4A2.0023,2.0023,0,0,0,2,4V17a10.9814,10.9814,0,0,0,5.8242,9.707L13,29.4668V27.2L8.7656,24.9424A8.9858,8.9858,0,0,1,4,17V4H24v9h2Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,gw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Db||(Db=i.createElement("path",{d:"M29,10H3a1,1,0,0,0-1,1V21a1,1,0,0,0,1,1H29a1,1,0,0,0,1-1V11A1,1,0,0,0,29,10ZM28,20H4V12H8v4h2V12h5v4h2V12h5v4h2V12h4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ew);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),yb||(yb=i.createElement("path",{d:"M29.41,21.67,10.34,2.58a2,2,0,0,0-2.83,0L2.59,7.51a2,2,0,0,0,0,2.82L21.66,29.42a2,2,0,0,0,1.42.58,2,2,0,0,0,1.41-.58l4.92-4.93A2,2,0,0,0,29.41,21.67ZM23.08,28,4,8.92,8.92,4l3.79,3.79L10.46,10l1.41,1.41L14.12,9.2l4.13,4.13L16,15.58,17.42,17l2.25-2.25,4.13,4.13-2.25,2.25L23,22.54l2.25-2.25L28,23.08Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ww);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Vb||(Vb=i.createElement("path",{d:"M21,16a6,6,0,1,1-6,6,6,6,0,0,1,6-6m0-2a8,8,0,1,0,8,8,8,8,0,0,0-8-8Z"})),Ab||(Ab=i.createElement("path",{d:"M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2h4V26H6V12H28V6A2,2,0,0,0,26,4ZM6,10V6H26v4Z"})),Tb||(Tb=i.createElement("path",{d:"M19 19L19 25 24 22 19 19z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,hw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Wb||(Wb=i.createElement("path",{d:"M18,23H12V21h6V17H14a2,2,0,0,1-2-2V11a2,2,0,0,1,2-2h6v2H14v4h4a2,2,0,0,1,2,2v4A2,2,0,0,1,18,23Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,xw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ub||(Ub=i.createElement("path",{d:"M24 9L22 9 22 7 20 7 20 9 18 9 18 11 20 11 20 17 22 17 22 11 24 11 24 9zM14 23H8V21h6V17H10a2 2 0 01-2-2V11a2 2 0 012-2h6v2H10v4h4a2 2 0 012 2v4A2 2 0 0114 23z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,zw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ib||(Ib=i.createElement("path",{d:"M24.7808,26,25.97,21.2422A1,1,0,0,0,25,20H20V17h5a1,1,0,0,0,.9082-1.4189l-6-13a1.0006,1.0006,0,0,0-1.7021-.19L8.2075,15.3906A1,1,0,0,0,9,17h9v3H7a1,1,0,0,0-.97,1.2422L7.2192,26H2v2H30V26ZM20,7.5527,23.437,15H20ZM11.0308,15,18,5.94V15ZM22.7192,26H9.2808l-1-4H23.7192Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Lw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Bb||(Bb=i.createElement("path",{d:"M6.9692,25H9.0308l-.75-3H23.7192l-.75,3h2.0616l.9394-3.7578A1,1,0,0,0,25,20H20V17h5a1,1,0,0,0,.9082-1.4189l-6-13a1.0006,1.0006,0,0,0-1.7021-.19L8.2075,15.3906A1,1,0,0,0,9,17h9v3H7a1,1,0,0,0-.97,1.2422ZM20,7.5527,23.437,15H20ZM11.0308,15,18,5.94V15Z"})),Ob||(Ob=i.createElement("path",{d:"M26.9058,25.751A2.998,2.998,0,0,1,24,28a3.4376,3.4376,0,0,1-3.0513-2.3164A1.007,1.007,0,0,0,20,25a.9894.9894,0,0,0-.9468.6787A3.44,3.44,0,0,1,16,28a3.4376,3.4376,0,0,1-3.0513-2.3164A1.007,1.007,0,0,0,12,25a.971.971,0,0,0-.9468.6787A3.44,3.44,0,0,1,8,28a2.998,2.998,0,0,1-2.9058-2.249l-1.9365.498A4.9965,4.9965,0,0,0,8,30a4.9316,4.9316,0,0,0,4-1.9873,5.0192,5.0192,0,0,0,8,0A4.9316,4.9316,0,0,0,24,30a4.9965,4.9965,0,0,0,4.8423-3.751Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Mw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Fb||(Fb=i.createElement("path",{d:"M28,2V8.0439c-1.9634.1968-6.3162,1.2325-10.5637,6.2764-.198-.2768-.3982-.5464-.5882-.8506C11.9736,5.6714,6.3191,4.2759,4,4.042V2H2V30H4V26.0464a14.8661,14.8661,0,0,0,9.9185-3.96C18.47,27.46,25.2363,28.0381,27.9341,28.0381c.0244,0,.0422-.001.0659-.001V30h2V2Zm0,8.0552v9.99a12.8834,12.8834,0,0,1-9.2756-4.1328C22.5032,11.2666,26.2915,10.26,28,10.0552ZM15.1519,14.53c.3242.5185.663.9907,1.0078,1.4409-.3384.4741-.6753.9707-1.0078,1.5029a16.1346,16.1346,0,0,1-1.0313,1.4531c-.0825-.1372-.1675-.27-.2466-.4126C9.3279,10.3315,5.7871,8.4438,4,8.0684V6.0508C5.9932,6.2905,10.8228,7.6035,15.1519,14.53ZM4,24.0488V10.1406c1.3254.4644,4.2034,2.2847,8.126,9.3448.1894.3413.396.6523.6.9667A12.8784,12.8784,0,0,1,4,24.0488Zm11.3179-3.4209a18.0563,18.0563,0,0,0,1.53-2.0937c.2212-.354.4454-.67.6687-.9951A14.8686,14.8686,0,0,0,28,22.0425v3.9863C25.67,26.019,19.374,25.5088,15.3179,20.6279Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Rw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),qb||(qb=i.createElement("path",{d:"M30,2H2V16H8.1113a7.0359,7.0359,0,0,1,3.13.7393L15.7637,19l-4.522,2.2607A7.0359,7.0359,0,0,1,8.1113,22H2v8H9.2231a9.0446,9.0446,0,0,0,4.0249-.95L21.87,24.7393A7.0359,7.0359,0,0,1,25,24h5V14H25a7.0359,7.0359,0,0,1-3.13-.7393L15.3481,10H30ZM8,4H24V8H8ZM4,4H6V14H4ZM4,24H6v4H4Zm16.9751-1.05-8.6216,4.3105A7.0359,7.0359,0,0,1,9.2231,28H8V24h.1113a9.0446,9.0446,0,0,0,4.0249-.95L18,20.1182l1.8638.9316a9.0446,9.0446,0,0,0,4.0249.95H24v.0586A9.0515,9.0515,0,0,0,20.9751,22.95ZM28,22H26V16h2ZM12.3535,10.7393l8.6216,4.31A9.0515,9.0515,0,0,0,24,15.9414V20h-.1113a7.0359,7.0359,0,0,1-3.13-.7393l-8.6221-4.31A9.0446,9.0446,0,0,0,8.1113,14H8V10H9.2231A7.0359,7.0359,0,0,1,12.3535,10.7393ZM28,8H26V4h2Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Sw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Xb||(Xb=i.createElement("path",{d:"M22.9141,16.5l2.7929-2.793a.9994.9994,0,0,0,0-1.414L23.4141,10,25.5,7.9141,28.5859,11,30,9.5859,22.4141,2,21,3.4141,24.0859,6.5,22,8.5859,19.707,6.293a.9994.9994,0,0,0-1.414,0L15.5,9.0859,8.707,2.293a.9994.9994,0,0,0-1.414,0l-5,5a.9994.9994,0,0,0,0,1.414L9.0859,15.5,6.293,18.293a.9994.9994,0,0,0,0,1.414L8.5859,22,6.5,24.0859,3.4141,21,2,22.4141,9.5859,30,11,28.5859,7.9141,25.5,10,23.4141l2.293,2.2929a.9995.9995,0,0,0,1.414,0L16.5,22.9141l6.793,6.7929a.9995.9995,0,0,0,1.414,0l5-5a.9994.9994,0,0,0,0-1.414ZM4.4141,8,8,4.4141,10.0859,6.5,6.5,10.0859Zm3.5,3.5L11.5,7.9141,14.0859,10.5,10.5,14.0859ZM13,23.5859,8.4141,19,19,8.4141,23.5859,13ZM17.9141,21.5,21.5,17.9141,24.0859,20.5,20.5,24.0859ZM24,27.5859,21.9141,25.5,25.5,21.9141,27.5859,24Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Dw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Cb||(Cb=i.createElement("path",{d:"M30,14H28A10.0113,10.0113,0,0,0,18,4V2A12.0137,12.0137,0,0,1,30,14Z"})),Hb||(Hb=i.createElement("path",{d:"M26 14H24a6.0067 6.0067 0 00-6-6V6A8.0092 8.0092 0 0126 14zM16 28V24.96a9.9124 9.9124 0 007.3179-2.208 1.8482 1.8482 0 00.6777-1.3344 1.8 1.8 0 00-.5239-1.36L18.4141 15 21 12.4141 19.5859 11 17 13.5859 11.9419 8.5273a1.8145 1.8145 0 00-1.36-.5229 1.845 1.845 0 00-1.3339.6782 9.9566 9.9566 0 00-.5127 11.95L6.2793 28H2v2H30V28zM10.68 10.0938L21.9058 21.32A8.0011 8.0011 0 0110.68 10.0938zM14 28H8.3875l1.8757-5.627A9.9894 9.9894 0 0014 24.5435z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,yw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),kb||(kb=i.createElement("path",{d:"M26.5 12H19a4 4 0 010-8h.0835A4.7864 4.7864 0 0123 2a4.9816 4.9816 0 014.6543 3.2034A3.4667 3.4667 0 0130 8.5 3.5041 3.5041 0 0126.5 12zM19 6a2 2 0 000 4h7.5A1.5017 1.5017 0 0028 8.5a1.4855 1.4855 0 00-1.2778-1.4739L26.061 6.927l-.1616-.6487a2.9568 2.9568 0 00-5.4873-.7121L20.1143 6zM13 28V24.8882a7.9363 7.9363 0 004.707-2.2818.9995.9995 0 000-1.414L13.4644 16.95 16 14.4141 14.5859 13 12.05 15.5356 7.8076 11.293a.9994.9994 0 00-1.414 0 7.9993 7.9993 0 000 11.3134c.1621.1622.3327.3125.5058.459L4.4321 28H2v2H30V28zm-2 0H6.6685L8.59 24.1567A7.8927 7.8927 0 0011 24.873zM7.8076 21.1924a6.0036 6.0036 0 01-.6489-7.72l8.3686 8.3681a6.0026 6.0026 0 01-7.72-.6484z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Vw);return 16===a||"16"===a||"16px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),Nb||(Nb=i.createElement("path",{d:"M13.9,4.6l-2.5-2.5C11.3,2.1,11.1,2,11,2H3C2.4,2,2,2.4,2,3v10c0,0.6,0.4,1,1,1h10c0.6,0,1-0.4,1-1V5 C14,4.9,13.9,4.7,13.9,4.6z M6,3h4v2H6V3z M10,13H6V9h4V13z M11,13V9c0-0.6-0.4-1-1-1H6C5.4,8,5,8.4,5,9v4H3V3h2v2c0,0.6,0.4,1,1,1 h4c0.6,0,1-0.4,1-1V3.2l2,2V13H11z"})),_):20===a||"20"===a||"20px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor"},n),Zb||(Zb=i.createElement("path",{d:"M17.8,5.5l-3.3-3.3C14.3,2.1,14.2,2,14,2H3.3C2.6,2,2,2.6,2,3.3v13.3C2,17.4,2.6,18,3.3,18h13.3c0.7,0,1.4-0.5,1.4-1.2V6.1 C18,5.7,17.9,5.7,17.8,5.5z M7.3,3.3h5.3v3.3H7.3V3.3z M12.7,16.7H7.3v-5.3h5.3L12.7,16.7L12.7,16.7z M14,16.7v-5.3 c0-0.7-0.6-1.3-1.3-1.3H7.3C6.6,10,6,10.6,6,11.3v5.3H3.3V3.3H6v3.3C6,7.4,6.6,8,7.3,8h5.3C13.4,8,14,7.4,14,6.7v-3l2.7,2.7v10.4 L14,16.7L14,16.7z"})),_):24===a||"24"===a||"24px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor"},n),Yb||(Yb=i.createElement("path",{d:"M20.8,7L17,3.2C16.9,3.1,16.7,3,16.5,3h-12C3.7,3,3,3.7,3,4.5v15C3,20.3,3.7,21,4.5,21h15c0.8,0,1.5-0.7,1.5-1.5v-12 C21,7.3,20.9,7.1,20.8,7z M9,4.5h6v3H9V4.5z M15,19.5H9v-6h6V19.5z M16.5,19.5v-6c0-0.8-0.7-1.5-1.5-1.5H9c-0.8,0-1.5,0.7-1.5,1.5v6 h-3v-15h3v3C7.5,8.3,8.2,9,9,9h6c0.8,0,1.5-0.7,1.5-1.5V4.8l3,3v11.7H16.5z"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Pb||(Pb=i.createElement("path",{d:"M27.71,9.29l-5-5A1,1,0,0,0,22,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V10A1,1,0,0,0,27.71,9.29ZM12,6h8v4H12Zm8,20H12V18h8Zm2,0V18a2,2,0,0,0-2-2H12a2,2,0,0,0-2,2v8H6V6h4v4a2,2,0,0,0,2,2h8a2,2,0,0,0,2-2V6.41l4,4V26Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Aw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),jb||(jb=i.createElement("path",{d:"M21.56,15.1l-3.48-4.35A2,2,0,0,0,16.52,10H4a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H20a2,2,0,0,0,2-2V16.35A2,2,0,0,0,21.56,15.1ZM9,12h6v3H9Zm6,16H9V22h6Zm2,0V22a2,2,0,0,0-2-2H9a2,2,0,0,0-2,2v6H4V12H7v3a2,2,0,0,0,2,2h6a2,2,0,0,0,2-2V12.6l3,3.75V28Z"})),Kb||(Kb=i.createElement("path",{d:"M28,20H25V18h3V4H8V7H6V4A2,2,0,0,1,8,2H28a2,2,0,0,1,2,2V18A2,2,0,0,1,28,20Z"})),Gb||(Gb=i.createElement("path",{d:"M20 6H26V8H20zM22 10H26V12H22z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Tw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Qb||(Qb=i.createElement("path",{d:"M21.56,15.1l-3.48-4.35A2,2,0,0,0,16.52,10H4a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H20a2,2,0,0,0,2-2V16.35A2,2,0,0,0,21.56,15.1ZM9,12h6v3H9Zm6,16H9V22h6Zm2,0V22a2,2,0,0,0-2-2H9a2,2,0,0,0-2,2v6H4V12H7v3a2,2,0,0,0,2,2h6a2,2,0,0,0,2-2V12.6l3,3.75V28Z"})),Jb||(Jb=i.createElement("path",{d:"M28,20H25V18h3V4H14V7H12V4a2,2,0,0,1,2-2H28a2,2,0,0,1,2,2V18A2,2,0,0,1,28,20Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ww);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),$b||($b=i.createElement("path",{d:"M26,20l1.4272,1.9028L23,26.9629l-4.4272-5.06L20,20h6m1-2H19l-3,4,7,8,7-8-3-4Z"})),ep||(ep=i.createElement("path",{d:"M16,26H12V18h2V16H12a2,2,0,0,0-2,2v8H6V6h4v4a2,2,0,0,0,2,2h8a2,2,0,0,0,2-2V6.41l4,4V16h2V10a1,1,0,0,0-.29-.71l-5-5A.9989.9989,0,0,0,22,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H16ZM12,6h8v4H12Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Uw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ip||(ip=i.createElement("path",{d:"M21.56,15.1l-3.48-4.35A2,2,0,0,0,16.52,10H4a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H20a2,2,0,0,0,2-2V16.35A2,2,0,0,0,21.56,15.1ZM9,12h6v3H9Zm6,16H9V22h6Zm2,0V22a2,2,0,0,0-2-2H9a2,2,0,0,0-2,2v6H4V12H7v3a2,2,0,0,0,2,2h6a2,2,0,0,0,2-2V12.6l3,3.75V28Z"})),tp||(tp=i.createElement("path",{d:"M27,21H25V7H11V5H25a2,2,0,0,1,2,2Z"})),_p||(_p=i.createElement("path",{d:"M32,14H30V2H18V0H30a2,2,0,0,1,2,2Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Iw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),sp||(sp=i.createElement("path",{d:"M13,17H7a2,2,0,0,0-2,2v6a2,2,0,0,0,2,2h6a2,2,0,0,0,2-2V19A2,2,0,0,0,13,17ZM7,25V19h6v6Z"})),ap||(ap=i.createElement("path",{d:"M19,21v2h6a2,2,0,0,0,2-2V7a2,2,0,0,0-2-2H11A2,2,0,0,0,9,7v6h2V7H25V21"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Bw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),np||(np=i.createElement("path",{d:"M20,16a5,5,0,0,0,10,0,1,1,0,0,0-.1055-.4473L25.896,7.5562a.8913.8913,0,0,0-.0454-.0816A1,1,0,0,0,25,7H18.8218A3.0155,3.0155,0,0,0,17,5.1841V2H15V5.1841A3.0155,3.0155,0,0,0,13.1782,7H7a1,1,0,0,0-.8945.5527l-4,8A1,1,0,0,0,2,16a5,5,0,0,0,10,0,1,1,0,0,0-.1055-.4473L8.6182,9h4.56A3.0147,3.0147,0,0,0,15,10.8154V28H6v2H26V28H17V10.8159A3.0155,3.0155,0,0,0,18.8218,9h4.56l-3.2763,6.5527A1,1,0,0,0,20,16ZM7,19a2.9958,2.9958,0,0,1-2.8152-2h5.63A2.9956,2.9956,0,0,1,7,19Zm2.3821-4H4.6179L7,10.2363ZM16,9a1,1,0,1,1,1-1A1.0009,1.0009,0,0,1,16,9Zm9,10a2.9958,2.9958,0,0,1-2.8152-2h5.63A2.9956,2.9956,0,0,1,25,19Zm0-8.7637L27.3821,15H22.6179Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ow);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),rp||(rp=i.createElement("path",{d:"M20,13a5,5,0,0,0,10,0,1,1,0,0,0-.1055-.4473l-4-8a1,1,0,0,0-1.2109-.5014l-6.3308,2.11A3.0322,3.0322,0,0,0,17,5.1841V2H15V5.1841a2.9949,2.9949,0,0,0-1.9956,2.76l-6.3208,2.107a1,1,0,0,0-.5781.5014l-4,8A1,1,0,0,0,2,19a5,5,0,0,0,10,0,1,1,0,0,0-.1055-.4473L8.41,11.584l5.237-1.7456A3.0285,3.0285,0,0,0,15,10.8154V28H6v2H26V28H17V10.8159a2.9951,2.9951,0,0,0,1.9956-2.76l4.03-1.3438-2.92,5.8408A1,1,0,0,0,20,13ZM7,22a2.9956,2.9956,0,0,1-2.8152-2h5.63A2.9956,2.9956,0,0,1,7,22Zm2.3821-4H4.6179L7,13.2363ZM16,9a1,1,0,1,1,1-1A1.0009,1.0009,0,0,1,16,9Zm9,7a2.9958,2.9958,0,0,1-2.8152-2h5.63A2.9956,2.9956,0,0,1,25,16Zm0-8.7637L27.3821,12H22.6179Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Fw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),lp||(lp=i.createElement("path",{d:"M28.83,5.17a4.1,4.1,0,0,0-5.66,0L.34,28H9.59a5,5,0,0,0,3.53-1.46L28.83,10.83a4,4,0,0,0,0-5.66ZM12.29,18.88l2.09-2.09,2.83,2.83-2.09,2.09Zm-.58,6.24A3,3,0,0,1,9.59,26H5.17l5.71-5.71,2.83,2.83ZM27.41,9.41l-8.79,8.8-2.83-2.83,8.8-8.79a2,2,0,0,1,2.82,0,2,2,0,0,1,0,2.82Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,qw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),dp||(dp=i.createElement("path",{d:"M28.8281 7.1338a4.0941 4.0941 0 00-5.6562 0L.3433 29.9619H9.5889a4.9682 4.9682 0 003.5356-1.4648L28.8281 12.79a3.9984 3.9984 0 000-5.6562zM12.2928 20.8406l2.086-2.0858 2.8293 2.8293L15.1224 23.67zM11.71 27.083a2.9824 2.9824 0 01-2.1215.8789H5.1714l5.7073-5.7072 2.83 2.83zM27.4141 11.376L18.6221 20.17l-2.8293-2.8292 8.7931-8.7928a2.0471 2.0471 0 012.8282 0 1.9993 1.9993 0 010 2.8281zM13 4L4 4 4 13 6 13 6 6 13 6 13 4z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Xw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),op||(op=i.createElement("path",{d:"M28.8281 7.1338a4.0941 4.0941 0 00-5.6562 0L.3433 29.9619H9.5889a4.9682 4.9682 0 003.5356-1.4648L28.8281 12.79a3.9984 3.9984 0 000-5.6562zM12.2928 20.8406l2.086-2.0858 2.8293 2.8293L15.1224 23.67zM11.71 27.083a2.9824 2.9824 0 01-2.1215.8789H5.1714l5.7073-5.7072 2.83 2.83zM27.4141 11.376L18.6221 20.17l-2.8293-2.8292 8.7931-8.7928a2.0471 2.0471 0 012.8282 0 1.9993 1.9993 0 010 2.8281zM11 2H7a4.9843 4.9843 0 00-3.8633 8.1528A2.9586 2.9586 0 003 11a2.9945 2.9945 0 002 2.8154V14a2.0025 2.0025 0 01-2 2H2v2H3a4.0045 4.0045 0 004-4v-.1841A2.9959 2.9959 0 008.8157 12H11A5 5 0 0011 2zM6 12a1 1 0 111-1A1.0009 1.0009 0 016 12zm5-2H8.8157A2.974 2.974 0 004.394 8.4746 2.9908 2.9908 0 017 4h4a3 3 0 010 6z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Cw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),mp||(mp=i.createElement("path",{d:"M28.8281 7.1719a4.0941 4.0941 0 00-5.6562 0L.3433 30H9.5889a4.9682 4.9682 0 003.5356-1.4648L28.8281 12.8281a3.9984 3.9984 0 000-5.6562zM12.2928 20.8787l2.086-2.0859 2.8293 2.8294-2.0857 2.0862zM11.71 27.1211A2.9824 2.9824 0 019.5889 28H5.1714l5.7073-5.7072 2.83 2.83zm15.7037-15.707l-8.792 8.7939-2.8293-2.8292 8.7931-8.7929a2.0473 2.0473 0 012.8282 0 1.9995 1.9995 0 010 2.8282zM15 2a2.9948 2.9948 0 00-2.8157 2H7.8156A2.9925 2.9925 0 104 7.8154v4.3687a3 3 0 102 0V7.8159A2.9959 2.9959 0 007.8156 6h4.3686A2.9947 2.9947 0 1015 2zM5 16a1 1 0 111-1A1.0008 1.0008 0 015 16zM5 6A1 1 0 116 5 1.0008 1.0008 0 015 6zM15 6a1 1 0 111-1A1.0008 1.0008 0 0115 6z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Hw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),vp||(vp=i.createElement("path",{d:"M21,29H5a2,2,0,0,1-2-2V5A2,2,0,0,1,5,3H21V5H5V27H21Z"})),cp||(cp=i.createElement("path",{d:"M15 9H17V23H15zM27 9H29V23H27zM21 9H23V23H21z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,kw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),up||(up=i.createElement("path",{d:"M22 24H10a2 2 0 01-2-2V19h2v3H22V19h2v3A2 2 0 0122 24zM2 15H30V17H2zM24 13H22V10H10v3H8V10a2 2 0 012-2H22a2 2 0 012 2zM30 10L28 10 28 4 22 4 22 2 30 2 30 10zM4 10L2 10 2 2 10 2 10 4 4 4 4 10zM10 30L2 30 2 22 4 22 4 28 10 28 10 30zM30 30L22 30 22 28 28 28 28 22 30 22 30 30z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Nw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),fp||(fp=i.createElement("path",{d:"M29.3826 2.0762a.9993.9993 0 00-1.09.2168l-26 26A1 1 0 003 30h8V28H5.4143l4-4H22a2.0021 2.0021 0 002-2V9.4146l4-4V11h2V3A1 1 0 0029.3826 2.0762zM22 22H11.4143L22 11.4146zM10 17.7554V10h7.7554l2-2H10a2.0025 2.0025 0 00-2 2v9.7554zM11 2L2 2 2 11 4 11 4 4 11 4 11 2zM21 30L30 30 30 21 28 21 28 28 21 28 21 30zM4 23.755L4 21 2 21 2 25.754 4 23.755zM25.755 2L21 2 21 4 23.755 4 25.755 2z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Zw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),bp||(bp=i.createElement("circle",{cx:"9.5",cy:"9.5",r:"2.5"})),pp||(pp=i.createElement("circle",{cx:"9.5",cy:"22.5",r:"2.5"})),gp||(gp=i.createElement("circle",{cx:"22.5",cy:"22.5",r:"2.5"})),Ep||(Ep=i.createElement("path",{d:"M28,2H4A2.0023,2.0023,0,0,0,2,4V28a2.0023,2.0023,0,0,0,2,2H28a2.0023,2.0023,0,0,0,2-2V4A2.0023,2.0023,0,0,0,28,2Zm0,13H17V4H28ZM15,4V15H4V4ZM4,17H15V28H4ZM17,28V17H28V28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Yw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),wp||(wp=i.createElement("path",{d:"M27,19.001A4.0056,4.0056,0,0,0,22.9991,15H9.0011A2.0031,2.0031,0,0,1,7,12.9991V9.858A3.9949,3.9949,0,0,0,9.8581,7h12.284a4,4,0,1,0,0-2H9.8581A3.9916,3.9916,0,1,0,5,9.858v3.1411A4.0057,4.0057,0,0,0,9.0011,17h13.998A2.003,2.003,0,0,1,25,19.001V22H22v3H9.8581a4,4,0,1,0,0,2H22v3h8V22H27ZM26,4a2,2,0,1,1-2,2A2.0019,2.0019,0,0,1,26,4ZM4,6A2,2,0,1,1,6,8,2.0019,2.0019,0,0,1,4,6ZM6,28a2,2,0,1,1,2-2A2.002,2.002,0,0,1,6,28Zm22-4v4H24V24Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Pw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),hp||(hp=i.createElement("path",{d:"M27,19c-0.3,0-0.7,0.1-1,0.2L20.4,12c1-1.1,1.6-2.5,1.6-4c0-3.3-2.7-6-6-6s-6,2.7-6,6c0,1.6,0.6,3,1.6,4L6,19.2 C5.7,19.1,5.3,19,5,19c-1.7,0-3,1.3-3,3s1.3,3,3,3s3-1.3,3-3c0-0.6-0.2-1.1-0.5-1.6l5.6-7.1c0.6,0.3,1.2,0.5,1.9,0.6v10.3 c-1.2,0.4-2,1.5-2,2.8c0,1.7,1.3,3,3,3s3-1.3,3-3c0-1.3-0.8-2.4-2-2.8V13.9c0.7-0.1,1.3-0.3,1.9-0.6l5.6,7.1c-0.3,0.5-0.5,1-0.5,1.6 c0,1.7,1.3,3,3,3s3-1.3,3-3S28.7,19,27,19z M16,4c2.2,0,4,1.8,4,4s-1.8,4-4,4s-4-1.8-4-4S13.8,4,16,4z M5,23c-0.6,0-1-0.4-1-1 s0.4-1,1-1s1,0.4,1,1S5.6,23,5,23z M16,28c-0.6,0-1-0.4-1-1s0.4-1,1-1s1,0.4,1,1S16.6,28,16,28z M27,23c-0.6,0-1-0.4-1-1s0.4-1,1-1 s1,0.4,1,1S27.6,23,27,23z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,jw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),xp||(xp=i.createElement("path",{d:"M23,23v3H8.5a4.5,4.5,0,0,1,0-9H9V15H8.5a6.5,6.5,0,0,0,0,13H23v3h8V23Zm6,6H25V25h4Z"})),zp||(zp=i.createElement("path",{d:"M21 22H19V19H13v3H11V19a2.0023 2.0023 0 012-2h6a2.0023 2.0023 0 012 2zM16 16a3 3 0 113-3A3.0033 3.0033 0 0116 16zm0-4a1 1 0 101 1A1.0013 1.0013 0 0016 12z"})),Lp||(Lp=i.createElement("path",{d:"M23.5,4H9V1H1V9H9V6H23.5a4.5,4.5,0,0,1,0,9H23v2h.5a6.5,6.5,0,0,0,0-13ZM7,7H3V3H7Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Kw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Mp||(Mp=i.createElement("path",{d:"M26 28a4 4 0 114-4A4.0045 4.0045 0 0126 28zm0-6a2 2 0 102 2A2.0023 2.0023 0 0026 22zM24 8H18v2h6a1 1 0 010 2H21a1 1 0 00-.98 1.1963l.9241 4.6211L18.4338 22h-2.69l-2.5723-8.5752A1.988 1.988 0 0011.2559 12H6v2h5.2561l.6 2H7a5.0057 5.0057 0 00-5 5v2a1 1 0 001 1H4a4 4 0 008 0h7a1 1 0 00.8574-.4854l3-5a1 1 0 00.1231-.7109L22.22 14H24a3 3 0 000-6zM8 26a2.0025 2.0025 0 01-2-2h4A2.0025 2.0025 0 018 26zM4 22V21a3.0033 3.0033 0 013-3h5.4561l1.2 4z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Gw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Rp||(Rp=i.createElement("path",{d:"M15 19H17V28H15z"})),Sp||(Sp=i.createElement("path",{d:"M23,10V8H20a2.0025,2.0025,0,0,0-2-2H14a2.0025,2.0025,0,0,0-2,2H9v2h3v4.1841A2.9957,2.9957,0,0,0,10,17v7h2V17a1.0008,1.0008,0,0,1,1-1h6a1.0008,1.0008,0,0,1,1,1v7h2V17a2.9957,2.9957,0,0,0-2-2.8159V10ZM18,8v6H14V8Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Qw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Dp||(Dp=i.createElement("path",{d:"M28,4H4A2,2,0,0,0,2,6V22a2,2,0,0,0,2,2h8v4H8v2H24V28H20V24h8a2,2,0,0,0,2-2V6A2,2,0,0,0,28,4ZM18,28H14V24h4Zm10-6H4V6H28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Jw);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),yp||(yp=i.createElement("path",{d:"M28,22H11.41L30,3.41,28.59,2l-2,2H4A2,2,0,0,0,2,6V22H4V6H24.59L2,28.59,3.41,30l6-6H12v4H8v2H24V28H20V24h8a2,2,0,0,0,2-2V9H28ZM18,28H14V24h4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,$w);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Vp||(Vp=i.createElement("path",{d:"M18.83 26L21.41 23.42 20 22 16 26 20 30 21.42 28.59 18.83 26zM27.17 26L24.59 28.58 26 30 30 26 26 22 24.58 23.41 27.17 26z"})),Ap||(Ap=i.createElement("path",{d:"M14,28H8V4h8v6a2.0058,2.0058,0,0,0,2,2h6v6h2V10a.9092.9092,0,0,0-.3-.7l-7-7A.9087.9087,0,0,0,18,2H8A2.0058,2.0058,0,0,0,6,4V28a2.0058,2.0058,0,0,0,2,2h6ZM18,4.4,23.6,10H18Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,eh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Tp||(Tp=i.createElement("path",{d:"M4 20L4 22 8.586 22 2 28.586 3.414 30 10 23.414 10 28 12 28 12 20 4 20zM27.17 26L24.59 28.58 26 30 30 26 26 22 24.58 23.41 27.17 26zM18.83 26L21.41 23.42 20 22 16 26 20 30 21.42 28.59 18.83 26zM25.7 9.3l-7-7A.9087.9087 0 0018 2H8A2.0058 2.0058 0 006 4V16H8V4h8v6a2.0058 2.0058 0 002 2h6v6h2V10A.9092.9092 0 0025.7 9.3zM18 10V4.4L23.6 10z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ih);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Wp||(Wp=i.createElement("path",{d:"M30 9L27.9 9 24 15.6 24 9 22 9 22 23 24 23 24 18.7 24.9 17.2 27.9 23 30 23 26.1 15.4 30 9zM16 23H12V9h4a4.0118 4.0118 0 014 4v6A4.0118 4.0118 0 0116 23zm-2-2h2a2.0059 2.0059 0 002-2V13a2.0059 2.0059 0 00-2-2H14zM8 23H2V21H8V17H4a2.0059 2.0059 0 01-2-2V11A2.0059 2.0059 0 014 9h6v2H4v4H8a2.0059 2.0059 0 012 2v4A2.0059 2.0059 0 018 23z"})),_)})).propTypes=da;var rx,lx=i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,th);return 16===a||"16"===a||"16px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),Up||(Up=i.createElement("path",{d:"M15,14.3L10.7,10c1.9-2.3,1.6-5.8-0.7-7.7S4.2,0.7,2.3,3S0.7,8.8,3,10.7c2,1.7,5,1.7,7,0l4.3,4.3L15,14.3z M2,6.5 C2,4,4,2,6.5,2S11,4,11,6.5S9,11,6.5,11S2,9,2,6.5z"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ip||(Ip=i.createElement("path",{d:"M29,27.5859l-7.5521-7.5521a11.0177,11.0177,0,1,0-1.4141,1.4141L27.5859,29ZM4,13a9,9,0,1,1,9,9A9.01,9.01,0,0,1,4,13Z"})),_)}));lx.propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,_h);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Bp||(Bp=i.createElement("path",{d:"M30 6L26 6 26 2 24 2 24 6 20 6 20 8 24 8 24 12 26 12 26 8 30 8 30 6zM24 28.5859l-5.9751-5.9751a9.0234 9.0234 0 10-1.4141 1.4141L22.5859 30zM4 17a7 7 0 117 7A7.0078 7.0078 0 014 17z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,sh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Op||(Op=i.createElement("path",{d:"M30 28.5859l-4.6885-4.6884a8.028 8.028 0 10-1.414 1.414L28.5859 30zM19 25a6 6 0 116-6A6.0066 6.0066 0 0119 25zM2 12H10V14H2zM2 2H18V4H2zM2 7H18V9H2z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ah);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Fp||(Fp=i.createElement("path",{d:"M14 16.59L11.41 14 10 15.41 14 19.41 22 11.41 20.59 10 14 16.59z"})),qp||(qp=i.createElement("path",{d:"M16,30,9.8242,26.7071A10.9818,10.9818,0,0,1,4,17V4A2.0021,2.0021,0,0,1,6,2H26a2.0021,2.0021,0,0,1,2,2V17a10.9818,10.9818,0,0,1-5.8242,9.7071ZM6,4V17a8.9852,8.9852,0,0,0,4.7656,7.9423L16,27.7333l5.2344-2.791A8.9852,8.9852,0,0,0,26,17V4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,nh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Xp||(Xp=i.createElement("path",{d:"M30,24V22H27.8989a4.9678,4.9678,0,0,0-.7319-1.7529l1.49-1.49-1.414-1.414-1.49,1.49A4.9678,4.9678,0,0,0,24,18.1011V16H22v2.1011a4.9678,4.9678,0,0,0-1.7529.7319l-1.49-1.49-1.414,1.414,1.49,1.49A4.9678,4.9678,0,0,0,18.1011,22H16v2h2.1011a4.9678,4.9678,0,0,0,.7319,1.7529l-1.49,1.49,1.414,1.414,1.49-1.49A4.9678,4.9678,0,0,0,22,27.8989V30h2V27.8989a4.9678,4.9678,0,0,0,1.7529-.7319l1.49,1.49,1.414-1.414-1.49-1.49A4.9678,4.9678,0,0,0,27.8989,24Zm-7,2a3,3,0,1,1,3-3A3.0033,3.0033,0,0,1,23,26Z"})),Cp||(Cp=i.createElement("path",{d:"M14,26.667l-3.2344-1.7246A8.9858,8.9858,0,0,1,6,17V4H26V14h2V4a2.0023,2.0023,0,0,0-2-2H6A2.0023,2.0023,0,0,0,4,4V17a10.9814,10.9814,0,0,0,5.8242,9.707L14,28.9336Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,rh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Hp||(Hp=i.createElement("path",{d:"M12 6L8 6 8 2 6 2 6 6 2 6 2 8 6 8 6 12 8 12 8 8 12 8 12 6zM16 6H20V8H16zM24 6V8h4v4h2V8a2 2 0 00-2-2zM6 16H8V20H6zM8 28V24H6v4a2 2 0 002 2h4V28zM28 16H30V20H28zM16 28H20V30H16zM28 24v4H24v2h4a2 2 0 002-2V24z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,lh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),kp||(kp=i.createElement("path",{d:"M12 6L8 6 8 2 6 2 6 6 2 6 2 8 6 8 6 12 8 12 8 8 12 8 12 6zM30 10V4H24V6H16V8h8v2h2V24H24v2H10V24H8V16H6v8H4v6h6V28H24v2h6V24H28V10zM8 28H6V26H8zm20 0H26V26h2zM26 6h2V8H26z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,dh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Np||(Np=i.createElement("path",{d:"M8 26H4a2.0021 2.0021 0 01-2-2V20H4v4H8zM2 12H4V16H2zM26 8H24V4H20V2h4a2.0021 2.0021 0 012 2zM12 2H16V4H12zM4 8H2V4A2.0021 2.0021 0 014 2H8V4H4zM27 32a.9967.9967 0 01-.707-.293l-6.1377-6.1377L16.832 30.5547a1 1 0 01-1.79-.2676l-6-20A1 1 0 0110.2871 9.042l20 6a1 1 0 01.2676 1.79l-4.9854 3.3233L31.707 26.293a.9994.9994 0 010 1.414l-4 4A.9967.9967 0 0127 32zm0-2.4141L29.5859 27 22.431 19.845l5.2458-3.4978L11.4917 11.4917l4.8555 16.1851L19.845 22.431z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,oh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Zp||(Zp=i.createElement("path",{d:"M27.45,15.11l-22-11a1,1,0,0,0-1.08.12,1,1,0,0,0-.33,1L7,16,4,26.74A1,1,0,0,0,5,28a1,1,0,0,0,.45-.11l22-11a1,1,0,0,0,0-1.78Zm-20.9,10L8.76,17H18V15H8.76L6.55,6.89,24.76,16Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,mh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Yp||(Yp=i.createElement("path",{d:"M27.71,4.29a1,1,0,0,0-1.05-.23l-22,8a1,1,0,0,0,0,1.87l9.6,3.84,3.84,9.6A1,1,0,0,0,19,28h0a1,1,0,0,0,.92-.66l8-22A1,1,0,0,0,27.71,4.29ZM19,24.2l-2.79-7L21,12.41,19.59,11l-4.83,4.83L7.8,13,25.33,6.67Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,vh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Pp||(Pp=i.createElement("path",{d:"M27.71,4.29a1,1,0,0,0-1.05-.23l-22,8a1,1,0,0,0,0,1.87l8.59,3.43L19.59,11,21,12.41l-6.37,6.37,3.44,8.59A1,1,0,0,0,19,28h0a1,1,0,0,0,.92-.66l8-22A1,1,0,0,0,27.71,4.29Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ch);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),jp||(jp=i.createElement("path",{d:"M27.45,15.11l-22-11a1,1,0,0,0-1.08.12,1,1,0,0,0-.33,1L6.69,15H18v2H6.69L4,26.74A1,1,0,0,0,5,28a1,1,0,0,0,.45-.11l22-11a1,1,0,0,0,0-1.78Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,uh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Kp||(Kp=i.createElement("path",{d:"M4 7H2V4A2.0023 2.0023 0 014 2H7V4H4zM7 22H4a2.0023 2.0023 0 01-2-2V17H4v3H7zM2 10H4V14H2zM22 7H20V4H17V2h3a2.0023 2.0023 0 012 2zM10 2H14V4H10zM28 30H12a2.0023 2.0023 0 01-2-2V12a2.0023 2.0023 0 012-2H28a2.0023 2.0023 0 012 2V28A2.0023 2.0023 0 0128 30zM12 12V28H28V12z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,fh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Gp||(Gp=i.createElement("path",{d:"M28,10H22V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V20a2,2,0,0,0,2,2h6v6a2.0023,2.0023,0,0,0,2,2H28a2.0023,2.0023,0,0,0,2-2V12A2.0023,2.0023,0,0,0,28,10ZM12,28V12H28l.0015,16Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,bh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Qp||(Qp=i.createElement("path",{d:"M16 2a8 8 0 108 8A8.0092 8.0092 0 0016 2zm5.91 7H19.4724a15.2457 15.2457 0 00-.7917-4.36A6.0088 6.0088 0 0121.91 9zM16.022 15.999h-.0076c-.3813-.1206-1.3091-1.8213-1.479-4.999h2.9292C17.2952 14.1763 16.3711 15.877 16.022 15.999zM14.5354 9c.1694-3.1763 1.0935-4.877 1.4426-4.999h.0076c.3813.1206 1.3091 1.8213 1.479 4.999zM13.3193 4.64A15.2457 15.2457 0 0012.5276 9H10.09A6.0088 6.0088 0 0113.3193 4.64zM10.09 11h2.4373a15.2457 15.2457 0 00.7917 4.36A6.0088 6.0088 0 0110.09 11zm8.59 4.36A15.2457 15.2457 0 0019.4724 11H21.91A6.0088 6.0088 0 0118.6807 15.36zM28 30H4a2.0021 2.0021 0 01-2-2V22a2.0021 2.0021 0 012-2H28a2.0021 2.0021 0 012 2v6A2.0021 2.0021 0 0128 30zM4 22v6H28V22z"})),Jp||(Jp=i.createElement("circle",{cx:"7",cy:"25",r:"1"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ph);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),$p||($p=i.createElement("path",{d:"M6,30H26a2,2,0,0,0,2-2V22a2,2,0,0,0-2-2H6a2,2,0,0,0-2,2v6A2,2,0,0,0,6,30Zm0-8H26v6H6Z"})),eg||(eg=i.createElement("circle",{cx:"9",cy:"25",r:"1"})),ig||(ig=i.createElement("path",{d:"M26,2,24.59,3.41,27.17,6H22.315A6.9835,6.9835,0,0,0,9.08,10H4.83L7.41,7.41,6,6,1,11l5,5,1.41-1.41L4.83,12H9.685A6.9835,6.9835,0,0,0,22.92,8h4.25l-2.58,2.59L26,12l5-5ZM21,9a4.983,4.983,0,0,1-8.9745,3H16V10H11.1011a4.9852,4.9852,0,0,1,8.8734-4H16V8h4.8989A5.0019,5.0019,0,0,1,21,9Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,gh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),tg||(tg=i.createElement("path",{d:"M28,30H4a2.0021,2.0021,0,0,1-2-2V22a2.0021,2.0021,0,0,1,2-2H28a2.0021,2.0021,0,0,1,2,2v6A2.0021,2.0021,0,0,1,28,30ZM4,22v6H28V22Z"})),_g||(_g=i.createElement("circle",{cx:"7",cy:"25",r:"1"})),sg||(sg=i.createElement("path",{d:"M19 11.586L17 9.586 17 6 15 6 15 10.414 17.586 13 19 11.586z"})),ag||(ag=i.createElement("path",{d:"M16,18a8,8,0,1,1,8-8A8.0092,8.0092,0,0,1,16,18ZM16,4a6,6,0,1,0,6,6A6.0067,6.0067,0,0,0,16,4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Eh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ng||(ng=i.createElement("path",{d:"M28,24V22A12.01,12.01,0,0,0,17,10.0507V8h3V6H12V8h3v2.0507A12.01,12.01,0,0,0,4,22v2H2v2H30V24ZM16,12a10.0167,10.0167,0,0,1,9.7984,8H6.2015A10.0165,10.0165,0,0,1,16,12ZM6,22H26v2H6Z",transform:"translate(0 .005)"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,wh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),rg||(rg=i.createElement("path",{d:"M26,8,24.59,9.41,27.17,12H16a5.967,5.967,0,0,0-4,1.54V6.83l2.59,2.58L16,8,11,3,6,8,7.41,9.41,10,6.83V18a5.969,5.969,0,0,0,1.54,4H4.83l2.58-2.59L6,18,1,23l5,5,1.41-1.41L4.83,24H16A5.99,5.99,0,0,0,20.46,14h6.71l-2.58,2.59L26,18l5-5ZM20,18a4,4,0,1,1-4-4A4.0045,4.0045,0,0,1,20,18Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,hh);return 16===a||"16"===a||"16px"===a?i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},n),lg||(lg=i.createElement("path",{d:"M13.5,8.4c0-0.1,0-0.3,0-0.4c0-0.1,0-0.3,0-0.4l1-0.8c0.4-0.3,0.4-0.9,0.2-1.3l-1.2-2C13.3,3.2,13,3,12.6,3 c-0.1,0-0.2,0-0.3,0.1l-1.2,0.4c-0.2-0.1-0.4-0.3-0.7-0.4l-0.3-1.3C10.1,1.3,9.7,1,9.2,1H6.8c-0.5,0-0.9,0.3-1,0.8L5.6,3.1 C5.3,3.2,5.1,3.3,4.9,3.4L3.7,3C3.6,3,3.5,3,3.4,3C3,3,2.7,3.2,2.5,3.5l-1.2,2C1.1,5.9,1.2,6.4,1.6,6.8l0.9,0.9c0,0.1,0,0.3,0,0.4 c0,0.1,0,0.3,0,0.4L1.6,9.2c-0.4,0.3-0.5,0.9-0.2,1.3l1.2,2C2.7,12.8,3,13,3.4,13c0.1,0,0.2,0,0.3-0.1l1.2-0.4 c0.2,0.1,0.4,0.3,0.7,0.4l0.3,1.3c0.1,0.5,0.5,0.8,1,0.8h2.4c0.5,0,0.9-0.3,1-0.8l0.3-1.3c0.2-0.1,0.4-0.2,0.7-0.4l1.2,0.4 c0.1,0,0.2,0.1,0.3,0.1c0.4,0,0.7-0.2,0.9-0.5l1.1-2c0.2-0.4,0.2-0.9-0.2-1.3L13.5,8.4z M12.6,12l-1.7-0.6c-0.4,0.3-0.9,0.6-1.4,0.8 L9.2,14H6.8l-0.4-1.8c-0.5-0.2-0.9-0.5-1.4-0.8L3.4,12l-1.2-2l1.4-1.2c-0.1-0.5-0.1-1.1,0-1.6L2.2,6l1.2-2l1.7,0.6 C5.5,4.2,6,4,6.5,3.8L6.8,2h2.4l0.4,1.8c0.5,0.2,0.9,0.5,1.4,0.8L12.6,4l1.2,2l-1.4,1.2c0.1,0.5,0.1,1.1,0,1.6l1.4,1.2L12.6,12z"})),dg||(dg=i.createElement("path",{d:"M8,11c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3C11,9.6,9.7,11,8,11C8,11,8,11,8,11z M8,6C6.9,6,6,6.8,6,7.9C6,7.9,6,8,6,8 c0,1.1,0.8,2,1.9,2c0,0,0.1,0,0.1,0c1.1,0,2-0.8,2-1.9c0,0,0-0.1,0-0.1C10,6.9,9.2,6,8,6C8.1,6,8,6,8,6z"})),_):i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),og||(og=i.createElement("path",{d:"M27,16.76c0-.25,0-.5,0-.76s0-.51,0-.77l1.92-1.68A2,2,0,0,0,29.3,11L26.94,7a2,2,0,0,0-1.73-1,2,2,0,0,0-.64.1l-2.43.82a11.35,11.35,0,0,0-1.31-.75l-.51-2.52a2,2,0,0,0-2-1.61H13.64a2,2,0,0,0-2,1.61l-.51,2.52a11.48,11.48,0,0,0-1.32.75L7.43,6.06A2,2,0,0,0,6.79,6,2,2,0,0,0,5.06,7L2.7,11a2,2,0,0,0,.41,2.51L5,15.24c0,.25,0,.5,0,.76s0,.51,0,.77L3.11,18.45A2,2,0,0,0,2.7,21L5.06,25a2,2,0,0,0,1.73,1,2,2,0,0,0,.64-.1l2.43-.82a11.35,11.35,0,0,0,1.31.75l.51,2.52a2,2,0,0,0,2,1.61h4.72a2,2,0,0,0,2-1.61l.51-2.52a11.48,11.48,0,0,0,1.32-.75l2.42.82a2,2,0,0,0,.64.1,2,2,0,0,0,1.73-1L29.3,21a2,2,0,0,0-.41-2.51ZM25.21,24l-3.43-1.16a8.86,8.86,0,0,1-2.71,1.57L18.36,28H13.64l-.71-3.55a9.36,9.36,0,0,1-2.7-1.57L6.79,24,4.43,20l2.72-2.4a8.9,8.9,0,0,1,0-3.13L4.43,12,6.79,8l3.43,1.16a8.86,8.86,0,0,1,2.71-1.57L13.64,4h4.72l.71,3.55a9.36,9.36,0,0,1,2.7,1.57L25.21,8,27.57,12l-2.72,2.4a8.9,8.9,0,0,1,0,3.13L27.57,20Z"})),mg||(mg=i.createElement("path",{d:"M16,22a6,6,0,1,1,6-6A5.94,5.94,0,0,1,16,22Zm0-10a3.91,3.91,0,0,0-4,4,3.91,3.91,0,0,0,4,4,3.91,3.91,0,0,0,4-4A3.91,3.91,0,0,0,16,12Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,xh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),vg||(vg=i.createElement("path",{d:"M30 8h-4.1c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2v2h14.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30V8zM21 12c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3S22.7 12 21 12zM2 24h4.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30v-2H15.9c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2V24zM11 20c1.7 0 3 1.3 3 3s-1.3 3-3 3-3-1.3-3-3S9.3 20 11 20z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,zh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),cg||(cg=i.createElement("path",{d:"M16,22a6,6,0,1,1,6-6A5.9364,5.9364,0,0,1,16,22Zm0-10a3.9123,3.9123,0,0,0-4,4,3.9123,3.9123,0,0,0,4,4,3.9123,3.9123,0,0,0,4-4A3.9123,3.9123,0,0,0,16,12Z"})),ug||(ug=i.createElement("path",{d:"M29.3047,11.044,26.9441,6.9562a1.9977,1.9977,0,0,0-2.3728-.8946l-2.4341.8233a11.0419,11.0419,0,0,0-1.312-.7583L20.3215,3.608A2,2,0,0,0,18.36,2H13.64A2,2,0,0,0,11.6785,3.608l-.5037,2.5186A10.9666,10.9666,0,0,0,9.8481,6.88L7.4287,6.0616a1.9977,1.9977,0,0,0-2.3728.8946L2.6953,11.044a2.0006,2.0006,0,0,0,.4119,2.5025l1.9309,1.6968C5.021,15.4947,5,15.7447,5,16c0,.2578.01.5127.0278.7656l-1.9206,1.688a2.0006,2.0006,0,0,0-.4119,2.5025L5.0559,25.044a1.9977,1.9977,0,0,0,2.3728.8946l2.4341-.8233a10.9736,10.9736,0,0,0,1.312.7583l.5037,2.5186A2,2,0,0,0,13.64,30H18V28H13.64l-.71-3.5508a9.0953,9.0953,0,0,1-2.6948-1.5713L6.7878,24.044l-2.36-4.0878,2.7253-2.3951a8.9263,8.9263,0,0,1-.007-3.1279L4.4275,12.044,6.7886,7.9562l3.4267,1.1591a9.0305,9.0305,0,0,1,2.7141-1.5644L13.64,4H18.36l.71,3.5508a9.0978,9.0978,0,0,1,2.6948,1.5713l3.4468-1.166,2.36,4.0878-2.7978,2.4522L26.0923,16l2.8-2.4536A2.0006,2.0006,0,0,0,29.3047,11.044Z"})),fg||(fg=i.createElement("path",{d:"M23 26.18L20.41 23.59 19 25 23 29 30 22 28.59 20.59 23 26.18z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Lh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),bg||(bg=i.createElement("path",{d:"M29,25H27V23h1V19H24v1H22V18a1,1,0,0,1,1-1h6a1,1,0,0,1,1,1v6A1,1,0,0,1,29,25Z"})),pg||(pg=i.createElement("path",{d:"M24 30H18a1 1 0 01-1-1V23a1 1 0 011-1h6a1 1 0 011 1v6A1 1 0 0124 30zm-5-2h4V24H19zM15 19.8579A3.9934 3.9934 0 1120 16h2a6 6 0 10-7 5.91z"})),gg||(gg=i.createElement("path",{d:"M28.89,13.55l-2.31,2.03-1.42-1.42,2.41-2.12L25.21,7.96,21.77,9.12a9.3684,9.3684,0,0,0-2.7-1.57L18.36,4H13.64l-.71,3.55a8.8609,8.8609,0,0,0-2.71,1.57L6.79,7.96,4.43,12.04l2.72,2.39a8.8948,8.8948,0,0,0,0,3.13l-2.72,2.4,2.36,4.08,3.44-1.16a9.3684,9.3684,0,0,0,2.7,1.57L13.64,28H15v2H13.64a2.0007,2.0007,0,0,1-1.96-1.61l-.51-2.52a11.412,11.412,0,0,1-1.31-.75l-2.43.82a2.038,2.038,0,0,1-.64.1,1.973,1.973,0,0,1-1.73-1L2.7,20.96a2,2,0,0,1,.41-2.51l1.92-1.68C5.01,16.51,5,16.26,5,16s.02-.51.04-.76L3.11,13.55a2,2,0,0,1-.41-2.51L5.06,6.96a1.973,1.973,0,0,1,1.73-1,2.038,2.038,0,0,1,.64.1l2.42.82a11.5416,11.5416,0,0,1,1.32-.75l.51-2.52A2.0007,2.0007,0,0,1,13.64,2h4.72a2.0007,2.0007,0,0,1,1.96,1.61l.51,2.52a11.412,11.412,0,0,1,1.31.75l2.43-.82a2.038,2.038,0,0,1,.64-.1,1.973,1.973,0,0,1,1.73,1l2.36,4.08A2,2,0,0,1,28.89,13.55Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Mh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Eg||(Eg=i.createElement("circle",{cx:"23",cy:"24",r:"2"})),wg||(wg=i.createElement("path",{d:"M30.7769 23.4785A8.64 8.64 0 0023 18a8.64 8.64 0 00-7.7769 5.4785L15 24l.2231.5215A8.64 8.64 0 0023 30a8.64 8.64 0 007.7769-5.4785L31 24zM23 28a4 4 0 114-4A4.0045 4.0045 0 0123 28zM12.3989 20.8A6 6 0 1122 16H20a4 4 0 10-6.4 3.2z"})),hg||(hg=i.createElement("path",{d:"M29.3047,11.0439,26.9441,6.9561a1.9977,1.9977,0,0,0-2.3728-.8946l-2.4341.8233a11.0419,11.0419,0,0,0-1.312-.7583l-.5037-2.5186A2,2,0,0,0,18.36,2H13.64a2,2,0,0,0-1.9611,1.6079l-.5037,2.5186A10.9666,10.9666,0,0,0,9.8481,6.88L7.4287,6.0615a1.9977,1.9977,0,0,0-2.3728.8946L2.6953,11.0439a2.0006,2.0006,0,0,0,.4119,2.5025l1.9309,1.6968C5.021,15.4946,5,15.7446,5,16c0,.2578.01.5127.0278.7656l-1.9206,1.688a2.0006,2.0006,0,0,0-.4119,2.5025l2.3606,4.0878a1.9977,1.9977,0,0,0,2.3728.8946l2.4341-.8233a10.9736,10.9736,0,0,0,1.312.7583l.5037,2.5186A2,2,0,0,0,13.64,30H15V28H13.64l-.71-3.5508a9.0953,9.0953,0,0,1-2.6948-1.5713l-3.4468,1.166-2.36-4.0878L7.1528,17.561a8.9263,8.9263,0,0,1-.007-3.1279L4.4275,12.0439,6.7886,7.9561l3.4267,1.1591a9.0305,9.0305,0,0,1,2.7141-1.5644L13.64,4H18.36l.71,3.5508a9.0978,9.0978,0,0,1,2.6948,1.5713l3.4468-1.166,2.36,4.0878-2.7978,2.4522L26.0923,16l2.8-2.4536A2.0006,2.0006,0,0,0,29.3047,11.0439Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Rh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),xg||(xg=i.createElement("path",{d:"M28,10H22V4a2.0023,2.0023,0,0,0-2-2H4A2.0025,2.0025,0,0,0,2,4V20a2.0025,2.0025,0,0,0,2,2h6v6a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V12A2,2,0,0,0,28,10ZM12,20V12h8v8ZM3.9988,4H20v6H12a2.0023,2.0023,0,0,0-2,2v8H4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Sh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),zg||(zg=i.createElement("path",{d:"M12,10H22V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V20a2,2,0,0,0,2,2h6V12A2,2,0,0,1,12,10Z"})),Lg||(Lg=i.createElement("path",{d:"M28,10H22V20a2,2,0,0,1-2,2H10v6a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V12A2,2,0,0,0,28,10Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Dh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Mg||(Mg=i.createElement("path",{d:"M28,10H22V4a2.0025,2.0025,0,0,0-2-2H4A2.0025,2.0025,0,0,0,2,4V20a2.0025,2.0025,0,0,0,2,2h6v6a2.0025,2.0025,0,0,0,2,2H28a2.0025,2.0025,0,0,0,2-2V12A2.0025,2.0025,0,0,0,28,10ZM4,20V4H20v6H12a2.0025,2.0025,0,0,0-2,2v8Zm8,8V22h8a2.0025,2.0025,0,0,0,2-2V12h6V28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,yh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Rg||(Rg=i.createElement("path",{d:"M28,10H22V4a2.0025,2.0025,0,0,0-2-2H4A2.0025,2.0025,0,0,0,2,4V20a2.0025,2.0025,0,0,0,2,2h6v6a2.0025,2.0025,0,0,0,2,2H28a2.0025,2.0025,0,0,0,2-2V12A2.0025,2.0025,0,0,0,28,10ZM4,20V4h6V20Zm18,8V12h6V28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Vh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Sg||(Sg=i.createElement("path",{d:"M28,10H22V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V20a2,2,0,0,0,2,2h6v6a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V12A2,2,0,0,0,28,10Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ah);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Dg||(Dg=i.createElement("path",{d:"M23,20a5,5,0,0,0-3.89,1.89L11.8,17.32a4.46,4.46,0,0,0,0-2.64l7.31-4.57A5,5,0,1,0,18,7a4.79,4.79,0,0,0,.2,1.32l-7.31,4.57a5,5,0,1,0,0,6.22l7.31,4.57A4.79,4.79,0,0,0,18,25a5,5,0,1,0,5-5ZM23,4a3,3,0,1,1-3,3A3,3,0,0,1,23,4ZM7,19a3,3,0,1,1,3-3A3,3,0,0,1,7,19Zm16,9a3,3,0,1,1,3-3A3,3,0,0,1,23,28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Th);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),yg||(yg=i.createElement("path",{d:"M27 25H21a3 3 0 00-3 3v2h2V28a1 1 0 011-1h6a1 1 0 011 1v2h2V28A3 3 0 0027 25zM20 20a4 4 0 104-4A4 4 0 0020 20zm6 0a2 2 0 11-2-2A2 2 0 0126 20zM6 21V20H4v1a7 7 0 007 7h3V26H11A5 5 0 016 21zM19 10H26V12H19zM19 6H29V8H19zM19 2H29V4H19zM11 11H5a3 3 0 00-3 3v2H4V14a1 1 0 011-1h6a1 1 0 011 1v2h2V14A3 3 0 0011 11zM8 10A4 4 0 104 6 4 4 0 008 10zM8 4A2 2 0 116 6 2 2 0 018 4z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Wh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Vg||(Vg=i.createElement("path",{d:"M28.76,11.35A1,1,0,0,0,28,11H22V7a3,3,0,0,0-3-3H13a3,3,0,0,0-3,3v4H4a1,1,0,0,0-1,1.15L4.88,24.3a2,2,0,0,0,2,1.7H25.14a2,2,0,0,0,2-1.7L29,12.15A1,1,0,0,0,28.76,11.35ZM12,7a1,1,0,0,1,1-1h6a1,1,0,0,1,1,1v4H12ZM25.14,24H6.86L5.17,13H26.83Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Uh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ag||(Ag=i.createElement("circle",{cx:"10",cy:"28",r:"2"})),Tg||(Tg=i.createElement("circle",{cx:"24",cy:"28",r:"2"})),Wg||(Wg=i.createElement("path",{d:"M28,7H5.82L5,2.8A1,1,0,0,0,4,2H0V4H3.18L7,23.2A1,1,0,0,0,8,24H26V22H8.82L8,18H26a1,1,0,0,0,1-.78l2-9A1,1,0,0,0,28,7Zm-2.8,9H7.62L6.22,9H26.75Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ih);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Ug||(Ug=i.createElement("circle",{cx:"10",cy:"28",r:"2"})),Ig||(Ig=i.createElement("circle",{cx:"24",cy:"28",r:"2"})),Bg||(Bg=i.createElement("path",{d:"M4.9806,2.8039A1,1,0,0,0,4,2H0V4H3.18L7.0194,23.1961A1,1,0,0,0,8,24H26V22H8.82l-.8-4H26a1,1,0,0,0,.9762-.783L29.2445,7H27.1971l-1.9989,9H7.62Z"})),Og||(Og=i.createElement("path",{d:"M21.586 6.586L18 10.172 18 2 16 2 16 10.172 12.414 6.586 11 8 17 14 23 8 21.586 6.586z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Bh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Fg||(Fg=i.createElement("circle",{cx:"10",cy:"28",r:"2"})),qg||(qg=i.createElement("circle",{cx:"24",cy:"28",r:"2"})),Xg||(Xg=i.createElement("path",{d:"M4.9806,2.8039A1,1,0,0,0,4,2H0V4H3.18L7.0194,23.1961A1,1,0,0,0,8,24H26V22H8.82l-.8-4H26a1,1,0,0,0,.9762-.783L29.2445,7H27.1971l-1.9989,9H7.62Z"})),Cg||(Cg=i.createElement("path",{d:"M21.586 9.414L18 5.828 18 14 16 14 16 5.828 12.414 9.414 11 8 17 2 23 8 21.586 9.414z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Oh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Hg||(Hg=i.createElement("circle",{cx:"10",cy:"28",r:"2"})),kg||(kg=i.createElement("circle",{cx:"24",cy:"28",r:"2"})),Ng||(Ng=i.createElement("path",{d:"M4.9806,2.8039A1,1,0,0,0,4,2H0V4H3.18L7.0194,23.1961A1,1,0,0,0,8,24H26V22H8.82l-.8-4H26a1,1,0,0,0,.9762-.783L29.2445,7H27.1971l-1.9989,9H7.62Z"})),Zg||(Zg=i.createElement("path",{d:"M18.41 8L22 4.41 20.59 3 17 6.59 13.41 3 12 4.41 15.59 8 12 11.59 13.41 13 17 9.41 20.59 13 22 11.59 18.41 8z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Fh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Yg||(Yg=i.createElement("circle",{cx:"10",cy:"28",r:"2"})),Pg||(Pg=i.createElement("circle",{cx:"24",cy:"28",r:"2"})),jg||(jg=i.createElement("path",{d:"M4.9806,2.8039A1,1,0,0,0,4,2H0V4H3.18L7.0194,23.1961A1,1,0,0,0,8,24H26V22H8.82l-.8-4H26a1,1,0,0,0,.9762-.783L29.2445,7H27.1971l-1.9989,9H7.62Z"})),Kg||(Kg=i.createElement("path",{d:"M17,2a6,6,0,1,0,6,6A6.0066,6.0066,0,0,0,17,2Zm0,2a3.9521,3.9521,0,0,1,2.019.5669L13.5669,10.019A3.9529,3.9529,0,0,1,13,8,4.0045,4.0045,0,0,1,17,4Zm0,8a3.9521,3.9521,0,0,1-2.019-.5669L20.4331,5.981A3.9529,3.9529,0,0,1,21,8,4.0045,4.0045,0,0,1,17,12Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,qh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),Gg||(Gg=i.createElement("circle",{cx:"10",cy:"28",r:"2"})),Qg||(Qg=i.createElement("circle",{cx:"24",cy:"28",r:"2"})),Jg||(Jg=i.createElement("path",{d:"M4.9806,2.8039A1,1,0,0,0,4,2H0V4H3.18L7.0194,23.1961A1,1,0,0,0,8,24H26V22H8.82l-.8-4H26a1,1,0,0,0,.9762-.783L29.2445,7H27.1971l-1.9989,9H7.62Z"})),$g||($g=i.createElement("path",{d:"M12 6L12 8 22 8 22 6 12 6z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Xh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),eE||(eE=i.createElement("circle",{cx:"10",cy:"28",r:"2"})),iE||(iE=i.createElement("circle",{cx:"24",cy:"28",r:"2"})),tE||(tE=i.createElement("path",{d:"M4.9806,2.8039A1,1,0,0,0,4,2H0V4H3.18L7.0194,23.1961A1,1,0,0,0,8,24H26V22H8.82l-.8-4H26a1,1,0,0,0,.9762-.783L29.2445,7H27.1971l-1.9989,9H7.62Z"})),_E||(_E=i.createElement("path",{d:"M18 6L18 2 16 2 16 6 12 6 12 8 16 8 16 12 18 12 18 8 22 8 22 6 18 6z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ch);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),sE||(sE=i.createElement("path",{d:"M17 24H21V28H17zM24 24H28V28H24zM17 17H21V21H17zM24 17H28V21H24z"})),aE||(aE=i.createElement("path",{d:"M28,11h-6V7c0-1.7-1.3-3-3-3h-6c-1.7,0-3,1.3-3,3v4H4c-0.6,0-1,0.4-1,1c0,0.1,0,0.1,0,0.2l1.9,12.1c0.1,1,1,1.7,2,1.7H15v-2 H6.9L5.2,13H28V11z M12,7c0-0.6,0.4-1,1-1h6c0.6,0,1,0.4,1,1v4h-8V7z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Hh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),nE||(nE=i.createElement("path",{d:"M28 10H4A2.0022 2.0022 0 012 8V4A2.0021 2.0021 0 014 2H28a2.0021 2.0021 0 012 2V8A2.0022 2.0022 0 0128 10zM4 4V8H28V4zM28 30H4a2.0022 2.0022 0 01-2-2V24a2.0021 2.0021 0 012-2H28a2.0021 2.0021 0 012 2v4A2.0022 2.0022 0 0128 30zM4 24v4H28V24zM28 20H4a2.0022 2.0022 0 01-2-2V14a2.0021 2.0021 0 012-2H28a2.0021 2.0021 0 012 2v4A2.0022 2.0022 0 0128 20zM4 14v4H28V14z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,kh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),rE||(rE=i.createElement("path",{d:"M28 28H17a2.0023 2.0023 0 01-2-2V20a2.0023 2.0023 0 012-2H28a2.0027 2.0027 0 012 2v6A2.0027 2.0027 0 0128 28zM17 20v6H28.002L28 20zM12 10L12 13.586 7.707 9.293 6.293 10.707 10.586 15 7 15 7 17 14 17 14 10 12 10z"})),lE||(lE=i.createElement("path",{d:"M13,22H4a2.0023,2.0023,0,0,1-2-2V7A2.002,2.002,0,0,1,4,5H26a2.0023,2.0023,0,0,1,2,2v9H26V7H4V20h9Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Nh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),dE||(dE=i.createElement("rect",{width:"15",height:"10",x:"15",y:"18",rx:"2"})),oE||(oE=i.createElement("path",{d:"M12 10L12 13.586 7.707 9.293 6.293 10.707 10.586 15 7 15 7 17 14 17 14 10 12 10z"})),mE||(mE=i.createElement("path",{d:"M13,22H4a2.0023,2.0023,0,0,1-2-2V7A2.002,2.002,0,0,1,4,5H26a2.0023,2.0023,0,0,1,2,2v9H26V7H4V20h9Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Zh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),vE||(vE=i.createElement("path",{d:"M22.59,19.41,26.17,23H19.55l-4.37-7,4.37-7h6.62l-3.58,3.59L24,14l6-6L24,2,22.59,3.41,26.17,7H19.55a2,2,0,0,0-1.69.94L14,14.11,10.14,7.94A2,2,0,0,0,8.45,7H2V9H8.45l4.37,7L8.45,23H2v2H8.45a2,2,0,0,0,1.69-.94L14,17.89l3.86,6.17a2,2,0,0,0,1.69.94h6.62l-3.58,3.59L24,30l6-6-6-6Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Yh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),cE||(cE=i.createElement("path",{d:"M29.81,16l-7-9.56A1,1,0,0,0,22,6H3A1,1,0,0,0,2,7V24a1,1,0,0,0,1,1H5.14a4,4,0,0,0,7.72,0h6.28a4,4,0,0,0,7.72,0H29a1,1,0,0,0,1-1V16.56A1,1,0,0,0,29.81,16ZM20,8h1.49l5.13,7H20ZM4,8H18v7H4ZM9,26a2,2,0,1,1,2-2A2,2,0,0,1,9,26Zm14,0a2,2,0,1,1,2-2A2,2,0,0,1,23,26Zm5-3H26.86a4,4,0,0,0-7.72,0H12.86a4,4,0,0,0-7.72,0H4V17H28Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Ph);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),uE||(uE=i.createElement("path",{d:"M10 12H12V14H10zM6 12H8V14H6zM2 12H4V14H2zM26 30H24V27H20a5.0055 5.0055 0 01-5-5V20.7207l-2.3162-.772a1 1 0 01-.5412-1.4631L15 13.7229V11a9.01 9.01 0 019-9h5V4H24a7.0078 7.0078 0 00-7 7v3a.9991.9991 0 01-.1426.5144l-2.3586 3.9312 1.8174.6057A1 1 0 0117 20v2a3.0033 3.0033 0 003 3h5a1 1 0 011 1z"})),fE||(fE=i.createElement("path",{d:"M19 12H23V14H19z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,jh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),bE||(bE=i.createElement("path",{d:"M24 5L7 5 7 7.414 15.586 16 7 24.586 7 27 24 27 24 25 9.414 25 18.414 16 9.414 7 24 7 24 5z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Kh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),pE||(pE=i.createElement("path",{d:"M26 6H28V26H26zM18 11H20V26H18zM11 16H13V26H11zM4 20H6V26H4z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Gh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),gE||(gE=i.createElement("path",{d:"M21,9H8a2.0023,2.0023,0,0,0-2,2V21a2.0023,2.0023,0,0,0,2,2H21a2.0023,2.0023,0,0,0,2-2V11A2.0023,2.0023,0,0,0,21,9Zm0,4H18V11h3Zm-3,2h3v2H18Zm-2-4V21H13V14a1,1,0,0,0-1-1H8V11Zm-5,6H8V15h3ZM8,19h3v2H8Zm10,2V19h3v2Z"})),EE||(EE=i.createElement("path",{d:"M23.5317,27H4a2.0021,2.0021,0,0,1-2-2V7A2.0021,2.0021,0,0,1,4,5H28a2.0021,2.0021,0,0,1,2,2V19.6379a2.0044,2.0044,0,0,1-.4639,1.2808L25.0679,26.28A1.9944,1.9944,0,0,1,23.5317,27ZM4,7V25H23.5317L28,19.6379V7Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Qh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),wE||(wE=i.createElement("path",{d:"M30 30H22V4h8zm-6-2h4V6H24zM20 30H12V12h8zm-6-2h4V14H14zM10 30H2V18h8zM4 28H8V20H4z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,Jh);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),hE||(hE=i.createElement("path",{d:"M30 30H22V4h8zM20 30H12V12h8zM10 30H2V18h8z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,$h);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),xE||(xE=i.createElement("path",{d:"M30 30H22V4h8zm-6-2h4V6H24zM20 30H12V12h8zm-6-2h4V14H14zM10 30H2V18h8z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ex);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),zE||(zE=i.createElement("path",{d:"M30 30H22V4h8zm-6-2h4V6H24zM20 30H12V12h8zM10 30H2V18h8z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ix);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),LE||(LE=i.createElement("path",{d:"M27 28a1 1 0 01-.5-.13l-19-11a1 1 0 010-1.74l19-11a1 1 0 011 0A1 1 0 0128 5V27a1 1 0 01-1 1zM10 16l16 9.27V6.73zM2 4H4V28H2z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,tx);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),ME||(ME=i.createElement("path",{d:"M27 28a.9975.9975 0 01-.501-.1348l-19-11a1 1 0 010-1.73l19-11A1 1 0 0128 5V27a1 1 0 01-1 1zM2 4H4V28H2z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,_x);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),RE||(RE=i.createElement("path",{d:"M23,22a1.0037,1.0037,0,0,1-.4858-.1257l-9-5a1,1,0,0,1,0-1.7485l9-5A1,1,0,0,1,24,11V21a1,1,0,0,1-1,1Zm-6.9409-6L22,19.3006V12.7Z"})),SE||(SE=i.createElement("path",{d:"M9 10H11V22H9z",transform:"rotate(-180 10 16)"})),DE||(DE=i.createElement("path",{d:"M16,30A14,14,0,1,1,30,16,14.0158,14.0158,0,0,1,16,30ZM16,4A12,12,0,1,0,28,16,12.0137,12.0137,0,0,0,16,4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,sx);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),yE||(yE=i.createElement("path",{d:"M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2ZM10,22H8V10h2Zm14-1a1,1,0,0,1-1.4858.874l-9-5a1,1,0,0,1,0-1.748l9-5A1,1,0,0,1,24,11Z"})),VE||(VE=i.createElement("path",{d:"M22 19.301L22 12.699 16.059 16 22 19.301z"})),AE||(AE=i.createElement("path",{fill:"none",d:"M23,22a1.0037,1.0037,0,0,1-.4858-.1257l-9-5a1,1,0,0,1,0-1.7486l9-5A1,1,0,0,1,24,11V21a1,1,0,0,1-1,1Zm-6.9409-6L22,19.3005V12.7Z"})),TE||(TE=i.createElement("path",{fill:"none",d:"M8 10H10V22H8z",transform:"rotate(-180 9 16)"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,ax);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),WE||(WE=i.createElement("path",{d:"M23,22a1.0037,1.0037,0,0,1-.4858-.1257l-9-5a1,1,0,0,1,0-1.7485l9-5A1,1,0,0,1,24,11V21a1,1,0,0,1-1,1Z"})),UE||(UE=i.createElement("path",{d:"M9 10H11V22H9z",transform:"rotate(-180 10 16)"})),IE||(IE=i.createElement("path",{d:"M16,30A14,14,0,1,1,30,16,14.0158,14.0158,0,0,1,16,30ZM16,4A12,12,0,1,0,28,16,12.0137,12.0137,0,0,0,16,4Z"})),_)})).propTypes=da,i.forwardRef((function(e,t){var _=e.children,s=e.size,a=void 0===s?16:s,n=re(e,nx);return i.createElement(oe,ae({width:a,height:a,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},n),BE||(BE=i.createElement("path",{d:"M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2ZM10,22H8V10h2Zm14-1a1,1,0,0,1-1.4858.874l-9-5a1,1,0,0,1,0-1.748l9-5A1,1,0,0,1,24,11Z"})),OE||(OE=i.createElement("path",{fill:"none",d:"M23,22a1.0037,1.0037,0,0,1-.4858-.1257l-9-5a1,1,0,0,1,0-1.7486l9-5A1,1,0,0,1,24,11V21a1,1,0,0,1-1,1Z"})),FE||(FE=i.createElement("path",{fill:"none",d:"M8 10H10V22H8z",transform:"rotate(-180 9 16)"})),_)})).propTypes=da;var dx=["autoComplete","className","closeButtonLabelText","defaultValue","disabled","id","labelText","light","onChange","onClear","onKeyDown","onExpand","placeholder","renderIcon","role","size","type","value"],ox=i.forwardRef((function(e,t){var _,s,a,n=e.autoComplete,r=void 0===n?"off":n,l=e.className,d=e.closeButtonLabelText,o=void 0===d?"Clear search input":d,m=e.defaultValue,v=e.disabled,c=e.id,u=e.labelText,f=e.light,b=e.onChange,p=void 0===b?function(){}:b,g=e.onClear,E=void 0===g?function(){}:g,w=e.onKeyDown,h=e.onExpand,x=e.placeholder,z=void 0===x?"":x,L=e.renderIcon,M=e.role,R=void 0===M?"searchbox":M,S=e.size,D=void 0===S?"md":S,y=e.type,V=void 0===y?"text":y,W=e.value,U=B(e,dx),I=Z(),O=(0,i.useRef)(null),F=(a=[t,O],(0,i.useCallback)((function(e){a.forEach((function(i){"function"===typeof i?i(e):null!==i&&void 0!==i&&(i.current=e)}))}),a)),X=Ir("search-input"),C=c||X,H="".concat(C,"-search"),N=q((0,i.useState)(W||m||!1),2),Y=N[0],P=N[1],j=q((0,i.useState)(W),2),K=j[0],G=j[1],Q=k()((A(_={},"".concat(I,"--search"),!0),A(_,"".concat(I,"--search--sm"),"sm"===D),A(_,"".concat(I,"--search--md"),"md"===D),A(_,"".concat(I,"--search--lg"),"lg"===D),A(_,"".concat(I,"--search--light"),f),A(_,"".concat(I,"--search--disabled"),v),A(_,l,l),_)),J=k()((A(s={},"".concat(I,"--search-close"),!0),A(s,"".concat(I,"--search-close--hidden"),!Y),s));function $(e){if(W){var i=Object.assign({},e.target,{target:{value:""}});p(i)}else O.current.value="",p(e);E(),P(!1),function(e){var i=e.current||e;i&&i.focus&&document.activeElement!==i&&i.focus()}(O)}return W!==K&&(P(!!W),G(W)),i.createElement("div",{role:"search","aria-labelledby":H,className:Q},i.createElement("div",{role:h?"button":null,className:"".concat(I,"--search-magnifier"),onClick:function(){h&&h()}},i.createElement(mx,{icon:L})),i.createElement("label",{id:H,htmlFor:C,className:"".concat(I,"--label")},u),i.createElement("input",T({},U,{autoComplete:r,className:"".concat(I,"--search-input"),defaultValue:m,disabled:v,role:R,ref:F,id:C,onChange:Ll([p,function(e){P(""!==e.target.value)}]),onKeyDown:Ll([w,function(e){Cr(e,Hr)&&(e.stopPropagation(),$(e))}]),placeholder:z,type:V,value:W})),i.createElement("button",{"aria-label":o,className:J,disabled:v,onClick:$,type:"button"},rx||(rx=i.createElement(Vr,null))))}));function mx(e){var t=e.icon,_=Z();return t?i.cloneElement(t,{className:"".concat(_,"--search-magnifier-icon")}):i.createElement(lx,{className:"".concat(_,"--search-magnifier-icon")})}ox.propTypes={autoComplete:P().string,className:P().string,closeButtonLabelText:P().string,defaultValue:P().oneOfType([P().string,P().number]),disabled:P().bool,id:P().string,labelText:P().node.isRequired,light:Or(P().bool),onChange:P().func,onClear:P().func,onExpand:P().func,onKeyDown:P().func,placeholder:P().string,renderIcon:P().oneOfType([P().func,P().object]),role:P().string,size:P().oneOf(["sm","md","lg"]),type:P().string,value:P().oneOfType([P().string,P().number])},mx.propTypes={icon:P().oneOfType([P().func,P().object])};var vx,cx=ox,ux=(0,i.createContext)(w);P().node,P().objectOf(P().bool);var fx=["className","type","id","placeHolderText","placeholder","labelText","closeButtonLabelText","small","size","light","disabled","onChange","onKeyDown","renderIcon","onClear"],bx=function(e){W(_,e);var t=F(_);function _(){var e;D(this,_);for(var i=arguments.length,s=new Array(i),a=0;a<i;a++)s[a]=arguments[a];return A(O(e=t.call.apply(t,[this].concat(s))),"state",{hasContent:e.props.value||e.props.defaultValue||!1,prevValue:e.props.value}),A(O(e),"clearInput",(function(i){if(e.props.value){var t=Object.assign({},i.target,{target:{value:""}});e.props.onChange(t)}else e.input.value="",e.props.onChange(i);e.props.onClear(),e.setState({hasContent:!1},(function(){return e.input.focus()}))})),A(O(e),"handleChange",(function(i){e.setState({hasContent:""!==i.target.value})})),A(O(e),"handleKeyDown",(function(i){Cr(i,Hr)&&e.clearInput(i)})),e}return V(_,[{key:"render",value:function(){var e=this,t=this.props,_=t.className,s=t.type,a=t.id,n=void 0===a?this._inputId=this._inputId||"search__input__id_".concat(Math.random().toString(36).substr(2)):a,r=t.placeHolderText,l=t.placeholder,d=t.labelText,o=t.closeButtonLabelText,m=t.small,v=t.size,c=void 0===v?m?"sm":"xl":v,u=t.light,f=t.disabled,b=t.onChange,p=t.onKeyDown,g=t.renderIcon;t.onClear;var E,w=B(t,fx),h=this.state.hasContent,x=this.context;return x.enabled&&(E=x.enabled("enable-v11-release")),i.createElement(N.Consumer,null,(function(t){var a,m,v,x=k()((A(a={},"".concat(t,"--search"),!0),A(a,"".concat(t,"--search--sm"),"sm"===c),A(a,"".concat(t,"--search--lg"),E?"md"===c:"lg"===c),A(a,"".concat(t,"--search--xl"),E?"lg"===c:"xl"===c),A(a,"".concat(t,"--search--light"),u),A(a,"".concat(t,"--search--disabled"),f),A(a,_,_),a)),z=k()((A(m={},"".concat(t,"--search-close"),!0),A(m,"".concat(t,"--search-close--hidden"),!h),m));g&&(v=i.cloneElement(g,{className:"".concat(t,"--search-magnifier-icon")}));var L="".concat(n,"-search"),M=g?v:i.createElement(lx,{className:"".concat(t,"--search-magnifier-icon")});return i.createElement("div",{role:"search","aria-labelledby":L,className:x},i.createElement("div",{className:"".concat(t,"--search-magnifier"),ref:function(i){e.magnifier=i}},M),i.createElement("label",{id:L,htmlFor:n,className:"".concat(t,"--label")},d),i.createElement("input",T({role:"searchbox",autoComplete:"off"},w,{type:s,disabled:f,className:"".concat(t,"--search-input"),id:n,placeholder:r||l,onChange:Ll([b,e.handleChange]),onKeyDown:Ll([p,e.handleKeyDown]),ref:function(i){e.input=i}})),i.createElement("button",{className:z,disabled:f,onClick:e.clearInput,type:"button","aria-label":o},vx||(vx=i.createElement(Vr,null))))}))}}],[{key:"getDerivedStateFromProps",value:function(e,i){var t=e.value;return i.prevValue===t?null:{hasContent:!!t,prevValue:t}}}]),_}(i.Component);A(bx,"propTypes",{className:P().string,closeButtonLabelText:P().string,defaultValue:P().oneOfType([P().string,P().number]),disabled:P().bool,id:P().string,labelText:P().node.isRequired,light:P().bool,onChange:P().func,onClear:P().func,onKeyDown:P().func,placeHolderText:Or(P().string),placeholder:P().string,renderIcon:P().oneOfType([P().func,P().object]),size:P().oneOf(["sm","md","lg","xl"]),small:Or(P().bool),type:P().string,value:P().oneOfType([P().string,P().number])}),A(bx,"contextType",ux),A(bx,"defaultProps",{type:"text",placeholder:"",closeButtonLabelText:"Clear search input",onChange:function(){},onClear:function(){}});var px=L("enable-v11-release")?cx:bx;var gx,Ex=(gx={"aria-label":P().string,"aria-labelledby":P().string},Object.keys(gx).reduce((function(e,i){return R(R({},e),{},A({},i,(t=gx[i],function(e,i,_){for(var s=arguments.length,a=new Array(s>3?s-3:0),n=3;n<s;n++)a[n-3]=arguments[n];return t.apply(void 0,[e,i,_].concat(a))})));var t}),{})),wx=["aria-label","aria-labelledby","children","className"],hx=function(e){W(_,e);var t=F(_);function _(e){var s;return D(this,_),A(O(s=t.call(this,e)),"handleItemRef",(function(e){return function(i){s.items[e]=i}})),A(O(s),"_renderNavItem",(function(e,t){if(i.isValidElement(e))return i.cloneElement(e,{ref:s.handleItemRef(t)})})),s.items=[],s.state={selectedIndex:0},s}return V(_,[{key:"render",value:function(){var e=this.context,t=this.props,_=t["aria-label"],s=t["aria-labelledby"],a=t.children,n=t.className,r=B(t,wx),l=k()("".concat(e,"--header__nav"),n),d={"aria-label":_,"aria-labelledby":s};return i.createElement("nav",T({},r,d,{className:l}),i.createElement("ul",T({},d,{className:"".concat(e,"--header__menu-bar")}),i.Children.map(a,this._renderNavItem)))}}]),_}(i.Component);A(hx,"propTypes",R(R({},Ex),{},{children:P().node,className:P().string})),A(hx,"contextType",N);var xx=function(e){var t,_=e.children,s=e.className,a=e.small,n=Z(),r=k()((A(t={},"".concat(n,"--side-nav__icon"),!0),A(t,"".concat(n,"--side-nav__icon--small"),a),A(t,s,!!s),t));return i.createElement("div",{className:r},_)};xx.propTypes={children:P().node.isRequired,className:P().string,small:P().bool.isRequired},xx.defaultProps={small:!1};var zx,Lx=xx,Mx=function(e){W(_,e);var t=F(_);function _(e){var i;return D(this,_),A(O(i=t.call(this,e)),"handleToggleExpand",(function(){i.setState((function(e){return{isExpanded:!e.isExpanded}}))})),A(O(i),"handleKeyDown",(function(e){Cr(e,Hr)&&i.setState((function(){return{isExpanded:!1}}))})),i.state={isExpanded:e.defaultExpanded||!1,wasPreviouslyExpanded:e.defaultExpanded||!1},i}return V(_,[{key:"render",value:function(){var e,t,_=this.context,s=this.props,a=s.buttonRef,n=s.className,r=s.children,l=s.renderIcon,d=s.isActive,o=s.title,m=s.large,v=this.state.isExpanded;r&&(t=Array.isArray(r)?r.some((function(e){return!(!e.props||!0!==e.props.isActive&&!e.props["aria-current"])})):r.props&&(!0===r.props.isActive||r.props["aria-current"]));var c=k()((A(e={},"".concat(_,"--side-nav__item"),!0),A(e,"".concat(_,"--side-nav__item--active"),d||t&&!v),A(e,"".concat(_,"--side-nav__item--icon"),l),A(e,"".concat(_,"--side-nav__item--large"),m),A(e,n,!!n),e));return i.createElement("li",{className:c,onKeyDown:this.handleKeyDown},i.createElement("button",{"aria-expanded":v,className:"".concat(_,"--side-nav__submenu"),onClick:this.handleToggleExpand,ref:a,type:"button"},l&&i.createElement(Lx,null,i.createElement(l,null)),i.createElement("span",{className:"".concat(_,"--side-nav__submenu-title")},o),i.createElement(Lx,{className:"".concat(_,"--side-nav__submenu-chevron"),small:!0},zx||(zx=i.createElement(Dr,{size:20})))),i.createElement("ul",{className:"".concat(_,"--side-nav__menu")},r))}}]),_}(i.Component);A(Mx,"contextType",N),A(Mx,"propTypes",{buttonRef:P().oneOfType([P().func,P().shape({current:P().any})]),children:P().node,className:P().string,defaultExpanded:P().bool,isActive:P().bool,isSideNavExpanded:P().bool,large:P().bool,renderIcon:P().oneOfType([P().func,P().object]),title:P().string.isRequired}),A(Mx,"defaultProps",{defaultExpanded:!1,isActive:!1,large:!1}),A(Mx,"getDerivedStateFromProps",(function(e,i){var t=null;return!1===e.isSideNavExpanded&&!0===i.isExpanded?t={isExpanded:e.isSideNavExpanded,wasPreviouslyExpanded:!0}:!0===e.isSideNavExpanded&&!0===i.wasPreviouslyExpanded&&(t={isExpanded:e.isSideNavExpanded,wasPreviouslyExpanded:!1}),t}));var Rx=i.forwardRef((function(e,t){return i.createElement(Mx,T({},e,{buttonRef:t}))}));Rx.displayName="SideNavMenu";var Sx,Dx=Rx,yx=i.forwardRef((function(e,t){var _,s=e.className,a=e.children,n=e.defaultExpanded,r=void 0!==n&&n,l=e.isActive,d=void 0!==l&&l,o=e.large,m=void 0!==o&&o,v=e.renderIcon,c=e.isSideNavExpanded,u=e.title,f=Z(),b=q((0,i.useState)(r),2),p=b[0],g=b[1],E=q((0,i.useState)(r),2),w=E[0],h=E[1],x=k()((A(_={},"".concat(f,"--side-nav__item"),!0),A(_,"".concat(f,"--side-nav__item--active"),d||function(e){if(Array.isArray(e))return e.some((function(e){return!!e.props&&(!0===e.props.isActive||!!e.props["aria-current"])}));if(e.props&&(!0===e.props.isActive||e.props["aria-current"]))return!0;return!1}(a)&&!p),A(_,"".concat(f,"--side-nav__item--icon"),v),A(_,"".concat(f,"--side-nav__item--large"),m),A(_,s,!!s),_));return!1===c&&!0===p?(g(!1),h(!0)):!0===c&&!0===w&&(g(!0),h(!1)),i.createElement("li",{className:x,onKeyDown:function(e){Cr(e,Hr)&&g(!1)}},i.createElement("button",{"aria-expanded":p,className:"".concat(f,"--side-nav__submenu"),onClick:function(){g(!p)},ref:t,type:"button"},v&&i.createElement(Lx,null,i.createElement(v,null)),i.createElement("span",{className:"".concat(f,"--side-nav__submenu-title")},u),i.createElement(Lx,{className:"".concat(f,"--side-nav__submenu-chevron"),small:!0},Sx||(Sx=i.createElement(Dr,{size:20})))),i.createElement("ul",{className:"".concat(f,"--side-nav__menu")},a))}));yx.propTypes={children:P().node,className:P().string,defaultExpanded:P().bool,isActive:P().bool,isSideNavExpanded:P().bool,large:P().bool,renderIcon:P().oneOfType([P().func,P().object]),title:P().string.isRequired};var Vx=["aria-label","aria-labelledby","children","className"];function Ax(e){var t=e["aria-label"],_=e["aria-labelledby"],s=e.children,a=e.className,n=B(e,Vx),r=Z(),l=k()("".concat(r,"--header__nav"),a),d={"aria-label":t,"aria-labelledby":_};return i.createElement("nav",T({},n,d,{className:l}),i.createElement("ul",{className:"".concat(r,"--header__menu-bar")},s))}Ax.propTypes=R(R({},Ex),{},{children:P().node,className:P().string});var Tx=L("enable-v11-release")?Ax:hx,Wx=(L("enable-v11-release"),["className","children"]),Ux=function(e){var t=e.className,_=e.children,s=B(e,Wx),a=Z(),n=k()("".concat(a,"--header"),t);return i.createElement("header",T({},s,{className:n}),_)};Ux.propTypes=R(R({},Ex),{},{className:P().string});var Ix=Ux,Bx=["element","isSideNavExpanded"],Ox=i.forwardRef((function(e,t){var _=e.element;e.isSideNavExpanded;var s=B(e,Bx);return i.createElement(_,R(R({},s),{},{ref:t}))})),Fx={element:P().elementType,isSideNavExpanded:P().bool};Ox.displayName="Link",Ox.propTypes=Fx,Ox.defaultProps={element:"a"};var qx=Ox,Xx=["className","isCurrentPage","aria-current","children","role","tabIndex"],Cx=i.forwardRef((function(e,t){var _,s=e.className,a=e.isCurrentPage,n=e["aria-current"],r=e.children,l=e.role,d=e.tabIndex,o=void 0===d?0:d,m=B(e,Xx),v=Z(),c=k()((A(_={},"".concat(v,"--header__menu-item"),!0),A(_,"".concat(v,"--header__menu-item--current"),a&&"page"!==n),_));return i.createElement("li",{className:s,role:l},i.createElement(qx,T({},m,{"aria-current":n,className:c,ref:t,tabIndex:o}),i.createElement("span",{className:"".concat(v,"--text-truncate--end")},r)))}));Cx.displayName="HeaderMenuItem",Cx.propTypes=R(R({},Fx),{},{children:P().node.isRequired,className:P().string,isCurrentPage:P().bool,role:P().string,tabIndex:P().number});var Hx=Cx,kx=["children","className","prefix","href"],Nx=function(e){var t=e.children,_=e.className,s=e.prefix,a=e.href,n=B(e,kx),r=Z(),l=k()("".concat(r,"--header__name"),_);return i.createElement(qx,T({},n,{className:l,href:a}),s&&i.createElement(i.Fragment,null,i.createElement("span",{className:"".concat(r,"--header__name--prefix")},s),"\xa0"),t)};Nx.propTypes=R(R({},Fx),{},{children:P().node.isRequired,className:P().string,href:P().string,prefix:P().string}),Nx.defaultProps={prefix:"IBM"};var Zx=Nx,Yx=t(184),Px=function(e){l(t,e);var i=v(t);function t(){return s(this,t),i.apply(this,arguments)}return n(t,[{key:"render",value:function(){return(0,Yx.jsx)("div",{children:(0,Yx.jsxs)(Ix,{"aria-label":"RISC-V ISA",children:[(0,Yx.jsx)(Zx,{href:"#",prefix:"RISC-V",children:"ISA Reference"}),(0,Yx.jsxs)(Tx,{"aria-label":"ISA",children:[(0,Yx.jsx)(Hx,{children:"|"}),(0,Yx.jsx)(Hx,{href:"https://riscv.org",children:"RISC-V International"}),(0,Yx.jsx)(Hx,{href:"https://riscv.org/technical/specifications/",children:"RISC-V Specifications"}),(0,Yx.jsx)(Hx,{href:"https://GitHub.com/riscv/sail-riscv",children:"RISC-V Sail Model"}),(0,Yx.jsx)(Hx,{href:"https://github.com/ThinkOpenly/sail/tree/json",children:"RISC-V Sail to JSON"})]})]})})}}]),t}(i.Component),jx=Px,Kx=JSON.parse('{"NE":[{"mnemonic":"add","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"add.uw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zba"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let shamt : bits(2) = match op { RISCV_ADDUW => 0b00, RISCV_SH1ADDUW => 0b01, RISCV_SH2ADDUW => 0b10, RISCV_SH3ADDUW => 0b11 } in { let result : xlenbits = add_bits(shift_bits_left(zero_extend(64, subrange_bits(rs1_val, 31, 0)), shamt), rs2_val) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"addi","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"imm","type":"bits(12)"}],"syntax":"rd,rs1,imm","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"encdec_iop(op)","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let immext : xlenbits = sign_extend(64, imm) in { let result : xlenbits = match op { RISCV_ADDI => add_bits(rs1_val, immext), RISCV_SLTI => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, immext))), RISCV_SLTIU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, immext))), RISCV_ANDI => and_vec(rs1_val, immext), RISCV_ORI => or_vec(rs1_val, immext), RISCV_XORI => xor_vec(rs1_val, immext) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"addiw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"imm","type":"bits(12)"}],"syntax":"rd,rs1,imm","format":"I","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":[],"function":"{ let result : xlenbits = add_bits(sign_extend(64, imm), rX_bits(rs1)) in { wX_bits(rd, sign_extend(64, subrange_bits(result, 31, 0))); RETIRE_SUCCESS } }","description":"TBD"},{"mnemonic":"addw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":[],"function":"{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let result : bits(32) = match op { RISCV_ADDW => add_bits(rs1_val, rs2_val), RISCV_SUBW => sub_vec(rs1_val, rs2_val), RISCV_SLLW => shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRLW => shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRAW => shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"aes32dsi","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"bs","type":"bits(2)"}],"syntax":"rd,rs1,rs2,bs","format":"TBD","fields":[{"field":"bs","size":2},{"field":"0b10101","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknd"],"function":"{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let si : bits(8) = subrange_bits(shift_bits_right(rX_bits(rs2), shamt), 7, 0) in { let so : bits(32) = bitvector_concat(0x000000, aes_sbox_inv(si)) in { let result : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 31, 0), rotate_bits_left(so, shamt)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"aes32dsmi","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"bs","type":"bits(2)"}],"syntax":"rd,rs1,rs2,bs","format":"TBD","fields":[{"field":"bs","size":2},{"field":"0b10111","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknd"],"function":"{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let si : bits(8) = subrange_bits(shift_bits_right(rX_bits(rs2), shamt), 7, 0) in { let so : bits(8) = aes_sbox_inv(si) in { let mixed : bits(32) = aes_mixcolumn_byte_inv(so) in { let result : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 31, 0), rotate_bits_left(mixed, shamt)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"aes32esi","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"bs","type":"bits(2)"}],"syntax":"rd,rs1,rs2,bs","format":"TBD","fields":[{"field":"bs","size":2},{"field":"0b10001","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zkne"],"function":"{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let si : bits(8) = subrange_bits(shift_bits_right(rX_bits(rs2), shamt), 7, 0) in { let so : bits(32) = bitvector_concat(0x000000, aes_sbox_fwd(si)) in { let result : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 31, 0), rotate_bits_left(so, shamt)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"aes32esmi","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"bs","type":"bits(2)"}],"syntax":"rd,rs1,rs2,bs","format":"TBD","fields":[{"field":"bs","size":2},{"field":"0b10011","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zkne"],"function":"{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let si : bits(8) = subrange_bits(shift_bits_right(rX_bits(rs2), shamt), 7, 0) in { let so : bits(8) = aes_sbox_fwd(si) in { let mixed : bits(32) = aes_mixcolumn_byte_fwd(so) in { let result : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 31, 0), rotate_bits_left(mixed, shamt)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"aes64ds","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b11101","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknd"],"function":"{ assert(eq_int(64, 64), \\"model/riscv_insts_zkn.sail:408.27-408.28\\"); let sr : bits(64) = aes_rv64_shiftrows_inv(rX_bits(rs2), rX_bits(rs1)) in { let wd : bits(64) = subrange_bits(sr, 63, 0) in { wX_bits(rd, aes_apply_inv_sbox_to_each_byte(wd)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"aes64dsm","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b11111","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknd"],"function":"{ assert(eq_int(64, 64), \\"model/riscv_insts_zkn.sail:399.27-399.28\\"); let sr : bits(64) = aes_rv64_shiftrows_inv(rX_bits(rs2), rX_bits(rs1)) in { let wd : bits(64) = subrange_bits(sr, 63, 0) in { let sb : bits(64) = aes_apply_inv_sbox_to_each_byte(wd) in { wX_bits(rd, bitvector_concat(aes_mixcolumn_inv(subrange_bits(sb, 63, 32)), aes_mixcolumn_inv(subrange_bits(sb, 31, 0)))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"aes64es","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b11001","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zkne"],"function":"{ assert(eq_int(64, 64), \\"model/riscv_insts_zkn.sail:391.27-391.28\\"); let sr : bits(64) = aes_rv64_shiftrows_fwd(rX_bits(rs2), rX_bits(rs1)) in { let wd : bits(64) = subrange_bits(sr, 63, 0) in { wX_bits(rd, aes_apply_fwd_sbox_to_each_byte(wd)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"aes64esm","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b11011","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zkne"],"function":"{ assert(eq_int(64, 64), \\"model/riscv_insts_zkn.sail:382.27-382.28\\"); let sr : bits(64) = aes_rv64_shiftrows_fwd(rX_bits(rs2), rX_bits(rs1)) in { let wd : bits(64) = subrange_bits(sr, 63, 0) in { let sb : bits(64) = aes_apply_fwd_sbox_to_each_byte(wd) in { wX_bits(rd, bitvector_concat(aes_mixcolumn_fwd(subrange_bits(sb, 63, 32)), aes_mixcolumn_fwd(subrange_bits(sb, 31, 0)))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"aes64im","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b11000","size":5},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknd"],"function":"{ assert(eq_int(64, 64), \\"model/riscv_insts_zkn.sail:374.27-374.28\\"); let w0 : bits(32) = aes_mixcolumn_inv(subrange_bits(rX_bits(rs1), 31, 0)) in { let w1 : bits(32) = aes_mixcolumn_inv(subrange_bits(rX_bits(rs1), 63, 32)) in { wX_bits(rd, bitvector_concat(w1, w0)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"aes64ks1i","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rnum","type":"bits(4)"}],"syntax":"rd,rs1,rnum","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b11000","size":5},{"field":"0b1","size":1},{"field":"rnum","size":4},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zkne","Zknd"],"function":"{ assert(eq_int(64, 64), \\"model/riscv_insts_zkn.sail:356.27-356.28\\"); let prev : bits(32) = subrange_bits(rX_bits(rs1), 63, 32) in { let subwords : bits(32) = aes_subword_fwd(prev) in { let result : bits(32) = if eq_bits(rnum, 0xA) then subwords else xor_vec(rotater(subwords, 8), aes_decode_rcon(rnum)) in { wX_bits(rd, bitvector_concat(result, result)); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"aes64ks2","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b01","size":2},{"field":"0b11111","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zkne","Zknd"],"function":"{ assert(eq_int(64, 64), \\"model/riscv_insts_zkn.sail:366.27-366.28\\"); let w0 : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 63, 32), subrange_bits(rX_bits(rs2), 31, 0)) in { let w1 : bits(32) = xor_vec(subrange_bits(rX_bits(rs1), 63, 32), xor_vec(subrange_bits(rX_bits(rs2), 31, 0), subrange_bits(rX_bits(rs2), 63, 32))) in { wX_bits(rd, bitvector_concat(w1, w0)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"amoadd.b","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoadd.b.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoadd.b.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoadd.b.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoadd.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoadd.d.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoadd.d.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoadd.d.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoadd.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoadd.h.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoadd.h.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoadd.h.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoadd.w","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoadd.w.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoadd.w.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoadd.w.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoand.b","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoand.b.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoand.b.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoand.b.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoand.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoand.d.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoand.d.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoand.d.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoand.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoand.h.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoand.h.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoand.h.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoand.w","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoand.w.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoand.w.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoand.w.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomax.b","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomax.b.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomax.b.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomax.b.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomax.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomax.d.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomax.d.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomax.d.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomax.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomax.h.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomax.h.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomax.h.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomax.w","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomax.w.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomax.w.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomax.w.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomaxu.b","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomaxu.b.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomaxu.b.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomaxu.b.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomaxu.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomaxu.d.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomaxu.d.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomaxu.d.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomaxu.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomaxu.h.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomaxu.h.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomaxu.h.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomaxu.w","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomaxu.w.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomaxu.w.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomaxu.w.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomin.b","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomin.b.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomin.b.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomin.b.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomin.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomin.d.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomin.d.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomin.d.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomin.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomin.h.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomin.h.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomin.h.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomin.w","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomin.w.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomin.w.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amomin.w.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amominu.b","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amominu.b.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amominu.b.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amominu.b.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amominu.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amominu.d.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amominu.d.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amominu.d.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amominu.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amominu.h.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amominu.h.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amominu.h.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amominu.w","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amominu.w.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amominu.w.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amominu.w.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoor.b","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoor.b.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoor.b.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoor.b.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoor.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoor.d.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoor.d.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoor.d.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoor.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoor.h.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoor.h.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoor.h.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoor.w","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoor.w.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoor.w.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoor.w.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoswap.b","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoswap.b.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoswap.b.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoswap.b.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoswap.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoswap.d.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoswap.d.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoswap.d.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoswap.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoswap.h.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoswap.h.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoswap.h.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoswap.w","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoswap.w.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoswap.w.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoswap.w.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoxor.b","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoxor.b.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoxor.b.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoxor.b.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoxor.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoxor.d.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoxor.d.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoxor.d.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoxor.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoxor.h.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoxor.h.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoxor.h.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoxor.w","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoxor.w.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoxor.w.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"amoxor.w.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), ReadWrite((Data, Data)), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { match translateAddr(vaddr, ReadWrite((Data, Data))) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 292, \\"Unexpected AMO width\\") } in { let is_unsigned : bool = match op { AMOMINU => true, AMOMAXU => true, _ => false } in { let rs2_val : xlenbits = match width { BYTE => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 7, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 7, 0)), HALF => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 15, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 15, 0)), WORD => if is_unsigned then zero_extend(64, subrange_bits(rX_bits(rs2), 31, 0)) else sign_extend(64, subrange_bits(rX_bits(rs2), 31, 0)), DOUBLE => rX_bits(rs2) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let mval : MemoryOpResult(xlenbits) = match (width, 64) { (BYTE, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 1, aq, and_bool(aq, rl), true)), (HALF, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 2, aq, and_bool(aq, rl), true)), (WORD, _) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 4, aq, and_bool(aq, rl), true)), (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite((Data, Data)), addr, 8, aq, and_bool(aq, rl), true)), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 313, \\"Unexpected AMO width\\") } in { match mval { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(loaded) => { let result : xlenbits = match op { AMOSWAP => rs2_val, AMOADD => add_bits(rs2_val, loaded), AMOXOR => xor_vec(rs2_val, loaded), AMOAND => and_vec(rs2_val, loaded), AMOOR => or_vec(rs2_val, loaded), AMOMIN => to_bits(64, min_int(signed(rs2_val), signed(loaded))), AMOMAX => to_bits(64, max_int(signed(rs2_val), signed(loaded))), AMOMINU => to_bits(64, min_int(unsigned(rs2_val), unsigned(loaded))), AMOMAXU => to_bits(64, max_int(unsigned(rs2_val), unsigned(loaded))) } in { let rval : xlenbits = match width { BYTE => sign_extend(64, subrange_bits(loaded, 7, 0)), HALF => sign_extend(64, subrange_bits(loaded, 15, 0)), WORD => sign_extend(64, subrange_bits(loaded, 31, 0)), DOUBLE => loaded } in { let wval : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(result, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(result, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(result, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, result, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 345, \\"Unexpected AMO width\\") } in { match wval { MemValue(true) => { wX_bits(rd, rval); RETIRE_SUCCESS }, MemValue(false) => { internal_error(\\"model/riscv_insts_aext.sail\\", 349, \\"AMO got false from mem_write_value\\") }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"and","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"andi","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"imm","type":"bits(12)"}],"syntax":"rd,rs1,imm","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"encdec_iop(op)","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let immext : xlenbits = sign_extend(64, imm) in { let result : xlenbits = match op { RISCV_ADDI => add_bits(rs1_val, immext), RISCV_SLTI => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, immext))), RISCV_SLTIU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, immext))), RISCV_ANDI => and_vec(rs1_val, immext), RISCV_ORI => or_vec(rs1_val, immext), RISCV_XORI => xor_vec(rs1_val, immext) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"andn","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"auipc","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(20)"}],"syntax":"rd,imm","format":"TBD","fields":[{"field":"imm","size":20},{"field":"rd","size":5},{"field":"encdec_uop(op)","size":7}],"extensions":[],"function":"{ let off : xlenbits = sign_extend(64, bitvector_concat(imm, 0x000)) in { let ret : xlenbits = match op { RISCV_LUI => off, RISCV_AUIPC => add_bits(get_arch_pc(), off) } in { wX_bits(rd, ret); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"bclr","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbs"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let mask : xlenbits = if eq_int(64, 32) then shift_bits_left(zero_extend(64, 0b1), subrange_bits(rs2_val, 4, 0)) else shift_bits_left(zero_extend(64, 0b1), subrange_bits(rs2_val, 5, 0)) in { let result : xlenbits = match op { RISCV_BCLR => and_vec(rs1_val, not_vec(mask)), RISCV_BEXT => zero_extend(64, bool_to_bits(neq_bits(and_vec(rs1_val, mask), zeros_implicit(64)))), RISCV_BINV => xor_vec(rs1_val, mask), RISCV_BSET => or_vec(rs1_val, mask) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"bclri","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"shamt","type":"bits(6)"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b001010","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbs"],"function":"{ let rs1_val = rX_bits(rs1) in { let mask : xlenbits = if eq_int(64, 32) then shift_bits_left(zero_extend(64, 0b1), subrange_bits(shamt, 4, 0)) else shift_bits_left(zero_extend(64, 0b1), shamt) in { let result : xlenbits = match op { RISCV_BCLRI => and_vec(rs1_val, not_vec(mask)), RISCV_BEXTI => zero_extend(64, bool_to_bits(neq_bits(and_vec(rs1_val, mask), zeros_implicit(64)))), RISCV_BINVI => xor_vec(rs1_val, mask), RISCV_BSETI => or_vec(rs1_val, mask) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"beq","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(13)"}],"syntax":"rs1,rs2,imm","format":"TBD","fields":[{"field":"imm7_6","size":1},{"field":"imm7_5_0","size":6},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_bop(op)","size":3},{"field":"imm5_4_1","size":4},{"field":"imm5_0","size":1},{"field":"0b1100011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let taken : bool = match op { RISCV_BEQ => eq_bits(rs1_val, rs2_val), RISCV_BNE => neq_bits(rs1_val, rs2_val), RISCV_BLT => (operator <_s)(rs1_val, rs2_val), RISCV_BGE => (operator >=_s)(rs1_val, rs2_val), RISCV_BLTU => (operator <_u)(rs1_val, rs2_val), RISCV_BGEU => (operator >=_u)(rs1_val, rs2_val) } in { let t : xlenbits = add_bits(PC, sign_extend(64, imm)) in { if taken then { match ext_control_check_pc(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(target) => { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(extension(\\"C\\"))) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { set_next_pc(target); RETIRE_SUCCESS } } } } else RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"bext","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbs"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let mask : xlenbits = if eq_int(64, 32) then shift_bits_left(zero_extend(64, 0b1), subrange_bits(rs2_val, 4, 0)) else shift_bits_left(zero_extend(64, 0b1), subrange_bits(rs2_val, 5, 0)) in { let result : xlenbits = match op { RISCV_BCLR => and_vec(rs1_val, not_vec(mask)), RISCV_BEXT => zero_extend(64, bool_to_bits(neq_bits(and_vec(rs1_val, mask), zeros_implicit(64)))), RISCV_BINV => xor_vec(rs1_val, mask), RISCV_BSET => or_vec(rs1_val, mask) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"bexti","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"shamt","type":"bits(6)"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b001010","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbs"],"function":"{ let rs1_val = rX_bits(rs1) in { let mask : xlenbits = if eq_int(64, 32) then shift_bits_left(zero_extend(64, 0b1), subrange_bits(shamt, 4, 0)) else shift_bits_left(zero_extend(64, 0b1), shamt) in { let result : xlenbits = match op { RISCV_BCLRI => and_vec(rs1_val, not_vec(mask)), RISCV_BEXTI => zero_extend(64, bool_to_bits(neq_bits(and_vec(rs1_val, mask), zeros_implicit(64)))), RISCV_BINVI => xor_vec(rs1_val, mask), RISCV_BSETI => or_vec(rs1_val, mask) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"bge","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(13)"}],"syntax":"rs1,rs2,imm","format":"TBD","fields":[{"field":"imm7_6","size":1},{"field":"imm7_5_0","size":6},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_bop(op)","size":3},{"field":"imm5_4_1","size":4},{"field":"imm5_0","size":1},{"field":"0b1100011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let taken : bool = match op { RISCV_BEQ => eq_bits(rs1_val, rs2_val), RISCV_BNE => neq_bits(rs1_val, rs2_val), RISCV_BLT => (operator <_s)(rs1_val, rs2_val), RISCV_BGE => (operator >=_s)(rs1_val, rs2_val), RISCV_BLTU => (operator <_u)(rs1_val, rs2_val), RISCV_BGEU => (operator >=_u)(rs1_val, rs2_val) } in { let t : xlenbits = add_bits(PC, sign_extend(64, imm)) in { if taken then { match ext_control_check_pc(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(target) => { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(extension(\\"C\\"))) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { set_next_pc(target); RETIRE_SUCCESS } } } } else RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"bgeu","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(13)"}],"syntax":"rs1,rs2,imm","format":"TBD","fields":[{"field":"imm7_6","size":1},{"field":"imm7_5_0","size":6},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_bop(op)","size":3},{"field":"imm5_4_1","size":4},{"field":"imm5_0","size":1},{"field":"0b1100011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let taken : bool = match op { RISCV_BEQ => eq_bits(rs1_val, rs2_val), RISCV_BNE => neq_bits(rs1_val, rs2_val), RISCV_BLT => (operator <_s)(rs1_val, rs2_val), RISCV_BGE => (operator >=_s)(rs1_val, rs2_val), RISCV_BLTU => (operator <_u)(rs1_val, rs2_val), RISCV_BGEU => (operator >=_u)(rs1_val, rs2_val) } in { let t : xlenbits = add_bits(PC, sign_extend(64, imm)) in { if taken then { match ext_control_check_pc(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(target) => { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(extension(\\"C\\"))) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { set_next_pc(target); RETIRE_SUCCESS } } } } else RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"binv","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbs"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let mask : xlenbits = if eq_int(64, 32) then shift_bits_left(zero_extend(64, 0b1), subrange_bits(rs2_val, 4, 0)) else shift_bits_left(zero_extend(64, 0b1), subrange_bits(rs2_val, 5, 0)) in { let result : xlenbits = match op { RISCV_BCLR => and_vec(rs1_val, not_vec(mask)), RISCV_BEXT => zero_extend(64, bool_to_bits(neq_bits(and_vec(rs1_val, mask), zeros_implicit(64)))), RISCV_BINV => xor_vec(rs1_val, mask), RISCV_BSET => or_vec(rs1_val, mask) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"binvi","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"shamt","type":"bits(6)"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b001010","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbs"],"function":"{ let rs1_val = rX_bits(rs1) in { let mask : xlenbits = if eq_int(64, 32) then shift_bits_left(zero_extend(64, 0b1), subrange_bits(shamt, 4, 0)) else shift_bits_left(zero_extend(64, 0b1), shamt) in { let result : xlenbits = match op { RISCV_BCLRI => and_vec(rs1_val, not_vec(mask)), RISCV_BEXTI => zero_extend(64, bool_to_bits(neq_bits(and_vec(rs1_val, mask), zeros_implicit(64)))), RISCV_BINVI => xor_vec(rs1_val, mask), RISCV_BSETI => or_vec(rs1_val, mask) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"blt","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(13)"}],"syntax":"rs1,rs2,imm","format":"TBD","fields":[{"field":"imm7_6","size":1},{"field":"imm7_5_0","size":6},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_bop(op)","size":3},{"field":"imm5_4_1","size":4},{"field":"imm5_0","size":1},{"field":"0b1100011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let taken : bool = match op { RISCV_BEQ => eq_bits(rs1_val, rs2_val), RISCV_BNE => neq_bits(rs1_val, rs2_val), RISCV_BLT => (operator <_s)(rs1_val, rs2_val), RISCV_BGE => (operator >=_s)(rs1_val, rs2_val), RISCV_BLTU => (operator <_u)(rs1_val, rs2_val), RISCV_BGEU => (operator >=_u)(rs1_val, rs2_val) } in { let t : xlenbits = add_bits(PC, sign_extend(64, imm)) in { if taken then { match ext_control_check_pc(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(target) => { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(extension(\\"C\\"))) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { set_next_pc(target); RETIRE_SUCCESS } } } } else RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"bltu","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(13)"}],"syntax":"rs1,rs2,imm","format":"TBD","fields":[{"field":"imm7_6","size":1},{"field":"imm7_5_0","size":6},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_bop(op)","size":3},{"field":"imm5_4_1","size":4},{"field":"imm5_0","size":1},{"field":"0b1100011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let taken : bool = match op { RISCV_BEQ => eq_bits(rs1_val, rs2_val), RISCV_BNE => neq_bits(rs1_val, rs2_val), RISCV_BLT => (operator <_s)(rs1_val, rs2_val), RISCV_BGE => (operator >=_s)(rs1_val, rs2_val), RISCV_BLTU => (operator <_u)(rs1_val, rs2_val), RISCV_BGEU => (operator >=_u)(rs1_val, rs2_val) } in { let t : xlenbits = add_bits(PC, sign_extend(64, imm)) in { if taken then { match ext_control_check_pc(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(target) => { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(extension(\\"C\\"))) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { set_next_pc(target); RETIRE_SUCCESS } } } } else RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"bne","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(13)"}],"syntax":"rs1,rs2,imm","format":"TBD","fields":[{"field":"imm7_6","size":1},{"field":"imm7_5_0","size":6},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_bop(op)","size":3},{"field":"imm5_4_1","size":4},{"field":"imm5_0","size":1},{"field":"0b1100011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let taken : bool = match op { RISCV_BEQ => eq_bits(rs1_val, rs2_val), RISCV_BNE => neq_bits(rs1_val, rs2_val), RISCV_BLT => (operator <_s)(rs1_val, rs2_val), RISCV_BGE => (operator >=_s)(rs1_val, rs2_val), RISCV_BLTU => (operator <_u)(rs1_val, rs2_val), RISCV_BGEU => (operator >=_u)(rs1_val, rs2_val) } in { let t : xlenbits = add_bits(PC, sign_extend(64, imm)) in { if taken then { match ext_control_check_pc(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(target) => { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(extension(\\"C\\"))) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { set_next_pc(target); RETIRE_SUCCESS } } } } else RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"brev8","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b011010000111","size":12},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbkb"],"function":"{ let rs1_val = rX_bits(rs1) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 8) by 8 order inc) { result[add_atom(i, 7) .. i] = reverse_bits_in_byte(subrange_bits(rs1_val, add_atom(i, 7), i)); wX_bits(rd, result); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"bset","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbs"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let mask : xlenbits = if eq_int(64, 32) then shift_bits_left(zero_extend(64, 0b1), subrange_bits(rs2_val, 4, 0)) else shift_bits_left(zero_extend(64, 0b1), subrange_bits(rs2_val, 5, 0)) in { let result : xlenbits = match op { RISCV_BCLR => and_vec(rs1_val, not_vec(mask)), RISCV_BEXT => zero_extend(64, bool_to_bits(neq_bits(and_vec(rs1_val, mask), zeros_implicit(64)))), RISCV_BINV => xor_vec(rs1_val, mask), RISCV_BSET => or_vec(rs1_val, mask) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"bseti","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"shamt","type":"bits(6)"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b001010","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbs"],"function":"{ let rs1_val = rX_bits(rs1) in { let mask : xlenbits = if eq_int(64, 32) then shift_bits_left(zero_extend(64, 0b1), subrange_bits(shamt, 4, 0)) else shift_bits_left(zero_extend(64, 0b1), shamt) in { let result : xlenbits = match op { RISCV_BCLRI => and_vec(rs1_val, not_vec(mask)), RISCV_BEXTI => zero_extend(64, bool_to_bits(neq_bits(and_vec(rs1_val, mask), zeros_implicit(64)))), RISCV_BINVI => xor_vec(rs1_val, mask), RISCV_BSETI => or_vec(rs1_val, mask) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"c.add","name":"TBD","operands":[{"name":"rsd","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rsd,rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b1","size":1},{"field":"rsd","size":5},{"field":"rs2","size":5},{"field":"0b10","size":2}],"extensions":[],"function":"execute(RTYPE((rs2, rsd, rsd, RISCV_ADD)))","description":"TBD"},{"mnemonic":"c.add.hint.","name":"TBD","operands":[{"name":"rs2","type":"regidx"}],"syntax":"rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b1","size":1},{"field":"0b00000","size":5},{"field":"rs2","size":5},{"field":"0b10","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.addi","name":"TBD","operands":[{"name":"rsd","type":"regidx"},{"name":"nzi","type":"bits(6)"}],"syntax":"rsd,nzi","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"nzi5","size":1},{"field":"rsd","size":5},{"field":"nzi40","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"{ let imm : bits(12) = sign_extend(12, nzi) in { execute(ITYPE((imm, rsd, rsd, RISCV_ADDI))) } }","description":"TBD"},{"mnemonic":"c.addi.hint.","name":"TBD","operands":[{"name":"rsd","type":"regidx"}],"syntax":"rsd","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"0b0","size":1},{"field":"rsd","size":5},{"field":"0b00000","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.addi16sp","name":"TBD","operands":[{"name":"imm","type":"bits(6)"}],"syntax":"imm","format":"TBD","fields":[{"field":"0b011","size":3},{"field":"nzi9","size":1},{"field":"0b00010","size":5},{"field":"nzi4","size":1},{"field":"nzi6","size":1},{"field":"nzi87","size":2},{"field":"nzi5","size":1},{"field":"0b01","size":2}],"extensions":[],"function":"{ let imm : bits(12) = sign_extend(12, bitvector_concat(imm, 0x0)) in { execute(ITYPE((imm, sp, sp, RISCV_ADDI))) } }","description":"TBD"},{"mnemonic":"c.addi4spn","name":"TBD","operands":[{"name":"rdc","type":"cregidx"},{"name":"nzimm","type":"bits(8)"}],"syntax":"rdc,nzimm,0b00","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"nz54","size":2},{"field":"nz96","size":4},{"field":"nz2","size":1},{"field":"nz3","size":1},{"field":"rd","size":3},{"field":"0b00","size":2}],"extensions":[],"function":"{ let imm : bits(12) = bitvector_concat(0b00, bitvector_concat(nzimm, 0b00)) in { let rd = creg2reg_idx(rdc) in { execute(ITYPE((imm, sp, rd, RISCV_ADDI))) } } }","description":"TBD"},{"mnemonic":"c.addiw","name":"TBD","operands":[{"name":"rsd","type":"regidx"},{"name":"imm","type":"bits(6)"}],"syntax":"rsd,imm","format":"TBD","fields":[{"field":"0b001","size":3},{"field":"imm5","size":1},{"field":"rsd","size":5},{"field":"imm40","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"execute(ADDIW((sign_extend(12, imm), rsd, rsd)))","description":"TBD"},{"mnemonic":"c.addw","name":"TBD","operands":[{"name":"rsd","type":"cregidx"},{"name":"rs2","type":"cregidx"}],"syntax":"rsd,rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b1","size":1},{"field":"0b11","size":2},{"field":"rsd","size":3},{"field":"0b01","size":2},{"field":"rs2","size":3},{"field":"0b01","size":2}],"extensions":[],"function":"{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPEW((rs2, rsd, rsd, RISCV_ADDW))) } } }","description":"TBD"},{"mnemonic":"c.and","name":"TBD","operands":[{"name":"rsd","type":"cregidx"},{"name":"rs2","type":"cregidx"}],"syntax":"rsd,rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"rsd","size":3},{"field":"0b11","size":2},{"field":"rs2","size":3},{"field":"0b01","size":2}],"extensions":[],"function":"{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPE((rs2, rsd, rsd, RISCV_AND))) } } }","description":"TBD"},{"mnemonic":"c.andi","name":"TBD","operands":[{"name":"rsd","type":"cregidx"},{"name":"imm","type":"bits(6)"}],"syntax":"rsd,imm","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"i5","size":1},{"field":"0b10","size":2},{"field":"rsd","size":3},{"field":"i40","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"{ let rsd = creg2reg_idx(rsd) in { execute(ITYPE((sign_extend(12, imm), rsd, rsd, RISCV_ANDI))) } }","description":"TBD"},{"mnemonic":"c.beqz","name":"TBD","operands":[{"name":"rs","type":"cregidx"},{"name":"imm","type":"bits(8)"}],"syntax":"rs,imm","format":"TBD","fields":[{"field":"0b110","size":3},{"field":"i8","size":1},{"field":"i43","size":2},{"field":"rs","size":3},{"field":"i76","size":2},{"field":"i21","size":2},{"field":"i5","size":1},{"field":"0b01","size":2}],"extensions":[],"function":"execute(BTYPE((sign_extend(13, bitvector_concat(imm, 0b0)), zreg, creg2reg_idx(rs), RISCV_BEQ)))","description":"TBD"},{"mnemonic":"c.bnez","name":"TBD","operands":[{"name":"rs","type":"cregidx"},{"name":"imm","type":"bits(8)"}],"syntax":"rs,imm","format":"TBD","fields":[{"field":"0b111","size":3},{"field":"i8","size":1},{"field":"i43","size":2},{"field":"rs","size":3},{"field":"i76","size":2},{"field":"i21","size":2},{"field":"i5","size":1},{"field":"0b01","size":2}],"extensions":[],"function":"execute(BTYPE((sign_extend(13, bitvector_concat(imm, 0b0)), zreg, creg2reg_idx(rs), RISCV_BNE)))","description":"TBD"},{"mnemonic":"c.ebreak","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b1","size":1},{"field":"0b00000","size":5},{"field":"0b00000","size":5},{"field":"0b10","size":2}],"extensions":[],"function":"execute(EBREAK())","description":"TBD"},{"mnemonic":"c.fld","name":"TBD","operands":[{"name":"rdc","type":"cregidx"},{"name":"rsc","type":"cregidx"},{"name":"uimm","type":"bits(5)"}],"syntax":"rdc,rsc,uimm,0b000","format":"TBD","fields":[{"field":"0b001","size":3},{"field":"ui53","size":3},{"field":"rs1","size":3},{"field":"ui76","size":2},{"field":"rd","size":3},{"field":"0b00","size":2}],"extensions":["C","D"],"function":"{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { let rd = creg2reg_idx(rdc) in { let rs = creg2reg_idx(rsc) in { execute(LOAD_FP((imm, rs, rd, DOUBLE))) } } } }","description":"TBD"},{"mnemonic":"c.fldsp","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"uimm","type":"bits(6)"}],"syntax":"rd,uimm","format":"TBD","fields":[{"field":"0b001","size":3},{"field":"ui5","size":1},{"field":"rd","size":5},{"field":"ui43","size":2},{"field":"ui86","size":3},{"field":"0b10","size":2}],"extensions":["C","D"],"function":"{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { execute(LOAD_FP((imm, sp, rd, DOUBLE))) } }","description":"TBD"},{"mnemonic":"c.flw","name":"TBD","operands":[{"name":"rdc","type":"cregidx"},{"name":"rsc","type":"cregidx"},{"name":"uimm","type":"bits(5)"}],"syntax":"rdc,rsc,uimm,0b00","format":"TBD","fields":[{"field":"0b011","size":3},{"field":"ui53","size":3},{"field":"rs1","size":3},{"field":"ui2","size":1},{"field":"ui6","size":1},{"field":"rd","size":3},{"field":"0b00","size":2}],"extensions":["C","F"],"function":"{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { let rd = creg2reg_idx(rdc) in { let rs = creg2reg_idx(rsc) in { execute(LOAD_FP((imm, rs, rd, WORD))) } } } }","description":"TBD"},{"mnemonic":"c.flwsp","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(6)"}],"syntax":"rd,imm","format":"TBD","fields":[{"field":"0b011","size":3},{"field":"ui5","size":1},{"field":"rd","size":5},{"field":"ui42","size":3},{"field":"ui76","size":2},{"field":"0b10","size":2}],"extensions":["C","F"],"function":"{ let imm : bits(12) = zero_extend(12, bitvector_concat(imm, 0b00)) in { execute(LOAD_FP((imm, sp, rd, WORD))) } }","description":"TBD"},{"mnemonic":"c.fsd","name":"TBD","operands":[{"name":"rsc1","type":"cregidx"},{"name":"rsc2","type":"cregidx"},{"name":"uimm","type":"bits(5)"}],"syntax":"rsc1,rsc2,uimm,0b000","format":"TBD","fields":[{"field":"0b101","size":3},{"field":"ui53","size":3},{"field":"rs1","size":3},{"field":"ui76","size":2},{"field":"rs2","size":3},{"field":"0b00","size":2}],"extensions":["C","D"],"function":"{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { let rs1 = creg2reg_idx(rsc1) in { let rs2 = creg2reg_idx(rsc2) in { execute(STORE_FP((imm, rs2, rs1, DOUBLE))) } } } }","description":"TBD"},{"mnemonic":"c.fsdsp","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"uimm","type":"bits(6)"}],"syntax":"rs2,uimm","format":"TBD","fields":[{"field":"0b101","size":3},{"field":"ui53","size":3},{"field":"ui86","size":3},{"field":"rs2","size":5},{"field":"0b10","size":2}],"extensions":["C","D"],"function":"{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { execute(STORE_FP((imm, rs2, sp, DOUBLE))) } }","description":"TBD"},{"mnemonic":"c.fsw","name":"TBD","operands":[{"name":"rsc1","type":"cregidx"},{"name":"rsc2","type":"cregidx"},{"name":"uimm","type":"bits(5)"}],"syntax":"rsc1,rsc2,uimm,0b00","format":"TBD","fields":[{"field":"0b111","size":3},{"field":"ui53","size":3},{"field":"rs1","size":3},{"field":"ui2","size":1},{"field":"ui6","size":1},{"field":"rs2","size":3},{"field":"0b00","size":2}],"extensions":["C","F"],"function":"{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { let rs1 = creg2reg_idx(rsc1) in { let rs2 = creg2reg_idx(rsc2) in { execute(STORE_FP((imm, rs2, rs1, WORD))) } } } }","description":"TBD"},{"mnemonic":"c.fswsp","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"uimm","type":"bits(6)"}],"syntax":"rs2,uimm","format":"TBD","fields":[{"field":"0b111","size":3},{"field":"ui52","size":4},{"field":"ui76","size":2},{"field":"rs2","size":5},{"field":"0b10","size":2}],"extensions":["C","F"],"function":"{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { execute(STORE_FP((imm, rs2, sp, WORD))) } }","description":"TBD"},{"mnemonic":"c.illegal","name":"TBD","operands":[{"name":"s","type":"half"}],"syntax":"s","format":"TBD","fields":[{"field":"s","size":16}],"extensions":[],"function":"{ handle_illegal(); RETIRE_FAIL }","description":"TBD"},{"mnemonic":"c.j","name":"TBD","operands":[{"name":"imm","type":"bits(11)"}],"syntax":"imm","format":"TBD","fields":[{"field":"0b101","size":3},{"field":"i11","size":1},{"field":"i4","size":1},{"field":"i98","size":2},{"field":"i10","size":1},{"field":"i6","size":1},{"field":"i7","size":1},{"field":"i31","size":3},{"field":"i5","size":1},{"field":"0b01","size":2}],"extensions":[],"function":"execute(RISCV_JAL((sign_extend(21, bitvector_concat(imm, 0b0)), zreg)))","description":"TBD"},{"mnemonic":"c.jal","name":"TBD","operands":[{"name":"imm","type":"bits(11)"}],"syntax":"imm,0b0","format":"TBD","fields":[{"field":"0b001","size":3},{"field":"i11","size":1},{"field":"i4","size":1},{"field":"i98","size":2},{"field":"i10","size":1},{"field":"i6","size":1},{"field":"i7","size":1},{"field":"i31","size":3},{"field":"i5","size":1},{"field":"0b01","size":2}],"extensions":[],"function":"execute(RISCV_JAL((sign_extend(21, bitvector_concat(imm, 0b0)), ra)))","description":"TBD"},{"mnemonic":"c.jalr","name":"TBD","operands":[{"name":"rs1","type":"regidx"}],"syntax":"rs1","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b1","size":1},{"field":"rs1","size":5},{"field":"0b00000","size":5},{"field":"0b10","size":2}],"extensions":[],"function":"execute(RISCV_JALR((zero_extend(12, 0b0), rs1, ra)))","description":"TBD"},{"mnemonic":"c.jr","name":"TBD","operands":[{"name":"rs1","type":"regidx"}],"syntax":"rs1","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"rs1","size":5},{"field":"0b00000","size":5},{"field":"0b10","size":2}],"extensions":[],"function":"execute(RISCV_JALR((zero_extend(12, 0b0), rs1, zreg)))","description":"TBD"},{"mnemonic":"c.ld","name":"TBD","operands":[{"name":"rdc","type":"cregidx"},{"name":"rsc","type":"cregidx"},{"name":"uimm","type":"bits(5)"}],"syntax":"rdc,rsc,uimm,0b000","format":"TBD","fields":[{"field":"0b011","size":3},{"field":"ui53","size":3},{"field":"rs1","size":3},{"field":"ui76","size":2},{"field":"rd","size":3},{"field":"0b00","size":2}],"extensions":[],"function":"{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { let rd = creg2reg_idx(rdc) in { let rs = creg2reg_idx(rsc) in { execute(LOAD((imm, rs, rd, false, DOUBLE, false, false))) } } } }","description":"TBD"},{"mnemonic":"c.ldsp","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"uimm","type":"bits(6)"}],"syntax":"rd,uimm","format":"TBD","fields":[{"field":"0b011","size":3},{"field":"ui5","size":1},{"field":"rd","size":5},{"field":"ui43","size":2},{"field":"ui86","size":3},{"field":"0b10","size":2}],"extensions":[],"function":"{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { execute(LOAD((imm, sp, rd, false, DOUBLE, false, false))) } }","description":"TBD"},{"mnemonic":"c.li","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(6)"}],"syntax":"rd,imm","format":"TBD","fields":[{"field":"0b010","size":3},{"field":"imm5","size":1},{"field":"rd","size":5},{"field":"imm40","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"{ let imm : bits(12) = sign_extend(12, imm) in { execute(ITYPE((imm, zreg, rd, RISCV_ADDI))) } }","description":"TBD"},{"mnemonic":"c.li.hint.","name":"TBD","operands":[{"name":"imm","type":"bits(6)"}],"syntax":"imm","format":"TBD","fields":[{"field":"0b010","size":3},{"field":"imm5","size":1},{"field":"0b00000","size":5},{"field":"imm40","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.lui","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(6)"}],"syntax":"rd,imm","format":"TBD","fields":[{"field":"0b011","size":3},{"field":"imm17","size":1},{"field":"rd","size":5},{"field":"imm1612","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"{ let res : bits(20) = sign_extend(20, imm) in { execute(UTYPE((res, rd, RISCV_LUI))) } }","description":"TBD"},{"mnemonic":"c.lui.hint.","name":"TBD","operands":[{"name":"imm","type":"bits(6)"}],"syntax":"imm","format":"TBD","fields":[{"field":"0b011","size":3},{"field":"imm17","size":1},{"field":"0b00000","size":5},{"field":"imm1612","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.lw","name":"TBD","operands":[{"name":"rdc","type":"cregidx"},{"name":"rsc","type":"cregidx"},{"name":"uimm","type":"bits(5)"}],"syntax":"rdc,rsc,uimm,0b00","format":"TBD","fields":[{"field":"0b010","size":3},{"field":"ui53","size":3},{"field":"rs1","size":3},{"field":"ui2","size":1},{"field":"ui6","size":1},{"field":"rd","size":3},{"field":"0b00","size":2}],"extensions":[],"function":"{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { let rd = creg2reg_idx(rdc) in { let rs = creg2reg_idx(rsc) in { execute(LOAD((imm, rs, rd, false, WORD, false, false))) } } } }","description":"TBD"},{"mnemonic":"c.lwsp","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"uimm","type":"bits(6)"}],"syntax":"rd,uimm","format":"TBD","fields":[{"field":"0b010","size":3},{"field":"ui5","size":1},{"field":"rd","size":5},{"field":"ui42","size":3},{"field":"ui76","size":2},{"field":"0b10","size":2}],"extensions":[],"function":"{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { execute(LOAD((imm, sp, rd, false, WORD, false, false))) } }","description":"TBD"},{"mnemonic":"c.mv","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"rd","size":5},{"field":"rs2","size":5},{"field":"0b10","size":2}],"extensions":[],"function":"execute(RTYPE((rs2, zreg, rd, RISCV_ADD)))","description":"TBD"},{"mnemonic":"c.mv.hint.","name":"TBD","operands":[{"name":"rs2","type":"regidx"}],"syntax":"rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"0b00000","size":5},{"field":"rs2","size":5},{"field":"0b10","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.nop","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"0b0","size":1},{"field":"0b00000","size":5},{"field":"0b00000","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.nop.hint.","name":"TBD","operands":[{"name":"imm","type":"bits(6)"}],"syntax":"imm","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"im5","size":1},{"field":"0b00000","size":5},{"field":"im40","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.or","name":"TBD","operands":[{"name":"rsd","type":"cregidx"},{"name":"rs2","type":"cregidx"}],"syntax":"rsd,rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"rsd","size":3},{"field":"0b10","size":2},{"field":"rs2","size":3},{"field":"0b01","size":2}],"extensions":[],"function":"{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPE((rs2, rsd, rsd, RISCV_OR))) } } }","description":"TBD"},{"mnemonic":"c.sd","name":"TBD","operands":[{"name":"rsc1","type":"cregidx"},{"name":"rsc2","type":"cregidx"},{"name":"uimm","type":"bits(5)"}],"syntax":"rsc1,rsc2,uimm,0b000","format":"TBD","fields":[{"field":"0b111","size":3},{"field":"ui53","size":3},{"field":"rs1","size":3},{"field":"ui76","size":2},{"field":"rs2","size":3},{"field":"0b00","size":2}],"extensions":[],"function":"{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { let rs1 = creg2reg_idx(rsc1) in { let rs2 = creg2reg_idx(rsc2) in { execute(STORE((imm, rs2, rs1, DOUBLE, false, false))) } } } }","description":"TBD"},{"mnemonic":"c.sdsp","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"uimm","type":"bits(6)"}],"syntax":"rs2,uimm","format":"TBD","fields":[{"field":"0b111","size":3},{"field":"ui53","size":3},{"field":"ui86","size":3},{"field":"rs2","size":5},{"field":"0b10","size":2}],"extensions":[],"function":"{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b000)) in { execute(STORE((imm, rs2, sp, DOUBLE, false, false))) } }","description":"TBD"},{"mnemonic":"c.slli","name":"TBD","operands":[{"name":"rsd","type":"regidx"},{"name":"shamt","type":"bits(6)"}],"syntax":"rsd,shamt","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"nzui5","size":1},{"field":"rsd","size":5},{"field":"nzui40","size":5},{"field":"0b10","size":2}],"extensions":[],"function":"execute(SHIFTIOP((shamt, rsd, rsd, RISCV_SLLI)))","description":"TBD"},{"mnemonic":"c.slli.hint.","name":"TBD","operands":[{"name":"rsd","type":"regidx"},{"name":"shamt","type":"bits(6)"}],"syntax":"rsd,shamt","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"nzui5","size":1},{"field":"rsd","size":5},{"field":"nzui40","size":5},{"field":"0b10","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.srai","name":"TBD","operands":[{"name":"rsd","type":"cregidx"},{"name":"shamt","type":"bits(6)"}],"syntax":"rsd,shamt","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"nzui5","size":1},{"field":"0b01","size":2},{"field":"rsd","size":3},{"field":"nzui40","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"{ let rsd = creg2reg_idx(rsd) in { execute(SHIFTIOP((shamt, rsd, rsd, RISCV_SRAI))) } }","description":"TBD"},{"mnemonic":"c.srai.hint.","name":"TBD","operands":[{"name":"rsd","type":"cregidx"}],"syntax":"rsd","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"rsd","size":3},{"field":"0b00000","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.srli","name":"TBD","operands":[{"name":"rsd","type":"cregidx"},{"name":"shamt","type":"bits(6)"}],"syntax":"rsd,shamt","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"nzui5","size":1},{"field":"0b00","size":2},{"field":"rsd","size":3},{"field":"nzui40","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"{ let rsd = creg2reg_idx(rsd) in { execute(SHIFTIOP((shamt, rsd, rsd, RISCV_SRLI))) } }","description":"TBD"},{"mnemonic":"c.srli.hint.","name":"TBD","operands":[{"name":"rsd","type":"cregidx"}],"syntax":"rsd","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"rsd","size":3},{"field":"0b00000","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.sub","name":"TBD","operands":[{"name":"rsd","type":"cregidx"},{"name":"rs2","type":"cregidx"}],"syntax":"rsd,rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"rsd","size":3},{"field":"0b00","size":2},{"field":"rs2","size":3},{"field":"0b01","size":2}],"extensions":[],"function":"{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPE((rs2, rsd, rsd, RISCV_SUB))) } } }","description":"TBD"},{"mnemonic":"c.subw","name":"TBD","operands":[{"name":"rsd","type":"cregidx"},{"name":"rs2","type":"cregidx"}],"syntax":"rsd,rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b1","size":1},{"field":"0b11","size":2},{"field":"rsd","size":3},{"field":"0b00","size":2},{"field":"rs2","size":3},{"field":"0b01","size":2}],"extensions":[],"function":"{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPEW((rs2, rsd, rsd, RISCV_SUBW))) } } }","description":"TBD"},{"mnemonic":"c.sw","name":"TBD","operands":[{"name":"rsc1","type":"cregidx"},{"name":"rsc2","type":"cregidx"},{"name":"uimm","type":"bits(5)"}],"syntax":"rsc1,rsc2,uimm,0b00","format":"TBD","fields":[{"field":"0b110","size":3},{"field":"ui53","size":3},{"field":"rs1","size":3},{"field":"ui2","size":1},{"field":"ui6","size":1},{"field":"rs2","size":3},{"field":"0b00","size":2}],"extensions":[],"function":"{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { let rs1 = creg2reg_idx(rsc1) in { let rs2 = creg2reg_idx(rsc2) in { execute(STORE((imm, rs2, rs1, WORD, false, false))) } } } }","description":"TBD"},{"mnemonic":"c.swsp","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"uimm","type":"bits(6)"}],"syntax":"rs2,uimm","format":"TBD","fields":[{"field":"0b110","size":3},{"field":"ui52","size":4},{"field":"ui76","size":2},{"field":"rs2","size":5},{"field":"0b10","size":2}],"extensions":[],"function":"{ let imm : bits(12) = zero_extend(12, bitvector_concat(uimm, 0b00)) in { execute(STORE((imm, rs2, sp, WORD, false, false))) } }","description":"TBD"},{"mnemonic":"c.xor","name":"TBD","operands":[{"name":"rsd","type":"cregidx"},{"name":"rs2","type":"cregidx"}],"syntax":"rsd,rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"rsd","size":3},{"field":"0b01","size":2},{"field":"rs2","size":3},{"field":"0b01","size":2}],"extensions":[],"function":"{ let rsd = creg2reg_idx(rsd) in { let rs2 = creg2reg_idx(rs2) in { execute(RTYPE((rs2, rsd, rsd, RISCV_XOR))) } } }","description":"TBD"},{"mnemonic":"clmul","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbc","Zbkc"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(xlen_val, 1) by 1 order inc) { if eq_bit(bitvector_access(rs2_val, i), bitone) then result = xor_vec(result, shiftl(rs1_val, i)) else (); wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"clmulh","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbc","Zbkc"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(xlen_val, 1) by 1 order inc) { if eq_bit(bitvector_access(rs2_val, i), bitone) then result = xor_vec(result, shiftr(rs1_val, sub_atom(xlen_val, i))) else (); wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"clmulr","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b010","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbc"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(xlen_val, 1) by 1 order inc) { if eq_bit(bitvector_access(rs2_val, i), bitone) then result = xor_vec(result, shiftr(rs1_val, sub_atom(sub_atom(xlen_val, i), 1))) else (); wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"clz","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b011000000000","size":12},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbb"],"function":"{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { var done : bool = false in { foreach (i from sub_atom(64, 1) to 0 by 1 order dec) { if not(done) then if eq_bit(bitvector_access(rs1_val, i), bitzero) then result = add_atom(result, 1) else done = true else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"clzw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b011000000000","size":12},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":["Zbb"],"function":"{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { var done : bool = false in { foreach (i from 31 to 0 by 1 order dec) { if not(done) then if eq_bit(bitvector_access(rs1_val, i), bitzero) then result = add_atom(result, 1) else done = true else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"cpop","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b011000000010","size":12},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbb"],"function":"{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { foreach (i from 0 to sub_atom(xlen_val, 1) by 1 order inc) { if eq_bit(bitvector_access(rs1_val, i), bitone) then result = add_atom(result, 1) else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"cpopw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b011000000010","size":12},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":["Zbb"],"function":"{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { foreach (i from 0 to 31 by 1 order inc) { if eq_bit(bitvector_access(rs1_val, i), bitone) then result = add_atom(result, 1) else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"csrrc","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"csr","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,csr,rs1","format":"TBD","fields":[{"field":"csr","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_imm)","size":1},{"field":"encdec_csrop(op)","size":2},{"field":"rd","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{ let rs1_val : xlenbits = if is_imm then zero_extend(64, rs1) else rX_bits(rs1) in { let isWrite : bool = match op { CSRRW => true, _ => if is_imm then neq_int(unsigned(rs1_val), 0) else neq_int(unsigned(rs1), 0) } in { if not(check_CSR(csr, cur_privilege, isWrite)) then { handle_illegal(); RETIRE_FAIL } else if not(ext_check_CSR(csr, cur_privilege, isWrite)) then { ext_check_CSR_fail(); RETIRE_FAIL } else { let csr_val = readCSR(csr) in { if isWrite then { let new_val : xlenbits = match op { CSRRW => rs1_val, CSRRS => or_vec(csr_val, rs1_val), CSRRC => and_vec(csr_val, not_vec(rs1_val)) } in { writeCSR(csr, new_val) } } else (); wX_bits(rd, csr_val); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"csrrci","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"csr","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,csr,rs1","format":"TBD","fields":[{"field":"csr","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_imm)","size":1},{"field":"encdec_csrop(op)","size":2},{"field":"rd","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{ let rs1_val : xlenbits = if is_imm then zero_extend(64, rs1) else rX_bits(rs1) in { let isWrite : bool = match op { CSRRW => true, _ => if is_imm then neq_int(unsigned(rs1_val), 0) else neq_int(unsigned(rs1), 0) } in { if not(check_CSR(csr, cur_privilege, isWrite)) then { handle_illegal(); RETIRE_FAIL } else if not(ext_check_CSR(csr, cur_privilege, isWrite)) then { ext_check_CSR_fail(); RETIRE_FAIL } else { let csr_val = readCSR(csr) in { if isWrite then { let new_val : xlenbits = match op { CSRRW => rs1_val, CSRRS => or_vec(csr_val, rs1_val), CSRRC => and_vec(csr_val, not_vec(rs1_val)) } in { writeCSR(csr, new_val) } } else (); wX_bits(rd, csr_val); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"csrrs","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"csr","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,csr,rs1","format":"TBD","fields":[{"field":"csr","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_imm)","size":1},{"field":"encdec_csrop(op)","size":2},{"field":"rd","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{ let rs1_val : xlenbits = if is_imm then zero_extend(64, rs1) else rX_bits(rs1) in { let isWrite : bool = match op { CSRRW => true, _ => if is_imm then neq_int(unsigned(rs1_val), 0) else neq_int(unsigned(rs1), 0) } in { if not(check_CSR(csr, cur_privilege, isWrite)) then { handle_illegal(); RETIRE_FAIL } else if not(ext_check_CSR(csr, cur_privilege, isWrite)) then { ext_check_CSR_fail(); RETIRE_FAIL } else { let csr_val = readCSR(csr) in { if isWrite then { let new_val : xlenbits = match op { CSRRW => rs1_val, CSRRS => or_vec(csr_val, rs1_val), CSRRC => and_vec(csr_val, not_vec(rs1_val)) } in { writeCSR(csr, new_val) } } else (); wX_bits(rd, csr_val); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"csrrsi","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"csr","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,csr,rs1","format":"TBD","fields":[{"field":"csr","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_imm)","size":1},{"field":"encdec_csrop(op)","size":2},{"field":"rd","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{ let rs1_val : xlenbits = if is_imm then zero_extend(64, rs1) else rX_bits(rs1) in { let isWrite : bool = match op { CSRRW => true, _ => if is_imm then neq_int(unsigned(rs1_val), 0) else neq_int(unsigned(rs1), 0) } in { if not(check_CSR(csr, cur_privilege, isWrite)) then { handle_illegal(); RETIRE_FAIL } else if not(ext_check_CSR(csr, cur_privilege, isWrite)) then { ext_check_CSR_fail(); RETIRE_FAIL } else { let csr_val = readCSR(csr) in { if isWrite then { let new_val : xlenbits = match op { CSRRW => rs1_val, CSRRS => or_vec(csr_val, rs1_val), CSRRC => and_vec(csr_val, not_vec(rs1_val)) } in { writeCSR(csr, new_val) } } else (); wX_bits(rd, csr_val); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"csrrw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"csr","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,csr,rs1","format":"TBD","fields":[{"field":"csr","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_imm)","size":1},{"field":"encdec_csrop(op)","size":2},{"field":"rd","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{ let rs1_val : xlenbits = if is_imm then zero_extend(64, rs1) else rX_bits(rs1) in { let isWrite : bool = match op { CSRRW => true, _ => if is_imm then neq_int(unsigned(rs1_val), 0) else neq_int(unsigned(rs1), 0) } in { if not(check_CSR(csr, cur_privilege, isWrite)) then { handle_illegal(); RETIRE_FAIL } else if not(ext_check_CSR(csr, cur_privilege, isWrite)) then { ext_check_CSR_fail(); RETIRE_FAIL } else { let csr_val = readCSR(csr) in { if isWrite then { let new_val : xlenbits = match op { CSRRW => rs1_val, CSRRS => or_vec(csr_val, rs1_val), CSRRC => and_vec(csr_val, not_vec(rs1_val)) } in { writeCSR(csr, new_val) } } else (); wX_bits(rd, csr_val); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"csrrwi","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"csr","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,csr,rs1","format":"TBD","fields":[{"field":"csr","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_imm)","size":1},{"field":"encdec_csrop(op)","size":2},{"field":"rd","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{ let rs1_val : xlenbits = if is_imm then zero_extend(64, rs1) else rX_bits(rs1) in { let isWrite : bool = match op { CSRRW => true, _ => if is_imm then neq_int(unsigned(rs1_val), 0) else neq_int(unsigned(rs1), 0) } in { if not(check_CSR(csr, cur_privilege, isWrite)) then { handle_illegal(); RETIRE_FAIL } else if not(ext_check_CSR(csr, cur_privilege, isWrite)) then { ext_check_CSR_fail(); RETIRE_FAIL } else { let csr_val = readCSR(csr) in { if isWrite then { let new_val : xlenbits = match op { CSRRW => rs1_val, CSRRS => or_vec(csr_val, rs1_val), CSRRC => and_vec(csr_val, not_vec(rs1_val)) } in { writeCSR(csr, new_val) } } else (); wX_bits(rd, csr_val); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"ctz","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b011000000001","size":12},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbb"],"function":"{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { var done : bool = false in { foreach (i from 0 to sub_atom(64, 1) by 1 order inc) { if not(done) then if eq_bit(bitvector_access(rs1_val, i), bitzero) then result = add_atom(result, 1) else done = true else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"ctzw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b011000000001","size":12},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":["Zbb"],"function":"{ let rs1_val = rX_bits(rs1) in { var result : nat = 0 in { var done : bool = false in { foreach (i from 0 to 31 by 1 order inc) { if not(done) then if eq_bit(bitvector_access(rs1_val, i), bitzero) then result = add_atom(result, 1) else done = true else (); wX_bits(rd, to_bits(64, result)); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"czero.eqz","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000111","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b111","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zicond"],"function":"{ let value = rX_bits(rs1) in { let condition = rX_bits(rs2) in { let result : xlenbits = if neq_bits(condition, zeros_implicit(64)) then zeros_implicit(64) else value in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"czero.nez","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000111","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b111","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zicond"],"function":"{ let value = rX_bits(rs1) in { let condition = rX_bits(rs2) in { let result : xlenbits = if neq_bits(condition, zeros_implicit(64)) then zeros_implicit(64) else value in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"div","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b10","size":2},{"field":"bool_not_bits(s)","size":1},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ if haveMulDiv() then { let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let q : int = if eq_int(rs2_int, 0) then -1 else quot_round_zero(rs1_int, rs2_int) in { let q\' : int = if and_bool(s, gt_int(q, xlen_max_signed)) then xlen_min_signed else q in { wX_bits(rd, to_bits(64, q\')); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"divu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b10","size":2},{"field":"bool_not_bits(s)","size":1},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ if haveMulDiv() then { let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let q : int = if eq_int(rs2_int, 0) then -1 else quot_round_zero(rs1_int, rs2_int) in { let q\' : int = if and_bool(s, gt_int(q, xlen_max_signed)) then xlen_min_signed else q in { wX_bits(rd, to_bits(64, q\')); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"divuw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b10","size":2},{"field":"bool_not_bits(s)","size":1},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":[],"function":"{ if haveMulDiv() then { let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let q : int = if eq_int(rs2_int, 0) then -1 else quot_round_zero(rs1_int, rs2_int) in { let q\' : int = if and_bool(s, gt_int(q, sub_atom(pow2(31), 1))) then sub_atom(0, int_power(2, 31)) else q in { wX_bits(rd, sign_extend(64, to_bits(32, q\'))); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"divw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b10","size":2},{"field":"bool_not_bits(s)","size":1},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":[],"function":"{ if haveMulDiv() then { let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let q : int = if eq_int(rs2_int, 0) then -1 else quot_round_zero(rs1_int, rs2_int) in { let q\' : int = if and_bool(s, gt_int(q, sub_atom(pow2(31), 1))) then sub_atom(0, int_power(2, 31)) else q in { wX_bits(rd, sign_extend(64, to_bits(32, q\'))); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"ebreak","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b000000000001","size":12},{"field":"0b00000","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{ handle_mem_exception(PC, E_Breakpoint()); RETIRE_FAIL }","description":"TBD"},{"mnemonic":"ecall","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b000000000000","size":12},{"field":"0b00000","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{ let t : sync_exception = struct { trap = match cur_privilege { User => E_U_EnvCall(), Supervisor => E_S_EnvCall(), Machine => E_M_EnvCall() }; excinfo = None() : option(xlenbits); ext = None() } in { set_next_pc(exception_handler(cur_privilege, CTL_TRAP(t), PC)); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"fadd.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_64b = rF_or_X_D(rs1) in { let rs2_val_64b = rF_or_X_D(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op { FADD_D => riscv_f64Add(rm_3b, rs1_val_64b, rs2_val_64b), FSUB_D => riscv_f64Sub(rm_3b, rs1_val_64b, rs2_val_64b), FMUL_D => riscv_f64Mul(rm_3b, rs1_val_64b, rs2_val_64b), FDIV_D => riscv_f64Div(rm_3b, rs1_val_64b, rs2_val_64b) } in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_64b); RETIRE_SUCCESS } } } } } } }","description":"TBD"},{"mnemonic":"fadd.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001110","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_16b = rF_or_X_H(rs1) in { let rs2_val_16b = rF_or_X_H(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op { FADD_H => riscv_f16Add(rm_3b, rs1_val_16b, rs2_val_16b), FSUB_H => riscv_f16Sub(rm_3b, rs1_val_16b, rs2_val_16b), FMUL_H => riscv_f16Mul(rm_3b, rs1_val_16b, rs2_val_16b), FDIV_H => riscv_f16Div(rm_3b, rs1_val_16b, rs2_val_16b) } in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_16b); RETIRE_SUCCESS } } } } } } }","description":"TBD"},{"mnemonic":"fadd.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_32b = rF_or_X_S(rs1) in { let rs2_val_32b = rF_or_X_S(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op { FADD_S => riscv_f32Add(rm_3b, rs1_val_32b, rs2_val_32b), FSUB_S => riscv_f32Sub(rm_3b, rs1_val_32b, rs2_val_32b), FMUL_S => riscv_f32Mul(rm_3b, rs1_val_32b, rs2_val_32b), FDIV_S => riscv_f32Div(rm_3b, rs1_val_32b, rs2_val_32b) } in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_32b); RETIRE_SUCCESS } } } } } } }","description":"TBD"},{"mnemonic":"fclass.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111001","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D"],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_dext.sail:1004.27-1004.28\\"); let rs1_val_X = rX_bits(rs1) in { let rd_val_D = subrange_bits(rs1_val_X, 63, 0) in { wF_bits(rd, rd_val_D); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"fclass.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111010","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh"],"function":"{ let rs1_val_X = rX_bits(rs1) in { let rd_val_H = subrange_bits(rs1_val_X, 15, 0) in { wF_bits(rd, nan_box_H(rd_val_H)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"fclass.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111000","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["F"],"function":"{ let rs1_val_X = rX_bits(rs1) in { let rd_val_S = subrange_bits(rs1_val_X, 31, 0) in { wF_bits(rd, nan_box_S(rd_val_S)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"fcvt.d.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_zfh.sail:823.27-823.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.d.l","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_dext.sail:650.27-650.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.d.lu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_dext.sail:650.27-650.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.d.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_dext.sail:650.27-650.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.d.w","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_dext.sail:650.27-650.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.d.wu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_dext.sail:650.27-650.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.h.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_zfh.sail:823.27-823.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.h.l","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_zfh.sail:823.27-823.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.h.lu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_zfh.sail:823.27-823.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.h.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_zfh.sail:823.27-823.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.h.w","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_zfh.sail:823.27-823.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.h.wu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_zfh.sail:823.27-823.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.l.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_dext.sail:650.27-650.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.l.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_zfh.sail:823.27-823.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.l.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_fext.sail:789.27-789.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.lu.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_dext.sail:650.27-650.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.lu.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_zfh.sail:823.27-823.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.lu.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_fext.sail:789.27-789.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.s.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_dext.sail:650.27-650.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.s.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_zfh.sail:823.27-823.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.s.l","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_fext.sail:789.27-789.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.s.lu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_fext.sail:789.27-789.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.s.w","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_fext.sail:789.27-789.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.s.wu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_fext.sail:789.27-789.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.w.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_dext.sail:650.27-650.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.w.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_zfh.sail:823.27-823.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.w.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_fext.sail:789.27-789.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.wu.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_dext.sail:650.27-650.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.wu.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_zfh.sail:823.27-823.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvt.wu.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_fext.sail:789.27-789.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fcvtmod.w.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1100001","size":7},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{ let rs1_val_D = rF_D(rs1) in { let (fflags, rd_val) = fcvtmod_helper(rs1_val_D) in { accrue_fflags(fflags); wX_bits(rd, sign_extend(64, rd_val)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"fdiv.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_64b = rF_or_X_D(rs1) in { let rs2_val_64b = rF_or_X_D(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op { FADD_D => riscv_f64Add(rm_3b, rs1_val_64b, rs2_val_64b), FSUB_D => riscv_f64Sub(rm_3b, rs1_val_64b, rs2_val_64b), FMUL_D => riscv_f64Mul(rm_3b, rs1_val_64b, rs2_val_64b), FDIV_D => riscv_f64Div(rm_3b, rs1_val_64b, rs2_val_64b) } in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_64b); RETIRE_SUCCESS } } } } } } }","description":"TBD"},{"mnemonic":"fdiv.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001110","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_16b = rF_or_X_H(rs1) in { let rs2_val_16b = rF_or_X_H(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op { FADD_H => riscv_f16Add(rm_3b, rs1_val_16b, rs2_val_16b), FSUB_H => riscv_f16Sub(rm_3b, rs1_val_16b, rs2_val_16b), FMUL_H => riscv_f16Mul(rm_3b, rs1_val_16b, rs2_val_16b), FDIV_H => riscv_f16Div(rm_3b, rs1_val_16b, rs2_val_16b) } in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_16b); RETIRE_SUCCESS } } } } } } }","description":"TBD"},{"mnemonic":"fdiv.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_32b = rF_or_X_S(rs1) in { let rs2_val_32b = rF_or_X_S(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op { FADD_S => riscv_f32Add(rm_3b, rs1_val_32b, rs2_val_32b), FSUB_S => riscv_f32Sub(rm_3b, rs1_val_32b, rs2_val_32b), FMUL_S => riscv_f32Mul(rm_3b, rs1_val_32b, rs2_val_32b), FDIV_S => riscv_f32Div(rm_3b, rs1_val_32b, rs2_val_32b) } in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_32b); RETIRE_SUCCESS } } } } } } }","description":"TBD"},{"mnemonic":"fence","name":"TBD","operands":[{"name":"pred","type":"bits(4)"},{"name":"succ","type":"bits(4)"}],"syntax":"pred,succ","format":"I","fields":[{"field":"0b0000","size":4},{"field":"pred","size":4},{"field":"succ","size":4},{"field":"0b00000","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b0001111","size":7}],"extensions":[],"function":"{ let fiom = is_fiom_active() in { let pred = effective_fence_set(pred, fiom) in { let succ = effective_fence_set(succ, fiom) in { match (pred, succ) { (_ : bits(2) @ 0b11, _ : bits(2) @ 0b11) => __barrier(Barrier_RISCV_rw_rw()), (_ : bits(2) @ 0b10, _ : bits(2) @ 0b11) => __barrier(Barrier_RISCV_r_rw()), (_ : bits(2) @ 0b10, _ : bits(2) @ 0b10) => __barrier(Barrier_RISCV_r_r()), (_ : bits(2) @ 0b11, _ : bits(2) @ 0b01) => __barrier(Barrier_RISCV_rw_w()), (_ : bits(2) @ 0b01, _ : bits(2) @ 0b01) => __barrier(Barrier_RISCV_w_w()), (_ : bits(2) @ 0b01, _ : bits(2) @ 0b11) => __barrier(Barrier_RISCV_w_rw()), (_ : bits(2) @ 0b11, _ : bits(2) @ 0b10) => __barrier(Barrier_RISCV_rw_r()), (_ : bits(2) @ 0b10, _ : bits(2) @ 0b01) => __barrier(Barrier_RISCV_r_w()), (_ : bits(2) @ 0b01, _ : bits(2) @ 0b10) => __barrier(Barrier_RISCV_w_r()), (_ : bits(4), _ : bits(2) @ 0b00) => (), (_ : bits(2) @ 0b00, _ : bits(4)) => (), _ => { print(\\"FIXME: unsupported fence\\"); () } }; RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fence.i","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b000000000000","size":12},{"field":"0b00000","size":5},{"field":"0b001","size":3},{"field":"0b00000","size":5},{"field":"0b0001111","size":7}],"extensions":[],"function":"{ RETIRE_SUCCESS }","description":"TBD"},{"mnemonic":"fence.tso","name":"TBD","operands":[{"name":"pred","type":"bits(4)"},{"name":"succ","type":"bits(4)"}],"syntax":"pred,succ","format":"I","fields":[{"field":"0b1000","size":4},{"field":"pred","size":4},{"field":"succ","size":4},{"field":"0b00000","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b0001111","size":7}],"extensions":[],"function":"{ match (pred, succ) { (_ : bits(2) @ 0b11, _ : bits(2) @ 0b11) => __barrier(Barrier_RISCV_tso()), (_ : bits(2) @ 0b00, _ : bits(2) @ 0b00) => (), _ => { print(\\"FIXME: unsupported fence\\"); () } }; RETIRE_SUCCESS }","description":"TBD"},{"mnemonic":"feq.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_D = rF_or_X_D(rs1) in { let rs2_val_D = rF_or_X_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"feq.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_H = rF_or_X_H(rs1) in { let rs2_val_H = rF_or_X_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"feq.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_S = rF_or_X_S(rs1) in { let rs2_val_S = rF_or_X_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"flb","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"rd","size":5},{"field":"0b0000111","size":7}],"extensions":["D"],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let (aq, rl, res) = (false, false, false) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)), WORD => process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)), DOUBLE if gteq_int(64, 64) => process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)), _ => report_invalid_width(\\"model/riscv_insts_fext.sail\\", 397, width, \\"floating point load\\") } } } } } } }","description":"TBD"},{"mnemonic":"fld","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"rd","size":5},{"field":"0b0000111","size":7}],"extensions":["D"],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let (aq, rl, res) = (false, false, false) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)), WORD => process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)), DOUBLE if gteq_int(64, 64) => process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)), _ => report_invalid_width(\\"model/riscv_insts_fext.sail\\", 397, width, \\"floating point load\\") } } } } } } }","description":"TBD"},{"mnemonic":"fle.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_D = rF_or_X_D(rs1) in { let rs2_val_D = rF_or_X_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fle.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_H = rF_or_X_H(rs1) in { let rs2_val_H = rF_or_X_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fle.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_S = rF_or_X_S(rs1) in { let rs2_val_S = rF_or_X_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fleq.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{ let rs1_val_D = rF_D(rs1) in { let rs2_val_D = rF_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le_quiet(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fleq.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh","Zfa"],"function":"{ let rs1_val_H = rF_H(rs1) in { let rs2_val_H = rF_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le_quiet(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fleq.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfa"],"function":"{ let rs1_val_S = rF_S(rs1) in { let rs2_val_S = rF_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le_quiet(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"flh","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"rd","size":5},{"field":"0b0000111","size":7}],"extensions":["D"],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let (aq, rl, res) = (false, false, false) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)), WORD => process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)), DOUBLE if gteq_int(64, 64) => process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)), _ => report_invalid_width(\\"model/riscv_insts_fext.sail\\", 397, width, \\"floating point load\\") } } } } } } }","description":"TBD"},{"mnemonic":"fli.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"constantidx","type":"bits(5)"}],"syntax":"rd,constantidx","format":"TBD","fields":[{"field":"0b1111001","size":7},{"field":"0b00001","size":5},{"field":"rs1","size":3},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{ let bits : bits(64) = match constantidx { 0b00000 => { 0xbff0000000000000 }, 0b00001 => { 0x0010000000000000 }, 0b00010 => { 0x3Ef0000000000000 }, 0b00011 => { 0x3f00000000000000 }, 0b00100 => { 0x3f70000000000000 }, 0b00101 => { 0x3f80000000000000 }, 0b00110 => { 0x3fb0000000000000 }, 0b00111 => { 0x3fc0000000000000 }, 0b01000 => { 0x3fd0000000000000 }, 0b01001 => { 0x3fd4000000000000 }, 0b01010 => { 0x3fd8000000000000 }, 0b01011 => { 0x3fdc000000000000 }, 0b01100 => { 0x3fe0000000000000 }, 0b01101 => { 0x3fe4000000000000 }, 0b01110 => { 0x3fe8000000000000 }, 0b01111 => { 0x3fec000000000000 }, 0b10000 => { 0x3ff0000000000000 }, 0b10001 => { 0x3ff4000000000000 }, 0b10010 => { 0x3ff8000000000000 }, 0b10011 => { 0x3ffc000000000000 }, 0b10100 => { 0x4000000000000000 }, 0b10101 => { 0x4004000000000000 }, 0b10110 => { 0x4008000000000000 }, 0b10111 => { 0x4010000000000000 }, 0b11000 => { 0x4020000000000000 }, 0b11001 => { 0x4030000000000000 }, 0b11010 => { 0x4060000000000000 }, 0b11011 => { 0x4070000000000000 }, 0b11100 => { 0x40e0000000000000 }, 0b11101 => { 0x40f0000000000000 }, 0b11110 => { 0x7ff0000000000000 }, _ : bitvector(5) => { canonical_NaN_D() } } in { wF_D(rd, bits); RETIRE_SUCCESS } }","description":"TBD"},{"mnemonic":"fli.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"constantidx","type":"bits(5)"}],"syntax":"rd,constantidx","format":"TBD","fields":[{"field":"0b1111010","size":7},{"field":"0b00001","size":5},{"field":"rs1","size":3},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh","Zfa"],"function":"{ let bits : bits(16) = match constantidx { 0b00000 => { 0xbc00 }, 0b00001 => { 0x0400 }, 0b00010 => { 0x0100 }, 0b00011 => { 0x0200 }, 0b00100 => { 0x1c00 }, 0b00101 => { 0x2000 }, 0b00110 => { 0x2c00 }, 0b00111 => { 0x3000 }, 0b01000 => { 0x3400 }, 0b01001 => { 0x3500 }, 0b01010 => { 0x3600 }, 0b01011 => { 0x3700 }, 0b01100 => { 0x3800 }, 0b01101 => { 0x3900 }, 0b01110 => { 0x3a00 }, 0b01111 => { 0x3b00 }, 0b10000 => { 0x3c00 }, 0b10001 => { 0x3d00 }, 0b10010 => { 0x3e00 }, 0b10011 => { 0x3f00 }, 0b10100 => { 0x4000 }, 0b10101 => { 0x4100 }, 0b10110 => { 0x4200 }, 0b10111 => { 0x4400 }, 0b11000 => { 0x4800 }, 0b11001 => { 0x4c00 }, 0b11010 => { 0x5800 }, 0b11011 => { 0x5c00 }, 0b11100 => { 0x7800 }, 0b11101 => { 0x7c00 }, 0b11110 => { 0x7c00 }, _ : bitvector(5) => { canonical_NaN_H() } } in { wF_H(rd, bits); RETIRE_SUCCESS } }","description":"TBD"},{"mnemonic":"fli.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"constantidx","type":"bits(5)"}],"syntax":"rd,constantidx","format":"TBD","fields":[{"field":"0b1111000","size":7},{"field":"0b00001","size":5},{"field":"rs1","size":3},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfa"],"function":"{ let bits : bits(32) = match constantidx { 0b00000 => { 0xbf800000 }, 0b00001 => { 0x00800000 }, 0b00010 => { 0x37800000 }, 0b00011 => { 0x38000000 }, 0b00100 => { 0x3b800000 }, 0b00101 => { 0x3c000000 }, 0b00110 => { 0x3d800000 }, 0b00111 => { 0x3e000000 }, 0b01000 => { 0x3e800000 }, 0b01001 => { 0x3ea00000 }, 0b01010 => { 0x3ec00000 }, 0b01011 => { 0x3ee00000 }, 0b01100 => { 0x3f000000 }, 0b01101 => { 0x3f200000 }, 0b01110 => { 0x3f400000 }, 0b01111 => { 0x3f600000 }, 0b10000 => { 0x3f800000 }, 0b10001 => { 0x3fa00000 }, 0b10010 => { 0x3fc00000 }, 0b10011 => { 0x3fe00000 }, 0b10100 => { 0x40000000 }, 0b10101 => { 0x40200000 }, 0b10110 => { 0x40400000 }, 0b10111 => { 0x40800000 }, 0b11000 => { 0x41000000 }, 0b11001 => { 0x41800000 }, 0b11010 => { 0x43000000 }, 0b11011 => { 0x43800000 }, 0b11100 => { 0x47000000 }, 0b11101 => { 0x47800000 }, 0b11110 => { 0x7f800000 }, _ : bitvector(5) => { canonical_NaN_S() } } in { wF_S(rd, bits); RETIRE_SUCCESS } }","description":"TBD"},{"mnemonic":"flt.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_D = rF_or_X_D(rs1) in { let rs2_val_D = rF_or_X_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"flt.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_H = rF_or_X_H(rs1) in { let rs2_val_H = rF_or_X_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"flt.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_S = rF_or_X_S(rs1) in { let rs2_val_S = rF_or_X_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fltq.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{ let rs1_val_D = rF_D(rs1) in { let rs2_val_D = rF_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Lt_quiet(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fltq.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh","Zfa"],"function":"{ let rs1_val_H = rF_H(rs1) in { let rs2_val_H = rF_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Lt_quiet(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fltq.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfa"],"function":"{ let rs1_val_S = rF_S(rs1) in { let rs2_val_S = rF_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Lt_quiet(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"flw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"rd","size":5},{"field":"0b0000111","size":7}],"extensions":["D"],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let (aq, rl, res) = (false, false, false) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)), WORD => process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)), DOUBLE if gteq_int(64, 64) => process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)), _ => report_invalid_width(\\"model/riscv_insts_fext.sail\\", 397, width, \\"floating point load\\") } } } } } } }","description":"TBD"},{"mnemonic":"fmadd.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs3","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b01","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{ let rs1_val_64b = rF_or_X_D(rs1) in { let rs2_val_64b = rF_or_X_D(rs2) in { let rs3_val_64b = rF_or_X_D(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op { FMADD_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, rs3_val_64b), FMSUB_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, negate_D(rs3_val_64b)), FNMSUB_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, rs3_val_64b), FNMADD_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, negate_D(rs3_val_64b)) } in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_64b); RETIRE_SUCCESS } } } } } } } }","description":"TBD"},{"mnemonic":"fmadd.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs3","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b10","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{ let rs1_val_16b = rF_or_X_H(rs1) in { let rs2_val_16b = rF_or_X_H(rs2) in { let rs3_val_16b = rF_or_X_H(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op { FMADD_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, rs3_val_16b), FMSUB_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, negate_H(rs3_val_16b)), FNMSUB_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, rs3_val_16b), FNMADD_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, negate_H(rs3_val_16b)) } in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_16b); RETIRE_SUCCESS } } } } } } } }","description":"TBD"},{"mnemonic":"fmadd.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs3","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b00","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{ let rs1_val_32b = rF_or_X_S(rs1) in { let rs2_val_32b = rF_or_X_S(rs2) in { let rs3_val_32b = rF_or_X_S(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op { FMADD_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, rs3_val_32b), FMSUB_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, negate_S(rs3_val_32b)), FNMSUB_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, rs3_val_32b), FNMADD_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, negate_S(rs3_val_32b)) } in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_32b); RETIRE_SUCCESS } } } } } } } }","description":"TBD"},{"mnemonic":"fmax.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_D = rF_or_X_D(rs1) in { let rs2_val_D = rF_or_X_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fmax.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_H = rF_or_X_H(rs1) in { let rs2_val_H = rF_or_X_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fmax.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_S = rF_or_X_S(rs1) in { let rs2_val_S = rF_or_X_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fmaxm.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{ let rs1_val_D = rF_bits(rs1) in { let rs2_val_D = rF_bits(rs2) in { let is_quiet = true in { let (rs2_lt_rs1, fflags) = fle_D(rs2_val_D, rs1_val_D, is_quiet) in { let rd_val_D = if or_bool(f_is_NaN_D(rs1_val_D), f_is_NaN_D(rs2_val_D)) then canonical_NaN_D() else if and_bool(f_is_neg_zero_D(rs1_val_D), f_is_pos_zero_D(rs2_val_D)) then rs2_val_D else if and_bool(f_is_neg_zero_D(rs2_val_D), f_is_pos_zero_D(rs1_val_D)) then rs1_val_D else if rs2_lt_rs1 then rs1_val_D else rs2_val_D in { accrue_fflags(fflags); wF_bits(rd, rd_val_D); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fmaxm.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010110","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh","Zfa"],"function":"{ let rs1_val_H = rF_H(rs1) in { let rs2_val_H = rF_H(rs2) in { let is_quiet = true in { let (rs2_lt_rs1, fflags) = fle_H(rs2_val_H, rs1_val_H, is_quiet) in { let rd_val_H = if or_bool(f_is_NaN_H(rs1_val_H), f_is_NaN_H(rs2_val_H)) then canonical_NaN_H() else if and_bool(f_is_neg_zero_H(rs1_val_H), f_is_pos_zero_H(rs2_val_H)) then rs2_val_H else if and_bool(f_is_neg_zero_H(rs2_val_H), f_is_pos_zero_H(rs1_val_H)) then rs1_val_H else if rs2_lt_rs1 then rs1_val_H else rs2_val_H in { accrue_fflags(fflags); wF_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fmaxm.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfa"],"function":"{ let rs1_val_S = rF_S(rs1) in { let rs2_val_S = rF_S(rs2) in { let is_quiet = true in { let (rs2_lt_rs1, fflags) = fle_S(rs2_val_S, rs1_val_S, is_quiet) in { let rd_val_S = if or_bool(f_is_NaN_S(rs1_val_S), f_is_NaN_S(rs2_val_S)) then canonical_NaN_S() else if and_bool(f_is_neg_zero_S(rs1_val_S), f_is_pos_zero_S(rs2_val_S)) then rs2_val_S else if and_bool(f_is_neg_zero_S(rs2_val_S), f_is_pos_zero_S(rs1_val_S)) then rs1_val_S else if rs2_lt_rs1 then rs1_val_S else rs2_val_S in { accrue_fflags(fflags); wF_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fmin.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_D = rF_or_X_D(rs1) in { let rs2_val_D = rF_or_X_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fmin.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_H = rF_or_X_H(rs1) in { let rs2_val_H = rF_or_X_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fmin.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_S = rF_or_X_S(rs1) in { let rs2_val_S = rF_or_X_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fminm.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b010","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{ let rs1_val_D = rF_bits(rs1) in { let rs2_val_D = rF_bits(rs2) in { let is_quiet = true in { let (rs1_lt_rs2, fflags) = fle_D(rs1_val_D, rs2_val_D, is_quiet) in { let rd_val_D = if or_bool(f_is_NaN_D(rs1_val_D), f_is_NaN_D(rs2_val_D)) then canonical_NaN_D() else if and_bool(f_is_neg_zero_D(rs1_val_D), f_is_pos_zero_D(rs2_val_D)) then rs1_val_D else if and_bool(f_is_neg_zero_D(rs2_val_D), f_is_pos_zero_D(rs1_val_D)) then rs2_val_D else if rs1_lt_rs2 then rs1_val_D else rs2_val_D in { accrue_fflags(fflags); wF_bits(rd, rd_val_D); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fminm.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010110","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b010","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh","Zfa"],"function":"{ let rs1_val_H = rF_H(rs1) in { let rs2_val_H = rF_H(rs2) in { let is_quiet = true in { let (rs1_lt_rs2, fflags) = fle_H(rs1_val_H, rs2_val_H, is_quiet) in { let rd_val_H = if or_bool(f_is_NaN_H(rs1_val_H), f_is_NaN_H(rs2_val_H)) then canonical_NaN_H() else if and_bool(f_is_neg_zero_H(rs1_val_H), f_is_pos_zero_H(rs2_val_H)) then rs1_val_H else if and_bool(f_is_neg_zero_H(rs2_val_H), f_is_pos_zero_H(rs1_val_H)) then rs2_val_H else if rs1_lt_rs2 then rs1_val_H else rs2_val_H in { accrue_fflags(fflags); wF_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fminm.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b010","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfa"],"function":"{ let rs1_val_S = rF_S(rs1) in { let rs2_val_S = rF_S(rs2) in { let is_quiet = true in { let (rs1_lt_rs2, fflags) = fle_S(rs1_val_S, rs2_val_S, is_quiet) in { let rd_val_S = if or_bool(f_is_NaN_S(rs1_val_S), f_is_NaN_S(rs2_val_S)) then canonical_NaN_S() else if and_bool(f_is_neg_zero_S(rs1_val_S), f_is_pos_zero_S(rs2_val_S)) then rs1_val_S else if and_bool(f_is_neg_zero_S(rs2_val_S), f_is_pos_zero_S(rs1_val_S)) then rs2_val_S else if rs1_lt_rs2 then rs1_val_S else rs2_val_S in { accrue_fflags(fflags); wF_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fmsub.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs3","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b01","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{ let rs1_val_64b = rF_or_X_D(rs1) in { let rs2_val_64b = rF_or_X_D(rs2) in { let rs3_val_64b = rF_or_X_D(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op { FMADD_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, rs3_val_64b), FMSUB_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, negate_D(rs3_val_64b)), FNMSUB_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, rs3_val_64b), FNMADD_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, negate_D(rs3_val_64b)) } in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_64b); RETIRE_SUCCESS } } } } } } } }","description":"TBD"},{"mnemonic":"fmsub.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs3","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b10","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{ let rs1_val_16b = rF_or_X_H(rs1) in { let rs2_val_16b = rF_or_X_H(rs2) in { let rs3_val_16b = rF_or_X_H(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op { FMADD_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, rs3_val_16b), FMSUB_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, negate_H(rs3_val_16b)), FNMSUB_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, rs3_val_16b), FNMADD_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, negate_H(rs3_val_16b)) } in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_16b); RETIRE_SUCCESS } } } } } } } }","description":"TBD"},{"mnemonic":"fmsub.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs3","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b00","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{ let rs1_val_32b = rF_or_X_S(rs1) in { let rs2_val_32b = rF_or_X_S(rs2) in { let rs3_val_32b = rF_or_X_S(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op { FMADD_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, rs3_val_32b), FMSUB_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, negate_S(rs3_val_32b)), FNMSUB_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, rs3_val_32b), FNMADD_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, negate_S(rs3_val_32b)) } in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_32b); RETIRE_SUCCESS } } } } } } } }","description":"TBD"},{"mnemonic":"fmul.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_64b = rF_or_X_D(rs1) in { let rs2_val_64b = rF_or_X_D(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op { FADD_D => riscv_f64Add(rm_3b, rs1_val_64b, rs2_val_64b), FSUB_D => riscv_f64Sub(rm_3b, rs1_val_64b, rs2_val_64b), FMUL_D => riscv_f64Mul(rm_3b, rs1_val_64b, rs2_val_64b), FDIV_D => riscv_f64Div(rm_3b, rs1_val_64b, rs2_val_64b) } in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_64b); RETIRE_SUCCESS } } } } } } }","description":"TBD"},{"mnemonic":"fmul.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001110","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_16b = rF_or_X_H(rs1) in { let rs2_val_16b = rF_or_X_H(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op { FADD_H => riscv_f16Add(rm_3b, rs1_val_16b, rs2_val_16b), FSUB_H => riscv_f16Sub(rm_3b, rs1_val_16b, rs2_val_16b), FMUL_H => riscv_f16Mul(rm_3b, rs1_val_16b, rs2_val_16b), FDIV_H => riscv_f16Div(rm_3b, rs1_val_16b, rs2_val_16b) } in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_16b); RETIRE_SUCCESS } } } } } } }","description":"TBD"},{"mnemonic":"fmul.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_32b = rF_or_X_S(rs1) in { let rs2_val_32b = rF_or_X_S(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op { FADD_S => riscv_f32Add(rm_3b, rs1_val_32b, rs2_val_32b), FSUB_S => riscv_f32Sub(rm_3b, rs1_val_32b, rs2_val_32b), FMUL_S => riscv_f32Mul(rm_3b, rs1_val_32b, rs2_val_32b), FDIV_S => riscv_f32Div(rm_3b, rs1_val_32b, rs2_val_32b) } in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_32b); RETIRE_SUCCESS } } } } } } }","description":"TBD"},{"mnemonic":"fmv.d.x","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111001","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D"],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_dext.sail:1004.27-1004.28\\"); let rs1_val_X = rX_bits(rs1) in { let rd_val_D = subrange_bits(rs1_val_X, 63, 0) in { wF_bits(rd, rd_val_D); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"fmv.h.x","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111010","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh"],"function":"{ let rs1_val_X = rX_bits(rs1) in { let rd_val_H = subrange_bits(rs1_val_X, 15, 0) in { wF_bits(rd, nan_box_H(rd_val_H)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"fmv.w.x","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111000","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["F"],"function":"{ let rs1_val_X = rX_bits(rs1) in { let rd_val_S = subrange_bits(rs1_val_X, 31, 0) in { wF_bits(rd, nan_box_S(rd_val_S)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"fmv.x.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111001","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D"],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_dext.sail:1004.27-1004.28\\"); let rs1_val_X = rX_bits(rs1) in { let rd_val_D = subrange_bits(rs1_val_X, 63, 0) in { wF_bits(rd, rd_val_D); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"fmv.x.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111010","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh"],"function":"{ let rs1_val_X = rX_bits(rs1) in { let rd_val_H = subrange_bits(rs1_val_X, 15, 0) in { wF_bits(rd, nan_box_H(rd_val_H)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"fmv.x.w","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111000","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["F"],"function":"{ let rs1_val_X = rX_bits(rs1) in { let rd_val_S = subrange_bits(rs1_val_X, 31, 0) in { wF_bits(rd, nan_box_S(rd_val_S)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"fmvh.x.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1110001","size":7},{"field":"0b00001","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{ let rs1_val_D = subrange_bits(rF_D(rs1), 63, 32) in { let rd_val_X : xlenbits = sign_extend(64, rs1_val_D) in { wX_bits(rd, rd_val_X); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"fmvp.d.x","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1011001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{ let rs1_val_X = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val_X = subrange_bits(rX_bits(rs2), 31, 0) in { let rd_val_D = bitvector_concat(rs2_val_X, rs1_val_X) in { wF_D(rd, rd_val_D); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fnmadd.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs3","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b01","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{ let rs1_val_64b = rF_or_X_D(rs1) in { let rs2_val_64b = rF_or_X_D(rs2) in { let rs3_val_64b = rF_or_X_D(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op { FMADD_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, rs3_val_64b), FMSUB_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, negate_D(rs3_val_64b)), FNMSUB_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, rs3_val_64b), FNMADD_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, negate_D(rs3_val_64b)) } in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_64b); RETIRE_SUCCESS } } } } } } } }","description":"TBD"},{"mnemonic":"fnmadd.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs3","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b10","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{ let rs1_val_16b = rF_or_X_H(rs1) in { let rs2_val_16b = rF_or_X_H(rs2) in { let rs3_val_16b = rF_or_X_H(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op { FMADD_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, rs3_val_16b), FMSUB_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, negate_H(rs3_val_16b)), FNMSUB_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, rs3_val_16b), FNMADD_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, negate_H(rs3_val_16b)) } in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_16b); RETIRE_SUCCESS } } } } } } } }","description":"TBD"},{"mnemonic":"fnmadd.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs3","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b00","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{ let rs1_val_32b = rF_or_X_S(rs1) in { let rs2_val_32b = rF_or_X_S(rs2) in { let rs3_val_32b = rF_or_X_S(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op { FMADD_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, rs3_val_32b), FMSUB_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, negate_S(rs3_val_32b)), FNMSUB_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, rs3_val_32b), FNMADD_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, negate_S(rs3_val_32b)) } in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_32b); RETIRE_SUCCESS } } } } } } } }","description":"TBD"},{"mnemonic":"fnmsub.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs3","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b01","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{ let rs1_val_64b = rF_or_X_D(rs1) in { let rs2_val_64b = rF_or_X_D(rs2) in { let rs3_val_64b = rF_or_X_D(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op { FMADD_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, rs3_val_64b), FMSUB_D => riscv_f64MulAdd(rm_3b, rs1_val_64b, rs2_val_64b, negate_D(rs3_val_64b)), FNMSUB_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, rs3_val_64b), FNMADD_D => riscv_f64MulAdd(rm_3b, negate_D(rs1_val_64b), rs2_val_64b, negate_D(rs3_val_64b)) } in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_64b); RETIRE_SUCCESS } } } } } } } }","description":"TBD"},{"mnemonic":"fnmsub.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs3","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b10","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{ let rs1_val_16b = rF_or_X_H(rs1) in { let rs2_val_16b = rF_or_X_H(rs2) in { let rs3_val_16b = rF_or_X_H(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op { FMADD_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, rs3_val_16b), FMSUB_H => riscv_f16MulAdd(rm_3b, rs1_val_16b, rs2_val_16b, negate_H(rs3_val_16b)), FNMSUB_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, rs3_val_16b), FNMADD_H => riscv_f16MulAdd(rm_3b, negate_H(rs1_val_16b), rs2_val_16b, negate_H(rs3_val_16b)) } in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_16b); RETIRE_SUCCESS } } } } } } } }","description":"TBD"},{"mnemonic":"fnmsub.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs3","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b00","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{ let rs1_val_32b = rF_or_X_S(rs1) in { let rs2_val_32b = rF_or_X_S(rs2) in { let rs3_val_32b = rF_or_X_S(rs3) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op { FMADD_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, rs3_val_32b), FMSUB_S => riscv_f32MulAdd(rm_3b, rs1_val_32b, rs2_val_32b, negate_S(rs3_val_32b)), FNMSUB_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, rs3_val_32b), FNMADD_S => riscv_f32MulAdd(rm_3b, negate_S(rs1_val_32b), rs2_val_32b, negate_S(rs3_val_32b)) } in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_32b); RETIRE_SUCCESS } } } } } } } }","description":"TBD"},{"mnemonic":"fround.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b0100001","size":7},{"field":"0b00100","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{ let rs1_val_D = rF_bits(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_D) = riscv_f64roundToInt(rm_3b, rs1_val_D, false) in { accrue_fflags(fflags); wF_bits(rd, rd_val_D); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fround.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b0100010","size":7},{"field":"0b00100","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh","Zfa"],"function":"{ let rs1_val_H = rF_H(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_H) = riscv_f16roundToInt(rm_3b, rs1_val_H, false) in { accrue_fflags(fflags); wF_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fround.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"0b00100","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfa"],"function":"{ let rs1_val_S = rF_S(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_S) = riscv_f32roundToInt(rm_3b, rs1_val_S, false) in { accrue_fflags(fflags); wF_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"froundnx.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b0100001","size":7},{"field":"0b00101","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{ let rs1_val_D = rF_D(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_D) = riscv_f64roundToInt(rm_3b, rs1_val_D, true) in { accrue_fflags(fflags); wF_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"froundnx.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b0100010","size":7},{"field":"0b00101","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh","Zfa"],"function":"{ let rs1_val_H = rF_H(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_H) = riscv_f16roundToInt(rm_3b, rs1_val_H, true) in { accrue_fflags(fflags); wF_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"froundnx.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"0b00101","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfa"],"function":"{ let rs1_val_S = rF_S(rs1) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_S) = riscv_f32roundToInt(rm_3b, rs1_val_S, true) in { accrue_fflags(fflags); wF_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fsb","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"imm5","size":1},{"field":"0b0100111","size":7}],"extensions":["D"],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { let (aq, rl, con) = (false, false, false) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => MemValue(), HALF => mem_write_ea(addr, 2, aq, rl, false), WORD => mem_write_ea(addr, 4, aq, rl, false), DOUBLE => mem_write_ea(addr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rF_bits(rs2) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fstore(vaddr, mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, con)), WORD => process_fstore(vaddr, mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, con)), DOUBLE if gteq_int(64, 64) => process_fstore(vaddr, mem_write_value(addr, 8, rs2_val, aq, rl, con)), _ => report_invalid_width(\\"model/riscv_insts_fext.sail\\", 470, width, \\"floating point store\\") } } } } } } } } } } }","description":"TBD"},{"mnemonic":"fsd","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"imm5","size":1},{"field":"0b0100111","size":7}],"extensions":["D"],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { let (aq, rl, con) = (false, false, false) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => MemValue(), HALF => mem_write_ea(addr, 2, aq, rl, false), WORD => mem_write_ea(addr, 4, aq, rl, false), DOUBLE => mem_write_ea(addr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rF_bits(rs2) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fstore(vaddr, mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, con)), WORD => process_fstore(vaddr, mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, con)), DOUBLE if gteq_int(64, 64) => process_fstore(vaddr, mem_write_value(addr, 8, rs2_val, aq, rl, con)), _ => report_invalid_width(\\"model/riscv_insts_fext.sail\\", 470, width, \\"floating point store\\") } } } } } } } } } } }","description":"TBD"},{"mnemonic":"fsgnj.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_D = rF_or_X_D(rs1) in { let rs2_val_D = rF_or_X_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fsgnj.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_H = rF_or_X_H(rs1) in { let rs2_val_H = rF_or_X_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fsgnj.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_S = rF_or_X_S(rs1) in { let rs2_val_S = rF_or_X_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fsgnjn.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_D = rF_or_X_D(rs1) in { let rs2_val_D = rF_or_X_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fsgnjn.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_H = rF_or_X_H(rs1) in { let rs2_val_H = rF_or_X_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fsgnjn.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_S = rF_or_X_S(rs1) in { let rs2_val_S = rF_or_X_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fsgnjx.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_D = rF_or_X_D(rs1) in { let rs2_val_D = rF_or_X_D(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f64Le(rs1_val_D, rs2_val_D) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fsgnjx.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_H = rF_or_X_H(rs1) in { let rs2_val_H = rF_or_X_H(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f16Le(rs1_val_H, rs2_val_H) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fsgnjx.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_S = rF_or_X_S(rs1) in { let rs2_val_S = rF_or_X_S(rs2) in { let (fflags, rd_val) : (bits_fflags, bool) = riscv_f32Le(rs1_val_S, rs2_val_S) in { accrue_fflags(fflags); wX_bits(rd, zero_extend(64, bool_to_bits(rd_val))); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"fsh","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"imm5","size":1},{"field":"0b0100111","size":7}],"extensions":["D"],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { let (aq, rl, con) = (false, false, false) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => MemValue(), HALF => mem_write_ea(addr, 2, aq, rl, false), WORD => mem_write_ea(addr, 4, aq, rl, false), DOUBLE => mem_write_ea(addr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rF_bits(rs2) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fstore(vaddr, mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, con)), WORD => process_fstore(vaddr, mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, con)), DOUBLE if gteq_int(64, 64) => process_fstore(vaddr, mem_write_value(addr, 8, rs2_val, aq, rl, con)), _ => report_invalid_width(\\"model/riscv_insts_fext.sail\\", 470, width, \\"floating point store\\") } } } } } } } } } } }","description":"TBD"},{"mnemonic":"fsqrt.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_dext.sail:650.27-650.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_D) = riscv_ui64ToF64(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_D); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fsqrt.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_zfh.sail:823.27-823.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_H) = riscv_ui64ToF16(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_H); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fsqrt.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ assert(gteq_int(64, 64), \\"model/riscv_insts_fext.sail:789.27-789.28\\"); let rs1_val_LU = subrange_bits(rX_bits(rs1), 63, 0) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_S) = riscv_ui64ToF32(rm_3b, rs1_val_LU) in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_S); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"fsub.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_64b = rF_or_X_D(rs1) in { let rs2_val_64b = rF_or_X_D(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op { FADD_D => riscv_f64Add(rm_3b, rs1_val_64b, rs2_val_64b), FSUB_D => riscv_f64Sub(rm_3b, rs1_val_64b, rs2_val_64b), FMUL_D => riscv_f64Mul(rm_3b, rs1_val_64b, rs2_val_64b), FDIV_D => riscv_f64Div(rm_3b, rs1_val_64b, rs2_val_64b) } in { accrue_fflags(fflags); wF_or_X_D(rd, rd_val_64b); RETIRE_SUCCESS } } } } } } }","description":"TBD"},{"mnemonic":"fsub.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001110","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_16b = rF_or_X_H(rs1) in { let rs2_val_16b = rF_or_X_H(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op { FADD_H => riscv_f16Add(rm_3b, rs1_val_16b, rs2_val_16b), FSUB_H => riscv_f16Sub(rm_3b, rs1_val_16b, rs2_val_16b), FMUL_H => riscv_f16Mul(rm_3b, rs1_val_16b, rs2_val_16b), FDIV_H => riscv_f16Div(rm_3b, rs1_val_16b, rs2_val_16b) } in { accrue_fflags(fflags); wF_or_X_H(rd, rd_val_16b); RETIRE_SUCCESS } } } } } } }","description":"TBD"},{"mnemonic":"fsub.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rm","type":"rounding_mode"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{ let rs1_val_32b = rF_or_X_S(rs1) in { let rs2_val_32b = rF_or_X_S(rs2) in { match select_instr_or_fcsr_rm(rm) { None(()) => { handle_illegal(); RETIRE_FAIL }, Some(rm\') => { let rm_3b = encdec_rounding_mode_forwards(rm\') in { let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op { FADD_S => riscv_f32Add(rm_3b, rs1_val_32b, rs2_val_32b), FSUB_S => riscv_f32Sub(rm_3b, rs1_val_32b, rs2_val_32b), FMUL_S => riscv_f32Mul(rm_3b, rs1_val_32b, rs2_val_32b), FDIV_S => riscv_f32Div(rm_3b, rs1_val_32b, rs2_val_32b) } in { accrue_fflags(fflags); wF_or_X_S(rd, rd_val_32b); RETIRE_SUCCESS } } } } } } }","description":"TBD"},{"mnemonic":"fsw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"imm5","size":1},{"field":"0b0100111","size":7}],"extensions":["D"],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { let (aq, rl, con) = (false, false, false) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => MemValue(), HALF => mem_write_ea(addr, 2, aq, rl, false), WORD => mem_write_ea(addr, 4, aq, rl, false), DOUBLE => mem_write_ea(addr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rF_bits(rs2) in { match width { BYTE => { handle_illegal(); RETIRE_FAIL }, HALF => process_fstore(vaddr, mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, con)), WORD => process_fstore(vaddr, mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, con)), DOUBLE if gteq_int(64, 64) => process_fstore(vaddr, mem_write_value(addr, 8, rs2_val, aq, rl, con)), _ => report_invalid_width(\\"model/riscv_insts_fext.sail\\", 470, width, \\"floating point store\\") } } } } } } } } } } }","description":"TBD"},{"mnemonic":"illegal","name":"TBD","operands":[{"name":"s","type":"word"}],"syntax":"s","format":"TBD","fields":[{"field":"s","size":32}],"extensions":[],"function":"{ handle_illegal(); RETIRE_FAIL }","description":"TBD"},{"mnemonic":"jal","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(21)"}],"syntax":"rd,imm","format":"TBD","fields":[{"field":"imm_19","size":1},{"field":"imm_18_13","size":6},{"field":"imm_12_9","size":4},{"field":"imm_8","size":1},{"field":"imm_7_0","size":8},{"field":"rd","size":5},{"field":"0b1101111","size":7}],"extensions":[],"function":"{ let t : xlenbits = add_bits(PC, sign_extend(64, imm)) in { match ext_control_check_pc(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(target) => { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(extension(\\"C\\"))) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { wX_bits(rd, get_next_pc()); set_next_pc(target); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"jalr","name":"jump and link register","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"imm","type":"bits(12)"}],"syntax":"rd,rs1,imm","format":"I","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1100111","size":7}],"extensions":[],"function":"{ let t : xlenbits = add_bits(rX_bits(rs1), sign_extend(64, imm)) in { match ext_control_check_addr(t) { Ext_ControlAddr_Error(e) => { ext_handle_control_check_error(e); RETIRE_FAIL }, Ext_ControlAddr_OK(addr) => { let target = bitvector_update(addr, 0, bitzero) in { if and_bool(bit_to_bool(bitvector_access(target, 1)), not(extension(\\"C\\"))) then { handle_mem_exception(target, E_Fetch_Addr_Align()); RETIRE_FAIL } else { wX_bits(rd, get_next_pc()); set_next_pc(target); RETIRE_SUCCESS } } } } } }","description":"\\nThe target address is obtained by adding the sign-extended 12-bit\\nI-immediate to the register rs1, then setting the\\nleast-significant bit of the result to zero. The address of the\\ninstruction following the jump (pc+4) is written to register rd.\\nRegister x0 can be used as the destination if the result is not\\nrequired.\\n "},{"mnemonic":"lb","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lb.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lb.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lb.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lbu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lbu.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lbu.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lbu.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"ld","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"ld.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"ld.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"ld.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"ldu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"ldu.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"ldu.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"ldu.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lh","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lh.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lh.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lh.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lhu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lhu.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lhu.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lhu.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lr.b","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 156, \\"Unexpected AMO width\\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"lr.b.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 156, \\"Unexpected AMO width\\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"lr.b.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 156, \\"Unexpected AMO width\\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"lr.b.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 156, \\"Unexpected AMO width\\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"lr.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 156, \\"Unexpected AMO width\\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"lr.d.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 156, \\"Unexpected AMO width\\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"lr.d.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 156, \\"Unexpected AMO width\\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"lr.d.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 156, \\"Unexpected AMO width\\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"lr.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 156, \\"Unexpected AMO width\\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"lr.h.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 156, \\"Unexpected AMO width\\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"lr.h.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 156, \\"Unexpected AMO width\\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"lr.h.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 156, \\"Unexpected AMO width\\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"lr.w","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 156, \\"Unexpected AMO width\\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"lr.w.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 156, \\"Unexpected AMO width\\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"lr.w.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 156, \\"Unexpected AMO width\\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"lr.w.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => match (width, 64) { (BYTE, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, and_bool(aq, rl), true), false), (HALF, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, and_bool(aq, rl), true), false), (WORD, _) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, and_bool(aq, rl), true), false), (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, and_bool(aq, rl), true), false), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 156, \\"Unexpected AMO width\\") } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"lui","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(20)"}],"syntax":"rd,imm","format":"TBD","fields":[{"field":"imm","size":20},{"field":"rd","size":5},{"field":"encdec_uop(op)","size":7}],"extensions":[],"function":"{ let off : xlenbits = sign_extend(64, bitvector_concat(imm, 0x000)) in { let ret : xlenbits = match op { RISCV_LUI => off, RISCV_AUIPC => add_bits(get_arch_pc(), off) } in { wX_bits(rd, ret); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"lw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lw.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lw.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lw.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lwu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lwu.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lwu.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"lwu.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Read(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Read(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => match width { BYTE => process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned), HALF => process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned), WORD => process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned), DOUBLE if gteq_int(64, 64) => process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 419, width, \\"load\\") } } } } }","description":"TBD"},{"mnemonic":"max","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"maxu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"min","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"minu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"mret","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b0011000","size":7},{"field":"0b00010","size":5},{"field":"0b00000","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{ if neq_anything(cur_privilege, Machine) then { handle_illegal(); RETIRE_FAIL } else if not(ext_check_xret_priv(Machine)) then { ext_fail_xret_priv(); RETIRE_FAIL } else { set_next_pc(exception_handler(cur_privilege, CTL_MRET(), PC)); RETIRE_SUCCESS } }","description":"TBD"},{"mnemonic":"mul","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_mul_op(high,signed1,signed2)","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ if or_bool(haveMulDiv(), haveZmmul()) then { let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let rs1_int : int = if signed1 then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if signed2 then signed(rs2_val) else unsigned(rs2_val) in { let result_wide = to_bits(mult_atom(2, 64), mult_atom(rs1_int, rs2_int)) in { let result = if high then subrange_bits(result_wide, sub_atom(mult_atom(2, 64), 1), 64) else subrange_bits(result_wide, sub_atom(64, 1), 0) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"mulh","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_mul_op(high,signed1,signed2)","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ if or_bool(haveMulDiv(), haveZmmul()) then { let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let rs1_int : int = if signed1 then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if signed2 then signed(rs2_val) else unsigned(rs2_val) in { let result_wide = to_bits(mult_atom(2, 64), mult_atom(rs1_int, rs2_int)) in { let result = if high then subrange_bits(result_wide, sub_atom(mult_atom(2, 64), 1), 64) else subrange_bits(result_wide, sub_atom(64, 1), 0) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"mulhsu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_mul_op(high,signed1,signed2)","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ if or_bool(haveMulDiv(), haveZmmul()) then { let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let rs1_int : int = if signed1 then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if signed2 then signed(rs2_val) else unsigned(rs2_val) in { let result_wide = to_bits(mult_atom(2, 64), mult_atom(rs1_int, rs2_int)) in { let result = if high then subrange_bits(result_wide, sub_atom(mult_atom(2, 64), 1), 64) else subrange_bits(result_wide, sub_atom(64, 1), 0) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"mulhu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_mul_op(high,signed1,signed2)","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ if or_bool(haveMulDiv(), haveZmmul()) then { let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let rs1_int : int = if signed1 then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if signed2 then signed(rs2_val) else unsigned(rs2_val) in { let result_wide = to_bits(mult_atom(2, 64), mult_atom(rs1_int, rs2_int)) in { let result = if high then subrange_bits(result_wide, sub_atom(mult_atom(2, 64), 1), 64) else subrange_bits(result_wide, sub_atom(64, 1), 0) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"mulw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":[],"function":"{ if or_bool(haveMulDiv(), haveZmmul()) then { let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let rs1_int : int = signed(rs1_val) in { let rs2_int : int = signed(rs2_val) in { let result32 = subrange_bits(to_bits(64, mult_atom(rs1_int, rs2_int)), 31, 0) in { let result : xlenbits = sign_extend(64, result32) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"or","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"orc.b","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b001010000111","size":12},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbb"],"function":"{ let rs1_val = rX_bits(rs1) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 8) by 8 order inc) { result[add_atom(i, 7) .. i] = if eq_bits(subrange_bits(rs1_val, add_atom(i, 7), i), zeros_implicit(add_atom(sub_atom(add_atom(__id(i), 7), __id(i)), 1))) then 0x00 else 0xFF; wX_bits(rd, result); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"ori","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"imm","type":"bits(12)"}],"syntax":"rd,rs1,imm","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"encdec_iop(op)","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let immext : xlenbits = sign_extend(64, imm) in { let result : xlenbits = match op { RISCV_ADDI => add_bits(rs1_val, immext), RISCV_SLTI => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, immext))), RISCV_SLTIU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, immext))), RISCV_ANDI => and_vec(rs1_val, immext), RISCV_ORI => or_vec(rs1_val, immext), RISCV_XORI => xor_vec(rs1_val, immext) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"orn","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"pack","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b111","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbkb"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_PACK => bitvector_concat(subrange_bits(rs2_val, sub_atom(mult_atom(8, 4), 1), 0), subrange_bits(rs1_val, sub_atom(mult_atom(8, 4), 1), 0)), RISCV_PACKH => zero_extend(64, bitvector_concat(subrange_bits(rs2_val, 7, 0), subrange_bits(rs1_val, 7, 0))) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"packh","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b111","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbkb"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_PACK => bitvector_concat(subrange_bits(rs2_val, sub_atom(mult_atom(8, 4), 1), 0), subrange_bits(rs1_val, sub_atom(mult_atom(8, 4), 1), 0)), RISCV_PACKH => zero_extend(64, bitvector_concat(subrange_bits(rs2_val, 7, 0), subrange_bits(rs1_val, 7, 0))) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"packw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zbkb"],"function":"{ assert(eq_int(64, 64), \\"model/riscv_insts_zbkb.sail:109.27-109.28\\"); let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : bits(32) = bitvector_concat(subrange_bits(rs2_val, 15, 0), subrange_bits(rs1_val, 15, 0)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"rem","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b11","size":2},{"field":"bool_not_bits(s)","size":1},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ if haveMulDiv() then { let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let r : int = if eq_int(rs2_int, 0) then rs1_int else rem_round_zero(rs1_int, rs2_int) in { wX_bits(rd, to_bits(64, r)); RETIRE_SUCCESS } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"remu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b11","size":2},{"field":"bool_not_bits(s)","size":1},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ if haveMulDiv() then { let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let r : int = if eq_int(rs2_int, 0) then rs1_int else rem_round_zero(rs1_int, rs2_int) in { wX_bits(rd, to_bits(64, r)); RETIRE_SUCCESS } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"remuw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b11","size":2},{"field":"bool_not_bits(s)","size":1},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":[],"function":"{ if haveMulDiv() then { let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let r : int = if eq_int(rs2_int, 0) then rs1_int else rem_round_zero(rs1_int, rs2_int) in { wX_bits(rd, sign_extend(64, to_bits(32, r))); RETIRE_SUCCESS } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"remw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b11","size":2},{"field":"bool_not_bits(s)","size":1},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":[],"function":"{ if haveMulDiv() then { let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val) in { let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val) in { let r : int = if eq_int(rs2_int, 0) then rs1_int else rem_round_zero(rs1_int, rs2_int) in { wX_bits(rd, sign_extend(64, to_bits(32, r))); RETIRE_SUCCESS } } } } } } else { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"rev8","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b011010111000","size":12},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{ let rs1_val = rX_bits(rs1) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 8) by 8 order inc) { result[add_atom(i, 7) .. i] = subrange_bits(rs1_val, sub_atom(sub_atom(64, i), 1), sub_atom(sub_atom(64, i), 8)); wX_bits(rd, result); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"rol","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"rolw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let shamt = subrange_bits(rX_bits(rs2), 4, 0) in { let result : bits(32) = match op { RISCV_ROLW => rotate_bits_left(rs1_val, shamt), RISCV_RORW => rotate_bits_right(rs1_val, shamt) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"ror","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"rori","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"shamt","type":"bits(6)"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b011000","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(shamt, 4, 0)) else rotate_bits_right(rs1_val, shamt) in { wX_bits(rd, result); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"roriw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"shamt","type":"bits(5)"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"shamt","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let result : xlenbits = sign_extend(64, rotate_bits_right(rs1_val, shamt)) in { wX_bits(rd, result); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"rorw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let shamt = subrange_bits(rX_bits(rs2), 4, 0) in { let result : bits(32) = match op { RISCV_ROLW => rotate_bits_left(rs1_val, shamt), RISCV_RORW => rotate_bits_right(rs1_val, shamt) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"sb","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 482, width, \\"store\\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\\"model/riscv_insts_base.sail\\", 486, \\"store got false from mem_write_value\\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"sb.aq","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 482, width, \\"store\\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\\"model/riscv_insts_base.sail\\", 486, \\"store got false from mem_write_value\\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"sb.aq.rl","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 482, width, \\"store\\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\\"model/riscv_insts_base.sail\\", 486, \\"store got false from mem_write_value\\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"sb.rl","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 482, width, \\"store\\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\\"model/riscv_insts_base.sail\\", 486, \\"store got false from mem_write_value\\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"sc.b","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 220, \\"STORECON expected word or double\\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 231, \\"STORECON expected word or double\\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }","description":"TBD"},{"mnemonic":"sc.b.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 220, \\"STORECON expected word or double\\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 231, \\"STORECON expected word or double\\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }","description":"TBD"},{"mnemonic":"sc.b.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 220, \\"STORECON expected word or double\\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 231, \\"STORECON expected word or double\\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }","description":"TBD"},{"mnemonic":"sc.b.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 220, \\"STORECON expected word or double\\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 231, \\"STORECON expected word or double\\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }","description":"TBD"},{"mnemonic":"sc.d","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 220, \\"STORECON expected word or double\\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 231, \\"STORECON expected word or double\\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }","description":"TBD"},{"mnemonic":"sc.d.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 220, \\"STORECON expected word or double\\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 231, \\"STORECON expected word or double\\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }","description":"TBD"},{"mnemonic":"sc.d.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 220, \\"STORECON expected word or double\\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 231, \\"STORECON expected word or double\\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }","description":"TBD"},{"mnemonic":"sc.d.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 220, \\"STORECON expected word or double\\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 231, \\"STORECON expected word or double\\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }","description":"TBD"},{"mnemonic":"sc.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 220, \\"STORECON expected word or double\\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 231, \\"STORECON expected word or double\\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }","description":"TBD"},{"mnemonic":"sc.h.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 220, \\"STORECON expected word or double\\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 231, \\"STORECON expected word or double\\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }","description":"TBD"},{"mnemonic":"sc.h.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 220, \\"STORECON expected word or double\\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 231, \\"STORECON expected word or double\\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }","description":"TBD"},{"mnemonic":"sc.h.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 220, \\"STORECON expected word or double\\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 231, \\"STORECON expected word or double\\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }","description":"TBD"},{"mnemonic":"sc.w","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 220, \\"STORECON expected word or double\\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 231, \\"STORECON expected word or double\\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }","description":"TBD"},{"mnemonic":"sc.w.aq","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 220, \\"STORECON expected word or double\\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 231, \\"STORECON expected word or double\\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }","description":"TBD"},{"mnemonic":"sc.w.aq.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 220, \\"STORECON expected word or double\\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 231, \\"STORECON expected word or double\\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }","description":"TBD"},{"mnemonic":"sc.w.rl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":[],"function":"{ if eq_bool(speculate_conditional(), false) then { wX_bits(rd, zero_extend(64, 0b1)); RETIRE_SUCCESS } else { if haveAtomics() then { match ext_data_get_addr(rs1, zeros_implicit(64), Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => { let aligned : bool = match width { BYTE => true, HALF => eq_bits(subrange_bits(vaddr, 0, 0), 0b0), WORD => eq_bits(subrange_bits(vaddr, 1, 0), 0b00), DOUBLE => eq_bits(subrange_bits(vaddr, 2, 0), 0b000) } in { if not(aligned) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else { if eq_bool(match_reservation(vaddr), false) then { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS } else { match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((addr, _)) => { let eares : MemoryOpResult(unit) = match (width, 64) { (BYTE, _) => mem_write_ea(addr, 1, and_bool(aq, rl), rl, true), (HALF, _) => mem_write_ea(addr, 2, and_bool(aq, rl), rl, true), (WORD, _) => mem_write_ea(addr, 4, and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_ea(addr, 8, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 220, \\"STORECON expected word or double\\") } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { var rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match (width, 64) { (BYTE, _) => mem_write_value(addr, 1, subrange_bits(rs2_val, 7, 0), and_bool(aq, rl), rl, true), (HALF, _) => mem_write_value(addr, 2, subrange_bits(rs2_val, 15, 0), and_bool(aq, rl), rl, true), (WORD, _) => mem_write_value(addr, 4, subrange_bits(rs2_val, 31, 0), and_bool(aq, rl), rl, true), (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val, and_bool(aq, rl), rl, true), _ => internal_error(\\"model/riscv_insts_aext.sail\\", 231, \\"STORECON expected word or double\\") } in { match res { MemValue(true) => { wX_bits(rd, zero_extend(64, 0b0)); cancel_reservation(); RETIRE_SUCCESS }, MemValue(false) => { wX_bits(rd, zero_extend(64, 0b1)); cancel_reservation(); RETIRE_SUCCESS }, MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } } } } } else { handle_illegal(); RETIRE_FAIL } } }","description":"TBD"},{"mnemonic":"sd","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 482, width, \\"store\\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\\"model/riscv_insts_base.sail\\", 486, \\"store got false from mem_write_value\\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"sd.aq","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 482, width, \\"store\\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\\"model/riscv_insts_base.sail\\", 486, \\"store got false from mem_write_value\\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"sd.aq.rl","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 482, width, \\"store\\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\\"model/riscv_insts_base.sail\\", 486, \\"store got false from mem_write_value\\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"sd.rl","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 482, width, \\"store\\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\\"model/riscv_insts_base.sail\\", 486, \\"store got false from mem_write_value\\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"sext.b","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b0000100","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zbb"],"function":"{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = match op { RISCV_SEXTB => sign_extend(64, subrange_bits(rs1_val, 7, 0)), RISCV_SEXTH => sign_extend(64, subrange_bits(rs1_val, 15, 0)), RISCV_ZEXTH => zero_extend(64, subrange_bits(rs1_val, 15, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"sext.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b0000100","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zbb"],"function":"{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = match op { RISCV_SEXTB => sign_extend(64, subrange_bits(rs1_val, 7, 0)), RISCV_SEXTH => sign_extend(64, subrange_bits(rs1_val, 15, 0)), RISCV_ZEXTH => zero_extend(64, subrange_bits(rs1_val, 15, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"sfence.vma","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rs1,rs2","format":"R","fields":[{"field":"0b0001001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{ let addr : option(xlenbits) = if eq_bits(rs1, 0b00000) then None() else Some(rX_bits(rs1)) in { let asid : option(xlenbits) = if eq_bits(rs2, 0b00000) then None() else Some(rX_bits(rs2)) in { match cur_privilege { User => { handle_illegal(); RETIRE_FAIL }, Supervisor => match (architecture(get_mstatus_SXL(mstatus)), _get_Mstatus_TVM(mstatus)) { (Some(_), 0b1) => { handle_illegal(); RETIRE_FAIL }, (Some(_), 0b0) => { flush_TLB(asid, addr); RETIRE_SUCCESS }, (_, _) => internal_error(\\"model/riscv_insts_base.sail\\", 866, \\"unimplemented sfence architecture\\") }, Machine => { flush_TLB(asid, addr); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"sh","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 482, width, \\"store\\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\\"model/riscv_insts_base.sail\\", 486, \\"store got false from mem_write_value\\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"sh.aq","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 482, width, \\"store\\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\\"model/riscv_insts_base.sail\\", 486, \\"store got false from mem_write_value\\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"sh.aq.rl","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 482, width, \\"store\\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\\"model/riscv_insts_base.sail\\", 486, \\"store got false from mem_write_value\\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"sh.rl","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 482, width, \\"store\\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\\"model/riscv_insts_base.sail\\", 486, \\"store got false from mem_write_value\\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"sh1add","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zba"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let shamt : bits(2) = match op { RISCV_SH1ADD => 0b01, RISCV_SH2ADD => 0b10, RISCV_SH3ADD => 0b11 } in { let result : xlenbits = add_bits(shift_bits_left(rs1_val, shamt), rs2_val) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"sh1add.uw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zba"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let shamt : bits(2) = match op { RISCV_ADDUW => 0b00, RISCV_SH1ADDUW => 0b01, RISCV_SH2ADDUW => 0b10, RISCV_SH3ADDUW => 0b11 } in { let result : xlenbits = add_bits(shift_bits_left(zero_extend(64, subrange_bits(rs1_val, 31, 0)), shamt), rs2_val) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"sh2add","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zba"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let shamt : bits(2) = match op { RISCV_SH1ADD => 0b01, RISCV_SH2ADD => 0b10, RISCV_SH3ADD => 0b11 } in { let result : xlenbits = add_bits(shift_bits_left(rs1_val, shamt), rs2_val) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"sh2add.uw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zba"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let shamt : bits(2) = match op { RISCV_ADDUW => 0b00, RISCV_SH1ADDUW => 0b01, RISCV_SH2ADDUW => 0b10, RISCV_SH3ADDUW => 0b11 } in { let result : xlenbits = add_bits(shift_bits_left(zero_extend(64, subrange_bits(rs1_val, 31, 0)), shamt), rs2_val) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"sh3add","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zba"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let shamt : bits(2) = match op { RISCV_SH1ADD => 0b01, RISCV_SH2ADD => 0b10, RISCV_SH3ADD => 0b11 } in { let result : xlenbits = add_bits(shift_bits_left(rs1_val, shamt), rs2_val) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"sh3add.uw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zba"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let shamt : bits(2) = match op { RISCV_ADDUW => 0b00, RISCV_SH1ADDUW => 0b01, RISCV_SH2ADDUW => 0b10, RISCV_SH3ADDUW => 0b11 } in { let result : xlenbits = add_bits(shift_bits_left(zero_extend(64, subrange_bits(rs1_val, 31, 0)), shamt), rs2_val) in { wX_bits(rd, result); RETIRE_SUCCESS } } } } }","description":"TBD"},{"mnemonic":"sha256sig0","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b00010","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknh"],"function":"{ let inb : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(rotater(inb, 7), xor_vec(rotater(inb, 18), shiftr(inb, 3))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"sha256sig1","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknh"],"function":"{ let inb : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(rotater(inb, 17), xor_vec(rotater(inb, 19), shiftr(inb, 10))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"sha256sum0","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknh"],"function":"{ let inb : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(rotater(inb, 2), xor_vec(rotater(inb, 13), rotater(inb, 22))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"sha256sum1","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b00001","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknh"],"function":"{ let inb : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(rotater(inb, 6), xor_vec(rotater(inb, 11), rotater(inb, 25))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"sha512sig0","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b00110","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknh"],"function":"{ assert(eq_int(64, 64), \\"model/riscv_insts_zkn.sail:452.27-452.28\\"); let input : bits(64) = rX_bits(rs1) in { let result : bits(64) = xor_vec(rotater(input, 1), xor_vec(rotater(input, 8), shiftr(input, 7))) in { wX_bits(rd, result); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"sha512sig0h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b01","size":2},{"field":"0b01110","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknh"],"function":"{ wX_bits(rd, sign_extend(64, xor_vec(shiftr(rX_bits(rs1), 1), xor_vec(shiftr(rX_bits(rs1), 7), xor_vec(shiftr(rX_bits(rs1), 8), xor_vec(shiftl(rX_bits(rs2), 31), shiftl(rX_bits(rs2), 24))))))); RETIRE_SUCCESS }","description":"TBD"},{"mnemonic":"sha512sig0l","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b01","size":2},{"field":"0b01010","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknh"],"function":"{ wX_bits(rd, sign_extend(64, xor_vec(shiftr(rX_bits(rs1), 1), xor_vec(shiftr(rX_bits(rs1), 7), xor_vec(shiftr(rX_bits(rs1), 8), xor_vec(shiftl(rX_bits(rs2), 31), xor_vec(shiftl(rX_bits(rs2), 25), shiftl(rX_bits(rs2), 24)))))))); RETIRE_SUCCESS }","description":"TBD"},{"mnemonic":"sha512sig1","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b00111","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknh"],"function":"{ assert(eq_int(64, 64), \\"model/riscv_insts_zkn.sail:460.27-460.28\\"); let input : bits(64) = rX_bits(rs1) in { let result : bits(64) = xor_vec(rotater(input, 19), xor_vec(rotater(input, 61), shiftr(input, 6))) in { wX_bits(rd, result); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"sha512sig1h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b01","size":2},{"field":"0b01111","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknh"],"function":"{ wX_bits(rd, sign_extend(64, xor_vec(shiftl(rX_bits(rs1), 3), xor_vec(shiftr(rX_bits(rs1), 6), xor_vec(shiftr(rX_bits(rs1), 19), xor_vec(shiftr(rX_bits(rs2), 29), shiftl(rX_bits(rs2), 13))))))); RETIRE_SUCCESS }","description":"TBD"},{"mnemonic":"sha512sig1l","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b01","size":2},{"field":"0b01011","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknh"],"function":"{ wX_bits(rd, sign_extend(64, xor_vec(shiftl(rX_bits(rs1), 3), xor_vec(shiftr(rX_bits(rs1), 6), xor_vec(shiftr(rX_bits(rs1), 19), xor_vec(shiftr(rX_bits(rs2), 29), xor_vec(shiftl(rX_bits(rs2), 26), shiftl(rX_bits(rs2), 13)))))))); RETIRE_SUCCESS }","description":"TBD"},{"mnemonic":"sha512sum0","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b00100","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknh"],"function":"{ assert(eq_int(64, 64), \\"model/riscv_insts_zkn.sail:468.27-468.28\\"); let input : bits(64) = rX_bits(rs1) in { let result : bits(64) = xor_vec(rotater(input, 28), xor_vec(rotater(input, 34), rotater(input, 39))) in { wX_bits(rd, result); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"sha512sum0r","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b01","size":2},{"field":"0b01000","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknh"],"function":"{ wX_bits(rd, sign_extend(64, xor_vec(shiftl(rX_bits(rs1), 25), xor_vec(shiftl(rX_bits(rs1), 30), xor_vec(shiftr(rX_bits(rs1), 28), xor_vec(shiftr(rX_bits(rs2), 7), xor_vec(shiftr(rX_bits(rs2), 2), shiftl(rX_bits(rs2), 4)))))))); RETIRE_SUCCESS }","description":"TBD"},{"mnemonic":"sha512sum1","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b00101","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknh"],"function":"{ assert(eq_int(64, 64), \\"model/riscv_insts_zkn.sail:476.27-476.28\\"); let input : bits(64) = rX_bits(rs1) in { let result : bits(64) = xor_vec(rotater(input, 14), xor_vec(rotater(input, 18), rotater(input, 41))) in { wX_bits(rd, result); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"sha512sum1r","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b01","size":2},{"field":"0b01001","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknh"],"function":"{ wX_bits(rd, sign_extend(64, xor_vec(shiftl(rX_bits(rs1), 23), xor_vec(shiftr(rX_bits(rs1), 14), xor_vec(shiftr(rX_bits(rs1), 18), xor_vec(shiftr(rX_bits(rs2), 9), xor_vec(shiftl(rX_bits(rs2), 18), shiftl(rX_bits(rs2), 14)))))))); RETIRE_SUCCESS }","description":"TBD"},{"mnemonic":"sll","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"slli","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"shamt","type":"bits(6)"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = match op { RISCV_SLLI => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(shamt, 4, 0)) else shift_bits_left(rs1_val, shamt), RISCV_SRLI => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(shamt, 4, 0)) else shift_bits_right(rs1_val, shamt), RISCV_SRAI => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(shamt, 4, 0)) else shift_right_arith64(rs1_val, shamt) } in { wX_bits(rd, result); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"slli.uw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"shamt","type":"bits(6)"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b000010","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":["Zba"],"function":"{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = shift_bits_left(zero_extend(64, subrange_bits(rs1_val, 31, 0)), shamt) in { wX_bits(rd, result); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"slliw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"shamt","type":"bits(5)"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"shamt","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":[],"function":"{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = match op { RISCV_SLLIW => shift_bits_left(rs1_val, shamt), RISCV_SRLIW => shift_bits_right(rs1_val, shamt), RISCV_SRAIW => shift_right_arith32(rs1_val, shamt) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"sllw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":[],"function":"{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let result : bits(32) = match op { RISCV_ADDW => add_bits(rs1_val, rs2_val), RISCV_SUBW => sub_vec(rs1_val, rs2_val), RISCV_SLLW => shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRLW => shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRAW => shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"slt","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"slti","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"imm","type":"bits(12)"}],"syntax":"rd,rs1,imm","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"encdec_iop(op)","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let immext : xlenbits = sign_extend(64, imm) in { let result : xlenbits = match op { RISCV_ADDI => add_bits(rs1_val, immext), RISCV_SLTI => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, immext))), RISCV_SLTIU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, immext))), RISCV_ANDI => and_vec(rs1_val, immext), RISCV_ORI => or_vec(rs1_val, immext), RISCV_XORI => xor_vec(rs1_val, immext) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"sltiu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"imm","type":"bits(12)"}],"syntax":"rd,rs1,imm","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"encdec_iop(op)","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let immext : xlenbits = sign_extend(64, imm) in { let result : xlenbits = match op { RISCV_ADDI => add_bits(rs1_val, immext), RISCV_SLTI => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, immext))), RISCV_SLTIU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, immext))), RISCV_ANDI => and_vec(rs1_val, immext), RISCV_ORI => or_vec(rs1_val, immext), RISCV_XORI => xor_vec(rs1_val, immext) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"sltu","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"sm3p0","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zksh"],"function":"{ let r1 : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(r1, xor_vec(rotatel(r1, 9), rotatel(r1, 17))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"sm3p1","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b01001","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zksh"],"function":"{ let r1 : bits(32) = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = xor_vec(r1, xor_vec(rotatel(r1, 15), rotatel(r1, 23))) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"sm4ed","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"bs","type":"bits(2)"}],"syntax":"rd,rs1,rs2,bs","format":"TBD","fields":[{"field":"bs","size":2},{"field":"0b11000","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zksed"],"function":"{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let sb_in : bits(8) = subrange_bits(shift_bits_right(subrange_bits(rX_bits(rs2), 31, 0), shamt), 7, 0) in { let x : bits(32) = bitvector_concat(0x000000, sm4_sbox(sb_in)) in { let y : bits(32) = xor_vec(x, xor_vec(shiftl(x, 8), xor_vec(shiftl(x, 2), xor_vec(shiftl(x, 18), xor_vec(shiftl(and_vec(x, 0x0000003F), 26), shiftl(and_vec(x, 0x000000C0), 10)))))) in { let z : bits(32) = rotate_bits_left(y, shamt) in { let result : bits(32) = xor_vec(z, subrange_bits(rX_bits(rs1), 31, 0)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } } } }","description":"TBD"},{"mnemonic":"sm4ks","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"bs","type":"bits(2)"}],"syntax":"rd,rs1,rs2,bs","format":"TBD","fields":[{"field":"bs","size":2},{"field":"0b11010","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zksed"],"function":"{ let shamt : bits(5) = bitvector_concat(bs, 0b000) in { let sb_in : bits(8) = subrange_bits(shift_bits_right(subrange_bits(rX_bits(rs2), 31, 0), shamt), 7, 0) in { let x : bits(32) = bitvector_concat(0x000000, sm4_sbox(sb_in)) in { let y : bits(32) = xor_vec(x, xor_vec(shiftl(and_vec(x, 0x00000007), 29), xor_vec(shiftl(and_vec(x, 0x000000FE), 7), xor_vec(shiftl(and_vec(x, 0x00000001), 23), shiftl(and_vec(x, 0x000000F8), 13))))) in { let z : bits(32) = rotate_bits_left(y, shamt) in { let result : bits(32) = xor_vec(z, subrange_bits(rX_bits(rs1), 31, 0)) in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } } } } }","description":"TBD"},{"mnemonic":"sra","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"srai","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"shamt","type":"bits(6)"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = match op { RISCV_SLLI => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(shamt, 4, 0)) else shift_bits_left(rs1_val, shamt), RISCV_SRLI => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(shamt, 4, 0)) else shift_bits_right(rs1_val, shamt), RISCV_SRAI => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(shamt, 4, 0)) else shift_right_arith64(rs1_val, shamt) } in { wX_bits(rd, result); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"sraiw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"shamt","type":"bits(5)"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"shamt","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":[],"function":"{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = match op { RISCV_SLLIW => shift_bits_left(rs1_val, shamt), RISCV_SRLIW => shift_bits_right(rs1_val, shamt), RISCV_SRAIW => shift_right_arith32(rs1_val, shamt) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"sraw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":[],"function":"{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let result : bits(32) = match op { RISCV_ADDW => add_bits(rs1_val, rs2_val), RISCV_SUBW => sub_vec(rs1_val, rs2_val), RISCV_SLLW => shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRLW => shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRAW => shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"sret","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b0001000","size":7},{"field":"0b00010","size":5},{"field":"0b00000","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{ let sret_illegal : bool = match cur_privilege { User => true, Supervisor => or_bool(not(haveSupMode()), eq_bits(_get_Mstatus_TSR(mstatus), 0b1)), Machine => not(haveSupMode()) } in { if sret_illegal then { handle_illegal(); RETIRE_FAIL } else if not(ext_check_xret_priv(Supervisor)) then { ext_fail_xret_priv(); RETIRE_FAIL } else { set_next_pc(exception_handler(cur_privilege, CTL_SRET(), PC)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"srl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"srli","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"shamt","type":"bits(6)"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = match op { RISCV_SLLI => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(shamt, 4, 0)) else shift_bits_left(rs1_val, shamt), RISCV_SRLI => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(shamt, 4, 0)) else shift_bits_right(rs1_val, shamt), RISCV_SRAI => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(shamt, 4, 0)) else shift_right_arith64(rs1_val, shamt) } in { wX_bits(rd, result); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"srliw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"shamt","type":"bits(5)"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"shamt","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":[],"function":"{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let result : bits(32) = match op { RISCV_SLLIW => shift_bits_left(rs1_val, shamt), RISCV_SRLIW => shift_bits_right(rs1_val, shamt), RISCV_SRAIW => shift_right_arith32(rs1_val, shamt) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"srlw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":[],"function":"{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let result : bits(32) = match op { RISCV_ADDW => add_bits(rs1_val, rs2_val), RISCV_SUBW => sub_vec(rs1_val, rs2_val), RISCV_SLLW => shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRLW => shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRAW => shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"sub","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"subw","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":[],"function":"{ let rs1_val = subrange_bits(rX_bits(rs1), 31, 0) in { let rs2_val = subrange_bits(rX_bits(rs2), 31, 0) in { let result : bits(32) = match op { RISCV_ADDW => add_bits(rs1_val, rs2_val), RISCV_SUBW => sub_vec(rs1_val, rs2_val), RISCV_SLLW => shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRLW => shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)), RISCV_SRAW => shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) } in { wX_bits(rd, sign_extend(64, result)); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"sw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 482, width, \\"store\\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\\"model/riscv_insts_base.sail\\", 486, \\"store got false from mem_write_value\\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"sw.aq","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 482, width, \\"store\\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\\"model/riscv_insts_base.sail\\", 486, \\"store got false from mem_write_value\\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"sw.aq.rl","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 482, width, \\"store\\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\\"model/riscv_insts_base.sail\\", 486, \\"store got false from mem_write_value\\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"sw.rl","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{ let offset : xlenbits = sign_extend(64, imm) in { match ext_data_get_addr(rs1, offset, Write(Data), width) { Ext_DataAddr_Error(e) => { ext_handle_data_check_error(e); RETIRE_FAIL }, Ext_DataAddr_OK(vaddr) => if check_misaligned(vaddr, width) then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL } else match translateAddr(vaddr, Write(Data)) { TR_Failure((e, _)) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, TR_Address((paddr, _)) => { let eares : MemoryOpResult(unit) = match width { BYTE => mem_write_ea(paddr, 1, aq, rl, false), HALF => mem_write_ea(paddr, 2, aq, rl, false), WORD => mem_write_ea(paddr, 4, aq, rl, false), DOUBLE => mem_write_ea(paddr, 8, aq, rl, false) } in { match eares { MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }, MemValue(_) => { let rs2_val = rX_bits(rs2) in { let res : MemoryOpResult(bool) = match width { BYTE => mem_write_value(paddr, 1, subrange_bits(rs2_val, 7, 0), aq, rl, false), HALF => mem_write_value(paddr, 2, subrange_bits(rs2_val, 15, 0), aq, rl, false), WORD => mem_write_value(paddr, 4, subrange_bits(rs2_val, 31, 0), aq, rl, false), DOUBLE if gteq_int(64, 64) => mem_write_value(paddr, 8, rs2_val, aq, rl, false), _ => report_invalid_width(\\"model/riscv_insts_base.sail\\", 482, width, \\"store\\") } in { match res { MemValue(true) => RETIRE_SUCCESS, MemValue(false) => internal_error(\\"model/riscv_insts_base.sail\\", 486, \\"store got false from mem_write_value\\"), MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"unzip","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b000010001111","size":12},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbkb"],"function":"{ assert(eq_int(64, 32), \\"model/riscv_insts_zbkb.sail:148.27-148.28\\"); exit () }","description":"TBD"},{"mnemonic":"uret","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b0000000","size":7},{"field":"0b00010","size":5},{"field":"0b00000","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{ if or_bool(not(haveUsrMode()), not(sys_enable_next())) then handle_illegal() else if not(ext_check_xret_priv(User)) then ext_fail_xret_priv() else set_next_pc(exception_handler(cur_privilege, CTL_URET(), PC)); RETIRE_FAIL }","description":"TBD"},{"mnemonic":"vaadd.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vaadd.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_arith.sail:1974.57-1974.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vaaddu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vaaddu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_arith.sail:1974.57-1974.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vadc.vim","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"v0","type":"unknown"}],"syntax":"vd,vs2,simm,v0","format":"TBD","fields":[{"field":"encdec_vimsfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { var vec_trues : vector(\'n, bool) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { vec_trues[i] = true }; let vm_val : vector(\'n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VIMS_VADC => to_bits(SEW, add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vadc.vvm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"v0","type":"unknown"}],"syntax":"vd,vs2,vs1,v0","format":"TBD","fields":[{"field":"encdec_vvmsfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { var vec_trues : vector(\'n, bool) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { vec_trues[i] = true }; let vm_val : vector(\'n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VVMS_VADC => to_bits(SEW, add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))), VVMS_VSBC => to_bits(SEW, sub_atom(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vadc.vxm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"v0","type":"unknown"}],"syntax":"vd,vs2,rs1,v0","format":"TBD","fields":[{"field":"encdec_vxmsfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { var vec_trues : vector(\'n, bool) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { vec_trues[i] = true }; let vm_val : vector(\'n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VXMS_VADC => to_bits(SEW, add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))), VXMS_VSBC => to_bits(SEW, sub_atom(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vadd.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vadd.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vadd.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vand.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vand.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vand.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vasub.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vasub.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_arith.sail:1974.57-1974.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vasubu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vasubu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_arith.sail:1974.57-1974.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vcompress.vm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let start_element = get_start_element() in { let end_element = get_end_element() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if or_bool(neq_int(start_element, 0), or_bool(eq_bits(vs1, vd), or_bool(eq_bits(vs2, vd), illegal_vd_unmasked()))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vs1_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var vd_idx : nat = 0 in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if lteq_int(i, end_element) then { if plain_vector_access(vs1_val, i) then { let p as \'p = vd_idx in { assert(lt_int(__id(p), __id(n)), \\"model/riscv_insts_vext_arith.sail:1877.22-1877.23\\"); result[__id(p)] = plain_vector_access(vs2_val, i); vd_idx = add_atom(vd_idx, 1) } } else () } else () }; if lt_int(vd_idx, num_elem) then { let tail_ag : agtype = get_vtype_vta() in { let p as \'p = vd_idx in { foreach (i from __id(p) to sub_atom(num_elem, 1) by 1 order inc) { { result[i] = match tail_ag { UNDISTURBED => plain_vector_access(vd_val, i), AGNOSTIC => plain_vector_access(vd_val, i) } } } } } else (); write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vdiv.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vdiv.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_arith.sail:1974.57-1974.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vdivu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vdivu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_arith.sail:1974.57-1974.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfadd.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:906.17-906.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_fp.sail:940.57-940.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfadd.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:70.17-70.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfclass.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010011","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary1_vs1(vfunary1)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:782.17-782.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary1 { FVV_VSQRT => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16Sqrt(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Sqrt(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Sqrt(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VRSQRT7 => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VREC7 => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16Recip7(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Recip7(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Recip7(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VCLASS => fp_class(plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfcvt.f.x.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary0_vs1(vfunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary0 { FV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_ui32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_ui64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_i32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_i64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfcvt.f.xu.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary0_vs1(vfunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary0 { FV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_ui32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_ui64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_i32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_i64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfcvt.rtz.x.f.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary0_vs1(vfunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary0 { FV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_ui32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_ui64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_i32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_i64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfcvt.rtz.xu.f.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary0_vs1(vfunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary0 { FV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_ui32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_ui64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_i32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_i64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfcvt.x.f.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary0_vs1(vfunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary0 { FV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_ui32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_ui64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_i32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_i64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfcvt.xu.f.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary0_vs1(vfunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary0 { FV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_ui32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_ui64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 32 => riscv_i32ToF32(rm_3b, plain_vector_access(vs2_val, i)), 64 => riscv_i64ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToUi32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f32ToI32(0b001, plain_vector_access(vs2_val, i)), 64 => riscv_f64ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfdiv.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:906.17-906.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_fp.sail:940.57-940.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfdiv.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:70.17-70.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfirst.m","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"rd,vs2vm","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"0b10001","size":5},{"field":"0b010","size":3},{"field":"rd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if or_bool(illegal_vd_unmasked(), not(assert_vstart(0))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs2) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vs2_val, vm_val); var index : int = -1 in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if eq_int(index, -1) then { if and_bool(plain_vector_access(mask, i), plain_vector_access(vs2_val, i)) then index = i else () } else () }; wX_bits(rd, to_bits(64, index)); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfmacc.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:996.17-996.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VMACC => fp_muladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMACC => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMSAC => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMSAC => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMADD => fp_muladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMADD => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VMSUB => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMSUB => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfmacc.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:145.17-145.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VMACC => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMACC => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMSAC => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMSAC => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMADD => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMADD => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VMSUB => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMSUB => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfmadd.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:996.17-996.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VMACC => fp_muladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMACC => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMSAC => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMSAC => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMADD => fp_muladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMADD => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VMSUB => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMSUB => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfmadd.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:145.17-145.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VMACC => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMACC => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMSAC => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMSAC => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMADD => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMADD => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VMSUB => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMSUB => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfmax.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:906.17-906.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_fp.sail:940.57-940.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfmax.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:70.17-70.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfmerge.vfm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"v0","type":"unknown"}],"syntax":"vd,vs2,rs1,v0","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let start_element = get_start_element() in { let end_element = get_end_element() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let real_num_elem = if gteq_int(LMUL_pow, 0) then num_elem else quot_round_zero(num_elem, sub_atom(0, LMUL_pow)) in { if illegal_fp_vd_masked(vd, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:1247.17-1247.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { let tail_ag : agtype = get_vtype_vta() in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if lt_int(i, start_element) then { result[i] = plain_vector_access(vd_val, i) } else if or_bool(gt_int(i, end_element), gteq_int(i, real_num_elem)) then { result[i] = match tail_ag { UNDISTURBED => plain_vector_access(vd_val, i), AGNOSTIC => plain_vector_access(vd_val, i) } } else { result[i] = if plain_vector_access(vm_val, i) then rs1_val else plain_vector_access(vs2_val, i) } }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfmin.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:906.17-906.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_fp.sail:940.57-940.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfmin.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:70.17-70.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfmsac.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:996.17-996.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VMACC => fp_muladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMACC => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMSAC => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMSAC => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMADD => fp_muladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMADD => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VMSUB => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMSUB => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfmsac.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:145.17-145.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VMACC => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMACC => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMSAC => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMSAC => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMADD => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMADD => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VMSUB => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMSUB => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfmsub.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:996.17-996.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VMACC => fp_muladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMACC => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMSAC => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMSAC => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMADD => fp_muladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMADD => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VMSUB => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMSUB => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfmsub.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:145.17-145.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VMACC => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMACC => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMSAC => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMSAC => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMADD => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMADD => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VMSUB => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMSUB => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfmul.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:906.17-906.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_fp.sail:940.57-940.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfmul.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:70.17-70.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfmv.f.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"vs2","type":"regidx"}],"syntax":"rd,vs2","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"0b00000","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let num_elem = get_num_elem(0, SEW) in { if or_bool(illegal_fp_vd_unmasked(SEW, rm_3b), gt_int(SEW, 64)) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gt_int(num_elem, 0), neq_int(SEW, 8)), \\"model/riscv_insts_vext_fp.sail:858.32-858.33\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, 0, vs2) in { match __id(m) { 16 => wF_H(rd, plain_vector_access(vs2_val, 0)), 32 => wF_S(rd, plain_vector_access(vs2_val, 0)), _ => wF_D(rd, plain_vector_access(vs2_val, 0)) }; vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } }","description":"TBD"},{"mnemonic":"vfmv.s.f","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,rs1","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"0b1","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let num_elem = get_num_elem(0, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gt_int(num_elem, 0), neq_int(SEW, 8)), \\"model/riscv_insts_vext_fp.sail:1332.32-1332.33\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, 0, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, 0, vd_val, vm_val); if plain_vector_access(mask, 0) then result[0] = rs1_val else (); let tail_ag : agtype = get_vtype_vta() in { foreach (i from 1 to sub_atom(num_elem, 1) by 1 order inc) { { result[i] = match tail_ag { UNDISTURBED => plain_vector_access(vd_val, i), AGNOSTIC => plain_vector_access(vd_val, i) } }; write_vreg(num_elem, SEW, 0, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfmv.v.f","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,rs1","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b1","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:1295.17-1295.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then result[i] = rs1_val else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfncvt.f.f.w","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfnunary0_vs1(vfnunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfnunary0 { FNV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToUi8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToI8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_ui32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_ui64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_i32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_i64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_ROD_F_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(0b110, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(0b110, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToUi8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToI8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfncvt.f.x.w","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfnunary0_vs1(vfnunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfnunary0 { FNV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToUi8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToI8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_ui32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_ui64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_i32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_i64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_ROD_F_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(0b110, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(0b110, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToUi8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToI8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfncvt.f.xu.w","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfnunary0_vs1(vfnunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfnunary0 { FNV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToUi8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToI8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_ui32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_ui64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_i32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_i64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_ROD_F_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(0b110, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(0b110, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToUi8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToI8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfncvt.rod.f.f.w","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfnunary0_vs1(vfnunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfnunary0 { FNV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToUi8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToI8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_ui32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_ui64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_i32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_i64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_ROD_F_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(0b110, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(0b110, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToUi8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToI8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfncvt.rtz.x.f.w","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfnunary0_vs1(vfnunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfnunary0 { FNV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToUi8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToI8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_ui32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_ui64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_i32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_i64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_ROD_F_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(0b110, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(0b110, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToUi8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToI8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfncvt.rtz.xu.f.w","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfnunary0_vs1(vfnunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfnunary0 { FNV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToUi8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToI8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_ui32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_ui64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_i32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_i64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_ROD_F_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(0b110, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(0b110, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToUi8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToI8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfncvt.x.f.w","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfnunary0_vs1(vfnunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfnunary0 { FNV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToUi8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToI8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_ui32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_ui64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_i32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_i64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_ROD_F_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(0b110, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(0b110, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToUi8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToI8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfncvt.xu.f.w","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfnunary0_vs1(vfnunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfnunary0 { FNV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToUi8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToI8(rm_3b, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_ui32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_ui64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_i32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_i64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_ROD_F_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f32ToF16(0b110, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToF32(0b110, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToUi8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToUi16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToUi32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FNV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 8 => riscv_f16ToI8(0b001, plain_vector_access(vs2_val, i)), 16 => riscv_f32ToI16(0b001, plain_vector_access(vs2_val, i)), 32 => riscv_f64ToI32(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfnmacc.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:996.17-996.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VMACC => fp_muladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMACC => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMSAC => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMSAC => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMADD => fp_muladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMADD => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VMSUB => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMSUB => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfnmacc.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:145.17-145.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VMACC => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMACC => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMSAC => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMSAC => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMADD => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMADD => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VMSUB => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMSUB => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfnmadd.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:996.17-996.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VMACC => fp_muladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMACC => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMSAC => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMSAC => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMADD => fp_muladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMADD => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VMSUB => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMSUB => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfnmadd.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:145.17-145.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VMACC => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMACC => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMSAC => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMSAC => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMADD => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMADD => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VMSUB => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMSUB => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfnmsac.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:996.17-996.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VMACC => fp_muladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMACC => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMSAC => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMSAC => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMADD => fp_muladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMADD => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VMSUB => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMSUB => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfnmsac.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:145.17-145.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VMACC => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMACC => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMSAC => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMSAC => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMADD => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMADD => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VMSUB => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMSUB => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfnmsub.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:996.17-996.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VMACC => fp_muladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMACC => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMSAC => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VNMSAC => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), VF_VMADD => fp_muladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMADD => fp_nmulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VMSUB => fp_mulsub(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), VF_VNMSUB => fp_nmuladd(rm_3b, rs1_val, plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfnmsub.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:145.17-145.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VMACC => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMACC => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMSAC => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VNMSAC => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vs2_val, i), plain_vector_access(vd_val, i)), FVV_VMADD => fp_muladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMADD => fp_nmulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VMSUB => fp_mulsub(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)), FVV_VNMSUB => fp_nmuladd(rm_3b, plain_vector_access(vs1_val, i), plain_vector_access(vd_val, i), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfrdiv.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:906.17-906.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_fp.sail:940.57-940.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfrec7.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010011","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary1_vs1(vfunary1)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:782.17-782.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary1 { FVV_VSQRT => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16Sqrt(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Sqrt(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Sqrt(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VRSQRT7 => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VREC7 => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16Recip7(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Recip7(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Recip7(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VCLASS => fp_class(plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfredmax.vs","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rfvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { if or_bool(eq_anything(funct6, FVV_VFWREDOSUM), eq_anything(funct6, FVV_VFWREDUSUM)) then process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) else process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) } } } }","description":"TBD"},{"mnemonic":"vfredmin.vs","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rfvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { if or_bool(eq_anything(funct6, FVV_VFWREDOSUM), eq_anything(funct6, FVV_VFWREDUSUM)) then process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) else process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) } } } }","description":"TBD"},{"mnemonic":"vfredosum.vs","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rfvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { if or_bool(eq_anything(funct6, FVV_VFWREDOSUM), eq_anything(funct6, FVV_VFWREDUSUM)) then process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) else process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) } } } }","description":"TBD"},{"mnemonic":"vfredusum.vs","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rfvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { if or_bool(eq_anything(funct6, FVV_VFWREDOSUM), eq_anything(funct6, FVV_VFWREDUSUM)) then process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) else process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) } } } }","description":"TBD"},{"mnemonic":"vfrsqrt7.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010011","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary1_vs1(vfunary1)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:782.17-782.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary1 { FVV_VSQRT => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16Sqrt(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Sqrt(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Sqrt(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VRSQRT7 => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VREC7 => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16Recip7(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Recip7(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Recip7(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VCLASS => fp_class(plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfrsub.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:906.17-906.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_fp.sail:940.57-940.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfsgnj.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:906.17-906.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_fp.sail:940.57-940.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfsgnj.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:70.17-70.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfsgnjn.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:906.17-906.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_fp.sail:940.57-940.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfsgnjn.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:70.17-70.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfsgnjx.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:906.17-906.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_fp.sail:940.57-940.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfsgnjx.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:70.17-70.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfslide1down.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:906.17-906.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_fp.sail:940.57-940.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfslide1up.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:906.17-906.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_fp.sail:940.57-940.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfsqrt.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010011","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary1_vs1(vfunary1)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:782.17-782.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfunary1 { FVV_VSQRT => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16Sqrt(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Sqrt(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Sqrt(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VRSQRT7 => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Rsqrte7(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VREC7 => { let (fflags, elem) : (bits_fflags, bits(\'m)) = match __id(m) { 16 => riscv_f16Recip7(rm_3b, plain_vector_access(vs2_val, i)), 32 => riscv_f32Recip7(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f64Recip7(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FVV_VCLASS => fp_class(plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfsub.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:906.17-906.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRSUB => fp_sub(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VMIN => fp_min(plain_vector_access(vs2_val, i), rs1_val), VF_VMAX => fp_max(plain_vector_access(vs2_val, i), rs1_val), VF_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), rs1_val), VF_VRDIV => fp_div(rm_3b, rs1_val, plain_vector_access(vs2_val, i)), VF_VSGNJ => bitvector_concat([bitvector_access(rs1_val, sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(rs1_val, sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), VF_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, VF_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_fp.sail:940.57-940.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfsub.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_fp.sail:70.17-70.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FVV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMIN => fp_min(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMAX => fp_max(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VMUL => fp_mul(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VDIV => fp_div(rm_3b, plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVV_VSGNJ => bitvector_concat([bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))], subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJN => bitvector_concat(xor_vec(0b1, [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)), FVV_VSGNJX => bitvector_concat(xor_vec([bitvector_access(plain_vector_access(vs2_val, i), sub_atom(__id(m), 1))], [bitvector_access(plain_vector_access(vs1_val, i), sub_atom(__id(m), 1))]), subrange_bits(plain_vector_access(vs2_val, i), sub_atom(__id(m), 2), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwadd.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fwvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:1067.36-1067.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVF_VADD => fp_add(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)), FWVF_VSUB => fp_sub(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)), FWVF_VMUL => fp_mul(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwadd.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fwvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:217.36-217.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVV_VADD => fp_add(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))), FWVV_VSUB => fp_sub(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))), FWVV_VMUL => fp_mul(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwadd.wf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fwffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:1193.36-1193.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), fp_widen(rs1_val)), FWF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), fp_widen(rs1_val)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwadd.wv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fwvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:345.36-345.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), fp_widen(plain_vector_access(vs1_val, i))), FWV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), fp_widen(plain_vector_access(vs1_val, i))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwcvt.f.f.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfwunary0_vs1(vfwunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 8), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:521.35-521.36\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfwunary0 { FWV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_ui32ToF32(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_ui32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_i32ToF32(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_i32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToF32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwcvt.f.x.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfwunary0_vs1(vfwunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 8), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:521.35-521.36\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfwunary0 { FWV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_ui32ToF32(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_ui32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_i32ToF32(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_i32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToF32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwcvt.f.xu.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfwunary0_vs1(vfwunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 8), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:521.35-521.36\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfwunary0 { FWV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_ui32ToF32(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_ui32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_i32ToF32(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_i32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToF32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwcvt.rtz.x.f.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfwunary0_vs1(vfwunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 8), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:521.35-521.36\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfwunary0 { FWV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_ui32ToF32(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_ui32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_i32ToF32(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_i32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToF32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwcvt.rtz.xu.f.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfwunary0_vs1(vfwunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 8), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:521.35-521.36\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfwunary0 { FWV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_ui32ToF32(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_ui32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_i32ToF32(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_i32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToF32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwcvt.x.f.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfwunary0_vs1(vfwunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 8), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:521.35-521.36\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfwunary0 { FWV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_ui32ToF32(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_ui32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_i32ToF32(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_i32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToF32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwcvt.xu.f.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfwunary0_vs1(vfwunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 8), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:521.35-521.36\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match vfwunary0 { FWV_CVT_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_X_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_XU => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => riscv_ui32ToF16(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_ui32ToF32(rm_3b, zero_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_ui32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_X => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => riscv_i32ToF16(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), 16 => riscv_i32ToF32(rm_3b, sign_extend(32, plain_vector_access(vs2_val, i))), _ => riscv_i32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_F_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToF32(rm_3b, plain_vector_access(vs2_val, i)), _ => riscv_f32ToF64(rm_3b, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_XU_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToUi32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToUi64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } }, FWV_CVT_RTZ_X_F => { let (fflags, elem) : (bits_fflags, bits(\'o)) = match __id(m) { 8 => { handle_illegal(); return RETIRE_FAIL }, 16 => riscv_f16ToI32(0b001, plain_vector_access(vs2_val, i)), _ => riscv_f32ToI64(0b001, plain_vector_access(vs2_val, i)) } in { accrue_fflags(fflags); elem } } } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwmacc.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fwvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:1131.36-1131.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVF_VMACC => fp_muladd(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VNMACC => fp_nmulsub(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VMSAC => fp_mulsub(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VNMSAC => fp_nmuladd(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwmacc.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fwvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs1","size":5},{"field":"vs2","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:282.36-282.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVV_VMACC => fp_muladd(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VNMACC => fp_nmulsub(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VMSAC => fp_mulsub(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VNMSAC => fp_nmuladd(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwmsac.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fwvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:1131.36-1131.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVF_VMACC => fp_muladd(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VNMACC => fp_nmulsub(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VMSAC => fp_mulsub(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VNMSAC => fp_nmuladd(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwmsac.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fwvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs1","size":5},{"field":"vs2","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:282.36-282.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVV_VMACC => fp_muladd(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VNMACC => fp_nmulsub(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VMSAC => fp_mulsub(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VNMSAC => fp_nmuladd(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwmul.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fwvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:1067.36-1067.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVF_VADD => fp_add(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)), FWVF_VSUB => fp_sub(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)), FWVF_VMUL => fp_mul(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwmul.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fwvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:217.36-217.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVV_VADD => fp_add(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))), FWVV_VSUB => fp_sub(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))), FWVV_VMUL => fp_mul(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwnmacc.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fwvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:1131.36-1131.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVF_VMACC => fp_muladd(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VNMACC => fp_nmulsub(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VMSAC => fp_mulsub(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VNMSAC => fp_nmuladd(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwnmacc.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fwvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs1","size":5},{"field":"vs2","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:282.36-282.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVV_VMACC => fp_muladd(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VNMACC => fp_nmulsub(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VMSAC => fp_mulsub(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VNMSAC => fp_nmuladd(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwnmsac.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fwvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:1131.36-1131.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVF_VMACC => fp_muladd(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VNMACC => fp_nmulsub(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VMSAC => fp_mulsub(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVF_VNMSAC => fp_nmuladd(rm_3b, fp_widen(rs1_val), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwnmsac.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fwvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs1","size":5},{"field":"vs2","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:282.36-282.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVV_VMACC => fp_muladd(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VNMACC => fp_nmulsub(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VMSAC => fp_mulsub(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)), FWVV_VNMSAC => fp_nmuladd(rm_3b, fp_widen(plain_vector_access(vs1_val, i)), fp_widen(plain_vector_access(vs2_val, i)), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwredosum.vs","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rfvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { if or_bool(eq_anything(funct6, FVV_VFWREDOSUM), eq_anything(funct6, FVV_VFWREDUSUM)) then process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) else process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) } } } }","description":"TBD"},{"mnemonic":"vfwredusum.vs","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rfvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { if or_bool(eq_anything(funct6, FVV_VFWREDOSUM), eq_anything(funct6, FVV_VFWREDUSUM)) then process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) else process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow) } } } }","description":"TBD"},{"mnemonic":"vfwsub.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fwvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:1067.36-1067.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVF_VADD => fp_add(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)), FWVF_VSUB => fp_sub(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)), FWVF_VMUL => fp_mul(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(rs1_val)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwsub.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fwvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:217.36-217.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWVV_VADD => fp_add(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))), FWVV_VSUB => fp_sub(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))), FWVV_VMUL => fp_mul(rm_3b, fp_widen(plain_vector_access(vs2_val, i)), fp_widen(plain_vector_access(vs1_val, i))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwsub.wf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fwffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:1193.36-1193.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWF_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), fp_widen(rs1_val)), FWF_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), fp_widen(rs1_val)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vfwsub.wv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fwvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); assert(and_bool(gteq_int(SEW, 16), lteq_int(SEW_widen, 64)), \\"model/riscv_insts_vext_fp.sail:345.36-345.37\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { FWV_VADD => fp_add(rm_3b, plain_vector_access(vs2_val, i), fp_widen(plain_vector_access(vs1_val, i))), FWV_VSUB => fp_sub(rm_3b, plain_vector_access(vs2_val, i), fp_widen(plain_vector_access(vs1_val, i))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vid.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vdvm","format":"TBD","fields":[{"field":"0b010100","size":6},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"0b10001","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then result[i] = to_bits(SEW, i) else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } }","description":"TBD"},{"mnemonic":"viota.m","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010100","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"0b10000","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if or_bool(illegal_normal(vd, vm), or_bool(not(assert_vstart(0)), eq_bits(vd, vs2))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); var sum : int = 0 in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = to_bits(SEW, sum); if plain_vector_access(vs2_val, i) then sum = add_atom(sum, 1) else () } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vle16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vle16ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vle32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vle32ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vle64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vle64ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vle8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vle8ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlm.v","name":"TBD","operands":[{"name":"vd_or_vs3","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd_or_vs3,(rs1)","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01011","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vd_or_vs3","size":5},{"field":"encdec_lsop(op)","size":7}],"extensions":["V"],"function":"{ let EEW = 8 in { let EMUL_pow = 0 in { let vl_val = unsigned(vl) in { let evl : int = if eq_int(emod_int(vl_val, 8), 0) then quot_round_zero(vl_val, 8) else add_atom(quot_round_zero(vl_val, 8), 1) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); assert(gteq_int(evl, 0), \\"model/riscv_insts_vext_mem.sail:929.17-929.18\\"); process_vm(vd_or_vs3, rs1, num_elem, evl, op) } } } } } }","description":"TBD"},{"mnemonic":"vloxei16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxei32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxei64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxei8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg2ei16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg2ei32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg2ei64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg2ei8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg3ei16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg3ei32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg3ei64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg3ei8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg4ei16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg4ei32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg4ei64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg4ei8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg5ei16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg5ei32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg5ei64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg5ei8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg6ei16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg6ei32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg6ei64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg6ei8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg7ei16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg7ei32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg7ei64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg7ei8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg8ei16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg8ei32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg8ei64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vloxseg8ei8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlre16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlre32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlre64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlre8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlse16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlse32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlse64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlse8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg2e16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg2e16ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg2e32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg2e32ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg2e64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg2e64ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg2e8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg2e8ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg2re16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg2re32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg2re64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg2re8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg3e16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg3e16ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg3e32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg3e32ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg3e64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg3e64ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg3e8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg3e8ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg3re16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg3re32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg3re64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg3re8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg4e16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg4e16ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg4e32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg4e32ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg4e64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg4e64ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg4e8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg4e8ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg4re16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg4re32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg4re64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg4re8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg5e16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg5e16ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg5e32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg5e32ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg5e64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg5e64ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg5e8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg5e8ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg5re16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg5re32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg5re64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg5re8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg6e16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg6e16ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg6e32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg6e32ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg6e64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg6e64ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg6e8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg6e8ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg6re16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg6re32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg6re64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg6re8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg7e16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg7e16ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg7e32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg7e32ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg7e64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg7e64ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg7e8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg7e8ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg7re16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg7re32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg7re64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg7re8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg8e16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg8e16ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg8e32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg8e32ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg8e64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg8e64ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg8e8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg8e8ff.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlseg8re16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg8re32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg8re64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlseg8re8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:738.26-738.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vlsseg2e16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg2e32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg2e64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg2e8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg3e16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg3e32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg3e64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg3e8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg4e16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg4e32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg4e64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg4e8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg5e16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg5e32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg5e64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg5e8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg6e16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg6e32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg6e64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg6e8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg7e16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg7e32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg7e64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg7e8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg8e16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg8e32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg8e64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vlsseg8e8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxei16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxei32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxei64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxei8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg2ei16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg2ei32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg2ei64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg2ei8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg3ei16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg3ei32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg3ei64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg3ei8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg4ei16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg4ei32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg4ei64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg4ei8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg5ei16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg5ei32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg5ei64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg5ei8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg6ei16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg6ei32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg6ei64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg6ei8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg7ei16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg7ei32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg7ei64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg7ei8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg8ei16.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg8ei32.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg8ei64.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vluxseg8ei8.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_load(vd, vm, nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vmacc.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_mvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VMACC => add_bits(get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i))), 0), plain_vector_access(vd_val, i)), MVV_VNMSAC => sub_vec(plain_vector_access(vd_val, i), get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i))), 0)), MVV_VMADD => add_bits(get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vd_val, i))), 0), plain_vector_access(vs2_val, i)), MVV_VNMSUB => sub_vec(plain_vector_access(vs2_val, i), get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vd_val, i))), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmacc.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_mvxmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VMACC => add_bits(get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i))), 0), plain_vector_access(vd_val, i)), MVX_VNMSAC => sub_vec(plain_vector_access(vd_val, i), get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i))), 0)), MVX_VMADD => add_bits(get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vd_val, i))), 0), plain_vector_access(vs2_val, i)), MVX_VNMSUB => sub_vec(plain_vector_access(vs2_val, i), get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vd_val, i))), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmadc.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"}],"syntax":"vd,vs2,simm","format":"TBD","fields":[{"field":"encdec_vimcfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VIMC_VMADC => gt_int(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), sub_atom(pow2(SEW), 1)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmadc.vim","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"v0","type":"unknown"}],"syntax":"vd,vs2,simm,v0","format":"TBD","fields":[{"field":"encdec_vimfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VIM_VMADC => gt_int(add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), sub_atom(pow2(SEW), 1)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmadc.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_vvmcfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVMC_VMADC => gt_int(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), sub_atom(pow2(SEW), 1)), VVMC_VMSBC => lt_int(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), 0) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmadc.vvm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"v0","type":"unknown"}],"syntax":"vd,vs2,vs1,v0","format":"TBD","fields":[{"field":"encdec_vvmfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVM_VMADC => gt_int(add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), sub_atom(pow2(SEW), 1)), VVM_VMSBC => lt_int(sub_atom(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), 0) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmadc.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,vs2,rs1","format":"TBD","fields":[{"field":"encdec_vxmcfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXMC_VMADC => gt_int(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), sub_atom(pow2(SEW), 1)), VXMC_VMSBC => lt_int(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), 0) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmadc.vxm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"v0","type":"unknown"}],"syntax":"vd,vs2,rs1,v0","format":"TBD","fields":[{"field":"encdec_vxmfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXM_VMADC => gt_int(add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), sub_atom(pow2(SEW), 1)), VXM_VMSBC => lt_int(sub_atom(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), 0) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmadd.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_mvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VMACC => add_bits(get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i))), 0), plain_vector_access(vd_val, i)), MVV_VNMSAC => sub_vec(plain_vector_access(vd_val, i), get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i))), 0)), MVV_VMADD => add_bits(get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vd_val, i))), 0), plain_vector_access(vs2_val, i)), MVV_VNMSUB => sub_vec(plain_vector_access(vs2_val, i), get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vd_val, i))), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmadd.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_mvxmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VMACC => add_bits(get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i))), 0), plain_vector_access(vd_val, i)), MVX_VNMSAC => sub_vec(plain_vector_access(vd_val, i), get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i))), 0)), MVX_VMADD => add_bits(get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vd_val, i))), 0), plain_vector_access(vs2_val, i)), MVX_VNMSUB => sub_vec(plain_vector_access(vs2_val, i), get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vd_val, i))), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmand.mm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_mmfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vs1_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MM_VMAND => and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNAND => not(and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMANDNOT => and_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXOR => neq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMOR => or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNOR => not(or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMORNOT => or_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXNOR => eq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmandnot.mm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_mmfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vs1_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MM_VMAND => and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNAND => not(and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMANDNOT => and_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXOR => neq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMOR => or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNOR => not(or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMORNOT => or_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXNOR => eq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmax.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmax.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmaxu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmaxu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmerge.vim","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"v0","type":"unknown"}],"syntax":"vd,vs2,simm,v0","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let start_element = get_start_element() in { let end_element = get_end_element() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let real_num_elem = if gteq_int(LMUL_pow, 0) then num_elem else quot_round_zero(num_elem, sub_atom(0, LMUL_pow)) in { if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { let tail_ag : agtype = get_vtype_vta() in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if lt_int(i, start_element) then { result[i] = plain_vector_access(vd_val, i) } else if or_bool(gt_int(i, end_element), gteq_int(i, real_num_elem)) then { result[i] = match tail_ag { UNDISTURBED => plain_vector_access(vd_val, i), AGNOSTIC => plain_vector_access(vd_val, i) } } else { result[i] = if plain_vector_access(vm_val, i) then imm_val else plain_vector_access(vs2_val, i) } }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmerge.vvm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"v0","type":"unknown"}],"syntax":"vd,vs2,vs1,v0","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let start_element = get_start_element() in { let end_element = get_end_element() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let real_num_elem = if gteq_int(LMUL_pow, 0) then num_elem else quot_round_zero(num_elem, sub_atom(0, LMUL_pow)) in { if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { let tail_ag : agtype = get_vtype_vta() in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if lt_int(i, start_element) then { result[i] = plain_vector_access(vd_val, i) } else if or_bool(gt_int(i, end_element), gteq_int(i, real_num_elem)) then { result[i] = match tail_ag { UNDISTURBED => plain_vector_access(vd_val, i), AGNOSTIC => plain_vector_access(vd_val, i) } } else { result[i] = if plain_vector_access(vm_val, i) then plain_vector_access(vs1_val, i) else plain_vector_access(vs2_val, i) } }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmerge.vxm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"v0","type":"unknown"}],"syntax":"vd,vs2,rs1,v0","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let start_element = get_start_element() in { let end_element = get_end_element() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let real_num_elem = if gteq_int(LMUL_pow, 0) then num_elem else quot_round_zero(num_elem, sub_atom(0, LMUL_pow)) in { if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { let tail_ag : agtype = get_vtype_vta() in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if lt_int(i, start_element) then { result[i] = plain_vector_access(vd_val, i) } else if or_bool(gt_int(i, end_element), gteq_int(i, real_num_elem)) then { result[i] = match tail_ag { UNDISTURBED => plain_vector_access(vd_val, i), AGNOSTIC => plain_vector_access(vd_val, i) } } else { result[i] = if plain_vector_access(vm_val, i) then rs1_val else plain_vector_access(vs2_val, i) } }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmfeq.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvfmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_vm.sail:840.17-840.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VFM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), rs1_val)), VFM_VMFLE => fp_le(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGE => fp_ge(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGT => fp_gt(plain_vector_access(vs2_val, i), rs1_val) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmfeq.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_vm.sail:776.17-776.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { FVVM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVVM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), FVVM_VMFLE => fp_le(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVVM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmfge.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvfmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_vm.sail:840.17-840.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VFM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), rs1_val)), VFM_VMFLE => fp_le(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGE => fp_ge(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGT => fp_gt(plain_vector_access(vs2_val, i), rs1_val) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmfgt.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvfmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_vm.sail:840.17-840.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VFM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), rs1_val)), VFM_VMFLE => fp_le(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGE => fp_ge(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGT => fp_gt(plain_vector_access(vs2_val, i), rs1_val) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmfle.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvfmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_vm.sail:840.17-840.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VFM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), rs1_val)), VFM_VMFLE => fp_le(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGE => fp_ge(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGT => fp_gt(plain_vector_access(vs2_val, i), rs1_val) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmfle.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_vm.sail:776.17-776.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { FVVM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVVM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), FVVM_VMFLE => fp_le(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVVM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmflt.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvfmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_vm.sail:840.17-840.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VFM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), rs1_val)), VFM_VMFLE => fp_le(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGE => fp_ge(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGT => fp_gt(plain_vector_access(vs2_val, i), rs1_val) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmflt.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_vm.sail:776.17-776.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { FVVM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVVM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), FVVM_VMFLE => fp_le(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVVM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmfne.vf","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvfmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_vm.sail:840.17-840.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar_fp(rs1, __id(m)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VFM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), rs1_val)), VFM_VMFLE => fp_le(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGE => fp_ge(plain_vector_access(vs2_val, i), rs1_val), VFM_VMFGT => fp_gt(plain_vector_access(vs2_val, i), rs1_val) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmfne.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let rm_3b = _get_Fcsr_FRM(fcsr) in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL } else (); assert(neq_int(SEW, 8), \\"model/riscv_insts_vext_vm.sail:776.17-776.18\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { FVVM_VMFEQ => fp_eq(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVVM_VMFNE => not_bool(fp_eq(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), FVVM_VMFLE => fp_le(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), FVVM_VMFLT => fp_lt(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmin.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmin.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vminu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vminu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmnand.mm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_mmfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vs1_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MM_VMAND => and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNAND => not(and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMANDNOT => and_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXOR => neq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMOR => or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNOR => not(or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMORNOT => or_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXNOR => eq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmnor.mm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_mmfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vs1_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MM_VMAND => and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNAND => not(and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMANDNOT => and_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXOR => neq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMOR => or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNOR => not(or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMORNOT => or_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXNOR => eq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmor.mm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_mmfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vs1_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MM_VMAND => and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNAND => not(and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMANDNOT => and_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXOR => neq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMOR => or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNOR => not(or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMORNOT => or_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXNOR => eq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmornot.mm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_mmfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vs1_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MM_VMAND => and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNAND => not(and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMANDNOT => and_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXOR => neq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMOR => or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNOR => not(or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMORNOT => or_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXNOR => eq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsbc.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_vvmcfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVMC_VMADC => gt_int(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), sub_atom(pow2(SEW), 1)), VVMC_VMSBC => lt_int(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), 0) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsbc.vvm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"v0","type":"unknown"}],"syntax":"vd,vs2,vs1,v0","format":"TBD","fields":[{"field":"encdec_vvmfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVM_VMADC => gt_int(add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), sub_atom(pow2(SEW), 1)), VVM_VMSBC => lt_int(sub_atom(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), 0) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsbc.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,vs2,rs1","format":"TBD","fields":[{"field":"encdec_vxmcfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXMC_VMADC => gt_int(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), sub_atom(pow2(SEW), 1)), VXMC_VMSBC => lt_int(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), 0) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsbc.vxm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"v0","type":"unknown"}],"syntax":"vd,vs2,rs1,v0","format":"TBD","fields":[{"field":"encdec_vxmfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXM_VMADC => gt_int(add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), sub_atom(pow2(SEW), 1)), VXM_VMSBC => lt_int(sub_atom(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i)))), 0) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsbf.m","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010100","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"0b00001","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if or_bool(illegal_normal(vd, vm), or_bool(not(assert_vstart(0)), eq_bits(vd, vs2))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vd_val, vm_val); var found_elem : bool = false in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { if plain_vector_access(vs2_val, i) then found_elem = true else (); result[i] = if found_elem then false else true } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmseq.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vicmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VICMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)), VICMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmseq.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), VVCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmseq.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsgt.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vicmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VICMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)), VICMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsgt.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsgtu.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vicmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VICMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)), VICMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsgtu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsif.m","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010100","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"0b00011","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if or_bool(illegal_normal(vd, vm), or_bool(not(assert_vstart(0)), eq_bits(vd, vs2))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vd_val, vm_val); var found_elem : bool = false in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = if found_elem then false else true; if plain_vector_access(vs2_val, i) then found_elem = true else () } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsle.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vicmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VICMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)), VICMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsle.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), VVCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsle.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsleu.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vicmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VICMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)), VICMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsleu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), VVCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsleu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmslt.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), VVCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmslt.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsltu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), VVCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsltu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsne.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vicmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VICMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), imm_val), VICMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)), VICMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(imm_val)), VICMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(imm_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsne.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VVCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VVCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), VVCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), VVCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsne.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let res : bool = match funct6 { VXCMP_VMSEQ => eq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSNE => neq_bits(plain_vector_access(vs2_val, i), rs1_val), VXCMP_VMSLTU => lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLT => lt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSLEU => lteq_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSLE => lteq_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), VXCMP_VMSGTU => gt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), VXCMP_VMSGT => gt_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) } in { result[i] = res } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmsof.m","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010100","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"0b00010","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if or_bool(illegal_normal(vd, vm), or_bool(not(assert_vstart(0)), eq_bits(vd, vs2))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vd_val, vm_val); var found_elem : bool = false in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { if and_bool(plain_vector_access(vs2_val, i), not(found_elem)) then { result[i] = true; found_elem = true } else { result[i] = false } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmul.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmul.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_arith.sail:1974.57-1974.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmulh.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmulh.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_arith.sail:1974.57-1974.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmulhsu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmulhsu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_arith.sail:1974.57-1974.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmulhu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmulhu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_arith.sail:1974.57-1974.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmv.s.x","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,rs1","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"0b1","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let num_elem = get_num_elem(0, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); assert(gt_int(num_elem, 0), \\"model/riscv_insts_vext_arith.sail:2301.21-2301.22\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, __id(m)) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, 0, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, 0, vd_val, vm_val); if plain_vector_access(mask, 0) then result[0] = rs1_val else (); let tail_ag : agtype = get_vtype_vta() in { foreach (i from 1 to sub_atom(num_elem, 1) by 1 order inc) { { result[i] = match tail_ag { UNDISTURBED => plain_vector_access(vd_val, i), AGNOSTIC => plain_vector_access(vd_val, i) } }; write_vreg(num_elem, SEW, 0, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmv.v.i","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"simm","type":"bits(5)"}],"syntax":"vd,simm","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b1","size":1},{"field":"0b00000","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then result[i] = imm_val else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmv.v.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"}],"syntax":"vd,vs1","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b1","size":1},{"field":"0b00000","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then result[i] = plain_vector_access(vs1_val, i) else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmv.v.x","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd,rs1","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b1","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let rs1_val : bits(\'m) = get_scalar(rs1, __id(m)) in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then result[i] = rs1_val else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmv.x.s","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"vs2","type":"regidx"}],"syntax":"rd,vs2","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"0b00000","size":5},{"field":"0b010","size":3},{"field":"rd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let num_elem = get_num_elem(0, SEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); assert(gt_int(num_elem, 0), \\"model/riscv_insts_vext_arith.sail:1830.21-1830.22\\"); let n as \'n = num_elem in { let m as \'m = SEW in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, 0, vs2) in { wX_bits(rd, if lt_int(64, SEW) then slice(plain_vector_access(vs2_val, 0), 0, 64) else if gt_int(64, SEW) then sign_extend(64, plain_vector_access(vs2_val, 0)) else plain_vector_access(vs2_val, 0)); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } }","description":"TBD"},{"mnemonic":"vmv1r.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"}],"syntax":"vd,vs2","format":"TBD","fields":[{"field":"0b100111","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let start_element = get_start_element() in { let SEW = get_sew() in { let imm_val = unsigned(zero_extend(64, simm)) in { let EMUL = add_atom(imm_val, 1) in { if not(or_bool(eq_int(EMUL, 1), or_bool(eq_int(EMUL, 2), or_bool(eq_int(EMUL, 4), eq_int(EMUL, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); let EMUL_pow = log2(EMUL) in { let num_elem = get_num_elem(EMUL_pow, SEW) in { let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, EMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, EMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { result[i] = if lt_int(i, start_element) then plain_vector_access(vd_val, i) else plain_vector_access(vs2_val, i) }; write_vreg(num_elem, SEW, EMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmv2r.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"}],"syntax":"vd,vs2","format":"TBD","fields":[{"field":"0b100111","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let start_element = get_start_element() in { let SEW = get_sew() in { let imm_val = unsigned(zero_extend(64, simm)) in { let EMUL = add_atom(imm_val, 1) in { if not(or_bool(eq_int(EMUL, 1), or_bool(eq_int(EMUL, 2), or_bool(eq_int(EMUL, 4), eq_int(EMUL, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); let EMUL_pow = log2(EMUL) in { let num_elem = get_num_elem(EMUL_pow, SEW) in { let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, EMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, EMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { result[i] = if lt_int(i, start_element) then plain_vector_access(vd_val, i) else plain_vector_access(vs2_val, i) }; write_vreg(num_elem, SEW, EMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmv4r.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"}],"syntax":"vd,vs2","format":"TBD","fields":[{"field":"0b100111","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let start_element = get_start_element() in { let SEW = get_sew() in { let imm_val = unsigned(zero_extend(64, simm)) in { let EMUL = add_atom(imm_val, 1) in { if not(or_bool(eq_int(EMUL, 1), or_bool(eq_int(EMUL, 2), or_bool(eq_int(EMUL, 4), eq_int(EMUL, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); let EMUL_pow = log2(EMUL) in { let num_elem = get_num_elem(EMUL_pow, SEW) in { let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, EMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, EMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { result[i] = if lt_int(i, start_element) then plain_vector_access(vd_val, i) else plain_vector_access(vs2_val, i) }; write_vreg(num_elem, SEW, EMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmv8r.v","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"}],"syntax":"vd,vs2","format":"TBD","fields":[{"field":"0b100111","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let start_element = get_start_element() in { let SEW = get_sew() in { let imm_val = unsigned(zero_extend(64, simm)) in { let EMUL = add_atom(imm_val, 1) in { if not(or_bool(eq_int(EMUL, 1), or_bool(eq_int(EMUL, 2), or_bool(eq_int(EMUL, 4), eq_int(EMUL, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); let EMUL_pow = log2(EMUL) in { let num_elem = get_num_elem(EMUL_pow, SEW) in { let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, 0b1, 0b00000) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, EMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, EMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { result[i] = if lt_int(i, start_element) then plain_vector_access(vd_val, i) else plain_vector_access(vs2_val, i) }; write_vreg(num_elem, SEW, EMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmxnor.mm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_mmfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vs1_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MM_VMAND => and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNAND => not(and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMANDNOT => and_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXOR => neq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMOR => or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNOR => not(or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMORNOT => or_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXNOR => eq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vmxor.mm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_mmfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vs1_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs1) in { let vs2_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs2) in { let vd_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vd) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MM_VMAND => and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNAND => not(and_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMANDNOT => and_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXOR => neq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMOR => or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), MM_VMNOR => not(or_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i))), MM_VMORNOT => or_bool(plain_vector_access(vs2_val, i), not(plain_vector_access(vs1_val, i))), MM_VMXNOR => eq_bool(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)) } } else () }; write_vmask(num_elem, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vnclip.wi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_nifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \\"model/riscv_insts_vext_arith.sail:1043.24-1043.25\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let shift_amount = get_shift_amount(imm_val, SEW_widen) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { result[i] = match funct6 { NI_VNCLIPU => { let result_wide = add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(o), rounding_incr)) in { unsigned_saturation(__id(m), result_wide) } }, NI_VNCLIP => { let v_double : bits((\'m * 4)) = sign_extend(mult_atom(__id(m), 4), plain_vector_access(vs2_val, i)) in { let result_wide = add_bits(slice(shiftr(v_double, shift_amount), 0, __id(o)), zero_extend(__id(o), rounding_incr)) in { signed_saturation(__id(m), result_wide) } } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vnclip.wv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_nvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \\"model/riscv_insts_vext_arith.sail:301.24-301.25\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW_widen) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { result[i] = match funct6 { NV_VNCLIPU => { let result_wide = add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(o), rounding_incr)) in { unsigned_saturation(__id(m), result_wide) } }, NV_VNCLIP => { let v_double : bits((\'m * 4)) = sign_extend(mult_atom(__id(m), 4), plain_vector_access(vs2_val, i)) in { let result_wide = add_bits(slice(shiftr(v_double, shift_amount), 0, __id(o)), zero_extend(__id(o), rounding_incr)) in { signed_saturation(__id(m), result_wide) } } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vnclip.wx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_nxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \\"model/riscv_insts_vext_arith.sail:653.24-653.25\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let shift_amount = get_shift_amount(rs1_val, SEW_widen) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { result[i] = match funct6 { NX_VNCLIPU => { let result_wide = add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(o), rounding_incr)) in { unsigned_saturation(__id(m), result_wide) } }, NX_VNCLIP => { let v_double : bits((\'m * 4)) = sign_extend(mult_atom(__id(m), 4), plain_vector_access(vs2_val, i)) in { let result_wide = add_bits(slice(shiftr(v_double, shift_amount), 0, __id(o)), zero_extend(__id(o), rounding_incr)) in { signed_saturation(__id(m), result_wide) } } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vnclipu.wi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_nifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \\"model/riscv_insts_vext_arith.sail:1043.24-1043.25\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let shift_amount = get_shift_amount(imm_val, SEW_widen) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { result[i] = match funct6 { NI_VNCLIPU => { let result_wide = add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(o), rounding_incr)) in { unsigned_saturation(__id(m), result_wide) } }, NI_VNCLIP => { let v_double : bits((\'m * 4)) = sign_extend(mult_atom(__id(m), 4), plain_vector_access(vs2_val, i)) in { let result_wide = add_bits(slice(shiftr(v_double, shift_amount), 0, __id(o)), zero_extend(__id(o), rounding_incr)) in { signed_saturation(__id(m), result_wide) } } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vnclipu.wv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_nvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \\"model/riscv_insts_vext_arith.sail:301.24-301.25\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW_widen) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { result[i] = match funct6 { NV_VNCLIPU => { let result_wide = add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(o), rounding_incr)) in { unsigned_saturation(__id(m), result_wide) } }, NV_VNCLIP => { let v_double : bits((\'m * 4)) = sign_extend(mult_atom(__id(m), 4), plain_vector_access(vs2_val, i)) in { let result_wide = add_bits(slice(shiftr(v_double, shift_amount), 0, __id(o)), zero_extend(__id(o), rounding_incr)) in { signed_saturation(__id(m), result_wide) } } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vnclipu.wx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_nxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \\"model/riscv_insts_vext_arith.sail:653.24-653.25\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let shift_amount = get_shift_amount(rs1_val, SEW_widen) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { result[i] = match funct6 { NX_VNCLIPU => { let result_wide = add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(o), rounding_incr)) in { unsigned_saturation(__id(m), result_wide) } }, NX_VNCLIP => { let v_double : bits((\'m * 4)) = sign_extend(mult_atom(__id(m), 4), plain_vector_access(vs2_val, i)) in { let result_wide = add_bits(slice(shiftr(v_double, shift_amount), 0, __id(o)), zero_extend(__id(o), rounding_incr)) in { signed_saturation(__id(m), result_wide) } } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vnmsac.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_mvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VMACC => add_bits(get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i))), 0), plain_vector_access(vd_val, i)), MVV_VNMSAC => sub_vec(plain_vector_access(vd_val, i), get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i))), 0)), MVV_VMADD => add_bits(get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vd_val, i))), 0), plain_vector_access(vs2_val, i)), MVV_VNMSUB => sub_vec(plain_vector_access(vs2_val, i), get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vd_val, i))), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vnmsac.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_mvxmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VMACC => add_bits(get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i))), 0), plain_vector_access(vd_val, i)), MVX_VNMSAC => sub_vec(plain_vector_access(vd_val, i), get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i))), 0)), MVX_VMADD => add_bits(get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vd_val, i))), 0), plain_vector_access(vs2_val, i)), MVX_VNMSUB => sub_vec(plain_vector_access(vs2_val, i), get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vd_val, i))), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vnmsub.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_mvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VMACC => add_bits(get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i))), 0), plain_vector_access(vd_val, i)), MVV_VNMSAC => sub_vec(plain_vector_access(vd_val, i), get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i))), 0)), MVV_VMADD => add_bits(get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vd_val, i))), 0), plain_vector_access(vs2_val, i)), MVV_VNMSUB => sub_vec(plain_vector_access(vs2_val, i), get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vd_val, i))), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vnmsub.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_mvxmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VMACC => add_bits(get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i))), 0), plain_vector_access(vd_val, i)), MVX_VNMSAC => sub_vec(plain_vector_access(vd_val, i), get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i))), 0)), MVX_VMADD => add_bits(get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vd_val, i))), 0), plain_vector_access(vs2_val, i)), MVX_VNMSUB => sub_vec(plain_vector_access(vs2_val, i), get_slice_int(SEW, mult_atom(signed(rs1_val), signed(plain_vector_access(vd_val, i))), 0)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vnsra.wi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_nisfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \\"model/riscv_insts_vext_arith.sail:976.24-976.25\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { NIS_VNSRL => { let shift_amount = get_shift_amount(imm_val, SEW_widen) in { slice(shiftr(plain_vector_access(vs2_val, i), shift_amount), 0, SEW) } }, NIS_VNSRA => { let shift_amount = get_shift_amount(imm_val, SEW_widen) in { let v_double : bits((\'o * 2)) = sign_extend(mult_atom(__id(o), 2), plain_vector_access(vs2_val, i)) in { let arith_shifted : bits(\'o) = slice(shiftr(v_double, shift_amount), 0, SEW_widen) in { slice(arith_shifted, 0, SEW) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vnsra.wv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_nvsfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \\"model/riscv_insts_vext_arith.sail:234.24-234.25\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { NVS_VNSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW_widen) in { slice(shiftr(plain_vector_access(vs2_val, i), shift_amount), 0, SEW) } }, NVS_VNSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW_widen) in { let v_double : bits((\'o * 2)) = sign_extend(mult_atom(__id(o), 2), plain_vector_access(vs2_val, i)) in { let arith_shifted : bits(\'o) = slice(shiftr(v_double, shift_amount), 0, SEW_widen) in { slice(arith_shifted, 0, SEW) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vnsra.wx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_nxsfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \\"model/riscv_insts_vext_arith.sail:586.24-586.25\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { NXS_VNSRL => { let shift_amount = get_shift_amount(rs1_val, SEW_widen) in { slice(shiftr(plain_vector_access(vs2_val, i), shift_amount), 0, SEW) } }, NXS_VNSRA => { let shift_amount = get_shift_amount(rs1_val, SEW_widen) in { let v_double : bits((\'o * 2)) = sign_extend(mult_atom(__id(o), 2), plain_vector_access(vs2_val, i)) in { let arith_shifted : bits(\'o) = slice(shiftr(v_double, shift_amount), 0, SEW_widen) in { slice(arith_shifted, 0, SEW) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vnsrl.wi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_nisfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \\"model/riscv_insts_vext_arith.sail:976.24-976.25\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { NIS_VNSRL => { let shift_amount = get_shift_amount(imm_val, SEW_widen) in { slice(shiftr(plain_vector_access(vs2_val, i), shift_amount), 0, SEW) } }, NIS_VNSRA => { let shift_amount = get_shift_amount(imm_val, SEW_widen) in { let v_double : bits((\'o * 2)) = sign_extend(mult_atom(__id(o), 2), plain_vector_access(vs2_val, i)) in { let arith_shifted : bits(\'o) = slice(shiftr(v_double, shift_amount), 0, SEW_widen) in { slice(arith_shifted, 0, SEW) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vnsrl.wv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_nvsfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \\"model/riscv_insts_vext_arith.sail:234.24-234.25\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { NVS_VNSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW_widen) in { slice(shiftr(plain_vector_access(vs2_val, i), shift_amount), 0, SEW) } }, NVS_VNSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW_widen) in { let v_double : bits((\'o * 2)) = sign_extend(mult_atom(__id(o), 2), plain_vector_access(vs2_val, i)) in { let arith_shifted : bits(\'o) = slice(shiftr(v_double, shift_amount), 0, SEW_widen) in { slice(arith_shifted, 0, SEW) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vnsrl.wx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_nxsfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(lteq_int(SEW_widen, 64), \\"model/riscv_insts_vext_arith.sail:586.24-586.25\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { NXS_VNSRL => { let shift_amount = get_shift_amount(rs1_val, SEW_widen) in { slice(shiftr(plain_vector_access(vs2_val, i), shift_amount), 0, SEW) } }, NXS_VNSRA => { let shift_amount = get_shift_amount(rs1_val, SEW_widen) in { let v_double : bits((\'o * 2)) = sign_extend(mult_atom(__id(o), 2), plain_vector_access(vs2_val, i)) in { let arith_shifted : bits(\'o) = slice(shiftr(v_double, shift_amount), 0, SEW_widen) in { slice(arith_shifted, 0, SEW) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vor.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vor.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vor.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vpopc.m","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"rd,vs2vm","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"0b10000","size":5},{"field":"0b010","size":3},{"field":"rd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = mult_atom(unsigned(vlenb), 8) in { if or_bool(illegal_vd_unmasked(), not(assert_vstart(0))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs2_val : vector(\'n, bool) = read_vmask(num_elem, 0b0, vs2) in { var result : vector(\'n, bool) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vs2_val, vm_val); var count : nat = 0 in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if and_bool(plain_vector_access(mask, i), plain_vector_access(vs2_val, i)) then count = add_atom(count, 1) else () }; wX_bits(rd, to_bits(64, count)); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vredand.vs","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW) in { if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as \'n = num_elem_vs in { let d as \'d = num_elem_vd in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector(\'d, bits(\'m)) = read_vreg(num_elem_vd, SEW, 0, vd) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector(\'n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits(\'m) = read_single_element(SEW, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { sum = match funct6 { MVV_VREDSUM => add_bits(sum, plain_vector_access(vs2_val, i)), MVV_VREDAND => and_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDOR => or_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDXOR => xor_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))), MVV_VREDMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))) } } else () }; write_single_element(SEW, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vredmax.vs","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW) in { if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as \'n = num_elem_vs in { let d as \'d = num_elem_vd in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector(\'d, bits(\'m)) = read_vreg(num_elem_vd, SEW, 0, vd) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector(\'n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits(\'m) = read_single_element(SEW, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { sum = match funct6 { MVV_VREDSUM => add_bits(sum, plain_vector_access(vs2_val, i)), MVV_VREDAND => and_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDOR => or_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDXOR => xor_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))), MVV_VREDMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))) } } else () }; write_single_element(SEW, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vredmaxu.vs","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW) in { if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as \'n = num_elem_vs in { let d as \'d = num_elem_vd in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector(\'d, bits(\'m)) = read_vreg(num_elem_vd, SEW, 0, vd) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector(\'n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits(\'m) = read_single_element(SEW, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { sum = match funct6 { MVV_VREDSUM => add_bits(sum, plain_vector_access(vs2_val, i)), MVV_VREDAND => and_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDOR => or_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDXOR => xor_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))), MVV_VREDMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))) } } else () }; write_single_element(SEW, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vredmin.vs","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW) in { if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as \'n = num_elem_vs in { let d as \'d = num_elem_vd in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector(\'d, bits(\'m)) = read_vreg(num_elem_vd, SEW, 0, vd) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector(\'n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits(\'m) = read_single_element(SEW, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { sum = match funct6 { MVV_VREDSUM => add_bits(sum, plain_vector_access(vs2_val, i)), MVV_VREDAND => and_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDOR => or_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDXOR => xor_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))), MVV_VREDMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))) } } else () }; write_single_element(SEW, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vredminu.vs","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW) in { if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as \'n = num_elem_vs in { let d as \'d = num_elem_vd in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector(\'d, bits(\'m)) = read_vreg(num_elem_vd, SEW, 0, vd) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector(\'n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits(\'m) = read_single_element(SEW, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { sum = match funct6 { MVV_VREDSUM => add_bits(sum, plain_vector_access(vs2_val, i)), MVV_VREDAND => and_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDOR => or_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDXOR => xor_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))), MVV_VREDMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))) } } else () }; write_single_element(SEW, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vredor.vs","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW) in { if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as \'n = num_elem_vs in { let d as \'d = num_elem_vd in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector(\'d, bits(\'m)) = read_vreg(num_elem_vd, SEW, 0, vd) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector(\'n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits(\'m) = read_single_element(SEW, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { sum = match funct6 { MVV_VREDSUM => add_bits(sum, plain_vector_access(vs2_val, i)), MVV_VREDAND => and_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDOR => or_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDXOR => xor_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))), MVV_VREDMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))) } } else () }; write_single_element(SEW, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vredsum.vs","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW) in { if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as \'n = num_elem_vs in { let d as \'d = num_elem_vd in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector(\'d, bits(\'m)) = read_vreg(num_elem_vd, SEW, 0, vd) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector(\'n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits(\'m) = read_single_element(SEW, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { sum = match funct6 { MVV_VREDSUM => add_bits(sum, plain_vector_access(vs2_val, i)), MVV_VREDAND => and_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDOR => or_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDXOR => xor_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))), MVV_VREDMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))) } } else () }; write_single_element(SEW, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vredxor.vs","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW) in { if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as \'n = num_elem_vs in { let d as \'d = num_elem_vd in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector(\'d, bits(\'m)) = read_vreg(num_elem_vd, SEW, 0, vd) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector(\'n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits(\'m) = read_single_element(SEW, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { sum = match funct6 { MVV_VREDSUM => add_bits(sum, plain_vector_access(vs2_val, i)), MVV_VREDAND => and_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDOR => or_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDXOR => xor_vec(sum, plain_vector_access(vs2_val, i)), MVV_VREDMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))), MVV_VREDMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(sum))), MVV_VREDMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(sum))) } } else () }; write_single_element(SEW, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vrem.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vrem.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_arith.sail:1974.57-1974.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vremu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVV_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i))) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVV_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), 0), MVV_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), SEW), MVV_VDIVU => { let q : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, q) } }, MVV_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVV_VREMU => { let r : int = if eq_int(unsigned(plain_vector_access(vs1_val, i)), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } }, MVV_VREM => { let r : int = if eq_int(signed(plain_vector_access(vs1_val, i)), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i))) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vremu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_arith.sail:1974.57-1974.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vrgather.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_visgfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : nat = unsigned(zero_extend(64, simm)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VSLIDEUP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if gteq_int(i, imm_val) then plain_vector_access(vs2_val, sub_atom(i, imm_val)) else plain_vector_access(vd_val, i) }, VI_VSLIDEDOWN => { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \\"model/riscv_insts_vext_arith.sail:1118.58-1118.59\\"); if lt_int(add_atom(i, imm_val), VLMAX) then plain_vector_access(vs2_val, add_atom(i, imm_val)) else zeros_implicit(__id(m)) } }, VI_VRGATHER => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \\"model/riscv_insts_vext_arith.sail:1124.58-1124.59\\"); if lt_int(imm_val, VLMAX) then plain_vector_access(vs2_val, imm_val) else zeros_implicit(__id(m)) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vrgather.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vrgather.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxsgfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : nat = unsigned(rX_bits(rs1)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VSLIDEUP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if gteq_int(i, rs1_val) then plain_vector_access(vs2_val, sub_atom(i, rs1_val)) else plain_vector_access(vd_val, i) }, VX_VSLIDEDOWN => { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \\"model/riscv_insts_vext_arith.sail:728.58-728.59\\"); if lt_int(add_atom(i, rs1_val), VLMAX) then plain_vector_access(vs2_val, add_atom(i, rs1_val)) else zeros_implicit(__id(m)) } }, VX_VRGATHER => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \\"model/riscv_insts_vext_arith.sail:734.58-734.59\\"); if lt_int(rs1_val, VLMAX) then plain_vector_access(vs2_val, rs1_val) else zeros_implicit(__id(m)) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vrgatherei16.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vrsub.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vrsub.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsadd.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsadd.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsadd.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsaddu.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsaddu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsaddu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsbc.vvm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"v0","type":"unknown"}],"syntax":"vd,vs2,vs1,v0","format":"TBD","fields":[{"field":"encdec_vvmsfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { var vec_trues : vector(\'n, bool) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { vec_trues[i] = true }; let vm_val : vector(\'n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VVMS_VADC => to_bits(SEW, add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))), VVMS_VSBC => to_bits(SEW, sub_atom(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsbc.vxm","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"v0","type":"unknown"}],"syntax":"vd,vs2,rs1,v0","format":"TBD","fields":[{"field":"encdec_vxmsfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { var vec_trues : vector(\'n, bool) = undefined in { foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { vec_trues[i] = true }; let vm_val : vector(\'n, bool) = read_vmask_carry(num_elem, 0b0, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VXMS_VADC => to_bits(SEW, add_atom(add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))), VXMS_VSBC => to_bits(SEW, sub_atom(sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), unsigned(bool_to_bits(plain_vector_access(vm_val, i))))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vse16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vse32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vse64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vse8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsetivli","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"uimm","type":"regidx"},{"name":"sew","type":"bits(3)"},{"name":"lmul","type":"bits(3)"},{"name":"ta","type":"bits(1)"},{"name":"ma","type":"bits(1)"}],"syntax":"rd,uimm,sewlmultama","format":"TBD","fields":[{"field":"0b1100","size":4},{"field":"ma","size":1},{"field":"ta","size":1},{"field":"sew","size":3},{"field":"lmul","size":3},{"field":"uimm","size":5},{"field":"0b111","size":3},{"field":"rd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let VLEN_pow = get_vlen_pow() in { let ELEN_pow = get_elen_pow() in { let LMUL_pow_ori = get_lmul_pow() in { let SEW_pow_ori = get_sew_pow() in { let ratio_pow_ori = sub_atom(SEW_pow_ori, LMUL_pow_ori) in { _set_Vtype_bits(ref vtype, bitvector_concat(0b0, bitvector_concat(zeros_implicit(sub_atom(64, 9)), bitvector_concat(ma, bitvector_concat(ta, bitvector_concat(sew, lmul)))))); let LMUL_pow_new = get_lmul_pow() in { let SEW_pow_new = get_sew_pow() in { if gt_int(SEW_pow_new, add_atom(LMUL_pow_new, ELEN_pow)) then { _set_Vtype_bits(ref vtype, bitvector_concat(0b1, zeros_implicit(sub_atom(64, 1)))); vl = zeros_implicit(64); print_reg(concat_str(\\"CSR vtype <- \\", string_of_bits(_get_Vtype_bits(vtype)))); print_reg(concat_str(\\"CSR vl <- \\", string_of_bits(vl))); return RETIRE_SUCCESS } else (); let VLMAX = int_power(2, sub_atom(add_atom(VLEN_pow, LMUL_pow_new), SEW_pow_new)) in { let AVL = unsigned(uimm) in { vl = if lteq_int(AVL, VLMAX) then to_bits(64, AVL) else if lt_int(AVL, mult_atom(2, VLMAX)) then to_bits(64, quot_round_zero(add_atom(AVL, 1), 2)) else to_bits(64, VLMAX); wX_bits(rd, vl); print_reg(concat_str(\\"CSR vtype <- \\", string_of_bits(_get_Vtype_bits(vtype)))); print_reg(concat_str(\\"CSR vl <- \\", string_of_bits(vl))); vstart = zeros_implicit(16); print_reg(concat_str(\\"CSR vstart <- \\", string_of_bits(vstart))); RETIRE_SUCCESS } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsetvl","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"sew","type":"bits(3)"},{"name":"lmul","type":"bits(3)"},{"name":"ta","type":"bits(1)"},{"name":"ma","type":"bits(1)"}],"syntax":"rd,rs1,sewlmultama","format":"TBD","fields":[{"field":"encdec_vsetop(op)","size":4},{"field":"ma","size":1},{"field":"ta","size":1},{"field":"sew","size":3},{"field":"lmul","size":3},{"field":"rs1","size":5},{"field":"0b111","size":3},{"field":"rd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let VLEN_pow = get_vlen_pow() in { let ELEN_pow = get_elen_pow() in { let LMUL_pow_ori = get_lmul_pow() in { let SEW_pow_ori = get_sew_pow() in { let ratio_pow_ori = sub_atom(SEW_pow_ori, LMUL_pow_ori) in { match op { VSETVLI => { _set_Vtype_bits(ref vtype, bitvector_concat(0b0, bitvector_concat(zeros_implicit(sub_atom(64, 9)), bitvector_concat(ma, bitvector_concat(ta, bitvector_concat(sew, lmul)))))) }, VSETVL => { let rs2 : regidx = bitvector_concat(subrange_bits(sew, 1, 0), lmul) in { _set_Vtype_bits(ref vtype, rX_bits(rs2)) } } }; let LMUL_pow_new = get_lmul_pow() in { let SEW_pow_new = get_sew_pow() in { if gt_int(SEW_pow_new, add_atom(LMUL_pow_new, ELEN_pow)) then { _set_Vtype_bits(ref vtype, bitvector_concat(0b1, zeros_implicit(sub_atom(64, 1)))); vl = zeros_implicit(64); print_reg(concat_str(\\"CSR vtype <- \\", string_of_bits(_get_Vtype_bits(vtype)))); print_reg(concat_str(\\"CSR vl <- \\", string_of_bits(vl))); return RETIRE_SUCCESS } else (); let VLMAX = int_power(2, sub_atom(add_atom(VLEN_pow, LMUL_pow_new), SEW_pow_new)) in { if neq_bits(rs1, 0b00000) then { let rs1_val = rX_bits(rs1) in { let AVL = unsigned(rs1_val) in { vl = if lteq_int(AVL, VLMAX) then to_bits(64, AVL) else if lt_int(AVL, mult_atom(2, VLMAX)) then to_bits(64, quot_round_zero(add_atom(AVL, 1), 2)) else to_bits(64, VLMAX); wX_bits(rd, vl) } } } else if neq_bits(rd, 0b00000) then { let AVL = unsigned(ones(64)) in { vl = to_bits(64, VLMAX); wX_bits(rd, vl) } } else { let AVL = unsigned(vl) in { let ratio_pow_new = sub_atom(SEW_pow_new, LMUL_pow_new) in { if neq_int(ratio_pow_new, ratio_pow_ori) then { _set_Vtype_bits(ref vtype, bitvector_concat(0b1, zeros_implicit(sub_atom(64, 1)))); vl = zeros_implicit(64) } else () } } }; print_reg(concat_str(\\"CSR vtype <- \\", string_of_bits(_get_Vtype_bits(vtype)))); print_reg(concat_str(\\"CSR vl <- \\", string_of_bits(vl))); vstart = zeros_implicit(16); print_reg(concat_str(\\"CSR vstart <- \\", string_of_bits(vstart))); RETIRE_SUCCESS } } } } } } } } }","description":"TBD"},{"mnemonic":"vsetvli","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"sew","type":"bits(3)"},{"name":"lmul","type":"bits(3)"},{"name":"ta","type":"bits(1)"},{"name":"ma","type":"bits(1)"}],"syntax":"rd,rs1,sewlmultama","format":"TBD","fields":[{"field":"encdec_vsetop(op)","size":4},{"field":"ma","size":1},{"field":"ta","size":1},{"field":"sew","size":3},{"field":"lmul","size":3},{"field":"rs1","size":5},{"field":"0b111","size":3},{"field":"rd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let VLEN_pow = get_vlen_pow() in { let ELEN_pow = get_elen_pow() in { let LMUL_pow_ori = get_lmul_pow() in { let SEW_pow_ori = get_sew_pow() in { let ratio_pow_ori = sub_atom(SEW_pow_ori, LMUL_pow_ori) in { match op { VSETVLI => { _set_Vtype_bits(ref vtype, bitvector_concat(0b0, bitvector_concat(zeros_implicit(sub_atom(64, 9)), bitvector_concat(ma, bitvector_concat(ta, bitvector_concat(sew, lmul)))))) }, VSETVL => { let rs2 : regidx = bitvector_concat(subrange_bits(sew, 1, 0), lmul) in { _set_Vtype_bits(ref vtype, rX_bits(rs2)) } } }; let LMUL_pow_new = get_lmul_pow() in { let SEW_pow_new = get_sew_pow() in { if gt_int(SEW_pow_new, add_atom(LMUL_pow_new, ELEN_pow)) then { _set_Vtype_bits(ref vtype, bitvector_concat(0b1, zeros_implicit(sub_atom(64, 1)))); vl = zeros_implicit(64); print_reg(concat_str(\\"CSR vtype <- \\", string_of_bits(_get_Vtype_bits(vtype)))); print_reg(concat_str(\\"CSR vl <- \\", string_of_bits(vl))); return RETIRE_SUCCESS } else (); let VLMAX = int_power(2, sub_atom(add_atom(VLEN_pow, LMUL_pow_new), SEW_pow_new)) in { if neq_bits(rs1, 0b00000) then { let rs1_val = rX_bits(rs1) in { let AVL = unsigned(rs1_val) in { vl = if lteq_int(AVL, VLMAX) then to_bits(64, AVL) else if lt_int(AVL, mult_atom(2, VLMAX)) then to_bits(64, quot_round_zero(add_atom(AVL, 1), 2)) else to_bits(64, VLMAX); wX_bits(rd, vl) } } } else if neq_bits(rd, 0b00000) then { let AVL = unsigned(ones(64)) in { vl = to_bits(64, VLMAX); wX_bits(rd, vl) } } else { let AVL = unsigned(vl) in { let ratio_pow_new = sub_atom(SEW_pow_new, LMUL_pow_new) in { if neq_int(ratio_pow_new, ratio_pow_ori) then { _set_Vtype_bits(ref vtype, bitvector_concat(0b1, zeros_implicit(sub_atom(64, 1)))); vl = zeros_implicit(64) } else () } } }; print_reg(concat_str(\\"CSR vtype <- \\", string_of_bits(_get_Vtype_bits(vtype)))); print_reg(concat_str(\\"CSR vl <- \\", string_of_bits(vl))); vstart = zeros_implicit(16); print_reg(concat_str(\\"CSR vstart <- \\", string_of_bits(vstart))); RETIRE_SUCCESS } } } } } } } } }","description":"TBD"},{"mnemonic":"vsext.vf2","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vext2_vs1(funct6)","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_half = quot_round_zero(SEW, 2) in { let LMUL_pow_half = sub_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_half, LMUL_pow_half), not(valid_reg_overlap(vs2, vd, LMUL_pow_half, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_half in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_half, LMUL_pow_half, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(gt_int(SEW, SEW_half), \\"model/riscv_insts_vext_arith.sail:1679.23-1679.24\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VEXT2_ZVF2 => zero_extend(__id(m), plain_vector_access(vs2_val, i)), VEXT2_SVF2 => sign_extend(__id(m), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsext.vf4","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vext4_vs1(funct6)","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_quart = quot_round_zero(SEW, 4) in { let LMUL_pow_quart = sub_atom(LMUL_pow, 2) in { if or_bool(illegal_variable_width(vd, vm, SEW_quart, LMUL_pow_quart), not(valid_reg_overlap(vs2, vd, LMUL_pow_quart, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_quart in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_quart, LMUL_pow_quart, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(gt_int(SEW, SEW_quart), \\"model/riscv_insts_vext_arith.sail:1737.24-1737.25\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VEXT4_ZVF4 => zero_extend(__id(m), plain_vector_access(vs2_val, i)), VEXT4_SVF4 => sign_extend(__id(m), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsext.vf8","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vext8_vs1(funct6)","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_eighth = quot_round_zero(SEW, 8) in { let LMUL_pow_eighth = sub_atom(LMUL_pow, 3) in { if or_bool(illegal_variable_width(vd, vm, SEW_eighth, LMUL_pow_eighth), not(valid_reg_overlap(vs2, vd, LMUL_pow_eighth, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_eighth in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_eighth, LMUL_pow_eighth, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(gt_int(SEW, SEW_eighth), \\"model/riscv_insts_vext_arith.sail:1795.25-1795.26\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VEXT8_ZVF8 => zero_extend(__id(m), plain_vector_access(vs2_val, i)), VEXT8_SVF8 => sign_extend(__id(m), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vslide1down.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_arith.sail:1974.57-1974.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vslide1up.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { MVX_VAADDU => { let result_add = add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VAADD => { let result_add = add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_add, 1) in { add_bits(slice(shiftr(result_add, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUBU => { let result_sub = sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VASUB => { let result_sub = sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val)) in { let rounding_incr = get_fixed_rounding_incr(result_sub, 1) in { add_bits(slice(shiftr(result_sub, 1), 0, __id(m)), zero_extend(__id(m), rounding_incr)) } } }, MVX_VSLIDE1UP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(i, 0) then rs1_val else plain_vector_access(vs2_val, sub_atom(i, 1)) }, MVX_VSLIDE1DOWN => { let last_elem = get_end_element() in { assert(lt_int(last_elem, num_elem), \\"model/riscv_insts_vext_arith.sail:1974.57-1974.58\\"); if lt_int(i, last_elem) then plain_vector_access(vs2_val, add_atom(i, 1)) else rs1_val } }, MVX_VMUL => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), 0), MVX_VMULH => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)), SEW), MVX_VMULHU => get_slice_int(SEW, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VMULHSU => get_slice_int(SEW, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val)), SEW), MVX_VDIVU => { let q : int = if eq_int(unsigned(rs1_val), 0) then -1 else quot_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, q) } }, MVX_VDIV => { let elem_max : int = sub_atom(pow2(sub_atom(SEW, 1)), 1) in { let elem_min : int = sub_atom(0, pow2(sub_atom(SEW, 1))) in { let q : int = if eq_int(signed(rs1_val), 0) then -1 else quot_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { let q\' : int = if gt_int(q, elem_max) then elem_min else q in { to_bits(SEW, q\') } } } } }, MVX_VREMU => { let r : int = if eq_int(unsigned(rs1_val), 0) then unsigned(plain_vector_access(vs2_val, i)) else rem_round_zero(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) in { to_bits(SEW, r) } }, MVX_VREM => { let r : int = if eq_int(signed(rs1_val), 0) then signed(plain_vector_access(vs2_val, i)) else rem_round_zero(signed(plain_vector_access(vs2_val, i)), signed(rs1_val)) in { to_bits(SEW, r) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vslidedown.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_visgfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : nat = unsigned(zero_extend(64, simm)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VSLIDEUP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if gteq_int(i, imm_val) then plain_vector_access(vs2_val, sub_atom(i, imm_val)) else plain_vector_access(vd_val, i) }, VI_VSLIDEDOWN => { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \\"model/riscv_insts_vext_arith.sail:1118.58-1118.59\\"); if lt_int(add_atom(i, imm_val), VLMAX) then plain_vector_access(vs2_val, add_atom(i, imm_val)) else zeros_implicit(__id(m)) } }, VI_VRGATHER => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \\"model/riscv_insts_vext_arith.sail:1124.58-1124.59\\"); if lt_int(imm_val, VLMAX) then plain_vector_access(vs2_val, imm_val) else zeros_implicit(__id(m)) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vslidedown.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxsgfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : nat = unsigned(rX_bits(rs1)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VSLIDEUP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if gteq_int(i, rs1_val) then plain_vector_access(vs2_val, sub_atom(i, rs1_val)) else plain_vector_access(vd_val, i) }, VX_VSLIDEDOWN => { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \\"model/riscv_insts_vext_arith.sail:728.58-728.59\\"); if lt_int(add_atom(i, rs1_val), VLMAX) then plain_vector_access(vs2_val, add_atom(i, rs1_val)) else zeros_implicit(__id(m)) } }, VX_VRGATHER => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \\"model/riscv_insts_vext_arith.sail:734.58-734.59\\"); if lt_int(rs1_val, VLMAX) then plain_vector_access(vs2_val, rs1_val) else zeros_implicit(__id(m)) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vslideup.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_visgfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : nat = unsigned(zero_extend(64, simm)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VSLIDEUP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if gteq_int(i, imm_val) then plain_vector_access(vs2_val, sub_atom(i, imm_val)) else plain_vector_access(vd_val, i) }, VI_VSLIDEDOWN => { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \\"model/riscv_insts_vext_arith.sail:1118.58-1118.59\\"); if lt_int(add_atom(i, imm_val), VLMAX) then plain_vector_access(vs2_val, add_atom(i, imm_val)) else zeros_implicit(__id(m)) } }, VI_VRGATHER => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \\"model/riscv_insts_vext_arith.sail:1124.58-1124.59\\"); if lt_int(imm_val, VLMAX) then plain_vector_access(vs2_val, imm_val) else zeros_implicit(__id(m)) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vslideup.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxsgfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : nat = unsigned(rX_bits(rs1)) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VSLIDEUP => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); if gteq_int(i, rs1_val) then plain_vector_access(vs2_val, sub_atom(i, rs1_val)) else plain_vector_access(vd_val, i) }, VX_VSLIDEDOWN => { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \\"model/riscv_insts_vext_arith.sail:728.58-728.59\\"); if lt_int(add_atom(i, rs1_val), VLMAX) then plain_vector_access(vs2_val, add_atom(i, rs1_val)) else zeros_implicit(__id(m)) } }, VX_VRGATHER => { if eq_bits(vs2, vd) then { handle_illegal(); return RETIRE_FAIL } else (); let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(and_bool(gt_int(VLMAX, 0), lteq_int(VLMAX, __id(n))), \\"model/riscv_insts_vext_arith.sail:734.58-734.59\\"); if lt_int(rs1_val, VLMAX) then plain_vector_access(vs2_val, rs1_val) else zeros_implicit(__id(m)) } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsll.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsll.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsll.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsm.v","name":"TBD","operands":[{"name":"vd_or_vs3","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vd_or_vs3,(rs1)","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01011","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vd_or_vs3","size":5},{"field":"encdec_lsop(op)","size":7}],"extensions":["V"],"function":"{ let EEW = 8 in { let EMUL_pow = 0 in { let vl_val = unsigned(vl) in { let evl : int = if eq_int(emod_int(vl_val, 8), 0) then quot_round_zero(vl_val, 8) else add_atom(quot_round_zero(vl_val, 8), 1) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL } else (); assert(gteq_int(evl, 0), \\"model/riscv_insts_vext_mem.sail:929.17-929.18\\"); process_vm(vd_or_vs3, rs1, num_elem, evl, op) } } } } } }","description":"TBD"},{"mnemonic":"vsmul.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsmul.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxei16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxei32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxei64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxei8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg2ei16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg2ei32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg2ei64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg2ei8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg3ei16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg3ei32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg3ei64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg3ei8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg4ei16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg4ei32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg4ei64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg4ei8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg5ei16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg5ei32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg5ei64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg5ei8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg6ei16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg6ei32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg6ei64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg6ei8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg7ei16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg7ei32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg7ei64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg7ei8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg8ei16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg8ei32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg8ei64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsoxseg8ei8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsr.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vs3,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = 1 in { let EEW = 8 in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:838.26-838.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vsra.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsra.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsra.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsrl.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsrl.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsrl.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsse16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsse32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsse64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsse8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg2e16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg2e32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg2e64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg2e8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg2r.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vs3,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = 1 in { let EEW = 8 in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:838.26-838.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vsseg3e16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg3e32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg3e64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg3e8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg3r.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vs3,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = 1 in { let EEW = 8 in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:838.26-838.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vsseg4e16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg4e32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg4e64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg4e8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg4r.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vs3,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = 1 in { let EEW = 8 in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:838.26-838.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vsseg5e16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg5e32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg5e64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg5e8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg5r.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vs3,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = 1 in { let EEW = 8 in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:838.26-838.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vsseg6e16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg6e32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg6e64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg6e8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg6r.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vs3,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = 1 in { let EEW = 8 in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:838.26-838.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vsseg7e16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg7e32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg7e64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg7e8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg7r.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vs3,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = 1 in { let EEW = 8 in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:838.26-838.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vsseg8e16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg8e32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg8e64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg8e8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsseg8r.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"vs3,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = 1 in { let EEW = 8 in { let VLEN = mult_atom(unsigned(vlenb), 8) in { let elem_per_reg : int = quot_round_zero(VLEN, EEW) in { let nf_int = nfields_int_forwards(nf) in { assert(gteq_int(elem_per_reg, 0), \\"model/riscv_insts_vext_mem.sail:838.26-838.27\\"); if not(or_bool(eq_int(nf_int, 1), or_bool(eq_int(nf_int, 2), or_bool(eq_int(nf_int, 4), eq_int(nf_int, 8))))) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg) } } } } } }","description":"TBD"},{"mnemonic":"vssra.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vssra.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vssra.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vssrl.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vssrl.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vssrl.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg2e16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg2e32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg2e64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg2e8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg3e16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg3e32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg3e64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg3e8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg4e16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg4e32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg4e64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg4e8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg5e16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg5e32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg5e64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg5e8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg6e16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg6e32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg6e64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg6e8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg7e16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg7e32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg7e64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg7e8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg8e16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg8e32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg8e64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssseg8e8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let load_width_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW = mult_atom(load_width_bytes, 8) in { let EEW_pow = vlewidth_pow_forwards(width) in { let SEW_pow = get_sew_pow() in { let LMUL_pow = get_lmul_pow() in { let EMUL_pow = add_atom(sub_atom(EEW_pow, SEW_pow), LMUL_pow) in { let num_elem = get_num_elem(EMUL_pow, EEW) in { let nf_int = nfields_int_forwards(nf) in { if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem) } } } } } } } } }","description":"TBD"},{"mnemonic":"vssub.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vssub.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vssubu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vssubu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsub.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsub.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxei16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxei32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxei64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxei8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg2ei16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg2ei32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg2ei64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg2ei8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg3ei16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg3ei32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg3ei64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg3ei8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg4ei16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg4ei32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg4ei64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg4ei8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg5ei16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg5ei32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg5ei64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg5ei8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg6ei16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg6ei32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg6ei64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg6ei8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg7ei16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg7ei32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg7ei64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg7ei8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg8ei16.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg8ei32.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg8ei64.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vsuxseg8ei8.v","name":"TBD","operands":[{"name":"vs3","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{ let EEW_index_pow = vlewidth_pow_forwards(width) in { let EEW_index_bytes = vlewidth_bytesnumber_forwards(width) in { let EEW_data_pow = get_sew_pow() in { let EEW_data_bytes = get_sew_bytes() in { let EMUL_data_pow = get_lmul_pow() in { let EMUL_index_pow = add_atom(sub_atom(EEW_index_pow, EEW_data_pow), EMUL_data_pow) in { let num_elem = get_num_elem(EMUL_data_pow, mult_atom(EEW_data_bytes, 8)) in { let nf_int = nfields_int_forwards(nf) in { if illegal_indexed_store(nf_int, mult_atom(EEW_index_bytes, 8), EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL } else (); process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1) } } } } } } } } }","description":"TBD"},{"mnemonic":"vwadd.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwadd.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwadd.wv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwadd.wx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwaddu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwaddu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwaddu.wv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwaddu.wx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwmacc.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_wmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WMVV_VWMACC => add_bits(to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVV_VWMACCU => add_bits(to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs1_val, i)), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVV_VWMACCSU => add_bits(to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs1_val, i)), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwmacc.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_wmvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WMVX_VWMACCU => add_bits(to_bits(SEW_widen, mult_atom(unsigned(rs1_val), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACC => add_bits(to_bits(SEW_widen, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACCUS => add_bits(to_bits(SEW_widen, mult_atom(unsigned(rs1_val), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACCSU => add_bits(to_bits(SEW_widen, mult_atom(signed(rs1_val), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwmaccsu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_wmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WMVV_VWMACC => add_bits(to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVV_VWMACCU => add_bits(to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs1_val, i)), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVV_VWMACCSU => add_bits(to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs1_val, i)), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwmaccsu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_wmvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WMVX_VWMACCU => add_bits(to_bits(SEW_widen, mult_atom(unsigned(rs1_val), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACC => add_bits(to_bits(SEW_widen, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACCUS => add_bits(to_bits(SEW_widen, mult_atom(unsigned(rs1_val), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACCSU => add_bits(to_bits(SEW_widen, mult_atom(signed(rs1_val), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwmaccu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_wmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WMVV_VWMACC => add_bits(to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs1_val, i)), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVV_VWMACCU => add_bits(to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs1_val, i)), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVV_VWMACCSU => add_bits(to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs1_val, i)), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwmaccu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_wmvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WMVX_VWMACCU => add_bits(to_bits(SEW_widen, mult_atom(unsigned(rs1_val), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACC => add_bits(to_bits(SEW_widen, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACCUS => add_bits(to_bits(SEW_widen, mult_atom(unsigned(rs1_val), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACCSU => add_bits(to_bits(SEW_widen, mult_atom(signed(rs1_val), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwmaccus.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_wmvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WMVX_VWMACCU => add_bits(to_bits(SEW_widen, mult_atom(unsigned(rs1_val), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACC => add_bits(to_bits(SEW_widen, mult_atom(signed(rs1_val), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACCUS => add_bits(to_bits(SEW_widen, mult_atom(unsigned(rs1_val), signed(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)), WMVX_VWMACCSU => add_bits(to_bits(SEW_widen, mult_atom(signed(rs1_val), unsigned(plain_vector_access(vs2_val, i)))), plain_vector_access(vd_val, i)) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwmul.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwmul.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwmulsu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwmulsu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwmulu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwmulu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwredsum.vs","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rivvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW_widen) in { if illegal_reduction_widen(SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as \'n = num_elem_vs in { let d as \'d = num_elem_vd in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector(\'d, bits(\'o)) = read_vreg(num_elem_vd, SEW_widen, 0, vd) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector(\'n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits(\'o) = read_single_element(SEW_widen, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let elem : bits(\'o) = match funct6 { IVV_VWREDSUMU => to_bits(SEW_widen, unsigned(plain_vector_access(vs2_val, i))), IVV_VWREDSUM => to_bits(SEW_widen, signed(plain_vector_access(vs2_val, i))) } in { sum = add_bits(sum, elem) } } else () }; write_single_element(SEW_widen, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwredsumu.vs","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rivvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { let num_elem_vs = get_num_elem(LMUL_pow, SEW) in { let num_elem_vd = get_num_elem(0, SEW_widen) in { if illegal_reduction_widen(SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL } else (); if eq_int(unsigned(vl), 0) then return RETIRE_SUCCESS else (); let n as \'n = num_elem_vs in { let d as \'d = num_elem_vd in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem_vs, vm, 0b00000) in { let vd_val : vector(\'d, bits(\'o)) = read_vreg(num_elem_vd, SEW_widen, 0, vd) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2) in { let mask : vector(\'n, bool) = init_masked_source(num_elem_vs, LMUL_pow, vm_val) in { var sum : bits(\'o) = read_single_element(SEW_widen, 0, vs1) in { foreach (i from 0 to sub_atom(num_elem_vs, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { let elem : bits(\'o) = match funct6 { IVV_VWREDSUMU => to_bits(SEW_widen, unsigned(plain_vector_access(vs2_val, i))), IVV_VWREDSUM => to_bits(SEW_widen, signed(plain_vector_access(vs2_val, i))) } in { sum = add_bits(sum, elem) } } else () }; write_single_element(SEW_widen, 0, vd, sum); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwsub.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwsub.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwsub.wv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwsub.wx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwsubu.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), or_bool(not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen)))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WVV_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WVV_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwsubu.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WVX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMUL => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WVX_VWMULU => to_bits(SEW_widen, mult_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WVX_VWMULSU => to_bits(SEW_widen, mult_atom(signed(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwsubu.wv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen), not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WV_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WV_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), WV_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), WV_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vwsubu.wx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_widen = mult_atom(SEW, 2) in { let LMUL_pow_widen = add_atom(LMUL_pow, 1) in { if illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_widen in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2) in { var result : vector(\'n, bits(\'o)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { WX_VADD => to_bits(SEW_widen, add_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WX_VSUB => to_bits(SEW_widen, sub_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), WX_VADDU => to_bits(SEW_widen, add_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), WX_VSUBU => to_bits(SEW_widen, sub_atom(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))) } } else () }; write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vxor.vi","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let imm_val : bits(\'m) = sign_extend(__id(m), simm) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VI_VADD => add_bits(plain_vector_access(vs2_val, i), imm_val), VI_VRSUB => sub_vec(imm_val, plain_vector_access(vs2_val, i)), VI_VAND => and_vec(plain_vector_access(vs2_val, i), imm_val), VI_VOR => or_vec(plain_vector_access(vs2_val, i), imm_val), VI_VXOR => xor_vec(plain_vector_access(vs2_val, i), imm_val), VI_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), imm_val))), VI_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), imm_val))), VI_VSLL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VI_VSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VI_VSSRL => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VI_VSSRA => { let shift_amount = get_shift_amount(zero_extend(__id(m), simm), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vxor.vv","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW_pow = get_sew_pow() in { let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let VLEN_pow = get_vlen_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vs1_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VV_VADD => add_bits(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSUB => sub_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VAND => and_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VOR => or_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VXOR => xor_vec(plain_vector_access(vs2_val, i), plain_vector_access(vs1_val, i)), VV_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i))) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))) }, VV_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), plain_vector_access(vs1_val, i)))), VV_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VV_VSLL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VV_VSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VV_VSSRL => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VV_VSSRA => { let shift_amount = get_shift_amount(plain_vector_access(vs1_val, i), SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VV_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(plain_vector_access(vs1_val, i)))), VV_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(plain_vector_access(vs1_val, i)))), VV_VRGATHER => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let idx = unsigned(plain_vector_access(vs1_val, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:150.48-150.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } }, VV_VRGATHEREI16 => { if or_bool(eq_bits(vs1, vd), eq_bits(vs2, vd)) then { handle_illegal(); return RETIRE_FAIL } else (); let vs1_new : vector(\'n, bits(16)) = read_vreg(num_elem, 16, sub_atom(add_atom(4, LMUL_pow), SEW_pow), vs1) in { let idx = unsigned(plain_vector_access(vs1_new, i)) in { let VLMAX = int_power(2, sub_atom(add_atom(LMUL_pow, VLEN_pow), SEW_pow)) in { assert(lteq_int(VLMAX, __id(n)), \\"model/riscv_insts_vext_arith.sail:159.48-159.49\\"); if lt_int(idx, VLMAX) then plain_vector_access(vs2_val, idx) else zeros_implicit(__id(m)) } } } } } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vxor.vx","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let rs1_val : bits(\'m) = get_scalar(rs1, SEW) in { let vs2_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VX_VADD => add_bits(plain_vector_access(vs2_val, i), rs1_val), VX_VSUB => sub_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VRSUB => sub_vec(rs1_val, plain_vector_access(vs2_val, i)), VX_VAND => and_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VOR => or_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VXOR => xor_vec(plain_vector_access(vs2_val, i), rs1_val), VX_VSADDU => unsigned_saturation(__id(m), add_bits(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))), VX_VSADD => signed_saturation(__id(m), add_bits(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSSUBU => { if lt_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val)) then zeros_implicit(__id(m)) else unsigned_saturation(__id(m), sub_vec(zero_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), zero_extend(add_atom(__id(m), 1), rs1_val))) }, VX_VSSUB => signed_saturation(__id(m), sub_vec(sign_extend(add_atom(__id(m), 1), plain_vector_access(vs2_val, i)), sign_extend(add_atom(__id(m), 1), rs1_val))), VX_VSMUL => { let result_mul = to_bits(mult_atom(__id(m), 2), mult_atom(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) in { let rounding_incr = get_fixed_rounding_incr(result_mul, sub_atom(__id(m), 1)) in { let result_wide = add_bits(shiftr(result_mul, sub_atom(__id(m), 1)), zero_extend(mult_atom(__id(m), 2), rounding_incr)) in { signed_saturation(__id(m), subrange_bits(result_wide, __id(m), 0)) } } } }, VX_VSLL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftl(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { shiftr(plain_vector_access(vs2_val, i), shift_amount) } }, VX_VSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { slice(shiftr(v_double, shift_amount), 0, SEW) } } }, VX_VSSRL => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { add_bits(shiftr(plain_vector_access(vs2_val, i), shift_amount), zero_extend(__id(m), rounding_incr)) } } }, VX_VSSRA => { let shift_amount = get_shift_amount(rs1_val, SEW) in { let rounding_incr = get_fixed_rounding_incr(plain_vector_access(vs2_val, i), shift_amount) in { let v_double : bits((\'m * 2)) = sign_extend(mult_atom(__id(m), 2), plain_vector_access(vs2_val, i)) in { add_bits(slice(shiftr(v_double, shift_amount), 0, SEW), zero_extend(__id(m), rounding_incr)) } } } }, VX_VMINU => to_bits(SEW, min_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMIN => to_bits(SEW, min_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))), VX_VMAXU => to_bits(SEW, max_int(unsigned(plain_vector_access(vs2_val, i)), unsigned(rs1_val))), VX_VMAX => to_bits(SEW, max_int(signed(plain_vector_access(vs2_val, i)), signed(rs1_val))) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vzext.vf2","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vext2_vs1(funct6)","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_half = quot_round_zero(SEW, 2) in { let LMUL_pow_half = sub_atom(LMUL_pow, 1) in { if or_bool(illegal_variable_width(vd, vm, SEW_half, LMUL_pow_half), not(valid_reg_overlap(vs2, vd, LMUL_pow_half, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_half in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_half, LMUL_pow_half, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(gt_int(SEW, SEW_half), \\"model/riscv_insts_vext_arith.sail:1679.23-1679.24\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VEXT2_ZVF2 => zero_extend(__id(m), plain_vector_access(vs2_val, i)), VEXT2_SVF2 => sign_extend(__id(m), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vzext.vf4","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vext4_vs1(funct6)","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_quart = quot_round_zero(SEW, 4) in { let LMUL_pow_quart = sub_atom(LMUL_pow, 2) in { if or_bool(illegal_variable_width(vd, vm, SEW_quart, LMUL_pow_quart), not(valid_reg_overlap(vs2, vd, LMUL_pow_quart, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_quart in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_quart, LMUL_pow_quart, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(gt_int(SEW, SEW_quart), \\"model/riscv_insts_vext_arith.sail:1737.24-1737.25\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VEXT4_ZVF4 => zero_extend(__id(m), plain_vector_access(vs2_val, i)), VEXT4_SVF4 => sign_extend(__id(m), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"vzext.vf8","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vm","type":"bits(1)"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vext8_vs1(funct6)","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{ let SEW = get_sew() in { let LMUL_pow = get_lmul_pow() in { let num_elem = get_num_elem(LMUL_pow, SEW) in { let SEW_eighth = quot_round_zero(SEW, 8) in { let LMUL_pow_eighth = sub_atom(LMUL_pow, 3) in { if or_bool(illegal_variable_width(vd, vm, SEW_eighth, LMUL_pow_eighth), not(valid_reg_overlap(vs2, vd, LMUL_pow_eighth, LMUL_pow))) then { handle_illegal(); return RETIRE_FAIL } else (); let n as \'n = num_elem in { let m as \'m = SEW in { let o as \'o = SEW_eighth in { let vm_val : vector(\'n, bool) = read_vmask(num_elem, vm, 0b00000) in { let vd_val : vector(\'n, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd) in { let vs2_val : vector(\'n, bits(\'o)) = read_vreg(num_elem, SEW_eighth, LMUL_pow_eighth, vs2) in { var result : vector(\'n, bits(\'m)) = undefined in { var mask : vector(\'n, bool) = undefined in { (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val); assert(gt_int(SEW, SEW_eighth), \\"model/riscv_insts_vext_arith.sail:1795.25-1795.26\\"); foreach (i from 0 to sub_atom(num_elem, 1) by 1 order inc) { { if plain_vector_access(mask, i) then { result[i] = match funct6 { VEXT8_ZVF8 => zero_extend(__id(m), plain_vector_access(vs2_val, i)), VEXT8_SVF8 => sign_extend(__id(m), plain_vector_access(vs2_val, i)) } } else () }; write_vreg(num_elem, SEW, LMUL_pow, vd, result); vstart = zeros_implicit(16); RETIRE_SUCCESS } } } } } } } } } } } } } }","description":"TBD"},{"mnemonic":"wfi","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b000100000101","size":12},{"field":"0b00000","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"match cur_privilege { Machine => { platform_wfi(); RETIRE_SUCCESS }, Supervisor => if eq_bits(_get_Mstatus_TW(mstatus), 0b1) then { handle_illegal(); RETIRE_FAIL } else { platform_wfi(); RETIRE_SUCCESS }, User => { handle_illegal(); RETIRE_FAIL } }","description":"TBD"},{"mnemonic":"xnor","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ANDN => and_vec(rs1_val, not_vec(rs2_val)), RISCV_ORN => or_vec(rs1_val, not_vec(rs2_val)), RISCV_XNOR => not_vec(xor_vec(rs1_val, rs2_val)), RISCV_MAX => to_bits(64, max_int(signed(rs1_val), signed(rs2_val))), RISCV_MAXU => to_bits(64, max_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_MIN => to_bits(64, min_int(signed(rs1_val), signed(rs2_val))), RISCV_MINU => to_bits(64, min_int(unsigned(rs1_val), unsigned(rs2_val))), RISCV_ROL => if eq_int(64, 32) then rotate_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_ROR => if eq_int(64, 32) then rotate_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else rotate_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"xor","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { let result : xlenbits = match op { RISCV_ADD => add_bits(rs1_val, rs2_val), RISCV_SLT => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, rs2_val))), RISCV_SLTU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, rs2_val))), RISCV_AND => and_vec(rs1_val, rs2_val), RISCV_OR => or_vec(rs1_val, rs2_val), RISCV_XOR => xor_vec(rs1_val, rs2_val), RISCV_SLL => if eq_int(64, 32) then shift_bits_left(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_left(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SRL => if eq_int(64, 32) then shift_bits_right(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_bits_right(rs1_val, subrange_bits(rs2_val, 5, 0)), RISCV_SUB => sub_vec(rs1_val, rs2_val), RISCV_SRA => if eq_int(64, 32) then shift_right_arith32(rs1_val, subrange_bits(rs2_val, 4, 0)) else shift_right_arith64(rs1_val, subrange_bits(rs2_val, 5, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"xori","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"imm","type":"bits(12)"}],"syntax":"rd,rs1,imm","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"encdec_iop(op)","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{ let rs1_val = rX_bits(rs1) in { let immext : xlenbits = sign_extend(64, imm) in { let result : xlenbits = match op { RISCV_ADDI => add_bits(rs1_val, immext), RISCV_SLTI => zero_extend(64, bool_to_bits((operator <_s)(rs1_val, immext))), RISCV_SLTIU => zero_extend(64, bool_to_bits((operator <_u)(rs1_val, immext))), RISCV_ANDI => and_vec(rs1_val, immext), RISCV_ORI => or_vec(rs1_val, immext), RISCV_XORI => xor_vec(rs1_val, immext) } in { wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"xperm4","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b010","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbkx"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 4) by 4 order inc) { { let index = unsigned(subrange_bits(rs2_val, add_atom(i, 3), i)) in { result[add_atom(i, 3) .. i] = if lt_int(mult_atom(4, index), 64) then subrange_bits(rs1_val, add_atom(mult_atom(4, index), 3), mult_atom(4, index)) else zeros_implicit(add_atom(sub_atom(add_atom(mult_atom(4, __id(index)), 3), mult_atom(4, __id(index))), 1)) } }; wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"xperm8","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbkx"],"function":"{ let rs1_val = rX_bits(rs1) in { let rs2_val = rX_bits(rs2) in { var result : xlenbits = zeros_implicit(64) in { foreach (i from 0 to sub_atom(64, 8) by 8 order inc) { { let index = unsigned(subrange_bits(rs2_val, add_atom(i, 7), i)) in { result[add_atom(i, 7) .. i] = if lt_int(mult_atom(8, index), 64) then subrange_bits(rs1_val, add_atom(mult_atom(8, index), 7), mult_atom(8, index)) else zeros_implicit(add_atom(sub_atom(add_atom(mult_atom(8, __id(index)), 7), mult_atom(8, __id(index))), 1)) } }; wX_bits(rd, result); RETIRE_SUCCESS } } } }","description":"TBD"},{"mnemonic":"zext.h","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b0000100","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zbb"],"function":"{ let rs1_val = rX_bits(rs1) in { let result : xlenbits = match op { RISCV_SEXTB => sign_extend(64, subrange_bits(rs1_val, 7, 0)), RISCV_SEXTH => sign_extend(64, subrange_bits(rs1_val, 15, 0)), RISCV_ZEXTH => zero_extend(64, subrange_bits(rs1_val, 15, 0)) } in { wX_bits(rd, result); RETIRE_SUCCESS } } }","description":"TBD"},{"mnemonic":"zip","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs1","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b000010001111","size":12},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbkb"],"function":"{ assert(eq_int(64, 32), \\"model/riscv_insts_zbkb.sail:127.27-127.28\\"); exit () }","description":"TBD"}],"bd":["I","R","TBD"],"Rw":["C","D","F","V","Zba","Zbb","Zbc","Zbkb","Zbkc","Zbkx","Zbs","Zfa","Zfh","Zicond","Zknd","Zkne","Zknh","Zksed","Zksh"]}'),Gx=t(29),Qx=[];function Jx(e,i,t){Qx.push(e)}var $x=function(e){l(t,e);var i=v(t);function t(e){var _;return s(this,t),(_=i.call(this,e)).genData=function(e){for(var i=[],t=0;t<e.length;t++)(_.state.search_mnemonics&&e[t].mnemonic.startsWith(_.state.search)||_.state.search_names&&_.state.search.split(" ").every(_.matchEach,e[t].name.toLowerCase()))&&_.state.formatSet.includes(e[t].format)&&_.matchAny(e[t].extensions,_.state.extensionSet)&&i.push((0,Yx.jsx)(Zr,{title:_.genTitle(e[t]),children:_.genItem(e[t])},e[t].mnemonic));return i},0==Qx.length&&Kx.bd.forEach(Jx),_.state={data:Kx.NE,extensionSet:Kx.Rw,formatSet:Qx,search:"",search_mnemonics:!0,search_names:!1},_}return n(t,[{key:"displayMnemonic",value:function(e){var i="               ",t=15-e.mnemonic.length;t<2&&(t=2);var _=e.mnemonic+i.substr(0,t)+e.syntax,s="";try{if(e.conditions.length>0){s="(";for(var a="",n=0;n<e.conditions.length;n++)s+=a+e.conditions[n].field+"="+e.conditions[n].value,a=", ";s+=")"}}catch(l){}var r="mnemonics-table-"+e.mnemonic;return(0,Yx.jsx)("table",{children:(0,Yx.jsx)("tbody",{children:(0,Yx.jsxs)("tr",{children:[(0,Yx.jsx)("td",{children:(0,Yx.jsx)(Gx.CopyToClipboard,{text:_,children:(0,Yx.jsx)(kE,{className:"syntax",feedback:"Copied to clipboard",copyButtonDescription:"Copy",ariaLabel:"mnemonic",type:"inline",children:_},"syntax")})}),(0,Yx.jsx)("td",{children:(0,Yx.jsx)("p",{className:"conditions",children:s})})]})})},r)}},{key:"displayField",value:function(e,i){return e.field.startsWith("0b")?e.field.substring(2).split("").map((function(e,t){return(0,Yx.jsx)("td",{className:"instruction-field",colSpan:1,children:e},i+"-"+t)})):(0,Yx.jsx)("td",{className:"instruction-field",colSpan:e.size,children:e.field},i)}},{key:"displayFields",value:function(e){for(var i=[],t=0;t<e.length;t++)i.push(this.displayField(e[t],t));return i}},{key:"displayBitScale",value:function(e,i){for(var t=[],_=i-1;_>=0;_--)t.push((0,Yx.jsx)("td",{className:"instruction-bit-number",children:("0"+_.toString()).slice(-2)},_));return t}},{key:"displayLayoutRows",value:function(e,i){for(var t=[],_=0,s=0,a=0;a<e.length;a++)(_+=parseInt(e[a].size))>=i&&(t.push((0,Yx.jsx)("tr",{children:this.displayFields(e.slice(s,a+1))},s)),s=a+1,_=0);return t}},{key:"displayLayout",value:function(e){for(var i=[],t=0,_=0;_<e.length;_++)t+=parseInt(e[_].size);return t>32&&(t=32),i.push(this.displayLayoutRows(e,t)),i.push((0,Yx.jsx)("tr",{children:this.displayBitScale(e,t)},"bitScale")),i}},{key:"genItem",value:function(e){return(0,Yx.jsx)("div",{className:"expandContainer",children:(0,Yx.jsxs)("div",{className:"column",children:[this.displayMnemonic(e),(0,Yx.jsx)("br",{}),(0,Yx.jsx)("table",{style:{width:"100%"},children:(0,Yx.jsx)("tbody",{children:(0,Yx.jsxs)("tr",{children:[(0,Yx.jsx)("td",{children:(0,Yx.jsx)("table",{className:"instruction-layout",children:(0,Yx.jsx)("tbody",{children:this.displayLayout(e.fields)})})}),(0,Yx.jsxs)("td",{style:{textAlign:"right"},children:[e.format,"-type"]})]})})}),(0,Yx.jsx)("br",{}),(0,Yx.jsx)(Gx.CopyToClipboard,{text:e.function,children:(0,Yx.jsx)(kE,{className:"pseudocode",type:"multi",feedback:"Copied to clipboard",children:(0,Yx.jsx)("p",{className:"inner",children:e.function})},"pseudocode")}),(0,Yx.jsx)("br",{}),(0,Yx.jsx)("div",{className:"prose",children:e.description})]})})}},{key:"genTitle",value:function(e){return(0,Yx.jsx)("table",{className:"item",children:(0,Yx.jsx)("tbody",{children:(0,Yx.jsxs)("tr",{children:[(0,Yx.jsx)("td",{className:"itemtitledesc",children:e.name}),(0,Yx.jsx)("td",{className:"itemtitlemnem",children:e.mnemonic}),(0,Yx.jsx)("td",{className:"itemtitleext",children:e.extensions.join()})]})})})}},{key:"matchEach",value:function(e){return this.includes(e)}},{key:"matchAny",value:function(e,i){var t=document.getElementById("all-extensions");if(!t)return!0;if(0==e.length)return t.checked;if(e.length>0&&0==i.length)return!1;for(var _=0;_<e.length;_++)if(i.includes(e[_]))return!0;return!1}},{key:"genExtensionLabel",value:function(e){return(0,Yx.jsx)("table",{className:"extensionlabel",children:(0,Yx.jsx)("tbody",{children:(0,Yx.jsx)("tr",{children:(0,Yx.jsx)("td",{className:"extensionversion",children:e})})})})}},{key:"genExtensionCheckboxes",value:function(e){for(var i=this,t=[],_=function(_){t.push((0,Yx.jsx)(jr,{defaultChecked:!0,className:"checkbox",id:e[_],labelText:i.genExtensionLabel(e[_]),disabled:!1,hideLabel:!1,onChange:function(t,s,a){i.filterByExtensions(s.checked,e[_])}},e[_]))},s=0;s<e.length;s++)_(s);return t}},{key:"genFormatCheckboxes",value:function(e){for(var i=this,t=[],_=function(_){t.push((0,Yx.jsx)(jr,{defaultChecked:!0,className:"checkbox",id:e[_],labelText:e[_],disabled:!1,hideLabel:!1,onChange:function(t,s,a){i.filterByFormats(s.checked,e[_])}},e[_]))},s=0;s<e.length;s++)_(s);return t}},{key:"search",value:function(){var e=document.getElementById("search-1");this.setState({search:e.value.toLowerCase()})}},{key:"filterAllExtensions",value:function(e){var i=[];e&&(i=Kx.Rw);for(var t=0;t<Kx.Rw.length;t++){document.getElementById(Kx.Rw[t]).checked=e}this.setState({extensionSet:i})}},{key:"filterAllFormats",value:function(e){var i=[];e&&(i=Qx);for(var t=0;t<Qx.length;t++){document.getElementById(Qx[t]).checked=e}this.setState({formatSet:i})}},{key:"filterByExtensions",value:function(e,i){var t=[];if(e)(t=this.state.extensionSet).push(i);else for(var _=0;_<this.state.extensionSet.length;_++)this.state.extensionSet[_]!==i&&t.push(this.state.extensionSet[_]);this.setState({extensionSet:t})}},{key:"filterByFormats",value:function(e,i){var t=[];if(e)(t=this.state.formatSet).push(i);else for(var _=0;_<this.state.formatSet.length;_++)this.state.formatSet[_]!==i&&t.push(this.state.formatSet[_]);this.setState({formatSet:t})}},{key:"genMultiLine",value:function(e,i){var t=[];try{i.split("\n").map((function(e){return t.push(e),t.push((0,Yx.jsx)("br",{}))}))}catch(_){}return t}},{key:"displayOps",value:function(e,i){for(var t="",_="",s=0;s<e.length;s++){e[s].optional[0]-"0"<=i&&(t+=_+e[s].name,_=",")}return t}},{key:"render",value:function(){var e=this;return(0,Yx.jsx)("div",{className:"App",children:(0,Yx.jsx)("div",{"data-floating-menu-container":"true",role:"main",className:"pageContainer",children:(0,Yx.jsxs)("div",{className:"homeContainer",children:[(0,Yx.jsx)(jx,{}),(0,Yx.jsxs)("div",{className:"mainContainer",children:[(0,Yx.jsxs)("div",{className:"filterContainer",children:[(0,Yx.jsx)(K,{children:(0,Yx.jsx)(Zr,{title:"Extensions",children:(0,Yx.jsxs)("fieldset",{className:"checkboxes",children:[(0,Yx.jsx)(jr,{defaultChecked:!0,className:"checkbox",id:"all-extensions",labelText:"[all]",disabled:!1,hideLabel:!1,onChange:function(i,t,_){e.filterAllExtensions(t.checked)}}),this.genExtensionCheckboxes(Kx.Rw)]})})}),(0,Yx.jsx)(K,{children:(0,Yx.jsx)(Zr,{title:"Instruction formats",children:(0,Yx.jsxs)("fieldset",{className:"checkboxes",children:[(0,Yx.jsx)(jr,{defaultChecked:!0,className:"checkbox",id:"all-forms",labelText:"[all]",disabled:!1,hideLabel:!1,onChange:function(i,t,_){e.filterAllFormats(t.checked)}}),this.genFormatCheckboxes(Kx.bd)]})})})]}),(0,Yx.jsxs)("div",{className:"accordianContainer",children:[(0,Yx.jsx)("div",{className:"searchContainer",children:(0,Yx.jsx)("table",{children:(0,Yx.jsx)("tbody",{children:(0,Yx.jsxs)("tr",{children:[(0,Yx.jsx)("td",{style:{width:"50%",justifyContent:"center"},children:(0,Yx.jsx)(px,{className:"some-class",name:"",defaultValue:"",labelText:"Search",closeButtonLabelText:"",placeholder:"Search",onChange:function(){e.search()},id:"search-1"})}),(0,Yx.jsxs)("td",{children:[(0,Yx.jsx)(jr,{defaultChecked:!0,className:"checkbox",id:"search-mnemonics",labelText:"mnemonics",disabled:!1,hideLabel:!1,onChange:function(i,t,_){e.setState({search_mnemonics:t.checked})}}),(0,Yx.jsx)(jr,{className:"checkbox",id:"search-names",labelText:"names",disabled:!1,hideLabel:!1,onChange:function(i,t,_){e.setState({search_names:t.checked})}})]})]})})})}),(0,Yx.jsx)(K,{children:this.genData(this.state.data)})]})]})]})})})}}]),t}(i.Component),ez=$x;_.render((0,Yx.jsx)(i.StrictMode,{children:(0,Yx.jsx)(ez,{})}),document.getElementById("root"))}()}();
//# sourceMappingURL=main.cda53fe5.js.map