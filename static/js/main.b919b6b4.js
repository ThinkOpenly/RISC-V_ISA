/*! For license information please see main.b919b6b4.js.LICENSE.txt */
!function(){var e={694:function(e,n){var t;!function(){"use strict";var i={}.hasOwnProperty;function s(){for(var e=[],n=0;n<arguments.length;n++){var t=arguments[n];if(t){var l=typeof t;if("string"===l||"number"===l)e.push(t);else if(Array.isArray(t)){if(t.length){var r=s.apply(null,t);r&&e.push(r)}}else if("object"===l)if(t.toString===Object.prototype.toString)for(var a in t)i.call(t,a)&&t[a]&&e.push(a);else e.push(t.toString())}}return e.join(" ")}e.exports?(s.default=s,e.exports=s):void 0===(t=function(){return s}.apply(n,[]))||(e.exports=t)}()},998:function(e,n,t){"use strict";var i=t(458),s={"text/plain":"Text","text/html":"Url",default:"Text"};e.exports=function(e,n){var t,l,r,a,d,_,o=!1;n||(n={}),t=n.debug||!1;try{if(r=i(),a=document.createRange(),d=document.getSelection(),(_=document.createElement("span")).textContent=e,_.style.all="unset",_.style.position="fixed",_.style.top=0,_.style.clip="rect(0, 0, 0, 0)",_.style.whiteSpace="pre",_.style.webkitUserSelect="text",_.style.MozUserSelect="text",_.style.msUserSelect="text",_.style.userSelect="text",_.addEventListener("copy",(function(i){if(i.stopPropagation(),n.format)if(i.preventDefault(),"undefined"===typeof i.clipboardData){t&&console.warn("unable to use e.clipboardData"),t&&console.warn("trying IE specific stuff"),window.clipboardData.clearData();var l=s[n.format]||s.default;window.clipboardData.setData(l,e)}else i.clipboardData.clearData(),i.clipboardData.setData(n.format,e);n.onCopy&&(i.preventDefault(),n.onCopy(i.clipboardData))})),document.body.appendChild(_),a.selectNodeContents(_),d.addRange(a),!document.execCommand("copy"))throw new Error("copy command was unsuccessful");o=!0}catch(m){t&&console.error("unable to copy using execCommand: ",m),t&&console.warn("trying IE specific stuff");try{window.clipboardData.setData(n.format||"text",e),n.onCopy&&n.onCopy(window.clipboardData),o=!0}catch(m){t&&console.error("unable to copy using clipboardData: ",m),t&&console.error("falling back to prompt"),l=function(e){var n=(/mac os x/i.test(navigator.userAgent)?"\u2318":"Ctrl")+"+C";return e.replace(/#{\s*key\s*}/g,n)}("message"in n?n.message:"Copy to clipboard: #{key}, Enter"),window.prompt(l,e)}}finally{d&&("function"==typeof d.removeRange?d.removeRange(a):d.removeAllRanges()),_&&document.body.removeChild(_),r()}return o}},95:function(e,n,t){var i=NaN,s="[object Symbol]",l=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,d=/^0o[0-7]+$/i,_=parseInt,o="object"==typeof t.g&&t.g&&t.g.Object===Object&&t.g,m="object"==typeof self&&self&&self.Object===Object&&self,v=o||m||Function("return this")(),f=Object.prototype.toString,u=Math.max,c=Math.min,p=function(){return v.Date.now()};function E(e){var n=typeof e;return!!e&&("object"==n||"function"==n)}function h(e){if("number"==typeof e)return e;if(function(e){return"symbol"==typeof e||function(e){return!!e&&"object"==typeof e}(e)&&f.call(e)==s}(e))return i;if(E(e)){var n="function"==typeof e.valueOf?e.valueOf():e;e=E(n)?n+"":n}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(l,"");var t=a.test(e);return t||d.test(e)?_(e.slice(2),t?2:8):r.test(e)?i:+e}e.exports=function(e,n,t){var i,s,l,r,a,d,_=0,o=!1,m=!1,v=!0;if("function"!=typeof e)throw new TypeError("Expected a function");function f(n){var t=i,l=s;return i=s=void 0,_=n,r=e.apply(l,t)}function g(e){var t=e-d;return void 0===d||t>=n||t<0||m&&e-_>=l}function w(){var e=p();if(g(e))return b(e);a=setTimeout(w,function(e){var t=n-(e-d);return m?c(t,l-(e-_)):t}(e))}function b(e){return a=void 0,v&&i?f(e):(i=s=void 0,r)}function x(){var e=p(),t=g(e);if(i=arguments,s=this,d=e,t){if(void 0===a)return function(e){return _=e,a=setTimeout(w,n),o?f(e):r}(d);if(m)return a=setTimeout(w,n),f(d)}return void 0===a&&(a=setTimeout(w,n)),r}return n=h(n)||0,E(t)&&(o=!!t.leading,l=(m="maxWait"in t)?u(h(t.maxWait)||0,n):l,v="trailing"in t?!!t.trailing:v),x.cancel=function(){void 0!==a&&clearTimeout(a),_=0,i=d=s=a=void 0},x.flush=function(){return void 0===a?r:b(p())},x}},725:function(e){"use strict";var n=Object.getOwnPropertySymbols,t=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;e.exports=function(){try{if(!Object.assign)return!1;var e=new String("abc");if(e[5]="de","5"===Object.getOwnPropertyNames(e)[0])return!1;for(var n={},t=0;t<10;t++)n["_"+String.fromCharCode(t)]=t;if("0123456789"!==Object.getOwnPropertyNames(n).map((function(e){return n[e]})).join(""))return!1;var i={};return"abcdefghijklmnopqrst".split("").forEach((function(e){i[e]=e})),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},i)).join("")}catch(s){return!1}}()?Object.assign:function(e,s){for(var l,r,a=function(e){if(null===e||void 0===e)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(e)}(e),d=1;d<arguments.length;d++){for(var _ in l=Object(arguments[d]))t.call(l,_)&&(a[_]=l[_]);if(n){r=n(l);for(var o=0;o<r.length;o++)i.call(l,r[o])&&(a[r[o]]=l[r[o]])}}return a}},888:function(e,n,t){"use strict";var i=t(47);function s(){}function l(){}l.resetWarningCache=s,e.exports=function(){function e(e,n,t,s,l,r){if(r!==i){var a=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw a.name="Invariant Violation",a}}function n(){return e}e.isRequired=e;var t={array:e,bigint:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:n,element:e,elementType:e,instanceOf:n,node:e,objectOf:n,oneOf:n,oneOfType:n,shape:n,exact:n,checkPropTypes:l,resetWarningCache:s};return t.PropTypes=t,t}},7:function(e,n,t){e.exports=t(888)()},47:function(e){"use strict";e.exports="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"},568:function(e,n,t){"use strict";function i(e){return i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i(e)}Object.defineProperty(n,"__esModule",{value:!0}),n.CopyToClipboard=void 0;var s=a(t(791)),l=a(t(998)),r=["text","onCopy","options","children"];function a(e){return e&&e.__esModule?e:{default:e}}function d(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function _(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?d(Object(t),!0).forEach((function(n){p(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):d(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,i,s=function(e,n){if(null==e)return{};var t,i,s={},l=Object.keys(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}function m(e,n){for(var t=0;t<n.length;t++){var i=n[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function v(e,n){return v=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e},v(e,n)}function f(e){var n=function(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var t,s=c(e);if(n){var l=c(this).constructor;t=Reflect.construct(s,arguments,l)}else t=s.apply(this,arguments);return function(e,n){if(n&&("object"===i(n)||"function"===typeof n))return n;if(void 0!==n)throw new TypeError("Derived constructors may only return object or undefined");return u(e)}(this,t)}}function u(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function c(e){return c=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},c(e)}function p(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}var E=function(e){!function(e,n){if("function"!==typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),n&&v(e,n)}(d,e);var n,t,i,a=f(d);function d(){var e;!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,d);for(var n=arguments.length,t=new Array(n),i=0;i<n;i++)t[i]=arguments[i];return p(u(e=a.call.apply(a,[this].concat(t))),"onClick",(function(n){var t=e.props,i=t.text,r=t.onCopy,a=t.children,d=t.options,_=s.default.Children.only(a),o=(0,l.default)(i,d);r&&r(i,o),_&&_.props&&"function"===typeof _.props.onClick&&_.props.onClick(n)})),e}return n=d,(t=[{key:"render",value:function(){var e=this.props,n=(e.text,e.onCopy,e.options,e.children),t=o(e,r),i=s.default.Children.only(n);return s.default.cloneElement(i,_(_({},t),{},{onClick:this.onClick}))}}])&&m(n.prototype,t),i&&m(n,i),Object.defineProperty(n,"prototype",{writable:!1}),d}(s.default.PureComponent);n.CopyToClipboard=E,p(E,"defaultProps",{onCopy:void 0,options:void 0})},29:function(e,n,t){"use strict";var i=t(568).CopyToClipboard;i.CopyToClipboard=i,e.exports=i},463:function(e,n,t){"use strict";var i=t(791),s=t(725),l=t(296);function r(e){for(var n="https://reactjs.org/docs/error-decoder.html?invariant="+e,t=1;t<arguments.length;t++)n+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+e+"; visit "+n+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!i)throw Error(r(227));var a=new Set,d={};function _(e,n){o(e,n),o(e+"Capture",n)}function o(e,n){for(d[e]=n,e=0;e<n.length;e++)a.add(n[e])}var m=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),v=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,f=Object.prototype.hasOwnProperty,u={},c={};function p(e,n,t,i,s,l,r){this.acceptsBooleans=2===n||3===n||4===n,this.attributeName=i,this.attributeNamespace=s,this.mustUseProperty=t,this.propertyName=e,this.type=n,this.sanitizeURL=l,this.removeEmptyString=r}var E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){E[e]=new p(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var n=e[0];E[n]=new p(n,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){E[e]=new p(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){E[e]=new p(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){E[e]=new p(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){E[e]=new p(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){E[e]=new p(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){E[e]=new p(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){E[e]=new p(e,5,!1,e.toLowerCase(),null,!1,!1)}));var h=/[\-:]([a-z])/g;function g(e){return e[1].toUpperCase()}function w(e,n,t,i){var s=E.hasOwnProperty(n)?E[n]:null;(null!==s?0===s.type:!i&&(2<n.length&&("o"===n[0]||"O"===n[0])&&("n"===n[1]||"N"===n[1])))||(function(e,n,t,i){if(null===n||"undefined"===typeof n||function(e,n,t,i){if(null!==t&&0===t.type)return!1;switch(typeof n){case"function":case"symbol":return!0;case"boolean":return!i&&(null!==t?!t.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,n,t,i))return!0;if(i)return!1;if(null!==t)switch(t.type){case 3:return!n;case 4:return!1===n;case 5:return isNaN(n);case 6:return isNaN(n)||1>n}return!1}(n,t,s,i)&&(t=null),i||null===s?function(e){return!!f.call(c,e)||!f.call(u,e)&&(v.test(e)?c[e]=!0:(u[e]=!0,!1))}(n)&&(null===t?e.removeAttribute(n):e.setAttribute(n,""+t)):s.mustUseProperty?e[s.propertyName]=null===t?3!==s.type&&"":t:(n=s.attributeName,i=s.attributeNamespace,null===t?e.removeAttribute(n):(t=3===(s=s.type)||4===s&&!0===t?"":""+t,i?e.setAttributeNS(i,n,t):e.setAttribute(n,t))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var n=e.replace(h,g);E[n]=new p(n,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var n=e.replace(h,g);E[n]=new p(n,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var n=e.replace(h,g);E[n]=new p(n,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){E[e]=new p(e,1,!1,e.toLowerCase(),null,!1,!1)})),E.xlinkHref=new p("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){E[e]=new p(e,1,!1,e.toLowerCase(),null,!0,!0)}));var b=i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,x=60103,z=60106,L=60107,M=60108,y=60114,R=60109,S=60110,A=60112,D=60113,V=60120,T=60115,W=60116,U=60121,I=60128,B=60129,O=60130,F=60131;if("function"===typeof Symbol&&Symbol.for){var X=Symbol.for;x=X("react.element"),z=X("react.portal"),L=X("react.fragment"),M=X("react.strict_mode"),y=X("react.profiler"),R=X("react.provider"),S=X("react.context"),A=X("react.forward_ref"),D=X("react.suspense"),V=X("react.suspense_list"),T=X("react.memo"),W=X("react.lazy"),U=X("react.block"),X("react.scope"),I=X("react.opaque.id"),B=X("react.debug_trace_mode"),O=X("react.offscreen"),F=X("react.legacy_hidden")}var C,q="function"===typeof Symbol&&Symbol.iterator;function H(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=q&&e[q]||e["@@iterator"])?e:null}function k(e){if(void 0===C)try{throw Error()}catch(t){var n=t.stack.trim().match(/\n( *(at )?)/);C=n&&n[1]||""}return"\n"+C+e}var N=!1;function Y(e,n){if(!e||N)return"";N=!0;var t=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(n)if(n=function(){throw Error()},Object.defineProperty(n.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(n,[])}catch(d){var i=d}Reflect.construct(e,[],n)}else{try{n.call()}catch(d){i=d}e.call(n.prototype)}else{try{throw Error()}catch(d){i=d}e()}}catch(d){if(d&&i&&"string"===typeof d.stack){for(var s=d.stack.split("\n"),l=i.stack.split("\n"),r=s.length-1,a=l.length-1;1<=r&&0<=a&&s[r]!==l[a];)a--;for(;1<=r&&0<=a;r--,a--)if(s[r]!==l[a]){if(1!==r||1!==a)do{if(r--,0>--a||s[r]!==l[a])return"\n"+s[r].replace(" at new "," at ")}while(1<=r&&0<=a);break}}}finally{N=!1,Error.prepareStackTrace=t}return(e=e?e.displayName||e.name:"")?k(e):""}function Z(e){switch(e.tag){case 5:return k(e.type);case 16:return k("Lazy");case 13:return k("Suspense");case 19:return k("SuspenseList");case 0:case 2:case 15:return e=Y(e.type,!1);case 11:return e=Y(e.type.render,!1);case 22:return e=Y(e.type._render,!1);case 1:return e=Y(e.type,!0);default:return""}}function P(e){if(null==e)return null;if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case L:return"Fragment";case z:return"Portal";case y:return"Profiler";case M:return"StrictMode";case D:return"Suspense";case V:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case S:return(e.displayName||"Context")+".Consumer";case R:return(e._context.displayName||"Context")+".Provider";case A:var n=e.render;return n=n.displayName||n.name||"",e.displayName||(""!==n?"ForwardRef("+n+")":"ForwardRef");case T:return P(e.type);case U:return P(e._render);case W:n=e._payload,e=e._init;try{return P(e(n))}catch(t){}}return null}function G(e){switch(typeof e){case"boolean":case"number":case"object":case"string":case"undefined":return e;default:return""}}function j(e){var n=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===n||"radio"===n)}function K(e){e._valueTracker||(e._valueTracker=function(e){var n=j(e)?"checked":"value",t=Object.getOwnPropertyDescriptor(e.constructor.prototype,n),i=""+e[n];if(!e.hasOwnProperty(n)&&"undefined"!==typeof t&&"function"===typeof t.get&&"function"===typeof t.set){var s=t.get,l=t.set;return Object.defineProperty(e,n,{configurable:!0,get:function(){return s.call(this)},set:function(e){i=""+e,l.call(this,e)}}),Object.defineProperty(e,n,{enumerable:t.enumerable}),{getValue:function(){return i},setValue:function(e){i=""+e},stopTracking:function(){e._valueTracker=null,delete e[n]}}}}(e))}function Q(e){if(!e)return!1;var n=e._valueTracker;if(!n)return!0;var t=n.getValue(),i="";return e&&(i=j(e)?e.checked?"true":"false":e.value),(e=i)!==t&&(n.setValue(e),!0)}function J(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(n){return e.body}}function $(e,n){var t=n.checked;return s({},n,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=t?t:e._wrapperState.initialChecked})}function ee(e,n){var t=null==n.defaultValue?"":n.defaultValue,i=null!=n.checked?n.checked:n.defaultChecked;t=G(null!=n.value?n.value:t),e._wrapperState={initialChecked:i,initialValue:t,controlled:"checkbox"===n.type||"radio"===n.type?null!=n.checked:null!=n.value}}function ne(e,n){null!=(n=n.checked)&&w(e,"checked",n,!1)}function te(e,n){ne(e,n);var t=G(n.value),i=n.type;if(null!=t)"number"===i?(0===t&&""===e.value||e.value!=t)&&(e.value=""+t):e.value!==""+t&&(e.value=""+t);else if("submit"===i||"reset"===i)return void e.removeAttribute("value");n.hasOwnProperty("value")?se(e,n.type,t):n.hasOwnProperty("defaultValue")&&se(e,n.type,G(n.defaultValue)),null==n.checked&&null!=n.defaultChecked&&(e.defaultChecked=!!n.defaultChecked)}function ie(e,n,t){if(n.hasOwnProperty("value")||n.hasOwnProperty("defaultValue")){var i=n.type;if(!("submit"!==i&&"reset"!==i||void 0!==n.value&&null!==n.value))return;n=""+e._wrapperState.initialValue,t||n===e.value||(e.value=n),e.defaultValue=n}""!==(t=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==t&&(e.name=t)}function se(e,n,t){"number"===n&&J(e.ownerDocument)===e||(null==t?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+t&&(e.defaultValue=""+t))}function le(e,n){return e=s({children:void 0},n),(n=function(e){var n="";return i.Children.forEach(e,(function(e){null!=e&&(n+=e)})),n}(n.children))&&(e.children=n),e}function re(e,n,t,i){if(e=e.options,n){n={};for(var s=0;s<t.length;s++)n["$"+t[s]]=!0;for(t=0;t<e.length;t++)s=n.hasOwnProperty("$"+e[t].value),e[t].selected!==s&&(e[t].selected=s),s&&i&&(e[t].defaultSelected=!0)}else{for(t=""+G(t),n=null,s=0;s<e.length;s++){if(e[s].value===t)return e[s].selected=!0,void(i&&(e[s].defaultSelected=!0));null!==n||e[s].disabled||(n=e[s])}null!==n&&(n.selected=!0)}}function ae(e,n){if(null!=n.dangerouslySetInnerHTML)throw Error(r(91));return s({},n,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function de(e,n){var t=n.value;if(null==t){if(t=n.children,n=n.defaultValue,null!=t){if(null!=n)throw Error(r(92));if(Array.isArray(t)){if(!(1>=t.length))throw Error(r(93));t=t[0]}n=t}null==n&&(n=""),t=n}e._wrapperState={initialValue:G(t)}}function _e(e,n){var t=G(n.value),i=G(n.defaultValue);null!=t&&((t=""+t)!==e.value&&(e.value=t),null==n.defaultValue&&e.defaultValue!==t&&(e.defaultValue=t)),null!=i&&(e.defaultValue=""+i)}function oe(e){var n=e.textContent;n===e._wrapperState.initialValue&&""!==n&&null!==n&&(e.value=n)}var me={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};function ve(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function fe(e,n){return null==e||"http://www.w3.org/1999/xhtml"===e?ve(n):"http://www.w3.org/2000/svg"===e&&"foreignObject"===n?"http://www.w3.org/1999/xhtml":e}var ue,ce,pe=(ce=function(e,n){if(e.namespaceURI!==me.svg||"innerHTML"in e)e.innerHTML=n;else{for((ue=ue||document.createElement("div")).innerHTML="<svg>"+n.valueOf().toString()+"</svg>",n=ue.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;n.firstChild;)e.appendChild(n.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,n,t,i){MSApp.execUnsafeLocalFunction((function(){return ce(e,n)}))}:ce);function Ee(e,n){if(n){var t=e.firstChild;if(t&&t===e.lastChild&&3===t.nodeType)return void(t.nodeValue=n)}e.textContent=n}var he={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},ge=["Webkit","ms","Moz","O"];function we(e,n,t){return null==n||"boolean"===typeof n||""===n?"":t||"number"!==typeof n||0===n||he.hasOwnProperty(e)&&he[e]?(""+n).trim():n+"px"}function be(e,n){for(var t in e=e.style,n)if(n.hasOwnProperty(t)){var i=0===t.indexOf("--"),s=we(t,n[t],i);"float"===t&&(t="cssFloat"),i?e.setProperty(t,s):e[t]=s}}Object.keys(he).forEach((function(e){ge.forEach((function(n){n=n+e.charAt(0).toUpperCase()+e.substring(1),he[n]=he[e]}))}));var xe=s({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function ze(e,n){if(n){if(xe[e]&&(null!=n.children||null!=n.dangerouslySetInnerHTML))throw Error(r(137,e));if(null!=n.dangerouslySetInnerHTML){if(null!=n.children)throw Error(r(60));if("object"!==typeof n.dangerouslySetInnerHTML||!("__html"in n.dangerouslySetInnerHTML))throw Error(r(61))}if(null!=n.style&&"object"!==typeof n.style)throw Error(r(62))}}function Le(e,n){if(-1===e.indexOf("-"))return"string"===typeof n.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}function Me(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var ye=null,Re=null,Se=null;function Ae(e){if(e=ts(e)){if("function"!==typeof ye)throw Error(r(280));var n=e.stateNode;n&&(n=ss(n),ye(e.stateNode,e.type,n))}}function De(e){Re?Se?Se.push(e):Se=[e]:Re=e}function Ve(){if(Re){var e=Re,n=Se;if(Se=Re=null,Ae(e),n)for(e=0;e<n.length;e++)Ae(n[e])}}function Te(e,n){return e(n)}function We(e,n,t,i,s){return e(n,t,i,s)}function Ue(){}var Ie=Te,Be=!1,Oe=!1;function Fe(){null===Re&&null===Se||(Ue(),Ve())}function Xe(e,n){var t=e.stateNode;if(null===t)return null;var i=ss(t);if(null===i)return null;t=i[n];e:switch(n){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(i=!i.disabled)||(i=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!i;break e;default:e=!1}if(e)return null;if(t&&"function"!==typeof t)throw Error(r(231,n,typeof t));return t}var Ce=!1;if(m)try{var qe={};Object.defineProperty(qe,"passive",{get:function(){Ce=!0}}),window.addEventListener("test",qe,qe),window.removeEventListener("test",qe,qe)}catch(ce){Ce=!1}function He(e,n,t,i,s,l,r,a,d){var _=Array.prototype.slice.call(arguments,3);try{n.apply(t,_)}catch(o){this.onError(o)}}var ke=!1,Ne=null,Ye=!1,Ze=null,Pe={onError:function(e){ke=!0,Ne=e}};function Ge(e,n,t,i,s,l,r,a,d){ke=!1,Ne=null,He.apply(Pe,arguments)}function je(e){var n=e,t=e;if(e.alternate)for(;n.return;)n=n.return;else{e=n;do{0!==(1026&(n=e).flags)&&(t=n.return),e=n.return}while(e)}return 3===n.tag?t:null}function Ke(e){if(13===e.tag){var n=e.memoizedState;if(null===n&&(null!==(e=e.alternate)&&(n=e.memoizedState)),null!==n)return n.dehydrated}return null}function Qe(e){if(je(e)!==e)throw Error(r(188))}function Je(e){if(e=function(e){var n=e.alternate;if(!n){if(null===(n=je(e)))throw Error(r(188));return n!==e?null:e}for(var t=e,i=n;;){var s=t.return;if(null===s)break;var l=s.alternate;if(null===l){if(null!==(i=s.return)){t=i;continue}break}if(s.child===l.child){for(l=s.child;l;){if(l===t)return Qe(s),e;if(l===i)return Qe(s),n;l=l.sibling}throw Error(r(188))}if(t.return!==i.return)t=s,i=l;else{for(var a=!1,d=s.child;d;){if(d===t){a=!0,t=s,i=l;break}if(d===i){a=!0,i=s,t=l;break}d=d.sibling}if(!a){for(d=l.child;d;){if(d===t){a=!0,t=l,i=s;break}if(d===i){a=!0,i=l,t=s;break}d=d.sibling}if(!a)throw Error(r(189))}}if(t.alternate!==i)throw Error(r(190))}if(3!==t.tag)throw Error(r(188));return t.stateNode.current===t?e:n}(e),!e)return null;for(var n=e;;){if(5===n.tag||6===n.tag)return n;if(n.child)n.child.return=n,n=n.child;else{if(n===e)break;for(;!n.sibling;){if(!n.return||n.return===e)return null;n=n.return}n.sibling.return=n.return,n=n.sibling}}return null}function $e(e,n){for(var t=e.alternate;null!==n;){if(n===e||n===t)return!0;n=n.return}return!1}var en,nn,tn,sn,ln=!1,rn=[],an=null,dn=null,_n=null,on=new Map,mn=new Map,vn=[],fn="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function un(e,n,t,i,s){return{blockedOn:e,domEventName:n,eventSystemFlags:16|t,nativeEvent:s,targetContainers:[i]}}function cn(e,n){switch(e){case"focusin":case"focusout":an=null;break;case"dragenter":case"dragleave":dn=null;break;case"mouseover":case"mouseout":_n=null;break;case"pointerover":case"pointerout":on.delete(n.pointerId);break;case"gotpointercapture":case"lostpointercapture":mn.delete(n.pointerId)}}function pn(e,n,t,i,s,l){return null===e||e.nativeEvent!==l?(e=un(n,t,i,s,l),null!==n&&(null!==(n=ts(n))&&nn(n)),e):(e.eventSystemFlags|=i,n=e.targetContainers,null!==s&&-1===n.indexOf(s)&&n.push(s),e)}function En(e){var n=ns(e.target);if(null!==n){var t=je(n);if(null!==t)if(13===(n=t.tag)){if(null!==(n=Ke(t)))return e.blockedOn=n,void sn(e.lanePriority,(function(){l.unstable_runWithPriority(e.priority,(function(){tn(t)}))}))}else if(3===n&&t.stateNode.hydrate)return void(e.blockedOn=3===t.tag?t.stateNode.containerInfo:null)}e.blockedOn=null}function hn(e){if(null!==e.blockedOn)return!1;for(var n=e.targetContainers;0<n.length;){var t=$n(e.domEventName,e.eventSystemFlags,n[0],e.nativeEvent);if(null!==t)return null!==(n=ts(t))&&nn(n),e.blockedOn=t,!1;n.shift()}return!0}function gn(e,n,t){hn(e)&&t.delete(n)}function wn(){for(ln=!1;0<rn.length;){var e=rn[0];if(null!==e.blockedOn){null!==(e=ts(e.blockedOn))&&en(e);break}for(var n=e.targetContainers;0<n.length;){var t=$n(e.domEventName,e.eventSystemFlags,n[0],e.nativeEvent);if(null!==t){e.blockedOn=t;break}n.shift()}null===e.blockedOn&&rn.shift()}null!==an&&hn(an)&&(an=null),null!==dn&&hn(dn)&&(dn=null),null!==_n&&hn(_n)&&(_n=null),on.forEach(gn),mn.forEach(gn)}function bn(e,n){e.blockedOn===n&&(e.blockedOn=null,ln||(ln=!0,l.unstable_scheduleCallback(l.unstable_NormalPriority,wn)))}function xn(e){function n(n){return bn(n,e)}if(0<rn.length){bn(rn[0],e);for(var t=1;t<rn.length;t++){var i=rn[t];i.blockedOn===e&&(i.blockedOn=null)}}for(null!==an&&bn(an,e),null!==dn&&bn(dn,e),null!==_n&&bn(_n,e),on.forEach(n),mn.forEach(n),t=0;t<vn.length;t++)(i=vn[t]).blockedOn===e&&(i.blockedOn=null);for(;0<vn.length&&null===(t=vn[0]).blockedOn;)En(t),null===t.blockedOn&&vn.shift()}function zn(e,n){var t={};return t[e.toLowerCase()]=n.toLowerCase(),t["Webkit"+e]="webkit"+n,t["Moz"+e]="moz"+n,t}var Ln={animationend:zn("Animation","AnimationEnd"),animationiteration:zn("Animation","AnimationIteration"),animationstart:zn("Animation","AnimationStart"),transitionend:zn("Transition","TransitionEnd")},Mn={},yn={};function Rn(e){if(Mn[e])return Mn[e];if(!Ln[e])return e;var n,t=Ln[e];for(n in t)if(t.hasOwnProperty(n)&&n in yn)return Mn[e]=t[n];return e}m&&(yn=document.createElement("div").style,"AnimationEvent"in window||(delete Ln.animationend.animation,delete Ln.animationiteration.animation,delete Ln.animationstart.animation),"TransitionEvent"in window||delete Ln.transitionend.transition);var Sn=Rn("animationend"),An=Rn("animationiteration"),Dn=Rn("animationstart"),Vn=Rn("transitionend"),Tn=new Map,Wn=new Map,Un=["abort","abort",Sn,"animationEnd",An,"animationIteration",Dn,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",Vn,"transitionEnd","waiting","waiting"];function In(e,n){for(var t=0;t<e.length;t+=2){var i=e[t],s=e[t+1];s="on"+(s[0].toUpperCase()+s.slice(1)),Wn.set(i,n),Tn.set(i,s),_(s,[i])}}(0,l.unstable_now)();var Bn=8;function On(e){if(0!==(1&e))return Bn=15,1;if(0!==(2&e))return Bn=14,2;if(0!==(4&e))return Bn=13,4;var n=24&e;return 0!==n?(Bn=12,n):0!==(32&e)?(Bn=11,32):0!==(n=192&e)?(Bn=10,n):0!==(256&e)?(Bn=9,256):0!==(n=3584&e)?(Bn=8,n):0!==(4096&e)?(Bn=7,4096):0!==(n=4186112&e)?(Bn=6,n):0!==(n=62914560&e)?(Bn=5,n):67108864&e?(Bn=4,67108864):0!==(134217728&e)?(Bn=3,134217728):0!==(n=805306368&e)?(Bn=2,n):0!==(1073741824&e)?(Bn=1,1073741824):(Bn=8,e)}function Fn(e,n){var t=e.pendingLanes;if(0===t)return Bn=0;var i=0,s=0,l=e.expiredLanes,r=e.suspendedLanes,a=e.pingedLanes;if(0!==l)i=l,s=Bn=15;else if(0!==(l=134217727&t)){var d=l&~r;0!==d?(i=On(d),s=Bn):0!==(a&=l)&&(i=On(a),s=Bn)}else 0!==(l=t&~r)?(i=On(l),s=Bn):0!==a&&(i=On(a),s=Bn);if(0===i)return 0;if(i=t&((0>(i=31-Nn(i))?0:1<<i)<<1)-1,0!==n&&n!==i&&0===(n&r)){if(On(n),s<=Bn)return n;Bn=s}if(0!==(n=e.entangledLanes))for(e=e.entanglements,n&=i;0<n;)s=1<<(t=31-Nn(n)),i|=e[t],n&=~s;return i}function Xn(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function Cn(e,n){switch(e){case 15:return 1;case 14:return 2;case 12:return 0===(e=qn(24&~n))?Cn(10,n):e;case 10:return 0===(e=qn(192&~n))?Cn(8,n):e;case 8:return 0===(e=qn(3584&~n))&&(0===(e=qn(4186112&~n))&&(e=512)),e;case 2:return 0===(n=qn(805306368&~n))&&(n=268435456),n}throw Error(r(358,e))}function qn(e){return e&-e}function Hn(e){for(var n=[],t=0;31>t;t++)n.push(e);return n}function kn(e,n,t){e.pendingLanes|=n;var i=n-1;e.suspendedLanes&=i,e.pingedLanes&=i,(e=e.eventTimes)[n=31-Nn(n)]=t}var Nn=Math.clz32?Math.clz32:function(e){return 0===e?32:31-(Yn(e)/Zn|0)|0},Yn=Math.log,Zn=Math.LN2;var Pn=l.unstable_UserBlockingPriority,Gn=l.unstable_runWithPriority,jn=!0;function Kn(e,n,t,i){Be||Ue();var s=Jn,l=Be;Be=!0;try{We(s,e,n,t,i)}finally{(Be=l)||Fe()}}function Qn(e,n,t,i){Gn(Pn,Jn.bind(null,e,n,t,i))}function Jn(e,n,t,i){var s;if(jn)if((s=0===(4&n))&&0<rn.length&&-1<fn.indexOf(e))e=un(null,e,n,t,i),rn.push(e);else{var l=$n(e,n,t,i);if(null===l)s&&cn(e,i);else{if(s){if(-1<fn.indexOf(e))return e=un(l,e,n,t,i),void rn.push(e);if(function(e,n,t,i,s){switch(n){case"focusin":return an=pn(an,e,n,t,i,s),!0;case"dragenter":return dn=pn(dn,e,n,t,i,s),!0;case"mouseover":return _n=pn(_n,e,n,t,i,s),!0;case"pointerover":var l=s.pointerId;return on.set(l,pn(on.get(l)||null,e,n,t,i,s)),!0;case"gotpointercapture":return l=s.pointerId,mn.set(l,pn(mn.get(l)||null,e,n,t,i,s)),!0}return!1}(l,e,n,t,i))return;cn(e,i)}Ui(e,n,i,null,t)}}}function $n(e,n,t,i){var s=Me(i);if(null!==(s=ns(s))){var l=je(s);if(null===l)s=null;else{var r=l.tag;if(13===r){if(null!==(s=Ke(l)))return s;s=null}else if(3===r){if(l.stateNode.hydrate)return 3===l.tag?l.stateNode.containerInfo:null;s=null}else l!==s&&(s=null)}}return Ui(e,n,i,s,t),null}var et=null,nt=null,tt=null;function it(){if(tt)return tt;var e,n,t=nt,i=t.length,s="value"in et?et.value:et.textContent,l=s.length;for(e=0;e<i&&t[e]===s[e];e++);var r=i-e;for(n=1;n<=r&&t[i-n]===s[l-n];n++);return tt=s.slice(e,1<n?1-n:void 0)}function st(e){var n=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===n&&(e=13):e=n,10===e&&(e=13),32<=e||13===e?e:0}function lt(){return!0}function rt(){return!1}function at(e){function n(n,t,i,s,l){for(var r in this._reactName=n,this._targetInst=i,this.type=t,this.nativeEvent=s,this.target=l,this.currentTarget=null,e)e.hasOwnProperty(r)&&(n=e[r],this[r]=n?n(s):s[r]);return this.isDefaultPrevented=(null!=s.defaultPrevented?s.defaultPrevented:!1===s.returnValue)?lt:rt,this.isPropagationStopped=rt,this}return s(n.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=lt)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=lt)},persist:function(){},isPersistent:lt}),n}var dt,_t,ot,mt={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},vt=at(mt),ft=s({},mt,{view:0,detail:0}),ut=at(ft),ct=s({},ft,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Rt,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==ot&&(ot&&"mousemove"===e.type?(dt=e.screenX-ot.screenX,_t=e.screenY-ot.screenY):_t=dt=0,ot=e),dt)},movementY:function(e){return"movementY"in e?e.movementY:_t}}),pt=at(ct),Et=at(s({},ct,{dataTransfer:0})),ht=at(s({},ft,{relatedTarget:0})),gt=at(s({},mt,{animationName:0,elapsedTime:0,pseudoElement:0})),wt=s({},mt,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),bt=at(wt),xt=at(s({},mt,{data:0})),zt={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Lt={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Mt={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function yt(e){var n=this.nativeEvent;return n.getModifierState?n.getModifierState(e):!!(e=Mt[e])&&!!n[e]}function Rt(){return yt}var St=s({},ft,{key:function(e){if(e.key){var n=zt[e.key]||e.key;if("Unidentified"!==n)return n}return"keypress"===e.type?13===(e=st(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?Lt[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Rt,charCode:function(e){return"keypress"===e.type?st(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?st(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),At=at(St),Dt=at(s({},ct,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Vt=at(s({},ft,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Rt})),Tt=at(s({},mt,{propertyName:0,elapsedTime:0,pseudoElement:0})),Wt=s({},ct,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Ut=at(Wt),It=[9,13,27,32],Bt=m&&"CompositionEvent"in window,Ot=null;m&&"documentMode"in document&&(Ot=document.documentMode);var Ft=m&&"TextEvent"in window&&!Ot,Xt=m&&(!Bt||Ot&&8<Ot&&11>=Ot),Ct=String.fromCharCode(32),qt=!1;function Ht(e,n){switch(e){case"keyup":return-1!==It.indexOf(n.keyCode);case"keydown":return 229!==n.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function kt(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var Nt=!1;var Yt={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Zt(e){var n=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===n?!!Yt[e.type]:"textarea"===n}function Pt(e,n,t,i){De(i),0<(n=Bi(n,"onChange")).length&&(t=new vt("onChange","change",null,t,i),e.push({event:t,listeners:n}))}var Gt=null,jt=null;function Kt(e){Si(e,0)}function Qt(e){if(Q(is(e)))return e}function Jt(e,n){if("change"===e)return n}var $t=!1;if(m){var ei;if(m){var ni="oninput"in document;if(!ni){var ti=document.createElement("div");ti.setAttribute("oninput","return;"),ni="function"===typeof ti.oninput}ei=ni}else ei=!1;$t=ei&&(!document.documentMode||9<document.documentMode)}function ii(){Gt&&(Gt.detachEvent("onpropertychange",si),jt=Gt=null)}function si(e){if("value"===e.propertyName&&Qt(jt)){var n=[];if(Pt(n,jt,e,Me(e)),e=Kt,Be)e(n);else{Be=!0;try{Te(e,n)}finally{Be=!1,Fe()}}}}function li(e,n,t){"focusin"===e?(ii(),jt=t,(Gt=n).attachEvent("onpropertychange",si)):"focusout"===e&&ii()}function ri(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Qt(jt)}function ai(e,n){if("click"===e)return Qt(n)}function di(e,n){if("input"===e||"change"===e)return Qt(n)}var _i="function"===typeof Object.is?Object.is:function(e,n){return e===n&&(0!==e||1/e===1/n)||e!==e&&n!==n},oi=Object.prototype.hasOwnProperty;function mi(e,n){if(_i(e,n))return!0;if("object"!==typeof e||null===e||"object"!==typeof n||null===n)return!1;var t=Object.keys(e),i=Object.keys(n);if(t.length!==i.length)return!1;for(i=0;i<t.length;i++)if(!oi.call(n,t[i])||!_i(e[t[i]],n[t[i]]))return!1;return!0}function vi(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function fi(e,n){var t,i=vi(e);for(e=0;i;){if(3===i.nodeType){if(t=e+i.textContent.length,e<=n&&t>=n)return{node:i,offset:n-e};e=t}e:{for(;i;){if(i.nextSibling){i=i.nextSibling;break e}i=i.parentNode}i=void 0}i=vi(i)}}function ui(e,n){return!(!e||!n)&&(e===n||(!e||3!==e.nodeType)&&(n&&3===n.nodeType?ui(e,n.parentNode):"contains"in e?e.contains(n):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(n))))}function ci(){for(var e=window,n=J();n instanceof e.HTMLIFrameElement;){try{var t="string"===typeof n.contentWindow.location.href}catch(i){t=!1}if(!t)break;n=J((e=n.contentWindow).document)}return n}function pi(e){var n=e&&e.nodeName&&e.nodeName.toLowerCase();return n&&("input"===n&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===n||"true"===e.contentEditable)}var Ei=m&&"documentMode"in document&&11>=document.documentMode,hi=null,gi=null,wi=null,bi=!1;function xi(e,n,t){var i=t.window===t?t.document:9===t.nodeType?t:t.ownerDocument;bi||null==hi||hi!==J(i)||("selectionStart"in(i=hi)&&pi(i)?i={start:i.selectionStart,end:i.selectionEnd}:i={anchorNode:(i=(i.ownerDocument&&i.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:i.anchorOffset,focusNode:i.focusNode,focusOffset:i.focusOffset},wi&&mi(wi,i)||(wi=i,0<(i=Bi(gi,"onSelect")).length&&(n=new vt("onSelect","select",null,n,t),e.push({event:n,listeners:i}),n.target=hi)))}In("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),0),In("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1),In(Un,2);for(var zi="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),Li=0;Li<zi.length;Li++)Wn.set(zi[Li],0);o("onMouseEnter",["mouseout","mouseover"]),o("onMouseLeave",["mouseout","mouseover"]),o("onPointerEnter",["pointerout","pointerover"]),o("onPointerLeave",["pointerout","pointerover"]),_("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),_("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),_("onBeforeInput",["compositionend","keypress","textInput","paste"]),_("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),_("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),_("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Mi="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),yi=new Set("cancel close invalid load scroll toggle".split(" ").concat(Mi));function Ri(e,n,t){var i=e.type||"unknown-event";e.currentTarget=t,function(e,n,t,i,s,l,a,d,_){if(Ge.apply(this,arguments),ke){if(!ke)throw Error(r(198));var o=Ne;ke=!1,Ne=null,Ye||(Ye=!0,Ze=o)}}(i,n,void 0,e),e.currentTarget=null}function Si(e,n){n=0!==(4&n);for(var t=0;t<e.length;t++){var i=e[t],s=i.event;i=i.listeners;e:{var l=void 0;if(n)for(var r=i.length-1;0<=r;r--){var a=i[r],d=a.instance,_=a.currentTarget;if(a=a.listener,d!==l&&s.isPropagationStopped())break e;Ri(s,a,_),l=d}else for(r=0;r<i.length;r++){if(d=(a=i[r]).instance,_=a.currentTarget,a=a.listener,d!==l&&s.isPropagationStopped())break e;Ri(s,a,_),l=d}}}if(Ye)throw e=Ze,Ye=!1,Ze=null,e}function Ai(e,n){var t=ls(n),i=e+"__bubble";t.has(i)||(Wi(n,e,2,!1),t.add(i))}var Di="_reactListening"+Math.random().toString(36).slice(2);function Vi(e){e[Di]||(e[Di]=!0,a.forEach((function(n){yi.has(n)||Ti(n,!1,e,null),Ti(n,!0,e,null)})))}function Ti(e,n,t,i){var s=4<arguments.length&&void 0!==arguments[4]?arguments[4]:0,l=t;if("selectionchange"===e&&9!==t.nodeType&&(l=t.ownerDocument),null!==i&&!n&&yi.has(e)){if("scroll"!==e)return;s|=2,l=i}var r=ls(l),a=e+"__"+(n?"capture":"bubble");r.has(a)||(n&&(s|=4),Wi(l,e,s,n),r.add(a))}function Wi(e,n,t,i){var s=Wn.get(n);switch(void 0===s?2:s){case 0:s=Kn;break;case 1:s=Qn;break;default:s=Jn}t=s.bind(null,n,t,e),s=void 0,!Ce||"touchstart"!==n&&"touchmove"!==n&&"wheel"!==n||(s=!0),i?void 0!==s?e.addEventListener(n,t,{capture:!0,passive:s}):e.addEventListener(n,t,!0):void 0!==s?e.addEventListener(n,t,{passive:s}):e.addEventListener(n,t,!1)}function Ui(e,n,t,i,s){var l=i;if(0===(1&n)&&0===(2&n)&&null!==i)e:for(;;){if(null===i)return;var r=i.tag;if(3===r||4===r){var a=i.stateNode.containerInfo;if(a===s||8===a.nodeType&&a.parentNode===s)break;if(4===r)for(r=i.return;null!==r;){var d=r.tag;if((3===d||4===d)&&((d=r.stateNode.containerInfo)===s||8===d.nodeType&&d.parentNode===s))return;r=r.return}for(;null!==a;){if(null===(r=ns(a)))return;if(5===(d=r.tag)||6===d){i=l=r;continue e}a=a.parentNode}}i=i.return}!function(e,n,t){if(Oe)return e(n,t);Oe=!0;try{return Ie(e,n,t)}finally{Oe=!1,Fe()}}((function(){var i=l,s=Me(t),r=[];e:{var a=Tn.get(e);if(void 0!==a){var d=vt,_=e;switch(e){case"keypress":if(0===st(t))break e;case"keydown":case"keyup":d=At;break;case"focusin":_="focus",d=ht;break;case"focusout":_="blur",d=ht;break;case"beforeblur":case"afterblur":d=ht;break;case"click":if(2===t.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":d=pt;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":d=Et;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":d=Vt;break;case Sn:case An:case Dn:d=gt;break;case Vn:d=Tt;break;case"scroll":d=ut;break;case"wheel":d=Ut;break;case"copy":case"cut":case"paste":d=bt;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":d=Dt}var o=0!==(4&n),m=!o&&"scroll"===e,v=o?null!==a?a+"Capture":null:a;o=[];for(var f,u=i;null!==u;){var c=(f=u).stateNode;if(5===f.tag&&null!==c&&(f=c,null!==v&&(null!=(c=Xe(u,v))&&o.push(Ii(u,c,f)))),m)break;u=u.return}0<o.length&&(a=new d(a,_,null,t,s),r.push({event:a,listeners:o}))}}if(0===(7&n)){if(d="mouseout"===e||"pointerout"===e,(!(a="mouseover"===e||"pointerover"===e)||0!==(16&n)||!(_=t.relatedTarget||t.fromElement)||!ns(_)&&!_[$i])&&(d||a)&&(a=s.window===s?s:(a=s.ownerDocument)?a.defaultView||a.parentWindow:window,d?(d=i,null!==(_=(_=t.relatedTarget||t.toElement)?ns(_):null)&&(_!==(m=je(_))||5!==_.tag&&6!==_.tag)&&(_=null)):(d=null,_=i),d!==_)){if(o=pt,c="onMouseLeave",v="onMouseEnter",u="mouse","pointerout"!==e&&"pointerover"!==e||(o=Dt,c="onPointerLeave",v="onPointerEnter",u="pointer"),m=null==d?a:is(d),f=null==_?a:is(_),(a=new o(c,u+"leave",d,t,s)).target=m,a.relatedTarget=f,c=null,ns(s)===i&&((o=new o(v,u+"enter",_,t,s)).target=f,o.relatedTarget=m,c=o),m=c,d&&_)e:{for(v=_,u=0,f=o=d;f;f=Oi(f))u++;for(f=0,c=v;c;c=Oi(c))f++;for(;0<u-f;)o=Oi(o),u--;for(;0<f-u;)v=Oi(v),f--;for(;u--;){if(o===v||null!==v&&o===v.alternate)break e;o=Oi(o),v=Oi(v)}o=null}else o=null;null!==d&&Fi(r,a,d,o,!1),null!==_&&null!==m&&Fi(r,m,_,o,!0)}if("select"===(d=(a=i?is(i):window).nodeName&&a.nodeName.toLowerCase())||"input"===d&&"file"===a.type)var p=Jt;else if(Zt(a))if($t)p=di;else{p=ri;var E=li}else(d=a.nodeName)&&"input"===d.toLowerCase()&&("checkbox"===a.type||"radio"===a.type)&&(p=ai);switch(p&&(p=p(e,i))?Pt(r,p,t,s):(E&&E(e,a,i),"focusout"===e&&(E=a._wrapperState)&&E.controlled&&"number"===a.type&&se(a,"number",a.value)),E=i?is(i):window,e){case"focusin":(Zt(E)||"true"===E.contentEditable)&&(hi=E,gi=i,wi=null);break;case"focusout":wi=gi=hi=null;break;case"mousedown":bi=!0;break;case"contextmenu":case"mouseup":case"dragend":bi=!1,xi(r,t,s);break;case"selectionchange":if(Ei)break;case"keydown":case"keyup":xi(r,t,s)}var h;if(Bt)e:{switch(e){case"compositionstart":var g="onCompositionStart";break e;case"compositionend":g="onCompositionEnd";break e;case"compositionupdate":g="onCompositionUpdate";break e}g=void 0}else Nt?Ht(e,t)&&(g="onCompositionEnd"):"keydown"===e&&229===t.keyCode&&(g="onCompositionStart");g&&(Xt&&"ko"!==t.locale&&(Nt||"onCompositionStart"!==g?"onCompositionEnd"===g&&Nt&&(h=it()):(nt="value"in(et=s)?et.value:et.textContent,Nt=!0)),0<(E=Bi(i,g)).length&&(g=new xt(g,e,null,t,s),r.push({event:g,listeners:E}),h?g.data=h:null!==(h=kt(t))&&(g.data=h))),(h=Ft?function(e,n){switch(e){case"compositionend":return kt(n);case"keypress":return 32!==n.which?null:(qt=!0,Ct);case"textInput":return(e=n.data)===Ct&&qt?null:e;default:return null}}(e,t):function(e,n){if(Nt)return"compositionend"===e||!Bt&&Ht(e,n)?(e=it(),tt=nt=et=null,Nt=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(n.ctrlKey||n.altKey||n.metaKey)||n.ctrlKey&&n.altKey){if(n.char&&1<n.char.length)return n.char;if(n.which)return String.fromCharCode(n.which)}return null;case"compositionend":return Xt&&"ko"!==n.locale?null:n.data}}(e,t))&&(0<(i=Bi(i,"onBeforeInput")).length&&(s=new xt("onBeforeInput","beforeinput",null,t,s),r.push({event:s,listeners:i}),s.data=h))}Si(r,n)}))}function Ii(e,n,t){return{instance:e,listener:n,currentTarget:t}}function Bi(e,n){for(var t=n+"Capture",i=[];null!==e;){var s=e,l=s.stateNode;5===s.tag&&null!==l&&(s=l,null!=(l=Xe(e,t))&&i.unshift(Ii(e,l,s)),null!=(l=Xe(e,n))&&i.push(Ii(e,l,s))),e=e.return}return i}function Oi(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Fi(e,n,t,i,s){for(var l=n._reactName,r=[];null!==t&&t!==i;){var a=t,d=a.alternate,_=a.stateNode;if(null!==d&&d===i)break;5===a.tag&&null!==_&&(a=_,s?null!=(d=Xe(t,l))&&r.unshift(Ii(t,d,a)):s||null!=(d=Xe(t,l))&&r.push(Ii(t,d,a))),t=t.return}0!==r.length&&e.push({event:n,listeners:r})}function Xi(){}var Ci=null,qi=null;function Hi(e,n){switch(e){case"button":case"input":case"select":case"textarea":return!!n.autoFocus}return!1}function ki(e,n){return"textarea"===e||"option"===e||"noscript"===e||"string"===typeof n.children||"number"===typeof n.children||"object"===typeof n.dangerouslySetInnerHTML&&null!==n.dangerouslySetInnerHTML&&null!=n.dangerouslySetInnerHTML.__html}var Ni="function"===typeof setTimeout?setTimeout:void 0,Yi="function"===typeof clearTimeout?clearTimeout:void 0;function Zi(e){1===e.nodeType?e.textContent="":9===e.nodeType&&(null!=(e=e.body)&&(e.textContent=""))}function Pi(e){for(;null!=e;e=e.nextSibling){var n=e.nodeType;if(1===n||3===n)break}return e}function Gi(e){e=e.previousSibling;for(var n=0;e;){if(8===e.nodeType){var t=e.data;if("$"===t||"$!"===t||"$?"===t){if(0===n)return e;n--}else"/$"===t&&n++}e=e.previousSibling}return null}var ji=0;var Ki=Math.random().toString(36).slice(2),Qi="__reactFiber$"+Ki,Ji="__reactProps$"+Ki,$i="__reactContainer$"+Ki,es="__reactEvents$"+Ki;function ns(e){var n=e[Qi];if(n)return n;for(var t=e.parentNode;t;){if(n=t[$i]||t[Qi]){if(t=n.alternate,null!==n.child||null!==t&&null!==t.child)for(e=Gi(e);null!==e;){if(t=e[Qi])return t;e=Gi(e)}return n}t=(e=t).parentNode}return null}function ts(e){return!(e=e[Qi]||e[$i])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function is(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(r(33))}function ss(e){return e[Ji]||null}function ls(e){var n=e[es];return void 0===n&&(n=e[es]=new Set),n}var rs=[],as=-1;function ds(e){return{current:e}}function _s(e){0>as||(e.current=rs[as],rs[as]=null,as--)}function os(e,n){as++,rs[as]=e.current,e.current=n}var ms={},vs=ds(ms),fs=ds(!1),us=ms;function cs(e,n){var t=e.type.contextTypes;if(!t)return ms;var i=e.stateNode;if(i&&i.__reactInternalMemoizedUnmaskedChildContext===n)return i.__reactInternalMemoizedMaskedChildContext;var s,l={};for(s in t)l[s]=n[s];return i&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=n,e.__reactInternalMemoizedMaskedChildContext=l),l}function ps(e){return null!==(e=e.childContextTypes)&&void 0!==e}function Es(){_s(fs),_s(vs)}function hs(e,n,t){if(vs.current!==ms)throw Error(r(168));os(vs,n),os(fs,t)}function gs(e,n,t){var i=e.stateNode;if(e=n.childContextTypes,"function"!==typeof i.getChildContext)return t;for(var l in i=i.getChildContext())if(!(l in e))throw Error(r(108,P(n)||"Unknown",l));return s({},t,i)}function ws(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||ms,us=vs.current,os(vs,e),os(fs,fs.current),!0}function bs(e,n,t){var i=e.stateNode;if(!i)throw Error(r(169));t?(e=gs(e,n,us),i.__reactInternalMemoizedMergedChildContext=e,_s(fs),_s(vs),os(vs,e)):_s(fs),os(fs,t)}var xs=null,zs=null,Ls=l.unstable_runWithPriority,Ms=l.unstable_scheduleCallback,ys=l.unstable_cancelCallback,Rs=l.unstable_shouldYield,Ss=l.unstable_requestPaint,As=l.unstable_now,Ds=l.unstable_getCurrentPriorityLevel,Vs=l.unstable_ImmediatePriority,Ts=l.unstable_UserBlockingPriority,Ws=l.unstable_NormalPriority,Us=l.unstable_LowPriority,Is=l.unstable_IdlePriority,Bs={},Os=void 0!==Ss?Ss:function(){},Fs=null,Xs=null,Cs=!1,qs=As(),Hs=1e4>qs?As:function(){return As()-qs};function ks(){switch(Ds()){case Vs:return 99;case Ts:return 98;case Ws:return 97;case Us:return 96;case Is:return 95;default:throw Error(r(332))}}function Ns(e){switch(e){case 99:return Vs;case 98:return Ts;case 97:return Ws;case 96:return Us;case 95:return Is;default:throw Error(r(332))}}function Ys(e,n){return e=Ns(e),Ls(e,n)}function Zs(e,n,t){return e=Ns(e),Ms(e,n,t)}function Ps(){if(null!==Xs){var e=Xs;Xs=null,ys(e)}Gs()}function Gs(){if(!Cs&&null!==Fs){Cs=!0;var e=0;try{var n=Fs;Ys(99,(function(){for(;e<n.length;e++){var t=n[e];do{t=t(!0)}while(null!==t)}})),Fs=null}catch(t){throw null!==Fs&&(Fs=Fs.slice(e+1)),Ms(Vs,Ps),t}finally{Cs=!1}}}var js=b.ReactCurrentBatchConfig;function Ks(e,n){if(e&&e.defaultProps){for(var t in n=s({},n),e=e.defaultProps)void 0===n[t]&&(n[t]=e[t]);return n}return n}var Qs=ds(null),Js=null,$s=null,el=null;function nl(){el=$s=Js=null}function tl(e){var n=Qs.current;_s(Qs),e.type._context._currentValue=n}function il(e,n){for(;null!==e;){var t=e.alternate;if((e.childLanes&n)===n){if(null===t||(t.childLanes&n)===n)break;t.childLanes|=n}else e.childLanes|=n,null!==t&&(t.childLanes|=n);e=e.return}}function sl(e,n){Js=e,el=$s=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&n)&&(Ir=!0),e.firstContext=null)}function ll(e,n){if(el!==e&&!1!==n&&0!==n)if("number"===typeof n&&1073741823!==n||(el=e,n=1073741823),n={context:e,observedBits:n,next:null},null===$s){if(null===Js)throw Error(r(308));$s=n,Js.dependencies={lanes:0,firstContext:n,responders:null}}else $s=$s.next=n;return e._currentValue}var rl=!1;function al(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null},effects:null}}function dl(e,n){e=e.updateQueue,n.updateQueue===e&&(n.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function _l(e,n){return{eventTime:e,lane:n,tag:0,payload:null,callback:null,next:null}}function ol(e,n){if(null!==(e=e.updateQueue)){var t=(e=e.shared).pending;null===t?n.next=n:(n.next=t.next,t.next=n),e.pending=n}}function ml(e,n){var t=e.updateQueue,i=e.alternate;if(null!==i&&t===(i=i.updateQueue)){var s=null,l=null;if(null!==(t=t.firstBaseUpdate)){do{var r={eventTime:t.eventTime,lane:t.lane,tag:t.tag,payload:t.payload,callback:t.callback,next:null};null===l?s=l=r:l=l.next=r,t=t.next}while(null!==t);null===l?s=l=n:l=l.next=n}else s=l=n;return t={baseState:i.baseState,firstBaseUpdate:s,lastBaseUpdate:l,shared:i.shared,effects:i.effects},void(e.updateQueue=t)}null===(e=t.lastBaseUpdate)?t.firstBaseUpdate=n:e.next=n,t.lastBaseUpdate=n}function vl(e,n,t,i){var l=e.updateQueue;rl=!1;var r=l.firstBaseUpdate,a=l.lastBaseUpdate,d=l.shared.pending;if(null!==d){l.shared.pending=null;var _=d,o=_.next;_.next=null,null===a?r=o:a.next=o,a=_;var m=e.alternate;if(null!==m){var v=(m=m.updateQueue).lastBaseUpdate;v!==a&&(null===v?m.firstBaseUpdate=o:v.next=o,m.lastBaseUpdate=_)}}if(null!==r){for(v=l.baseState,a=0,m=o=_=null;;){d=r.lane;var f=r.eventTime;if((i&d)===d){null!==m&&(m=m.next={eventTime:f,lane:0,tag:r.tag,payload:r.payload,callback:r.callback,next:null});e:{var u=e,c=r;switch(d=n,f=t,c.tag){case 1:if("function"===typeof(u=c.payload)){v=u.call(f,v,d);break e}v=u;break e;case 3:u.flags=-4097&u.flags|64;case 0:if(null===(d="function"===typeof(u=c.payload)?u.call(f,v,d):u)||void 0===d)break e;v=s({},v,d);break e;case 2:rl=!0}}null!==r.callback&&(e.flags|=32,null===(d=l.effects)?l.effects=[r]:d.push(r))}else f={eventTime:f,lane:d,tag:r.tag,payload:r.payload,callback:r.callback,next:null},null===m?(o=m=f,_=v):m=m.next=f,a|=d;if(null===(r=r.next)){if(null===(d=l.shared.pending))break;r=d.next,d.next=null,l.lastBaseUpdate=d,l.shared.pending=null}}null===m&&(_=v),l.baseState=_,l.firstBaseUpdate=o,l.lastBaseUpdate=m,Ca|=a,e.lanes=a,e.memoizedState=v}}function fl(e,n,t){if(e=n.effects,n.effects=null,null!==e)for(n=0;n<e.length;n++){var i=e[n],s=i.callback;if(null!==s){if(i.callback=null,i=t,"function"!==typeof s)throw Error(r(191,s));s.call(i)}}}var ul=(new i.Component).refs;function cl(e,n,t,i){t=null===(t=t(i,n=e.memoizedState))||void 0===t?n:s({},n,t),e.memoizedState=t,0===e.lanes&&(e.updateQueue.baseState=t)}var pl={isMounted:function(e){return!!(e=e._reactInternals)&&je(e)===e},enqueueSetState:function(e,n,t){e=e._reactInternals;var i=md(),s=vd(e),l=_l(i,s);l.payload=n,void 0!==t&&null!==t&&(l.callback=t),ol(e,l),fd(e,s,i)},enqueueReplaceState:function(e,n,t){e=e._reactInternals;var i=md(),s=vd(e),l=_l(i,s);l.tag=1,l.payload=n,void 0!==t&&null!==t&&(l.callback=t),ol(e,l),fd(e,s,i)},enqueueForceUpdate:function(e,n){e=e._reactInternals;var t=md(),i=vd(e),s=_l(t,i);s.tag=2,void 0!==n&&null!==n&&(s.callback=n),ol(e,s),fd(e,i,t)}};function El(e,n,t,i,s,l,r){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(i,l,r):!n.prototype||!n.prototype.isPureReactComponent||(!mi(t,i)||!mi(s,l))}function hl(e,n,t){var i=!1,s=ms,l=n.contextType;return"object"===typeof l&&null!==l?l=ll(l):(s=ps(n)?us:vs.current,l=(i=null!==(i=n.contextTypes)&&void 0!==i)?cs(e,s):ms),n=new n(t,l),e.memoizedState=null!==n.state&&void 0!==n.state?n.state:null,n.updater=pl,e.stateNode=n,n._reactInternals=e,i&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=s,e.__reactInternalMemoizedMaskedChildContext=l),n}function gl(e,n,t,i){e=n.state,"function"===typeof n.componentWillReceiveProps&&n.componentWillReceiveProps(t,i),"function"===typeof n.UNSAFE_componentWillReceiveProps&&n.UNSAFE_componentWillReceiveProps(t,i),n.state!==e&&pl.enqueueReplaceState(n,n.state,null)}function wl(e,n,t,i){var s=e.stateNode;s.props=t,s.state=e.memoizedState,s.refs=ul,al(e);var l=n.contextType;"object"===typeof l&&null!==l?s.context=ll(l):(l=ps(n)?us:vs.current,s.context=cs(e,l)),vl(e,t,s,i),s.state=e.memoizedState,"function"===typeof(l=n.getDerivedStateFromProps)&&(cl(e,n,l,t),s.state=e.memoizedState),"function"===typeof n.getDerivedStateFromProps||"function"===typeof s.getSnapshotBeforeUpdate||"function"!==typeof s.UNSAFE_componentWillMount&&"function"!==typeof s.componentWillMount||(n=s.state,"function"===typeof s.componentWillMount&&s.componentWillMount(),"function"===typeof s.UNSAFE_componentWillMount&&s.UNSAFE_componentWillMount(),n!==s.state&&pl.enqueueReplaceState(s,s.state,null),vl(e,t,s,i),s.state=e.memoizedState),"function"===typeof s.componentDidMount&&(e.flags|=4)}var bl=Array.isArray;function xl(e,n,t){if(null!==(e=t.ref)&&"function"!==typeof e&&"object"!==typeof e){if(t._owner){if(t=t._owner){if(1!==t.tag)throw Error(r(309));var i=t.stateNode}if(!i)throw Error(r(147,e));var s=""+e;return null!==n&&null!==n.ref&&"function"===typeof n.ref&&n.ref._stringRef===s?n.ref:(n=function(e){var n=i.refs;n===ul&&(n=i.refs={}),null===e?delete n[s]:n[s]=e},n._stringRef=s,n)}if("string"!==typeof e)throw Error(r(284));if(!t._owner)throw Error(r(290,e))}return e}function zl(e,n){if("textarea"!==e.type)throw Error(r(31,"[object Object]"===Object.prototype.toString.call(n)?"object with keys {"+Object.keys(n).join(", ")+"}":n))}function Ll(e){function n(n,t){if(e){var i=n.lastEffect;null!==i?(i.nextEffect=t,n.lastEffect=t):n.firstEffect=n.lastEffect=t,t.nextEffect=null,t.flags=8}}function t(t,i){if(!e)return null;for(;null!==i;)n(t,i),i=i.sibling;return null}function i(e,n){for(e=new Map;null!==n;)null!==n.key?e.set(n.key,n):e.set(n.index,n),n=n.sibling;return e}function s(e,n){return(e=Yd(e,n)).index=0,e.sibling=null,e}function l(n,t,i){return n.index=i,e?null!==(i=n.alternate)?(i=i.index)<t?(n.flags=2,t):i:(n.flags=2,t):t}function a(n){return e&&null===n.alternate&&(n.flags=2),n}function d(e,n,t,i){return null===n||6!==n.tag?((n=jd(t,e.mode,i)).return=e,n):((n=s(n,t)).return=e,n)}function _(e,n,t,i){return null!==n&&n.elementType===t.type?((i=s(n,t.props)).ref=xl(e,n,t),i.return=e,i):((i=Zd(t.type,t.key,t.props,null,e.mode,i)).ref=xl(e,n,t),i.return=e,i)}function o(e,n,t,i){return null===n||4!==n.tag||n.stateNode.containerInfo!==t.containerInfo||n.stateNode.implementation!==t.implementation?((n=Kd(t,e.mode,i)).return=e,n):((n=s(n,t.children||[])).return=e,n)}function m(e,n,t,i,l){return null===n||7!==n.tag?((n=Pd(t,e.mode,i,l)).return=e,n):((n=s(n,t)).return=e,n)}function v(e,n,t){if("string"===typeof n||"number"===typeof n)return(n=jd(""+n,e.mode,t)).return=e,n;if("object"===typeof n&&null!==n){switch(n.$$typeof){case x:return(t=Zd(n.type,n.key,n.props,null,e.mode,t)).ref=xl(e,null,n),t.return=e,t;case z:return(n=Kd(n,e.mode,t)).return=e,n}if(bl(n)||H(n))return(n=Pd(n,e.mode,t,null)).return=e,n;zl(e,n)}return null}function f(e,n,t,i){var s=null!==n?n.key:null;if("string"===typeof t||"number"===typeof t)return null!==s?null:d(e,n,""+t,i);if("object"===typeof t&&null!==t){switch(t.$$typeof){case x:return t.key===s?t.type===L?m(e,n,t.props.children,i,s):_(e,n,t,i):null;case z:return t.key===s?o(e,n,t,i):null}if(bl(t)||H(t))return null!==s?null:m(e,n,t,i,null);zl(e,t)}return null}function u(e,n,t,i,s){if("string"===typeof i||"number"===typeof i)return d(n,e=e.get(t)||null,""+i,s);if("object"===typeof i&&null!==i){switch(i.$$typeof){case x:return e=e.get(null===i.key?t:i.key)||null,i.type===L?m(n,e,i.props.children,s,i.key):_(n,e,i,s);case z:return o(n,e=e.get(null===i.key?t:i.key)||null,i,s)}if(bl(i)||H(i))return m(n,e=e.get(t)||null,i,s,null);zl(n,i)}return null}function c(s,r,a,d){for(var _=null,o=null,m=r,c=r=0,p=null;null!==m&&c<a.length;c++){m.index>c?(p=m,m=null):p=m.sibling;var E=f(s,m,a[c],d);if(null===E){null===m&&(m=p);break}e&&m&&null===E.alternate&&n(s,m),r=l(E,r,c),null===o?_=E:o.sibling=E,o=E,m=p}if(c===a.length)return t(s,m),_;if(null===m){for(;c<a.length;c++)null!==(m=v(s,a[c],d))&&(r=l(m,r,c),null===o?_=m:o.sibling=m,o=m);return _}for(m=i(s,m);c<a.length;c++)null!==(p=u(m,s,c,a[c],d))&&(e&&null!==p.alternate&&m.delete(null===p.key?c:p.key),r=l(p,r,c),null===o?_=p:o.sibling=p,o=p);return e&&m.forEach((function(e){return n(s,e)})),_}function p(s,a,d,_){var o=H(d);if("function"!==typeof o)throw Error(r(150));if(null==(d=o.call(d)))throw Error(r(151));for(var m=o=null,c=a,p=a=0,E=null,h=d.next();null!==c&&!h.done;p++,h=d.next()){c.index>p?(E=c,c=null):E=c.sibling;var g=f(s,c,h.value,_);if(null===g){null===c&&(c=E);break}e&&c&&null===g.alternate&&n(s,c),a=l(g,a,p),null===m?o=g:m.sibling=g,m=g,c=E}if(h.done)return t(s,c),o;if(null===c){for(;!h.done;p++,h=d.next())null!==(h=v(s,h.value,_))&&(a=l(h,a,p),null===m?o=h:m.sibling=h,m=h);return o}for(c=i(s,c);!h.done;p++,h=d.next())null!==(h=u(c,s,p,h.value,_))&&(e&&null!==h.alternate&&c.delete(null===h.key?p:h.key),a=l(h,a,p),null===m?o=h:m.sibling=h,m=h);return e&&c.forEach((function(e){return n(s,e)})),o}return function(e,i,l,d){var _="object"===typeof l&&null!==l&&l.type===L&&null===l.key;_&&(l=l.props.children);var o="object"===typeof l&&null!==l;if(o)switch(l.$$typeof){case x:e:{for(o=l.key,_=i;null!==_;){if(_.key===o){if(7===_.tag){if(l.type===L){t(e,_.sibling),(i=s(_,l.props.children)).return=e,e=i;break e}}else if(_.elementType===l.type){t(e,_.sibling),(i=s(_,l.props)).ref=xl(e,_,l),i.return=e,e=i;break e}t(e,_);break}n(e,_),_=_.sibling}l.type===L?((i=Pd(l.props.children,e.mode,d,l.key)).return=e,e=i):((d=Zd(l.type,l.key,l.props,null,e.mode,d)).ref=xl(e,i,l),d.return=e,e=d)}return a(e);case z:e:{for(_=l.key;null!==i;){if(i.key===_){if(4===i.tag&&i.stateNode.containerInfo===l.containerInfo&&i.stateNode.implementation===l.implementation){t(e,i.sibling),(i=s(i,l.children||[])).return=e,e=i;break e}t(e,i);break}n(e,i),i=i.sibling}(i=Kd(l,e.mode,d)).return=e,e=i}return a(e)}if("string"===typeof l||"number"===typeof l)return l=""+l,null!==i&&6===i.tag?(t(e,i.sibling),(i=s(i,l)).return=e,e=i):(t(e,i),(i=jd(l,e.mode,d)).return=e,e=i),a(e);if(bl(l))return c(e,i,l,d);if(H(l))return p(e,i,l,d);if(o&&zl(e,l),"undefined"===typeof l&&!_)switch(e.tag){case 1:case 22:case 0:case 11:case 15:throw Error(r(152,P(e.type)||"Component"))}return t(e,i)}}var Ml=Ll(!0),yl=Ll(!1),Rl={},Sl=ds(Rl),Al=ds(Rl),Dl=ds(Rl);function Vl(e){if(e===Rl)throw Error(r(174));return e}function Tl(e,n){switch(os(Dl,n),os(Al,e),os(Sl,Rl),e=n.nodeType){case 9:case 11:n=(n=n.documentElement)?n.namespaceURI:fe(null,"");break;default:n=fe(n=(e=8===e?n.parentNode:n).namespaceURI||null,e=e.tagName)}_s(Sl),os(Sl,n)}function Wl(){_s(Sl),_s(Al),_s(Dl)}function Ul(e){Vl(Dl.current);var n=Vl(Sl.current),t=fe(n,e.type);n!==t&&(os(Al,e),os(Sl,t))}function Il(e){Al.current===e&&(_s(Sl),_s(Al))}var Bl=ds(0);function Ol(e){for(var n=e;null!==n;){if(13===n.tag){var t=n.memoizedState;if(null!==t&&(null===(t=t.dehydrated)||"$?"===t.data||"$!"===t.data))return n}else if(19===n.tag&&void 0!==n.memoizedProps.revealOrder){if(0!==(64&n.flags))return n}else if(null!==n.child){n.child.return=n,n=n.child;continue}if(n===e)break;for(;null===n.sibling;){if(null===n.return||n.return===e)return null;n=n.return}n.sibling.return=n.return,n=n.sibling}return null}var Fl=null,Xl=null,Cl=!1;function ql(e,n){var t=kd(5,null,null,0);t.elementType="DELETED",t.type="DELETED",t.stateNode=n,t.return=e,t.flags=8,null!==e.lastEffect?(e.lastEffect.nextEffect=t,e.lastEffect=t):e.firstEffect=e.lastEffect=t}function Hl(e,n){switch(e.tag){case 5:var t=e.type;return null!==(n=1!==n.nodeType||t.toLowerCase()!==n.nodeName.toLowerCase()?null:n)&&(e.stateNode=n,!0);case 6:return null!==(n=""===e.pendingProps||3!==n.nodeType?null:n)&&(e.stateNode=n,!0);default:return!1}}function kl(e){if(Cl){var n=Xl;if(n){var t=n;if(!Hl(e,n)){if(!(n=Pi(t.nextSibling))||!Hl(e,n))return e.flags=-1025&e.flags|2,Cl=!1,void(Fl=e);ql(Fl,t)}Fl=e,Xl=Pi(n.firstChild)}else e.flags=-1025&e.flags|2,Cl=!1,Fl=e}}function Nl(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;Fl=e}function Yl(e){if(e!==Fl)return!1;if(!Cl)return Nl(e),Cl=!0,!1;var n=e.type;if(5!==e.tag||"head"!==n&&"body"!==n&&!ki(n,e.memoizedProps))for(n=Xl;n;)ql(e,n),n=Pi(n.nextSibling);if(Nl(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(r(317));e:{for(e=e.nextSibling,n=0;e;){if(8===e.nodeType){var t=e.data;if("/$"===t){if(0===n){Xl=Pi(e.nextSibling);break e}n--}else"$"!==t&&"$!"!==t&&"$?"!==t||n++}e=e.nextSibling}Xl=null}}else Xl=Fl?Pi(e.stateNode.nextSibling):null;return!0}function Zl(){Xl=Fl=null,Cl=!1}var Pl=[];function Gl(){for(var e=0;e<Pl.length;e++)Pl[e]._workInProgressVersionPrimary=null;Pl.length=0}var jl=b.ReactCurrentDispatcher,Kl=b.ReactCurrentBatchConfig,Ql=0,Jl=null,$l=null,er=null,nr=!1,tr=!1;function ir(){throw Error(r(321))}function sr(e,n){if(null===n)return!1;for(var t=0;t<n.length&&t<e.length;t++)if(!_i(e[t],n[t]))return!1;return!0}function lr(e,n,t,i,s,l){if(Ql=l,Jl=n,n.memoizedState=null,n.updateQueue=null,n.lanes=0,jl.current=null===e||null===e.memoizedState?Vr:Tr,e=t(i,s),tr){l=0;do{if(tr=!1,!(25>l))throw Error(r(301));l+=1,er=$l=null,n.updateQueue=null,jl.current=Wr,e=t(i,s)}while(tr)}if(jl.current=Dr,n=null!==$l&&null!==$l.next,Ql=0,er=$l=Jl=null,nr=!1,n)throw Error(r(300));return e}function rr(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===er?Jl.memoizedState=er=e:er=er.next=e,er}function ar(){if(null===$l){var e=Jl.alternate;e=null!==e?e.memoizedState:null}else e=$l.next;var n=null===er?Jl.memoizedState:er.next;if(null!==n)er=n,$l=e;else{if(null===e)throw Error(r(310));e={memoizedState:($l=e).memoizedState,baseState:$l.baseState,baseQueue:$l.baseQueue,queue:$l.queue,next:null},null===er?Jl.memoizedState=er=e:er=er.next=e}return er}function dr(e,n){return"function"===typeof n?n(e):n}function _r(e){var n=ar(),t=n.queue;if(null===t)throw Error(r(311));t.lastRenderedReducer=e;var i=$l,s=i.baseQueue,l=t.pending;if(null!==l){if(null!==s){var a=s.next;s.next=l.next,l.next=a}i.baseQueue=s=l,t.pending=null}if(null!==s){s=s.next,i=i.baseState;var d=a=l=null,_=s;do{var o=_.lane;if((Ql&o)===o)null!==d&&(d=d.next={lane:0,action:_.action,eagerReducer:_.eagerReducer,eagerState:_.eagerState,next:null}),i=_.eagerReducer===e?_.eagerState:e(i,_.action);else{var m={lane:o,action:_.action,eagerReducer:_.eagerReducer,eagerState:_.eagerState,next:null};null===d?(a=d=m,l=i):d=d.next=m,Jl.lanes|=o,Ca|=o}_=_.next}while(null!==_&&_!==s);null===d?l=i:d.next=a,_i(i,n.memoizedState)||(Ir=!0),n.memoizedState=i,n.baseState=l,n.baseQueue=d,t.lastRenderedState=i}return[n.memoizedState,t.dispatch]}function or(e){var n=ar(),t=n.queue;if(null===t)throw Error(r(311));t.lastRenderedReducer=e;var i=t.dispatch,s=t.pending,l=n.memoizedState;if(null!==s){t.pending=null;var a=s=s.next;do{l=e(l,a.action),a=a.next}while(a!==s);_i(l,n.memoizedState)||(Ir=!0),n.memoizedState=l,null===n.baseQueue&&(n.baseState=l),t.lastRenderedState=l}return[l,i]}function mr(e,n,t){var i=n._getVersion;i=i(n._source);var s=n._workInProgressVersionPrimary;if(null!==s?e=s===i:(e=e.mutableReadLanes,(e=(Ql&e)===e)&&(n._workInProgressVersionPrimary=i,Pl.push(n))),e)return t(n._source);throw Pl.push(n),Error(r(350))}function vr(e,n,t,i){var s=Ta;if(null===s)throw Error(r(349));var l=n._getVersion,a=l(n._source),d=jl.current,_=d.useState((function(){return mr(s,n,t)})),o=_[1],m=_[0];_=er;var v=e.memoizedState,f=v.refs,u=f.getSnapshot,c=v.source;v=v.subscribe;var p=Jl;return e.memoizedState={refs:f,source:n,subscribe:i},d.useEffect((function(){f.getSnapshot=t,f.setSnapshot=o;var e=l(n._source);if(!_i(a,e)){e=t(n._source),_i(m,e)||(o(e),e=vd(p),s.mutableReadLanes|=e&s.pendingLanes),e=s.mutableReadLanes,s.entangledLanes|=e;for(var i=s.entanglements,r=e;0<r;){var d=31-Nn(r),_=1<<d;i[d]|=e,r&=~_}}}),[t,n,i]),d.useEffect((function(){return i(n._source,(function(){var e=f.getSnapshot,t=f.setSnapshot;try{t(e(n._source));var i=vd(p);s.mutableReadLanes|=i&s.pendingLanes}catch(l){t((function(){throw l}))}}))}),[n,i]),_i(u,t)&&_i(c,n)&&_i(v,i)||((e={pending:null,dispatch:null,lastRenderedReducer:dr,lastRenderedState:m}).dispatch=o=Ar.bind(null,Jl,e),_.queue=e,_.baseQueue=null,m=mr(s,n,t),_.memoizedState=_.baseState=m),m}function fr(e,n,t){return vr(ar(),e,n,t)}function ur(e){var n=rr();return"function"===typeof e&&(e=e()),n.memoizedState=n.baseState=e,e=(e=n.queue={pending:null,dispatch:null,lastRenderedReducer:dr,lastRenderedState:e}).dispatch=Ar.bind(null,Jl,e),[n.memoizedState,e]}function cr(e,n,t,i){return e={tag:e,create:n,destroy:t,deps:i,next:null},null===(n=Jl.updateQueue)?(n={lastEffect:null},Jl.updateQueue=n,n.lastEffect=e.next=e):null===(t=n.lastEffect)?n.lastEffect=e.next=e:(i=t.next,t.next=e,e.next=i,n.lastEffect=e),e}function pr(e){return e={current:e},rr().memoizedState=e}function Er(){return ar().memoizedState}function hr(e,n,t,i){var s=rr();Jl.flags|=e,s.memoizedState=cr(1|n,t,void 0,void 0===i?null:i)}function gr(e,n,t,i){var s=ar();i=void 0===i?null:i;var l=void 0;if(null!==$l){var r=$l.memoizedState;if(l=r.destroy,null!==i&&sr(i,r.deps))return void cr(n,t,l,i)}Jl.flags|=e,s.memoizedState=cr(1|n,t,l,i)}function wr(e,n){return hr(516,4,e,n)}function br(e,n){return gr(516,4,e,n)}function xr(e,n){return gr(4,2,e,n)}function zr(e,n){return"function"===typeof n?(e=e(),n(e),function(){n(null)}):null!==n&&void 0!==n?(e=e(),n.current=e,function(){n.current=null}):void 0}function Lr(e,n,t){return t=null!==t&&void 0!==t?t.concat([e]):null,gr(4,2,zr.bind(null,n,e),t)}function Mr(){}function yr(e,n){var t=ar();n=void 0===n?null:n;var i=t.memoizedState;return null!==i&&null!==n&&sr(n,i[1])?i[0]:(t.memoizedState=[e,n],e)}function Rr(e,n){var t=ar();n=void 0===n?null:n;var i=t.memoizedState;return null!==i&&null!==n&&sr(n,i[1])?i[0]:(e=e(),t.memoizedState=[e,n],e)}function Sr(e,n){var t=ks();Ys(98>t?98:t,(function(){e(!0)})),Ys(97<t?97:t,(function(){var t=Kl.transition;Kl.transition=1;try{e(!1),n()}finally{Kl.transition=t}}))}function Ar(e,n,t){var i=md(),s=vd(e),l={lane:s,action:t,eagerReducer:null,eagerState:null,next:null},r=n.pending;if(null===r?l.next=l:(l.next=r.next,r.next=l),n.pending=l,r=e.alternate,e===Jl||null!==r&&r===Jl)tr=nr=!0;else{if(0===e.lanes&&(null===r||0===r.lanes)&&null!==(r=n.lastRenderedReducer))try{var a=n.lastRenderedState,d=r(a,t);if(l.eagerReducer=r,l.eagerState=d,_i(d,a))return}catch(_){}fd(e,s,i)}}var Dr={readContext:ll,useCallback:ir,useContext:ir,useEffect:ir,useImperativeHandle:ir,useLayoutEffect:ir,useMemo:ir,useReducer:ir,useRef:ir,useState:ir,useDebugValue:ir,useDeferredValue:ir,useTransition:ir,useMutableSource:ir,useOpaqueIdentifier:ir,unstable_isNewReconciler:!1},Vr={readContext:ll,useCallback:function(e,n){return rr().memoizedState=[e,void 0===n?null:n],e},useContext:ll,useEffect:wr,useImperativeHandle:function(e,n,t){return t=null!==t&&void 0!==t?t.concat([e]):null,hr(4,2,zr.bind(null,n,e),t)},useLayoutEffect:function(e,n){return hr(4,2,e,n)},useMemo:function(e,n){var t=rr();return n=void 0===n?null:n,e=e(),t.memoizedState=[e,n],e},useReducer:function(e,n,t){var i=rr();return n=void 0!==t?t(n):n,i.memoizedState=i.baseState=n,e=(e=i.queue={pending:null,dispatch:null,lastRenderedReducer:e,lastRenderedState:n}).dispatch=Ar.bind(null,Jl,e),[i.memoizedState,e]},useRef:pr,useState:ur,useDebugValue:Mr,useDeferredValue:function(e){var n=ur(e),t=n[0],i=n[1];return wr((function(){var n=Kl.transition;Kl.transition=1;try{i(e)}finally{Kl.transition=n}}),[e]),t},useTransition:function(){var e=ur(!1),n=e[0];return pr(e=Sr.bind(null,e[1])),[e,n]},useMutableSource:function(e,n,t){var i=rr();return i.memoizedState={refs:{getSnapshot:n,setSnapshot:null},source:e,subscribe:t},vr(i,e,n,t)},useOpaqueIdentifier:function(){if(Cl){var e=!1,n=function(e){return{$$typeof:I,toString:e,valueOf:e}}((function(){throw e||(e=!0,t("r:"+(ji++).toString(36))),Error(r(355))})),t=ur(n)[1];return 0===(2&Jl.mode)&&(Jl.flags|=516,cr(5,(function(){t("r:"+(ji++).toString(36))}),void 0,null)),n}return ur(n="r:"+(ji++).toString(36)),n},unstable_isNewReconciler:!1},Tr={readContext:ll,useCallback:yr,useContext:ll,useEffect:br,useImperativeHandle:Lr,useLayoutEffect:xr,useMemo:Rr,useReducer:_r,useRef:Er,useState:function(){return _r(dr)},useDebugValue:Mr,useDeferredValue:function(e){var n=_r(dr),t=n[0],i=n[1];return br((function(){var n=Kl.transition;Kl.transition=1;try{i(e)}finally{Kl.transition=n}}),[e]),t},useTransition:function(){var e=_r(dr)[0];return[Er().current,e]},useMutableSource:fr,useOpaqueIdentifier:function(){return _r(dr)[0]},unstable_isNewReconciler:!1},Wr={readContext:ll,useCallback:yr,useContext:ll,useEffect:br,useImperativeHandle:Lr,useLayoutEffect:xr,useMemo:Rr,useReducer:or,useRef:Er,useState:function(){return or(dr)},useDebugValue:Mr,useDeferredValue:function(e){var n=or(dr),t=n[0],i=n[1];return br((function(){var n=Kl.transition;Kl.transition=1;try{i(e)}finally{Kl.transition=n}}),[e]),t},useTransition:function(){var e=or(dr)[0];return[Er().current,e]},useMutableSource:fr,useOpaqueIdentifier:function(){return or(dr)[0]},unstable_isNewReconciler:!1},Ur=b.ReactCurrentOwner,Ir=!1;function Br(e,n,t,i){n.child=null===e?yl(n,null,t,i):Ml(n,e.child,t,i)}function Or(e,n,t,i,s){t=t.render;var l=n.ref;return sl(n,s),i=lr(e,n,t,i,l,s),null===e||Ir?(n.flags|=1,Br(e,n,i,s),n.child):(n.updateQueue=e.updateQueue,n.flags&=-517,e.lanes&=~s,sa(e,n,s))}function Fr(e,n,t,i,s,l){if(null===e){var r=t.type;return"function"!==typeof r||Nd(r)||void 0!==r.defaultProps||null!==t.compare||void 0!==t.defaultProps?((e=Zd(t.type,null,i,n,n.mode,l)).ref=n.ref,e.return=n,n.child=e):(n.tag=15,n.type=r,Xr(e,n,r,i,s,l))}return r=e.child,0===(s&l)&&(s=r.memoizedProps,(t=null!==(t=t.compare)?t:mi)(s,i)&&e.ref===n.ref)?sa(e,n,l):(n.flags|=1,(e=Yd(r,i)).ref=n.ref,e.return=n,n.child=e)}function Xr(e,n,t,i,s,l){if(null!==e&&mi(e.memoizedProps,i)&&e.ref===n.ref){if(Ir=!1,0===(l&s))return n.lanes=e.lanes,sa(e,n,l);0!==(16384&e.flags)&&(Ir=!0)}return Hr(e,n,t,i,l)}function Cr(e,n,t){var i=n.pendingProps,s=i.children,l=null!==e?e.memoizedState:null;if("hidden"===i.mode||"unstable-defer-without-hiding"===i.mode)if(0===(4&n.mode))n.memoizedState={baseLanes:0},bd(n,t);else{if(0===(1073741824&t))return e=null!==l?l.baseLanes|t:t,n.lanes=n.childLanes=1073741824,n.memoizedState={baseLanes:e},bd(n,e),null;n.memoizedState={baseLanes:0},bd(n,null!==l?l.baseLanes:t)}else null!==l?(i=l.baseLanes|t,n.memoizedState=null):i=t,bd(n,i);return Br(e,n,s,t),n.child}function qr(e,n){var t=n.ref;(null===e&&null!==t||null!==e&&e.ref!==t)&&(n.flags|=128)}function Hr(e,n,t,i,s){var l=ps(t)?us:vs.current;return l=cs(n,l),sl(n,s),t=lr(e,n,t,i,l,s),null===e||Ir?(n.flags|=1,Br(e,n,t,s),n.child):(n.updateQueue=e.updateQueue,n.flags&=-517,e.lanes&=~s,sa(e,n,s))}function kr(e,n,t,i,s){if(ps(t)){var l=!0;ws(n)}else l=!1;if(sl(n,s),null===n.stateNode)null!==e&&(e.alternate=null,n.alternate=null,n.flags|=2),hl(n,t,i),wl(n,t,i,s),i=!0;else if(null===e){var r=n.stateNode,a=n.memoizedProps;r.props=a;var d=r.context,_=t.contextType;"object"===typeof _&&null!==_?_=ll(_):_=cs(n,_=ps(t)?us:vs.current);var o=t.getDerivedStateFromProps,m="function"===typeof o||"function"===typeof r.getSnapshotBeforeUpdate;m||"function"!==typeof r.UNSAFE_componentWillReceiveProps&&"function"!==typeof r.componentWillReceiveProps||(a!==i||d!==_)&&gl(n,r,i,_),rl=!1;var v=n.memoizedState;r.state=v,vl(n,i,r,s),d=n.memoizedState,a!==i||v!==d||fs.current||rl?("function"===typeof o&&(cl(n,t,o,i),d=n.memoizedState),(a=rl||El(n,t,a,i,v,d,_))?(m||"function"!==typeof r.UNSAFE_componentWillMount&&"function"!==typeof r.componentWillMount||("function"===typeof r.componentWillMount&&r.componentWillMount(),"function"===typeof r.UNSAFE_componentWillMount&&r.UNSAFE_componentWillMount()),"function"===typeof r.componentDidMount&&(n.flags|=4)):("function"===typeof r.componentDidMount&&(n.flags|=4),n.memoizedProps=i,n.memoizedState=d),r.props=i,r.state=d,r.context=_,i=a):("function"===typeof r.componentDidMount&&(n.flags|=4),i=!1)}else{r=n.stateNode,dl(e,n),a=n.memoizedProps,_=n.type===n.elementType?a:Ks(n.type,a),r.props=_,m=n.pendingProps,v=r.context,"object"===typeof(d=t.contextType)&&null!==d?d=ll(d):d=cs(n,d=ps(t)?us:vs.current);var f=t.getDerivedStateFromProps;(o="function"===typeof f||"function"===typeof r.getSnapshotBeforeUpdate)||"function"!==typeof r.UNSAFE_componentWillReceiveProps&&"function"!==typeof r.componentWillReceiveProps||(a!==m||v!==d)&&gl(n,r,i,d),rl=!1,v=n.memoizedState,r.state=v,vl(n,i,r,s);var u=n.memoizedState;a!==m||v!==u||fs.current||rl?("function"===typeof f&&(cl(n,t,f,i),u=n.memoizedState),(_=rl||El(n,t,_,i,v,u,d))?(o||"function"!==typeof r.UNSAFE_componentWillUpdate&&"function"!==typeof r.componentWillUpdate||("function"===typeof r.componentWillUpdate&&r.componentWillUpdate(i,u,d),"function"===typeof r.UNSAFE_componentWillUpdate&&r.UNSAFE_componentWillUpdate(i,u,d)),"function"===typeof r.componentDidUpdate&&(n.flags|=4),"function"===typeof r.getSnapshotBeforeUpdate&&(n.flags|=256)):("function"!==typeof r.componentDidUpdate||a===e.memoizedProps&&v===e.memoizedState||(n.flags|=4),"function"!==typeof r.getSnapshotBeforeUpdate||a===e.memoizedProps&&v===e.memoizedState||(n.flags|=256),n.memoizedProps=i,n.memoizedState=u),r.props=i,r.state=u,r.context=d,i=_):("function"!==typeof r.componentDidUpdate||a===e.memoizedProps&&v===e.memoizedState||(n.flags|=4),"function"!==typeof r.getSnapshotBeforeUpdate||a===e.memoizedProps&&v===e.memoizedState||(n.flags|=256),i=!1)}return Nr(e,n,t,i,l,s)}function Nr(e,n,t,i,s,l){qr(e,n);var r=0!==(64&n.flags);if(!i&&!r)return s&&bs(n,t,!1),sa(e,n,l);i=n.stateNode,Ur.current=n;var a=r&&"function"!==typeof t.getDerivedStateFromError?null:i.render();return n.flags|=1,null!==e&&r?(n.child=Ml(n,e.child,null,l),n.child=Ml(n,null,a,l)):Br(e,n,a,l),n.memoizedState=i.state,s&&bs(n,t,!0),n.child}function Yr(e){var n=e.stateNode;n.pendingContext?hs(0,n.pendingContext,n.pendingContext!==n.context):n.context&&hs(0,n.context,!1),Tl(e,n.containerInfo)}var Zr,Pr,Gr,jr,Kr={dehydrated:null,retryLane:0};function Qr(e,n,t){var i,s=n.pendingProps,l=Bl.current,r=!1;return(i=0!==(64&n.flags))||(i=(null===e||null!==e.memoizedState)&&0!==(2&l)),i?(r=!0,n.flags&=-65):null!==e&&null===e.memoizedState||void 0===s.fallback||!0===s.unstable_avoidThisFallback||(l|=1),os(Bl,1&l),null===e?(void 0!==s.fallback&&kl(n),e=s.children,l=s.fallback,r?(e=Jr(n,e,l,t),n.child.memoizedState={baseLanes:t},n.memoizedState=Kr,e):"number"===typeof s.unstable_expectedLoadTime?(e=Jr(n,e,l,t),n.child.memoizedState={baseLanes:t},n.memoizedState=Kr,n.lanes=33554432,e):((t=Gd({mode:"visible",children:e},n.mode,t,null)).return=n,n.child=t)):(e.memoizedState,r?(s=ea(e,n,s.children,s.fallback,t),r=n.child,l=e.child.memoizedState,r.memoizedState=null===l?{baseLanes:t}:{baseLanes:l.baseLanes|t},r.childLanes=e.childLanes&~t,n.memoizedState=Kr,s):(t=$r(e,n,s.children,t),n.memoizedState=null,t))}function Jr(e,n,t,i){var s=e.mode,l=e.child;return n={mode:"hidden",children:n},0===(2&s)&&null!==l?(l.childLanes=0,l.pendingProps=n):l=Gd(n,s,0,null),t=Pd(t,s,i,null),l.return=e,t.return=e,l.sibling=t,e.child=l,t}function $r(e,n,t,i){var s=e.child;return e=s.sibling,t=Yd(s,{mode:"visible",children:t}),0===(2&n.mode)&&(t.lanes=i),t.return=n,t.sibling=null,null!==e&&(e.nextEffect=null,e.flags=8,n.firstEffect=n.lastEffect=e),n.child=t}function ea(e,n,t,i,s){var l=n.mode,r=e.child;e=r.sibling;var a={mode:"hidden",children:t};return 0===(2&l)&&n.child!==r?((t=n.child).childLanes=0,t.pendingProps=a,null!==(r=t.lastEffect)?(n.firstEffect=t.firstEffect,n.lastEffect=r,r.nextEffect=null):n.firstEffect=n.lastEffect=null):t=Yd(r,a),null!==e?i=Yd(e,i):(i=Pd(i,l,s,null)).flags|=2,i.return=n,t.return=n,t.sibling=i,n.child=t,i}function na(e,n){e.lanes|=n;var t=e.alternate;null!==t&&(t.lanes|=n),il(e.return,n)}function ta(e,n,t,i,s,l){var r=e.memoizedState;null===r?e.memoizedState={isBackwards:n,rendering:null,renderingStartTime:0,last:i,tail:t,tailMode:s,lastEffect:l}:(r.isBackwards=n,r.rendering=null,r.renderingStartTime=0,r.last=i,r.tail=t,r.tailMode=s,r.lastEffect=l)}function ia(e,n,t){var i=n.pendingProps,s=i.revealOrder,l=i.tail;if(Br(e,n,i.children,t),0!==(2&(i=Bl.current)))i=1&i|2,n.flags|=64;else{if(null!==e&&0!==(64&e.flags))e:for(e=n.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&na(e,t);else if(19===e.tag)na(e,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===n)break e;for(;null===e.sibling;){if(null===e.return||e.return===n)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}i&=1}if(os(Bl,i),0===(2&n.mode))n.memoizedState=null;else switch(s){case"forwards":for(t=n.child,s=null;null!==t;)null!==(e=t.alternate)&&null===Ol(e)&&(s=t),t=t.sibling;null===(t=s)?(s=n.child,n.child=null):(s=t.sibling,t.sibling=null),ta(n,!1,s,t,l,n.lastEffect);break;case"backwards":for(t=null,s=n.child,n.child=null;null!==s;){if(null!==(e=s.alternate)&&null===Ol(e)){n.child=s;break}e=s.sibling,s.sibling=t,t=s,s=e}ta(n,!0,t,null,l,n.lastEffect);break;case"together":ta(n,!1,null,null,void 0,n.lastEffect);break;default:n.memoizedState=null}return n.child}function sa(e,n,t){if(null!==e&&(n.dependencies=e.dependencies),Ca|=n.lanes,0!==(t&n.childLanes)){if(null!==e&&n.child!==e.child)throw Error(r(153));if(null!==n.child){for(t=Yd(e=n.child,e.pendingProps),n.child=t,t.return=n;null!==e.sibling;)e=e.sibling,(t=t.sibling=Yd(e,e.pendingProps)).return=n;t.sibling=null}return n.child}return null}function la(e,n){if(!Cl)switch(e.tailMode){case"hidden":n=e.tail;for(var t=null;null!==n;)null!==n.alternate&&(t=n),n=n.sibling;null===t?e.tail=null:t.sibling=null;break;case"collapsed":t=e.tail;for(var i=null;null!==t;)null!==t.alternate&&(i=t),t=t.sibling;null===i?n||null===e.tail?e.tail=null:e.tail.sibling=null:i.sibling=null}}function ra(e,n,t){var i=n.pendingProps;switch(n.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:case 17:return ps(n.type)&&Es(),null;case 3:return Wl(),_s(fs),_s(vs),Gl(),(i=n.stateNode).pendingContext&&(i.context=i.pendingContext,i.pendingContext=null),null!==e&&null!==e.child||(Yl(n)?n.flags|=4:i.hydrate||(n.flags|=256)),Pr(n),null;case 5:Il(n);var l=Vl(Dl.current);if(t=n.type,null!==e&&null!=n.stateNode)Gr(e,n,t,i,l),e.ref!==n.ref&&(n.flags|=128);else{if(!i){if(null===n.stateNode)throw Error(r(166));return null}if(e=Vl(Sl.current),Yl(n)){i=n.stateNode,t=n.type;var a=n.memoizedProps;switch(i[Qi]=n,i[Ji]=a,t){case"dialog":Ai("cancel",i),Ai("close",i);break;case"iframe":case"object":case"embed":Ai("load",i);break;case"video":case"audio":for(e=0;e<Mi.length;e++)Ai(Mi[e],i);break;case"source":Ai("error",i);break;case"img":case"image":case"link":Ai("error",i),Ai("load",i);break;case"details":Ai("toggle",i);break;case"input":ee(i,a),Ai("invalid",i);break;case"select":i._wrapperState={wasMultiple:!!a.multiple},Ai("invalid",i);break;case"textarea":de(i,a),Ai("invalid",i)}for(var _ in ze(t,a),e=null,a)a.hasOwnProperty(_)&&(l=a[_],"children"===_?"string"===typeof l?i.textContent!==l&&(e=["children",l]):"number"===typeof l&&i.textContent!==""+l&&(e=["children",""+l]):d.hasOwnProperty(_)&&null!=l&&"onScroll"===_&&Ai("scroll",i));switch(t){case"input":K(i),ie(i,a,!0);break;case"textarea":K(i),oe(i);break;case"select":case"option":break;default:"function"===typeof a.onClick&&(i.onclick=Xi)}i=e,n.updateQueue=i,null!==i&&(n.flags|=4)}else{switch(_=9===l.nodeType?l:l.ownerDocument,e===me.html&&(e=ve(t)),e===me.html?"script"===t?((e=_.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"===typeof i.is?e=_.createElement(t,{is:i.is}):(e=_.createElement(t),"select"===t&&(_=e,i.multiple?_.multiple=!0:i.size&&(_.size=i.size))):e=_.createElementNS(e,t),e[Qi]=n,e[Ji]=i,Zr(e,n,!1,!1),n.stateNode=e,_=Le(t,i),t){case"dialog":Ai("cancel",e),Ai("close",e),l=i;break;case"iframe":case"object":case"embed":Ai("load",e),l=i;break;case"video":case"audio":for(l=0;l<Mi.length;l++)Ai(Mi[l],e);l=i;break;case"source":Ai("error",e),l=i;break;case"img":case"image":case"link":Ai("error",e),Ai("load",e),l=i;break;case"details":Ai("toggle",e),l=i;break;case"input":ee(e,i),l=$(e,i),Ai("invalid",e);break;case"option":l=le(e,i);break;case"select":e._wrapperState={wasMultiple:!!i.multiple},l=s({},i,{value:void 0}),Ai("invalid",e);break;case"textarea":de(e,i),l=ae(e,i),Ai("invalid",e);break;default:l=i}ze(t,l);var o=l;for(a in o)if(o.hasOwnProperty(a)){var m=o[a];"style"===a?be(e,m):"dangerouslySetInnerHTML"===a?null!=(m=m?m.__html:void 0)&&pe(e,m):"children"===a?"string"===typeof m?("textarea"!==t||""!==m)&&Ee(e,m):"number"===typeof m&&Ee(e,""+m):"suppressContentEditableWarning"!==a&&"suppressHydrationWarning"!==a&&"autoFocus"!==a&&(d.hasOwnProperty(a)?null!=m&&"onScroll"===a&&Ai("scroll",e):null!=m&&w(e,a,m,_))}switch(t){case"input":K(e),ie(e,i,!1);break;case"textarea":K(e),oe(e);break;case"option":null!=i.value&&e.setAttribute("value",""+G(i.value));break;case"select":e.multiple=!!i.multiple,null!=(a=i.value)?re(e,!!i.multiple,a,!1):null!=i.defaultValue&&re(e,!!i.multiple,i.defaultValue,!0);break;default:"function"===typeof l.onClick&&(e.onclick=Xi)}Hi(t,i)&&(n.flags|=4)}null!==n.ref&&(n.flags|=128)}return null;case 6:if(e&&null!=n.stateNode)jr(e,n,e.memoizedProps,i);else{if("string"!==typeof i&&null===n.stateNode)throw Error(r(166));t=Vl(Dl.current),Vl(Sl.current),Yl(n)?(i=n.stateNode,t=n.memoizedProps,i[Qi]=n,i.nodeValue!==t&&(n.flags|=4)):((i=(9===t.nodeType?t:t.ownerDocument).createTextNode(i))[Qi]=n,n.stateNode=i)}return null;case 13:return _s(Bl),i=n.memoizedState,0!==(64&n.flags)?(n.lanes=t,n):(i=null!==i,t=!1,null===e?void 0!==n.memoizedProps.fallback&&Yl(n):t=null!==e.memoizedState,i&&!t&&0!==(2&n.mode)&&(null===e&&!0!==n.memoizedProps.unstable_avoidThisFallback||0!==(1&Bl.current)?0===Oa&&(Oa=3):(0!==Oa&&3!==Oa||(Oa=4),null===Ta||0===(134217727&Ca)&&0===(134217727&qa)||Ed(Ta,Ua))),(i||t)&&(n.flags|=4),null);case 4:return Wl(),Pr(n),null===e&&Vi(n.stateNode.containerInfo),null;case 10:return tl(n),null;case 19:if(_s(Bl),null===(i=n.memoizedState))return null;if(a=0!==(64&n.flags),null===(_=i.rendering))if(a)la(i,!1);else{if(0!==Oa||null!==e&&0!==(64&e.flags))for(e=n.child;null!==e;){if(null!==(_=Ol(e))){for(n.flags|=64,la(i,!1),null!==(a=_.updateQueue)&&(n.updateQueue=a,n.flags|=4),null===i.lastEffect&&(n.firstEffect=null),n.lastEffect=i.lastEffect,i=t,t=n.child;null!==t;)e=i,(a=t).flags&=2,a.nextEffect=null,a.firstEffect=null,a.lastEffect=null,null===(_=a.alternate)?(a.childLanes=0,a.lanes=e,a.child=null,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=_.childLanes,a.lanes=_.lanes,a.child=_.child,a.memoizedProps=_.memoizedProps,a.memoizedState=_.memoizedState,a.updateQueue=_.updateQueue,a.type=_.type,e=_.dependencies,a.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),t=t.sibling;return os(Bl,1&Bl.current|2),n.child}e=e.sibling}null!==i.tail&&Hs()>Ya&&(n.flags|=64,a=!0,la(i,!1),n.lanes=33554432)}else{if(!a)if(null!==(e=Ol(_))){if(n.flags|=64,a=!0,null!==(t=e.updateQueue)&&(n.updateQueue=t,n.flags|=4),la(i,!0),null===i.tail&&"hidden"===i.tailMode&&!_.alternate&&!Cl)return null!==(n=n.lastEffect=i.lastEffect)&&(n.nextEffect=null),null}else 2*Hs()-i.renderingStartTime>Ya&&1073741824!==t&&(n.flags|=64,a=!0,la(i,!1),n.lanes=33554432);i.isBackwards?(_.sibling=n.child,n.child=_):(null!==(t=i.last)?t.sibling=_:n.child=_,i.last=_)}return null!==i.tail?(t=i.tail,i.rendering=t,i.tail=t.sibling,i.lastEffect=n.lastEffect,i.renderingStartTime=Hs(),t.sibling=null,n=Bl.current,os(Bl,a?1&n|2:1&n),t):null;case 23:case 24:return xd(),null!==e&&null!==e.memoizedState!==(null!==n.memoizedState)&&"unstable-defer-without-hiding"!==i.mode&&(n.flags|=4),null}throw Error(r(156,n.tag))}function aa(e){switch(e.tag){case 1:ps(e.type)&&Es();var n=e.flags;return 4096&n?(e.flags=-4097&n|64,e):null;case 3:if(Wl(),_s(fs),_s(vs),Gl(),0!==(64&(n=e.flags)))throw Error(r(285));return e.flags=-4097&n|64,e;case 5:return Il(e),null;case 13:return _s(Bl),4096&(n=e.flags)?(e.flags=-4097&n|64,e):null;case 19:return _s(Bl),null;case 4:return Wl(),null;case 10:return tl(e),null;case 23:case 24:return xd(),null;default:return null}}function da(e,n){try{var t="",i=n;do{t+=Z(i),i=i.return}while(i);var s=t}catch(l){s="\nError generating stack: "+l.message+"\n"+l.stack}return{value:e,source:n,stack:s}}function _a(e,n){try{console.error(n.value)}catch(t){setTimeout((function(){throw t}))}}Zr=function(e,n){for(var t=n.child;null!==t;){if(5===t.tag||6===t.tag)e.appendChild(t.stateNode);else if(4!==t.tag&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===n)break;for(;null===t.sibling;){if(null===t.return||t.return===n)return;t=t.return}t.sibling.return=t.return,t=t.sibling}},Pr=function(){},Gr=function(e,n,t,i){var l=e.memoizedProps;if(l!==i){e=n.stateNode,Vl(Sl.current);var r,a=null;switch(t){case"input":l=$(e,l),i=$(e,i),a=[];break;case"option":l=le(e,l),i=le(e,i),a=[];break;case"select":l=s({},l,{value:void 0}),i=s({},i,{value:void 0}),a=[];break;case"textarea":l=ae(e,l),i=ae(e,i),a=[];break;default:"function"!==typeof l.onClick&&"function"===typeof i.onClick&&(e.onclick=Xi)}for(m in ze(t,i),t=null,l)if(!i.hasOwnProperty(m)&&l.hasOwnProperty(m)&&null!=l[m])if("style"===m){var _=l[m];for(r in _)_.hasOwnProperty(r)&&(t||(t={}),t[r]="")}else"dangerouslySetInnerHTML"!==m&&"children"!==m&&"suppressContentEditableWarning"!==m&&"suppressHydrationWarning"!==m&&"autoFocus"!==m&&(d.hasOwnProperty(m)?a||(a=[]):(a=a||[]).push(m,null));for(m in i){var o=i[m];if(_=null!=l?l[m]:void 0,i.hasOwnProperty(m)&&o!==_&&(null!=o||null!=_))if("style"===m)if(_){for(r in _)!_.hasOwnProperty(r)||o&&o.hasOwnProperty(r)||(t||(t={}),t[r]="");for(r in o)o.hasOwnProperty(r)&&_[r]!==o[r]&&(t||(t={}),t[r]=o[r])}else t||(a||(a=[]),a.push(m,t)),t=o;else"dangerouslySetInnerHTML"===m?(o=o?o.__html:void 0,_=_?_.__html:void 0,null!=o&&_!==o&&(a=a||[]).push(m,o)):"children"===m?"string"!==typeof o&&"number"!==typeof o||(a=a||[]).push(m,""+o):"suppressContentEditableWarning"!==m&&"suppressHydrationWarning"!==m&&(d.hasOwnProperty(m)?(null!=o&&"onScroll"===m&&Ai("scroll",e),a||_===o||(a=[])):"object"===typeof o&&null!==o&&o.$$typeof===I?o.toString():(a=a||[]).push(m,o))}t&&(a=a||[]).push("style",t);var m=a;(n.updateQueue=m)&&(n.flags|=4)}},jr=function(e,n,t,i){t!==i&&(n.flags|=4)};var oa="function"===typeof WeakMap?WeakMap:Map;function ma(e,n,t){(t=_l(-1,t)).tag=3,t.payload={element:null};var i=n.value;return t.callback=function(){ja||(ja=!0,Ka=i),_a(0,n)},t}function va(e,n,t){(t=_l(-1,t)).tag=3;var i=e.type.getDerivedStateFromError;if("function"===typeof i){var s=n.value;t.payload=function(){return _a(0,n),i(s)}}var l=e.stateNode;return null!==l&&"function"===typeof l.componentDidCatch&&(t.callback=function(){"function"!==typeof i&&(null===Qa?Qa=new Set([this]):Qa.add(this),_a(0,n));var e=n.stack;this.componentDidCatch(n.value,{componentStack:null!==e?e:""})}),t}var fa="function"===typeof WeakSet?WeakSet:Set;function ua(e){var n=e.ref;if(null!==n)if("function"===typeof n)try{n(null)}catch(t){Xd(e,t)}else n.current=null}function ca(e,n){switch(n.tag){case 0:case 11:case 15:case 22:case 5:case 6:case 4:case 17:return;case 1:if(256&n.flags&&null!==e){var t=e.memoizedProps,i=e.memoizedState;n=(e=n.stateNode).getSnapshotBeforeUpdate(n.elementType===n.type?t:Ks(n.type,t),i),e.__reactInternalSnapshotBeforeUpdate=n}return;case 3:return void(256&n.flags&&Zi(n.stateNode.containerInfo))}throw Error(r(163))}function pa(e,n,t){switch(t.tag){case 0:case 11:case 15:case 22:if(null!==(n=null!==(n=t.updateQueue)?n.lastEffect:null)){e=n=n.next;do{if(3===(3&e.tag)){var i=e.create;e.destroy=i()}e=e.next}while(e!==n)}if(null!==(n=null!==(n=t.updateQueue)?n.lastEffect:null)){e=n=n.next;do{var s=e;i=s.next,0!==(4&(s=s.tag))&&0!==(1&s)&&(Bd(t,e),Id(t,e)),e=i}while(e!==n)}return;case 1:return e=t.stateNode,4&t.flags&&(null===n?e.componentDidMount():(i=t.elementType===t.type?n.memoizedProps:Ks(t.type,n.memoizedProps),e.componentDidUpdate(i,n.memoizedState,e.__reactInternalSnapshotBeforeUpdate))),void(null!==(n=t.updateQueue)&&fl(t,n,e));case 3:if(null!==(n=t.updateQueue)){if(e=null,null!==t.child)switch(t.child.tag){case 5:case 1:e=t.child.stateNode}fl(t,n,e)}return;case 5:return e=t.stateNode,void(null===n&&4&t.flags&&Hi(t.type,t.memoizedProps)&&e.focus());case 6:case 4:case 12:case 19:case 17:case 20:case 21:case 23:case 24:return;case 13:return void(null===t.memoizedState&&(t=t.alternate,null!==t&&(t=t.memoizedState,null!==t&&(t=t.dehydrated,null!==t&&xn(t)))))}throw Error(r(163))}function Ea(e,n){for(var t=e;;){if(5===t.tag){var i=t.stateNode;if(n)"function"===typeof(i=i.style).setProperty?i.setProperty("display","none","important"):i.display="none";else{i=t.stateNode;var s=t.memoizedProps.style;s=void 0!==s&&null!==s&&s.hasOwnProperty("display")?s.display:null,i.style.display=we("display",s)}}else if(6===t.tag)t.stateNode.nodeValue=n?"":t.memoizedProps;else if((23!==t.tag&&24!==t.tag||null===t.memoizedState||t===e)&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return;t=t.return}t.sibling.return=t.return,t=t.sibling}}function ha(e,n){if(zs&&"function"===typeof zs.onCommitFiberUnmount)try{zs.onCommitFiberUnmount(xs,n)}catch(l){}switch(n.tag){case 0:case 11:case 14:case 15:case 22:if(null!==(e=n.updateQueue)&&null!==(e=e.lastEffect)){var t=e=e.next;do{var i=t,s=i.destroy;if(i=i.tag,void 0!==s)if(0!==(4&i))Bd(n,t);else{i=n;try{s()}catch(l){Xd(i,l)}}t=t.next}while(t!==e)}break;case 1:if(ua(n),"function"===typeof(e=n.stateNode).componentWillUnmount)try{e.props=n.memoizedProps,e.state=n.memoizedState,e.componentWillUnmount()}catch(l){Xd(n,l)}break;case 5:ua(n);break;case 4:La(e,n)}}function ga(e){e.alternate=null,e.child=null,e.dependencies=null,e.firstEffect=null,e.lastEffect=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.return=null,e.updateQueue=null}function wa(e){return 5===e.tag||3===e.tag||4===e.tag}function ba(e){e:{for(var n=e.return;null!==n;){if(wa(n))break e;n=n.return}throw Error(r(160))}var t=n;switch(n=t.stateNode,t.tag){case 5:var i=!1;break;case 3:case 4:n=n.containerInfo,i=!0;break;default:throw Error(r(161))}16&t.flags&&(Ee(n,""),t.flags&=-17);e:n:for(t=e;;){for(;null===t.sibling;){if(null===t.return||wa(t.return)){t=null;break e}t=t.return}for(t.sibling.return=t.return,t=t.sibling;5!==t.tag&&6!==t.tag&&18!==t.tag;){if(2&t.flags)continue n;if(null===t.child||4===t.tag)continue n;t.child.return=t,t=t.child}if(!(2&t.flags)){t=t.stateNode;break e}}i?xa(e,t,n):za(e,t,n)}function xa(e,n,t){var i=e.tag,s=5===i||6===i;if(s)e=s?e.stateNode:e.stateNode.instance,n?8===t.nodeType?t.parentNode.insertBefore(e,n):t.insertBefore(e,n):(8===t.nodeType?(n=t.parentNode).insertBefore(e,t):(n=t).appendChild(e),null!==(t=t._reactRootContainer)&&void 0!==t||null!==n.onclick||(n.onclick=Xi));else if(4!==i&&null!==(e=e.child))for(xa(e,n,t),e=e.sibling;null!==e;)xa(e,n,t),e=e.sibling}function za(e,n,t){var i=e.tag,s=5===i||6===i;if(s)e=s?e.stateNode:e.stateNode.instance,n?t.insertBefore(e,n):t.appendChild(e);else if(4!==i&&null!==(e=e.child))for(za(e,n,t),e=e.sibling;null!==e;)za(e,n,t),e=e.sibling}function La(e,n){for(var t,i,s=n,l=!1;;){if(!l){l=s.return;e:for(;;){if(null===l)throw Error(r(160));switch(t=l.stateNode,l.tag){case 5:i=!1;break e;case 3:case 4:t=t.containerInfo,i=!0;break e}l=l.return}l=!0}if(5===s.tag||6===s.tag){e:for(var a=e,d=s,_=d;;)if(ha(a,_),null!==_.child&&4!==_.tag)_.child.return=_,_=_.child;else{if(_===d)break e;for(;null===_.sibling;){if(null===_.return||_.return===d)break e;_=_.return}_.sibling.return=_.return,_=_.sibling}i?(a=t,d=s.stateNode,8===a.nodeType?a.parentNode.removeChild(d):a.removeChild(d)):t.removeChild(s.stateNode)}else if(4===s.tag){if(null!==s.child){t=s.stateNode.containerInfo,i=!0,s.child.return=s,s=s.child;continue}}else if(ha(e,s),null!==s.child){s.child.return=s,s=s.child;continue}if(s===n)break;for(;null===s.sibling;){if(null===s.return||s.return===n)return;4===(s=s.return).tag&&(l=!1)}s.sibling.return=s.return,s=s.sibling}}function Ma(e,n){switch(n.tag){case 0:case 11:case 14:case 15:case 22:var t=n.updateQueue;if(null!==(t=null!==t?t.lastEffect:null)){var i=t=t.next;do{3===(3&i.tag)&&(e=i.destroy,i.destroy=void 0,void 0!==e&&e()),i=i.next}while(i!==t)}return;case 1:case 12:case 17:return;case 5:if(null!=(t=n.stateNode)){i=n.memoizedProps;var s=null!==e?e.memoizedProps:i;e=n.type;var l=n.updateQueue;if(n.updateQueue=null,null!==l){for(t[Ji]=i,"input"===e&&"radio"===i.type&&null!=i.name&&ne(t,i),Le(e,s),n=Le(e,i),s=0;s<l.length;s+=2){var a=l[s],d=l[s+1];"style"===a?be(t,d):"dangerouslySetInnerHTML"===a?pe(t,d):"children"===a?Ee(t,d):w(t,a,d,n)}switch(e){case"input":te(t,i);break;case"textarea":_e(t,i);break;case"select":e=t._wrapperState.wasMultiple,t._wrapperState.wasMultiple=!!i.multiple,null!=(l=i.value)?re(t,!!i.multiple,l,!1):e!==!!i.multiple&&(null!=i.defaultValue?re(t,!!i.multiple,i.defaultValue,!0):re(t,!!i.multiple,i.multiple?[]:"",!1))}}}return;case 6:if(null===n.stateNode)throw Error(r(162));return void(n.stateNode.nodeValue=n.memoizedProps);case 3:return void((t=n.stateNode).hydrate&&(t.hydrate=!1,xn(t.containerInfo)));case 13:return null!==n.memoizedState&&(Na=Hs(),Ea(n.child,!0)),void ya(n);case 19:return void ya(n);case 23:case 24:return void Ea(n,null!==n.memoizedState)}throw Error(r(163))}function ya(e){var n=e.updateQueue;if(null!==n){e.updateQueue=null;var t=e.stateNode;null===t&&(t=e.stateNode=new fa),n.forEach((function(n){var i=qd.bind(null,e,n);t.has(n)||(t.add(n),n.then(i,i))}))}}function Ra(e,n){return null!==e&&(null===(e=e.memoizedState)||null!==e.dehydrated)&&(null!==(n=n.memoizedState)&&null===n.dehydrated)}var Sa=Math.ceil,Aa=b.ReactCurrentDispatcher,Da=b.ReactCurrentOwner,Va=0,Ta=null,Wa=null,Ua=0,Ia=0,Ba=ds(0),Oa=0,Fa=null,Xa=0,Ca=0,qa=0,Ha=0,ka=null,Na=0,Ya=1/0;function Za(){Ya=Hs()+500}var Pa,Ga=null,ja=!1,Ka=null,Qa=null,Ja=!1,$a=null,ed=90,nd=[],td=[],id=null,sd=0,ld=null,rd=-1,ad=0,dd=0,_d=null,od=!1;function md(){return 0!==(48&Va)?Hs():-1!==rd?rd:rd=Hs()}function vd(e){if(0===(2&(e=e.mode)))return 1;if(0===(4&e))return 99===ks()?1:2;if(0===ad&&(ad=Xa),0!==js.transition){0!==dd&&(dd=null!==ka?ka.pendingLanes:0),e=ad;var n=4186112&~dd;return 0===(n&=-n)&&(0===(n=(e=4186112&~e)&-e)&&(n=8192)),n}return e=ks(),0!==(4&Va)&&98===e?e=Cn(12,ad):e=Cn(e=function(e){switch(e){case 99:return 15;case 98:return 10;case 97:case 96:return 8;case 95:return 2;default:return 0}}(e),ad),e}function fd(e,n,t){if(50<sd)throw sd=0,ld=null,Error(r(185));if(null===(e=ud(e,n)))return null;kn(e,n,t),e===Ta&&(qa|=n,4===Oa&&Ed(e,Ua));var i=ks();1===n?0!==(8&Va)&&0===(48&Va)?hd(e):(cd(e,t),0===Va&&(Za(),Ps())):(0===(4&Va)||98!==i&&99!==i||(null===id?id=new Set([e]):id.add(e)),cd(e,t)),ka=e}function ud(e,n){e.lanes|=n;var t=e.alternate;for(null!==t&&(t.lanes|=n),t=e,e=e.return;null!==e;)e.childLanes|=n,null!==(t=e.alternate)&&(t.childLanes|=n),t=e,e=e.return;return 3===t.tag?t.stateNode:null}function cd(e,n){for(var t=e.callbackNode,i=e.suspendedLanes,s=e.pingedLanes,l=e.expirationTimes,a=e.pendingLanes;0<a;){var d=31-Nn(a),_=1<<d,o=l[d];if(-1===o){if(0===(_&i)||0!==(_&s)){o=n,On(_);var m=Bn;l[d]=10<=m?o+250:6<=m?o+5e3:-1}}else o<=n&&(e.expiredLanes|=_);a&=~_}if(i=Fn(e,e===Ta?Ua:0),n=Bn,0===i)null!==t&&(t!==Bs&&ys(t),e.callbackNode=null,e.callbackPriority=0);else{if(null!==t){if(e.callbackPriority===n)return;t!==Bs&&ys(t)}15===n?(t=hd.bind(null,e),null===Fs?(Fs=[t],Xs=Ms(Vs,Gs)):Fs.push(t),t=Bs):14===n?t=Zs(99,hd.bind(null,e)):(t=function(e){switch(e){case 15:case 14:return 99;case 13:case 12:case 11:case 10:return 98;case 9:case 8:case 7:case 6:case 4:case 5:return 97;case 3:case 2:case 1:return 95;case 0:return 90;default:throw Error(r(358,e))}}(n),t=Zs(t,pd.bind(null,e))),e.callbackPriority=n,e.callbackNode=t}}function pd(e){if(rd=-1,dd=ad=0,0!==(48&Va))throw Error(r(327));var n=e.callbackNode;if(Ud()&&e.callbackNode!==n)return null;var t=Fn(e,e===Ta?Ua:0);if(0===t)return null;var i=t,s=Va;Va|=16;var l=Md();for(Ta===e&&Ua===i||(Za(),zd(e,i));;)try{Sd();break}catch(d){Ld(e,d)}if(nl(),Aa.current=l,Va=s,null!==Wa?i=0:(Ta=null,Ua=0,i=Oa),0!==(Xa&qa))zd(e,0);else if(0!==i){if(2===i&&(Va|=64,e.hydrate&&(e.hydrate=!1,Zi(e.containerInfo)),0!==(t=Xn(e))&&(i=yd(e,t))),1===i)throw n=Fa,zd(e,0),Ed(e,t),cd(e,Hs()),n;switch(e.finishedWork=e.current.alternate,e.finishedLanes=t,i){case 0:case 1:throw Error(r(345));case 2:case 5:Vd(e);break;case 3:if(Ed(e,t),(62914560&t)===t&&10<(i=Na+500-Hs())){if(0!==Fn(e,0))break;if(((s=e.suspendedLanes)&t)!==t){md(),e.pingedLanes|=e.suspendedLanes&s;break}e.timeoutHandle=Ni(Vd.bind(null,e),i);break}Vd(e);break;case 4:if(Ed(e,t),(4186112&t)===t)break;for(i=e.eventTimes,s=-1;0<t;){var a=31-Nn(t);l=1<<a,(a=i[a])>s&&(s=a),t&=~l}if(t=s,10<(t=(120>(t=Hs()-t)?120:480>t?480:1080>t?1080:1920>t?1920:3e3>t?3e3:4320>t?4320:1960*Sa(t/1960))-t)){e.timeoutHandle=Ni(Vd.bind(null,e),t);break}Vd(e);break;default:throw Error(r(329))}}return cd(e,Hs()),e.callbackNode===n?pd.bind(null,e):null}function Ed(e,n){for(n&=~Ha,n&=~qa,e.suspendedLanes|=n,e.pingedLanes&=~n,e=e.expirationTimes;0<n;){var t=31-Nn(n),i=1<<t;e[t]=-1,n&=~i}}function hd(e){if(0!==(48&Va))throw Error(r(327));if(Ud(),e===Ta&&0!==(e.expiredLanes&Ua)){var n=Ua,t=yd(e,n);0!==(Xa&qa)&&(t=yd(e,n=Fn(e,n)))}else t=yd(e,n=Fn(e,0));if(0!==e.tag&&2===t&&(Va|=64,e.hydrate&&(e.hydrate=!1,Zi(e.containerInfo)),0!==(n=Xn(e))&&(t=yd(e,n))),1===t)throw t=Fa,zd(e,0),Ed(e,n),cd(e,Hs()),t;return e.finishedWork=e.current.alternate,e.finishedLanes=n,Vd(e),cd(e,Hs()),null}function gd(e,n){var t=Va;Va|=1;try{return e(n)}finally{0===(Va=t)&&(Za(),Ps())}}function wd(e,n){var t=Va;Va&=-2,Va|=8;try{return e(n)}finally{0===(Va=t)&&(Za(),Ps())}}function bd(e,n){os(Ba,Ia),Ia|=n,Xa|=n}function xd(){Ia=Ba.current,_s(Ba)}function zd(e,n){e.finishedWork=null,e.finishedLanes=0;var t=e.timeoutHandle;if(-1!==t&&(e.timeoutHandle=-1,Yi(t)),null!==Wa)for(t=Wa.return;null!==t;){var i=t;switch(i.tag){case 1:null!==(i=i.type.childContextTypes)&&void 0!==i&&Es();break;case 3:Wl(),_s(fs),_s(vs),Gl();break;case 5:Il(i);break;case 4:Wl();break;case 13:case 19:_s(Bl);break;case 10:tl(i);break;case 23:case 24:xd()}t=t.return}Ta=e,Wa=Yd(e.current,null),Ua=Ia=Xa=n,Oa=0,Fa=null,Ha=qa=Ca=0}function Ld(e,n){for(;;){var t=Wa;try{if(nl(),jl.current=Dr,nr){for(var i=Jl.memoizedState;null!==i;){var s=i.queue;null!==s&&(s.pending=null),i=i.next}nr=!1}if(Ql=0,er=$l=Jl=null,tr=!1,Da.current=null,null===t||null===t.return){Oa=1,Fa=n,Wa=null;break}e:{var l=e,r=t.return,a=t,d=n;if(n=Ua,a.flags|=2048,a.firstEffect=a.lastEffect=null,null!==d&&"object"===typeof d&&"function"===typeof d.then){var _=d;if(0===(2&a.mode)){var o=a.alternate;o?(a.updateQueue=o.updateQueue,a.memoizedState=o.memoizedState,a.lanes=o.lanes):(a.updateQueue=null,a.memoizedState=null)}var m=0!==(1&Bl.current),v=r;do{var f;if(f=13===v.tag){var u=v.memoizedState;if(null!==u)f=null!==u.dehydrated;else{var c=v.memoizedProps;f=void 0!==c.fallback&&(!0!==c.unstable_avoidThisFallback||!m)}}if(f){var p=v.updateQueue;if(null===p){var E=new Set;E.add(_),v.updateQueue=E}else p.add(_);if(0===(2&v.mode)){if(v.flags|=64,a.flags|=16384,a.flags&=-2981,1===a.tag)if(null===a.alternate)a.tag=17;else{var h=_l(-1,1);h.tag=2,ol(a,h)}a.lanes|=1;break e}d=void 0,a=n;var g=l.pingCache;if(null===g?(g=l.pingCache=new oa,d=new Set,g.set(_,d)):void 0===(d=g.get(_))&&(d=new Set,g.set(_,d)),!d.has(a)){d.add(a);var w=Cd.bind(null,l,_,a);_.then(w,w)}v.flags|=4096,v.lanes=n;break e}v=v.return}while(null!==v);d=Error((P(a.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.")}5!==Oa&&(Oa=2),d=da(d,a),v=r;do{switch(v.tag){case 3:l=d,v.flags|=4096,n&=-n,v.lanes|=n,ml(v,ma(0,l,n));break e;case 1:l=d;var b=v.type,x=v.stateNode;if(0===(64&v.flags)&&("function"===typeof b.getDerivedStateFromError||null!==x&&"function"===typeof x.componentDidCatch&&(null===Qa||!Qa.has(x)))){v.flags|=4096,n&=-n,v.lanes|=n,ml(v,va(v,l,n));break e}}v=v.return}while(null!==v)}Dd(t)}catch(z){n=z,Wa===t&&null!==t&&(Wa=t=t.return);continue}break}}function Md(){var e=Aa.current;return Aa.current=Dr,null===e?Dr:e}function yd(e,n){var t=Va;Va|=16;var i=Md();for(Ta===e&&Ua===n||zd(e,n);;)try{Rd();break}catch(s){Ld(e,s)}if(nl(),Va=t,Aa.current=i,null!==Wa)throw Error(r(261));return Ta=null,Ua=0,Oa}function Rd(){for(;null!==Wa;)Ad(Wa)}function Sd(){for(;null!==Wa&&!Rs();)Ad(Wa)}function Ad(e){var n=Pa(e.alternate,e,Ia);e.memoizedProps=e.pendingProps,null===n?Dd(e):Wa=n,Da.current=null}function Dd(e){var n=e;do{var t=n.alternate;if(e=n.return,0===(2048&n.flags)){if(null!==(t=ra(t,n,Ia)))return void(Wa=t);if(24!==(t=n).tag&&23!==t.tag||null===t.memoizedState||0!==(1073741824&Ia)||0===(4&t.mode)){for(var i=0,s=t.child;null!==s;)i|=s.lanes|s.childLanes,s=s.sibling;t.childLanes=i}null!==e&&0===(2048&e.flags)&&(null===e.firstEffect&&(e.firstEffect=n.firstEffect),null!==n.lastEffect&&(null!==e.lastEffect&&(e.lastEffect.nextEffect=n.firstEffect),e.lastEffect=n.lastEffect),1<n.flags&&(null!==e.lastEffect?e.lastEffect.nextEffect=n:e.firstEffect=n,e.lastEffect=n))}else{if(null!==(t=aa(n)))return t.flags&=2047,void(Wa=t);null!==e&&(e.firstEffect=e.lastEffect=null,e.flags|=2048)}if(null!==(n=n.sibling))return void(Wa=n);Wa=n=e}while(null!==n);0===Oa&&(Oa=5)}function Vd(e){var n=ks();return Ys(99,Td.bind(null,e,n)),null}function Td(e,n){do{Ud()}while(null!==$a);if(0!==(48&Va))throw Error(r(327));var t=e.finishedWork;if(null===t)return null;if(e.finishedWork=null,e.finishedLanes=0,t===e.current)throw Error(r(177));e.callbackNode=null;var i=t.lanes|t.childLanes,s=i,l=e.pendingLanes&~s;e.pendingLanes=s,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=s,e.mutableReadLanes&=s,e.entangledLanes&=s,s=e.entanglements;for(var a=e.eventTimes,d=e.expirationTimes;0<l;){var _=31-Nn(l),o=1<<_;s[_]=0,a[_]=-1,d[_]=-1,l&=~o}if(null!==id&&0===(24&i)&&id.has(e)&&id.delete(e),e===Ta&&(Wa=Ta=null,Ua=0),1<t.flags?null!==t.lastEffect?(t.lastEffect.nextEffect=t,i=t.firstEffect):i=t:i=t.firstEffect,null!==i){if(s=Va,Va|=32,Da.current=null,Ci=jn,pi(a=ci())){if("selectionStart"in a)d={start:a.selectionStart,end:a.selectionEnd};else e:if(d=(d=a.ownerDocument)&&d.defaultView||window,(o=d.getSelection&&d.getSelection())&&0!==o.rangeCount){d=o.anchorNode,l=o.anchorOffset,_=o.focusNode,o=o.focusOffset;try{d.nodeType,_.nodeType}catch(y){d=null;break e}var m=0,v=-1,f=-1,u=0,c=0,p=a,E=null;n:for(;;){for(var h;p!==d||0!==l&&3!==p.nodeType||(v=m+l),p!==_||0!==o&&3!==p.nodeType||(f=m+o),3===p.nodeType&&(m+=p.nodeValue.length),null!==(h=p.firstChild);)E=p,p=h;for(;;){if(p===a)break n;if(E===d&&++u===l&&(v=m),E===_&&++c===o&&(f=m),null!==(h=p.nextSibling))break;E=(p=E).parentNode}p=h}d=-1===v||-1===f?null:{start:v,end:f}}else d=null;d=d||{start:0,end:0}}else d=null;qi={focusedElem:a,selectionRange:d},jn=!1,_d=null,od=!1,Ga=i;do{try{Wd()}catch(y){if(null===Ga)throw Error(r(330));Xd(Ga,y),Ga=Ga.nextEffect}}while(null!==Ga);_d=null,Ga=i;do{try{for(a=e;null!==Ga;){var g=Ga.flags;if(16&g&&Ee(Ga.stateNode,""),128&g){var w=Ga.alternate;if(null!==w){var b=w.ref;null!==b&&("function"===typeof b?b(null):b.current=null)}}switch(1038&g){case 2:ba(Ga),Ga.flags&=-3;break;case 6:ba(Ga),Ga.flags&=-3,Ma(Ga.alternate,Ga);break;case 1024:Ga.flags&=-1025;break;case 1028:Ga.flags&=-1025,Ma(Ga.alternate,Ga);break;case 4:Ma(Ga.alternate,Ga);break;case 8:La(a,d=Ga);var x=d.alternate;ga(d),null!==x&&ga(x)}Ga=Ga.nextEffect}}catch(y){if(null===Ga)throw Error(r(330));Xd(Ga,y),Ga=Ga.nextEffect}}while(null!==Ga);if(b=qi,w=ci(),g=b.focusedElem,a=b.selectionRange,w!==g&&g&&g.ownerDocument&&ui(g.ownerDocument.documentElement,g)){null!==a&&pi(g)&&(w=a.start,void 0===(b=a.end)&&(b=w),"selectionStart"in g?(g.selectionStart=w,g.selectionEnd=Math.min(b,g.value.length)):(b=(w=g.ownerDocument||document)&&w.defaultView||window).getSelection&&(b=b.getSelection(),d=g.textContent.length,x=Math.min(a.start,d),a=void 0===a.end?x:Math.min(a.end,d),!b.extend&&x>a&&(d=a,a=x,x=d),d=fi(g,x),l=fi(g,a),d&&l&&(1!==b.rangeCount||b.anchorNode!==d.node||b.anchorOffset!==d.offset||b.focusNode!==l.node||b.focusOffset!==l.offset)&&((w=w.createRange()).setStart(d.node,d.offset),b.removeAllRanges(),x>a?(b.addRange(w),b.extend(l.node,l.offset)):(w.setEnd(l.node,l.offset),b.addRange(w))))),w=[];for(b=g;b=b.parentNode;)1===b.nodeType&&w.push({element:b,left:b.scrollLeft,top:b.scrollTop});for("function"===typeof g.focus&&g.focus(),g=0;g<w.length;g++)(b=w[g]).element.scrollLeft=b.left,b.element.scrollTop=b.top}jn=!!Ci,qi=Ci=null,e.current=t,Ga=i;do{try{for(g=e;null!==Ga;){var z=Ga.flags;if(36&z&&pa(g,Ga.alternate,Ga),128&z){w=void 0;var L=Ga.ref;if(null!==L){var M=Ga.stateNode;Ga.tag,w=M,"function"===typeof L?L(w):L.current=w}}Ga=Ga.nextEffect}}catch(y){if(null===Ga)throw Error(r(330));Xd(Ga,y),Ga=Ga.nextEffect}}while(null!==Ga);Ga=null,Os(),Va=s}else e.current=t;if(Ja)Ja=!1,$a=e,ed=n;else for(Ga=i;null!==Ga;)n=Ga.nextEffect,Ga.nextEffect=null,8&Ga.flags&&((z=Ga).sibling=null,z.stateNode=null),Ga=n;if(0===(i=e.pendingLanes)&&(Qa=null),1===i?e===ld?sd++:(sd=0,ld=e):sd=0,t=t.stateNode,zs&&"function"===typeof zs.onCommitFiberRoot)try{zs.onCommitFiberRoot(xs,t,void 0,64===(64&t.current.flags))}catch(y){}if(cd(e,Hs()),ja)throw ja=!1,e=Ka,Ka=null,e;return 0!==(8&Va)||Ps(),null}function Wd(){for(;null!==Ga;){var e=Ga.alternate;od||null===_d||(0!==(8&Ga.flags)?$e(Ga,_d)&&(od=!0):13===Ga.tag&&Ra(e,Ga)&&$e(Ga,_d)&&(od=!0));var n=Ga.flags;0!==(256&n)&&ca(e,Ga),0===(512&n)||Ja||(Ja=!0,Zs(97,(function(){return Ud(),null}))),Ga=Ga.nextEffect}}function Ud(){if(90!==ed){var e=97<ed?97:ed;return ed=90,Ys(e,Od)}return!1}function Id(e,n){nd.push(n,e),Ja||(Ja=!0,Zs(97,(function(){return Ud(),null})))}function Bd(e,n){td.push(n,e),Ja||(Ja=!0,Zs(97,(function(){return Ud(),null})))}function Od(){if(null===$a)return!1;var e=$a;if($a=null,0!==(48&Va))throw Error(r(331));var n=Va;Va|=32;var t=td;td=[];for(var i=0;i<t.length;i+=2){var s=t[i],l=t[i+1],a=s.destroy;if(s.destroy=void 0,"function"===typeof a)try{a()}catch(_){if(null===l)throw Error(r(330));Xd(l,_)}}for(t=nd,nd=[],i=0;i<t.length;i+=2){s=t[i],l=t[i+1];try{var d=s.create;s.destroy=d()}catch(_){if(null===l)throw Error(r(330));Xd(l,_)}}for(d=e.current.firstEffect;null!==d;)e=d.nextEffect,d.nextEffect=null,8&d.flags&&(d.sibling=null,d.stateNode=null),d=e;return Va=n,Ps(),!0}function Fd(e,n,t){ol(e,n=ma(0,n=da(t,n),1)),n=md(),null!==(e=ud(e,1))&&(kn(e,1,n),cd(e,n))}function Xd(e,n){if(3===e.tag)Fd(e,e,n);else for(var t=e.return;null!==t;){if(3===t.tag){Fd(t,e,n);break}if(1===t.tag){var i=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof i.componentDidCatch&&(null===Qa||!Qa.has(i))){var s=va(t,e=da(n,e),1);if(ol(t,s),s=md(),null!==(t=ud(t,1)))kn(t,1,s),cd(t,s);else if("function"===typeof i.componentDidCatch&&(null===Qa||!Qa.has(i)))try{i.componentDidCatch(n,e)}catch(l){}break}}t=t.return}}function Cd(e,n,t){var i=e.pingCache;null!==i&&i.delete(n),n=md(),e.pingedLanes|=e.suspendedLanes&t,Ta===e&&(Ua&t)===t&&(4===Oa||3===Oa&&(62914560&Ua)===Ua&&500>Hs()-Na?zd(e,0):Ha|=t),cd(e,n)}function qd(e,n){var t=e.stateNode;null!==t&&t.delete(n),0===(n=0)&&(0===(2&(n=e.mode))?n=1:0===(4&n)?n=99===ks()?1:2:(0===ad&&(ad=Xa),0===(n=qn(62914560&~ad))&&(n=4194304))),t=md(),null!==(e=ud(e,n))&&(kn(e,n,t),cd(e,t))}function Hd(e,n,t,i){this.tag=e,this.key=t,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=n,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=i,this.flags=0,this.lastEffect=this.firstEffect=this.nextEffect=null,this.childLanes=this.lanes=0,this.alternate=null}function kd(e,n,t,i){return new Hd(e,n,t,i)}function Nd(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Yd(e,n){var t=e.alternate;return null===t?((t=kd(e.tag,n,e.key,e.mode)).elementType=e.elementType,t.type=e.type,t.stateNode=e.stateNode,t.alternate=e,e.alternate=t):(t.pendingProps=n,t.type=e.type,t.flags=0,t.nextEffect=null,t.firstEffect=null,t.lastEffect=null),t.childLanes=e.childLanes,t.lanes=e.lanes,t.child=e.child,t.memoizedProps=e.memoizedProps,t.memoizedState=e.memoizedState,t.updateQueue=e.updateQueue,n=e.dependencies,t.dependencies=null===n?null:{lanes:n.lanes,firstContext:n.firstContext},t.sibling=e.sibling,t.index=e.index,t.ref=e.ref,t}function Zd(e,n,t,i,s,l){var a=2;if(i=e,"function"===typeof e)Nd(e)&&(a=1);else if("string"===typeof e)a=5;else e:switch(e){case L:return Pd(t.children,s,l,n);case B:a=8,s|=16;break;case M:a=8,s|=1;break;case y:return(e=kd(12,t,n,8|s)).elementType=y,e.type=y,e.lanes=l,e;case D:return(e=kd(13,t,n,s)).type=D,e.elementType=D,e.lanes=l,e;case V:return(e=kd(19,t,n,s)).elementType=V,e.lanes=l,e;case O:return Gd(t,s,l,n);case F:return(e=kd(24,t,n,s)).elementType=F,e.lanes=l,e;default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case R:a=10;break e;case S:a=9;break e;case A:a=11;break e;case T:a=14;break e;case W:a=16,i=null;break e;case U:a=22;break e}throw Error(r(130,null==e?e:typeof e,""))}return(n=kd(a,t,n,s)).elementType=e,n.type=i,n.lanes=l,n}function Pd(e,n,t,i){return(e=kd(7,e,i,n)).lanes=t,e}function Gd(e,n,t,i){return(e=kd(23,e,i,n)).elementType=O,e.lanes=t,e}function jd(e,n,t){return(e=kd(6,e,null,n)).lanes=t,e}function Kd(e,n,t){return(n=kd(4,null!==e.children?e.children:[],e.key,n)).lanes=t,n.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},n}function Qd(e,n,t){this.tag=n,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.pendingContext=this.context=null,this.hydrate=t,this.callbackNode=null,this.callbackPriority=0,this.eventTimes=Hn(0),this.expirationTimes=Hn(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Hn(0),this.mutableSourceEagerHydrationData=null}function Jd(e,n,t,i){var s=n.current,l=md(),a=vd(s);e:if(t){n:{if(je(t=t._reactInternals)!==t||1!==t.tag)throw Error(r(170));var d=t;do{switch(d.tag){case 3:d=d.stateNode.context;break n;case 1:if(ps(d.type)){d=d.stateNode.__reactInternalMemoizedMergedChildContext;break n}}d=d.return}while(null!==d);throw Error(r(171))}if(1===t.tag){var _=t.type;if(ps(_)){t=gs(t,_,d);break e}}t=d}else t=ms;return null===n.context?n.context=t:n.pendingContext=t,(n=_l(l,a)).payload={element:e},null!==(i=void 0===i?null:i)&&(n.callback=i),ol(s,n),fd(s,a,l),a}function $d(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function e_(e,n){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var t=e.retryLane;e.retryLane=0!==t&&t<n?t:n}}function n_(e,n){e_(e,n),(e=e.alternate)&&e_(e,n)}function t_(e,n,t){var i=null!=t&&null!=t.hydrationOptions&&t.hydrationOptions.mutableSources||null;if(t=new Qd(e,n,null!=t&&!0===t.hydrate),n=kd(3,null,null,2===n?7:1===n?3:0),t.current=n,n.stateNode=t,al(n),e[$i]=t.current,Vi(8===e.nodeType?e.parentNode:e),i)for(e=0;e<i.length;e++){var s=(n=i[e])._getVersion;s=s(n._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[n,s]:t.mutableSourceEagerHydrationData.push(n,s)}this._internalRoot=t}function i_(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function s_(e,n,t,i,s){var l=t._reactRootContainer;if(l){var r=l._internalRoot;if("function"===typeof s){var a=s;s=function(){var e=$d(r);a.call(e)}}Jd(n,r,e,s)}else{if(l=t._reactRootContainer=function(e,n){if(n||(n=!(!(n=e?9===e.nodeType?e.documentElement:e.firstChild:null)||1!==n.nodeType||!n.hasAttribute("data-reactroot"))),!n)for(var t;t=e.lastChild;)e.removeChild(t);return new t_(e,0,n?{hydrate:!0}:void 0)}(t,i),r=l._internalRoot,"function"===typeof s){var d=s;s=function(){var e=$d(r);d.call(e)}}wd((function(){Jd(n,r,e,s)}))}return $d(r)}function l_(e,n){var t=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!i_(n))throw Error(r(200));return function(e,n,t){var i=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:z,key:null==i?null:""+i,children:e,containerInfo:n,implementation:t}}(e,n,null,t)}Pa=function(e,n,t){var i=n.lanes;if(null!==e)if(e.memoizedProps!==n.pendingProps||fs.current)Ir=!0;else{if(0===(t&i)){switch(Ir=!1,n.tag){case 3:Yr(n),Zl();break;case 5:Ul(n);break;case 1:ps(n.type)&&ws(n);break;case 4:Tl(n,n.stateNode.containerInfo);break;case 10:i=n.memoizedProps.value;var s=n.type._context;os(Qs,s._currentValue),s._currentValue=i;break;case 13:if(null!==n.memoizedState)return 0!==(t&n.child.childLanes)?Qr(e,n,t):(os(Bl,1&Bl.current),null!==(n=sa(e,n,t))?n.sibling:null);os(Bl,1&Bl.current);break;case 19:if(i=0!==(t&n.childLanes),0!==(64&e.flags)){if(i)return ia(e,n,t);n.flags|=64}if(null!==(s=n.memoizedState)&&(s.rendering=null,s.tail=null,s.lastEffect=null),os(Bl,Bl.current),i)break;return null;case 23:case 24:return n.lanes=0,Cr(e,n,t)}return sa(e,n,t)}Ir=0!==(16384&e.flags)}else Ir=!1;switch(n.lanes=0,n.tag){case 2:if(i=n.type,null!==e&&(e.alternate=null,n.alternate=null,n.flags|=2),e=n.pendingProps,s=cs(n,vs.current),sl(n,t),s=lr(null,n,i,e,s,t),n.flags|=1,"object"===typeof s&&null!==s&&"function"===typeof s.render&&void 0===s.$$typeof){if(n.tag=1,n.memoizedState=null,n.updateQueue=null,ps(i)){var l=!0;ws(n)}else l=!1;n.memoizedState=null!==s.state&&void 0!==s.state?s.state:null,al(n);var a=i.getDerivedStateFromProps;"function"===typeof a&&cl(n,i,a,e),s.updater=pl,n.stateNode=s,s._reactInternals=n,wl(n,i,e,t),n=Nr(null,n,i,!0,l,t)}else n.tag=0,Br(null,n,s,t),n=n.child;return n;case 16:s=n.elementType;e:{switch(null!==e&&(e.alternate=null,n.alternate=null,n.flags|=2),e=n.pendingProps,s=(l=s._init)(s._payload),n.type=s,l=n.tag=function(e){if("function"===typeof e)return Nd(e)?1:0;if(void 0!==e&&null!==e){if((e=e.$$typeof)===A)return 11;if(e===T)return 14}return 2}(s),e=Ks(s,e),l){case 0:n=Hr(null,n,s,e,t);break e;case 1:n=kr(null,n,s,e,t);break e;case 11:n=Or(null,n,s,e,t);break e;case 14:n=Fr(null,n,s,Ks(s.type,e),i,t);break e}throw Error(r(306,s,""))}return n;case 0:return i=n.type,s=n.pendingProps,Hr(e,n,i,s=n.elementType===i?s:Ks(i,s),t);case 1:return i=n.type,s=n.pendingProps,kr(e,n,i,s=n.elementType===i?s:Ks(i,s),t);case 3:if(Yr(n),i=n.updateQueue,null===e||null===i)throw Error(r(282));if(i=n.pendingProps,s=null!==(s=n.memoizedState)?s.element:null,dl(e,n),vl(n,i,null,t),(i=n.memoizedState.element)===s)Zl(),n=sa(e,n,t);else{if((l=(s=n.stateNode).hydrate)&&(Xl=Pi(n.stateNode.containerInfo.firstChild),Fl=n,l=Cl=!0),l){if(null!=(e=s.mutableSourceEagerHydrationData))for(s=0;s<e.length;s+=2)(l=e[s])._workInProgressVersionPrimary=e[s+1],Pl.push(l);for(t=yl(n,null,i,t),n.child=t;t;)t.flags=-3&t.flags|1024,t=t.sibling}else Br(e,n,i,t),Zl();n=n.child}return n;case 5:return Ul(n),null===e&&kl(n),i=n.type,s=n.pendingProps,l=null!==e?e.memoizedProps:null,a=s.children,ki(i,s)?a=null:null!==l&&ki(i,l)&&(n.flags|=16),qr(e,n),Br(e,n,a,t),n.child;case 6:return null===e&&kl(n),null;case 13:return Qr(e,n,t);case 4:return Tl(n,n.stateNode.containerInfo),i=n.pendingProps,null===e?n.child=Ml(n,null,i,t):Br(e,n,i,t),n.child;case 11:return i=n.type,s=n.pendingProps,Or(e,n,i,s=n.elementType===i?s:Ks(i,s),t);case 7:return Br(e,n,n.pendingProps,t),n.child;case 8:case 12:return Br(e,n,n.pendingProps.children,t),n.child;case 10:e:{i=n.type._context,s=n.pendingProps,a=n.memoizedProps,l=s.value;var d=n.type._context;if(os(Qs,d._currentValue),d._currentValue=l,null!==a)if(d=a.value,0===(l=_i(d,l)?0:0|("function"===typeof i._calculateChangedBits?i._calculateChangedBits(d,l):1073741823))){if(a.children===s.children&&!fs.current){n=sa(e,n,t);break e}}else for(null!==(d=n.child)&&(d.return=n);null!==d;){var _=d.dependencies;if(null!==_){a=d.child;for(var o=_.firstContext;null!==o;){if(o.context===i&&0!==(o.observedBits&l)){1===d.tag&&((o=_l(-1,t&-t)).tag=2,ol(d,o)),d.lanes|=t,null!==(o=d.alternate)&&(o.lanes|=t),il(d.return,t),_.lanes|=t;break}o=o.next}}else a=10===d.tag&&d.type===n.type?null:d.child;if(null!==a)a.return=d;else for(a=d;null!==a;){if(a===n){a=null;break}if(null!==(d=a.sibling)){d.return=a.return,a=d;break}a=a.return}d=a}Br(e,n,s.children,t),n=n.child}return n;case 9:return s=n.type,i=(l=n.pendingProps).children,sl(n,t),i=i(s=ll(s,l.unstable_observedBits)),n.flags|=1,Br(e,n,i,t),n.child;case 14:return l=Ks(s=n.type,n.pendingProps),Fr(e,n,s,l=Ks(s.type,l),i,t);case 15:return Xr(e,n,n.type,n.pendingProps,i,t);case 17:return i=n.type,s=n.pendingProps,s=n.elementType===i?s:Ks(i,s),null!==e&&(e.alternate=null,n.alternate=null,n.flags|=2),n.tag=1,ps(i)?(e=!0,ws(n)):e=!1,sl(n,t),hl(n,i,s),wl(n,i,s,t),Nr(null,n,i,!0,e,t);case 19:return ia(e,n,t);case 23:case 24:return Cr(e,n,t)}throw Error(r(156,n.tag))},t_.prototype.render=function(e){Jd(e,this._internalRoot,null,null)},t_.prototype.unmount=function(){var e=this._internalRoot,n=e.containerInfo;Jd(null,e,null,(function(){n[$i]=null}))},en=function(e){13===e.tag&&(fd(e,4,md()),n_(e,4))},nn=function(e){13===e.tag&&(fd(e,67108864,md()),n_(e,67108864))},tn=function(e){if(13===e.tag){var n=md(),t=vd(e);fd(e,t,n),n_(e,t)}},sn=function(e,n){return n()},ye=function(e,n,t){switch(n){case"input":if(te(e,t),n=t.name,"radio"===t.type&&null!=n){for(t=e;t.parentNode;)t=t.parentNode;for(t=t.querySelectorAll("input[name="+JSON.stringify(""+n)+'][type="radio"]'),n=0;n<t.length;n++){var i=t[n];if(i!==e&&i.form===e.form){var s=ss(i);if(!s)throw Error(r(90));Q(i),te(i,s)}}}break;case"textarea":_e(e,t);break;case"select":null!=(n=t.value)&&re(e,!!t.multiple,n,!1)}},Te=gd,We=function(e,n,t,i,s){var l=Va;Va|=4;try{return Ys(98,e.bind(null,n,t,i,s))}finally{0===(Va=l)&&(Za(),Ps())}},Ue=function(){0===(49&Va)&&(function(){if(null!==id){var e=id;id=null,e.forEach((function(e){e.expiredLanes|=24&e.pendingLanes,cd(e,Hs())}))}Ps()}(),Ud())},Ie=function(e,n){var t=Va;Va|=2;try{return e(n)}finally{0===(Va=t)&&(Za(),Ps())}};var r_={Events:[ts,is,ss,De,Ve,Ud,{current:!1}]},a_={findFiberByHostInstance:ns,bundleType:0,version:"17.0.2",rendererPackageName:"react-dom"},d_={bundleType:a_.bundleType,version:a_.version,rendererPackageName:a_.rendererPackageName,rendererConfig:a_.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:b.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=Je(e))?null:e.stateNode},findFiberByHostInstance:a_.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var __=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!__.isDisabled&&__.supportsFiber)try{xs=__.inject(d_),zs=__}catch(ce){}}n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=r_,n.createPortal=l_,n.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var n=e._reactInternals;if(void 0===n){if("function"===typeof e.render)throw Error(r(188));throw Error(r(268,Object.keys(e)))}return e=null===(e=Je(n))?null:e.stateNode},n.flushSync=function(e,n){var t=Va;if(0!==(48&t))return e(n);Va|=1;try{if(e)return Ys(99,e.bind(null,n))}finally{Va=t,Ps()}},n.hydrate=function(e,n,t){if(!i_(n))throw Error(r(200));return s_(null,e,n,!0,t)},n.render=function(e,n,t){if(!i_(n))throw Error(r(200));return s_(null,e,n,!1,t)},n.unmountComponentAtNode=function(e){if(!i_(e))throw Error(r(40));return!!e._reactRootContainer&&(wd((function(){s_(null,null,e,!1,(function(){e._reactRootContainer=null,e[$i]=null}))})),!0)},n.unstable_batchedUpdates=gd,n.unstable_createPortal=function(e,n){return l_(e,n,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)},n.unstable_renderSubtreeIntoContainer=function(e,n,t,i){if(!i_(t))throw Error(r(200));if(null==e||void 0===e._reactInternals)throw Error(r(38));return s_(e,n,t,!1,i)},n.version="17.0.2"},164:function(e,n,t){"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(n){console.error(n)}}(),e.exports=t(463)},374:function(e,n,t){"use strict";t(725);var i=t(791),s=60103;if(60107,"function"===typeof Symbol&&Symbol.for){var l=Symbol.for;s=l("react.element"),l("react.fragment")}var r=i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,a=Object.prototype.hasOwnProperty,d={key:!0,ref:!0,__self:!0,__source:!0};function _(e,n,t){var i,l={},_=null,o=null;for(i in void 0!==t&&(_=""+t),void 0!==n.key&&(_=""+n.key),void 0!==n.ref&&(o=n.ref),n)a.call(n,i)&&!d.hasOwnProperty(i)&&(l[i]=n[i]);if(e&&e.defaultProps)for(i in n=e.defaultProps)void 0===l[i]&&(l[i]=n[i]);return{$$typeof:s,type:e,key:_,ref:o,props:l,_owner:r.current}}n.jsx=_,n.jsxs=_},117:function(e,n,t){"use strict";var i=t(725),s=60103,l=60106;n.Fragment=60107,n.StrictMode=60108,n.Profiler=60114;var r=60109,a=60110,d=60112;n.Suspense=60113;var _=60115,o=60116;if("function"===typeof Symbol&&Symbol.for){var m=Symbol.for;s=m("react.element"),l=m("react.portal"),n.Fragment=m("react.fragment"),n.StrictMode=m("react.strict_mode"),n.Profiler=m("react.profiler"),r=m("react.provider"),a=m("react.context"),d=m("react.forward_ref"),n.Suspense=m("react.suspense"),_=m("react.memo"),o=m("react.lazy")}var v="function"===typeof Symbol&&Symbol.iterator;function f(e){for(var n="https://reactjs.org/docs/error-decoder.html?invariant="+e,t=1;t<arguments.length;t++)n+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+e+"; visit "+n+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var u={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},c={};function p(e,n,t){this.props=e,this.context=n,this.refs=c,this.updater=t||u}function E(){}function h(e,n,t){this.props=e,this.context=n,this.refs=c,this.updater=t||u}p.prototype.isReactComponent={},p.prototype.setState=function(e,n){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error(f(85));this.updater.enqueueSetState(this,e,n,"setState")},p.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},E.prototype=p.prototype;var g=h.prototype=new E;g.constructor=h,i(g,p.prototype),g.isPureReactComponent=!0;var w={current:null},b=Object.prototype.hasOwnProperty,x={key:!0,ref:!0,__self:!0,__source:!0};function z(e,n,t){var i,l={},r=null,a=null;if(null!=n)for(i in void 0!==n.ref&&(a=n.ref),void 0!==n.key&&(r=""+n.key),n)b.call(n,i)&&!x.hasOwnProperty(i)&&(l[i]=n[i]);var d=arguments.length-2;if(1===d)l.children=t;else if(1<d){for(var _=Array(d),o=0;o<d;o++)_[o]=arguments[o+2];l.children=_}if(e&&e.defaultProps)for(i in d=e.defaultProps)void 0===l[i]&&(l[i]=d[i]);return{$$typeof:s,type:e,key:r,ref:a,props:l,_owner:w.current}}function L(e){return"object"===typeof e&&null!==e&&e.$$typeof===s}var M=/\/+/g;function y(e,n){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var n={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return n[e]}))}(""+e.key):n.toString(36)}function R(e,n,t,i,r){var a=typeof e;"undefined"!==a&&"boolean"!==a||(e=null);var d=!1;if(null===e)d=!0;else switch(a){case"string":case"number":d=!0;break;case"object":switch(e.$$typeof){case s:case l:d=!0}}if(d)return r=r(d=e),e=""===i?"."+y(d,0):i,Array.isArray(r)?(t="",null!=e&&(t=e.replace(M,"$&/")+"/"),R(r,n,t,"",(function(e){return e}))):null!=r&&(L(r)&&(r=function(e,n){return{$$typeof:s,type:e.type,key:n,ref:e.ref,props:e.props,_owner:e._owner}}(r,t+(!r.key||d&&d.key===r.key?"":(""+r.key).replace(M,"$&/")+"/")+e)),n.push(r)),1;if(d=0,i=""===i?".":i+":",Array.isArray(e))for(var _=0;_<e.length;_++){var o=i+y(a=e[_],_);d+=R(a,n,t,o,r)}else if(o=function(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=v&&e[v]||e["@@iterator"])?e:null}(e),"function"===typeof o)for(e=o.call(e),_=0;!(a=e.next()).done;)d+=R(a=a.value,n,t,o=i+y(a,_++),r);else if("object"===a)throw n=""+e,Error(f(31,"[object Object]"===n?"object with keys {"+Object.keys(e).join(", ")+"}":n));return d}function S(e,n,t){if(null==e)return e;var i=[],s=0;return R(e,i,"","",(function(e){return n.call(t,e,s++)})),i}function A(e){if(-1===e._status){var n=e._result;n=n(),e._status=0,e._result=n,n.then((function(n){0===e._status&&(n=n.default,e._status=1,e._result=n)}),(function(n){0===e._status&&(e._status=2,e._result=n)}))}if(1===e._status)return e._result;throw e._result}var D={current:null};function V(){var e=D.current;if(null===e)throw Error(f(321));return e}var T={ReactCurrentDispatcher:D,ReactCurrentBatchConfig:{transition:0},ReactCurrentOwner:w,IsSomeRendererActing:{current:!1},assign:i};n.Children={map:S,forEach:function(e,n,t){S(e,(function(){n.apply(this,arguments)}),t)},count:function(e){var n=0;return S(e,(function(){n++})),n},toArray:function(e){return S(e,(function(e){return e}))||[]},only:function(e){if(!L(e))throw Error(f(143));return e}},n.Component=p,n.PureComponent=h,n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=T,n.cloneElement=function(e,n,t){if(null===e||void 0===e)throw Error(f(267,e));var l=i({},e.props),r=e.key,a=e.ref,d=e._owner;if(null!=n){if(void 0!==n.ref&&(a=n.ref,d=w.current),void 0!==n.key&&(r=""+n.key),e.type&&e.type.defaultProps)var _=e.type.defaultProps;for(o in n)b.call(n,o)&&!x.hasOwnProperty(o)&&(l[o]=void 0===n[o]&&void 0!==_?_[o]:n[o])}var o=arguments.length-2;if(1===o)l.children=t;else if(1<o){_=Array(o);for(var m=0;m<o;m++)_[m]=arguments[m+2];l.children=_}return{$$typeof:s,type:e.type,key:r,ref:a,props:l,_owner:d}},n.createContext=function(e,n){return void 0===n&&(n=null),(e={$$typeof:a,_calculateChangedBits:n,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null}).Provider={$$typeof:r,_context:e},e.Consumer=e},n.createElement=z,n.createFactory=function(e){var n=z.bind(null,e);return n.type=e,n},n.createRef=function(){return{current:null}},n.forwardRef=function(e){return{$$typeof:d,render:e}},n.isValidElement=L,n.lazy=function(e){return{$$typeof:o,_payload:{_status:-1,_result:e},_init:A}},n.memo=function(e,n){return{$$typeof:_,type:e,compare:void 0===n?null:n}},n.useCallback=function(e,n){return V().useCallback(e,n)},n.useContext=function(e,n){return V().useContext(e,n)},n.useDebugValue=function(){},n.useEffect=function(e,n){return V().useEffect(e,n)},n.useImperativeHandle=function(e,n,t){return V().useImperativeHandle(e,n,t)},n.useLayoutEffect=function(e,n){return V().useLayoutEffect(e,n)},n.useMemo=function(e,n){return V().useMemo(e,n)},n.useReducer=function(e,n,t){return V().useReducer(e,n,t)},n.useRef=function(e){return V().useRef(e)},n.useState=function(e){return V().useState(e)},n.version="17.0.2"},791:function(e,n,t){"use strict";e.exports=t(117)},184:function(e,n,t){"use strict";e.exports=t(374)},813:function(e,n){"use strict";var t,i,s,l;if("object"===typeof performance&&"function"===typeof performance.now){var r=performance;n.unstable_now=function(){return r.now()}}else{var a=Date,d=a.now();n.unstable_now=function(){return a.now()-d}}if("undefined"===typeof window||"function"!==typeof MessageChannel){var _=null,o=null,m=function e(){if(null!==_)try{var t=n.unstable_now();_(!0,t),_=null}catch(i){throw setTimeout(e,0),i}};t=function(e){null!==_?setTimeout(t,0,e):(_=e,setTimeout(m,0))},i=function(e,n){o=setTimeout(e,n)},s=function(){clearTimeout(o)},n.unstable_shouldYield=function(){return!1},l=n.unstable_forceFrameRate=function(){}}else{var v=window.setTimeout,f=window.clearTimeout;if("undefined"!==typeof console){var u=window.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"),"function"!==typeof u&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")}var c=!1,p=null,E=-1,h=5,g=0;n.unstable_shouldYield=function(){return n.unstable_now()>=g},l=function(){},n.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):h=0<e?Math.floor(1e3/e):5};var w=new MessageChannel,b=w.port2;w.port1.onmessage=function(){if(null!==p){var e=n.unstable_now();g=e+h;try{p(!0,e)?b.postMessage(null):(c=!1,p=null)}catch(t){throw b.postMessage(null),t}}else c=!1},t=function(e){p=e,c||(c=!0,b.postMessage(null))},i=function(e,t){E=v((function(){e(n.unstable_now())}),t)},s=function(){f(E),E=-1}}function x(e,n){var t=e.length;e.push(n);e:for(;;){var i=t-1>>>1,s=e[i];if(!(void 0!==s&&0<M(s,n)))break e;e[i]=n,e[t]=s,t=i}}function z(e){return void 0===(e=e[0])?null:e}function L(e){var n=e[0];if(void 0!==n){var t=e.pop();if(t!==n){e[0]=t;e:for(var i=0,s=e.length;i<s;){var l=2*(i+1)-1,r=e[l],a=l+1,d=e[a];if(void 0!==r&&0>M(r,t))void 0!==d&&0>M(d,r)?(e[i]=d,e[a]=t,i=a):(e[i]=r,e[l]=t,i=l);else{if(!(void 0!==d&&0>M(d,t)))break e;e[i]=d,e[a]=t,i=a}}}return n}return null}function M(e,n){var t=e.sortIndex-n.sortIndex;return 0!==t?t:e.id-n.id}var y=[],R=[],S=1,A=null,D=3,V=!1,T=!1,W=!1;function U(e){for(var n=z(R);null!==n;){if(null===n.callback)L(R);else{if(!(n.startTime<=e))break;L(R),n.sortIndex=n.expirationTime,x(y,n)}n=z(R)}}function I(e){if(W=!1,U(e),!T)if(null!==z(y))T=!0,t(B);else{var n=z(R);null!==n&&i(I,n.startTime-e)}}function B(e,t){T=!1,W&&(W=!1,s()),V=!0;var l=D;try{for(U(t),A=z(y);null!==A&&(!(A.expirationTime>t)||e&&!n.unstable_shouldYield());){var r=A.callback;if("function"===typeof r){A.callback=null,D=A.priorityLevel;var a=r(A.expirationTime<=t);t=n.unstable_now(),"function"===typeof a?A.callback=a:A===z(y)&&L(y),U(t)}else L(y);A=z(y)}if(null!==A)var d=!0;else{var _=z(R);null!==_&&i(I,_.startTime-t),d=!1}return d}finally{A=null,D=l,V=!1}}var O=l;n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(e){e.callback=null},n.unstable_continueExecution=function(){T||V||(T=!0,t(B))},n.unstable_getCurrentPriorityLevel=function(){return D},n.unstable_getFirstCallbackNode=function(){return z(y)},n.unstable_next=function(e){switch(D){case 1:case 2:case 3:var n=3;break;default:n=D}var t=D;D=n;try{return e()}finally{D=t}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=O,n.unstable_runWithPriority=function(e,n){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var t=D;D=e;try{return n()}finally{D=t}},n.unstable_scheduleCallback=function(e,l,r){var a=n.unstable_now();switch("object"===typeof r&&null!==r?r="number"===typeof(r=r.delay)&&0<r?a+r:a:r=a,e){case 1:var d=-1;break;case 2:d=250;break;case 5:d=1073741823;break;case 4:d=1e4;break;default:d=5e3}return e={id:S++,callback:l,priorityLevel:e,startTime:r,expirationTime:d=r+d,sortIndex:-1},r>a?(e.sortIndex=r,x(R,e),null===z(y)&&e===z(R)&&(W?s():W=!0,i(I,r-a))):(e.sortIndex=d,x(y,e),T||V||(T=!0,t(B))),e},n.unstable_wrapCallback=function(e){var n=D;return function(){var t=D;D=n;try{return e.apply(this,arguments)}finally{D=t}}}},296:function(e,n,t){"use strict";e.exports=t(813)},458:function(e){e.exports=function(){var e=document.getSelection();if(!e.rangeCount)return function(){};for(var n=document.activeElement,t=[],i=0;i<e.rangeCount;i++)t.push(e.getRangeAt(i));switch(n.tagName.toUpperCase()){case"INPUT":case"TEXTAREA":n.blur();break;default:n=null}return e.removeAllRanges(),function(){"Caret"===e.type&&e.removeAllRanges(),e.rangeCount||t.forEach((function(n){e.addRange(n)})),n&&n.focus()}}}},n={};function t(i){var s=n[i];if(void 0!==s)return s.exports;var l=n[i]={exports:{}};return e[i](l,l.exports,t),l.exports}t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,{a:n}),n},t.d=function(e,n){for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},t.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},function(){"use strict";var e={};t.r(e),t.d(e,{default:function(){return Ed}});var n=t(791),i=t(164);function s(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function l(e,n){for(var t=0;t<n.length;t++){var i=n[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function r(e,n,t){return n&&l(e.prototype,n),t&&l(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}function a(e,n){return a=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e},a(e,n)}function d(e,n){if("function"!==typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),n&&a(e,n)}function _(e){return _=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},_(e)}function o(e){return o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},o(e)}function m(e,n){if(n&&("object"===o(n)||"function"===typeof n))return n;if(void 0!==n)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}function v(e){var n=function(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var t,i=_(e);if(n){var s=_(this).constructor;t=Reflect.construct(i,arguments,s)}else t=i.apply(this,arguments);return m(this,t)}}var f={};try{f.enableCssCustomProperties=!!{NODE_ENV:"production",PUBLIC_URL:"/RISC-V_ISA",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.CARBON_ENABLE_CSS_CUSTOM_PROPERTIES&&"true"==={NODE_ENV:"production",PUBLIC_URL:"/RISC-V_ISA",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.CARBON_ENABLE_CSS_CUSTOM_PROPERTIES,f.enableUseControlledStateWithValue=!!{NODE_ENV:"production",PUBLIC_URL:"/RISC-V_ISA",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.CARBON_ENABLE_USE_CONTROLLED_STATE_WITH_VALUE&&"true"==={NODE_ENV:"production",PUBLIC_URL:"/RISC-V_ISA",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.CARBON_ENABLE_USE_CONTROLLED_STATE_WITH_VALUE,f.enableCssGrid=!!{NODE_ENV:"production",PUBLIC_URL:"/RISC-V_ISA",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.CARBON_ENABLE_CSS_GRID&&"true"==={NODE_ENV:"production",PUBLIC_URL:"/RISC-V_ISA",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.CARBON_ENABLE_CSS_GRID,f.enableV11Release=!!{NODE_ENV:"production",PUBLIC_URL:"/RISC-V_ISA",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.CARBON_ENABLE_V11_RELEASE&&"true"==={NODE_ENV:"production",PUBLIC_URL:"/RISC-V_ISA",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0}.CARBON_ENABLE_V11_RELEASE}catch(nz){f.enableCssCustomProperties=!1,f.enableUseControlledStateWithValue=!1,f.enableCssGrid=!1,f.enableV11Release=!1}var u=[{name:"enable-css-custom-properties",description:"Describe what the flag does",enabled:f.enableCssCustomProperties},{name:"enable-use-controlled-state-with-value",description:"Enable components to be created in either a controlled or uncontrolled mode\n",enabled:f.enableUseControlledStateWithValue},{name:"enable-css-grid",description:"Enable CSS Grid Layout in the Grid and Column React components\n",enabled:f.enableCssGrid},{name:"enable-v11-release",description:"Enable the features and functionality for the v11 Release\n",enabled:f.enableV11Release}];function c(e,n){for(var t=0;t<n.length;t++){var i=n[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function p(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!==typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null==t)return;var i,s,l=[],r=!0,a=!1;try{for(t=t.call(e);!(r=(i=t.next()).done)&&(l.push(i.value),!n||l.length!==n);r=!0);}catch(d){a=!0,s=d}finally{try{r||null==t.return||t.return()}finally{if(a)throw s}}return l}(e,n)||E(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function E(e,n){if(e){if("string"===typeof e)return h(e,n);var t=Object.prototype.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?h(e,n):void 0}}function h(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,i=new Array(n);t<n;t++)i[t]=e[t];return i}for(var g=function(){function e(n){var t=this;!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.flags=new Map,n&&Object.keys(n).forEach((function(e){t.flags.set(e,n[e])}))}var n,t,i;return n=e,t=[{key:"checkForFlag",value:function(e){if(!this.flags.has(e))throw new Error("Unable to find a feature flag with the name: `".concat(e,"`"))}},{key:"add",value:function(e,n){if(this.flags.has(e))throw new Error("The feature flag: ".concat(e," already exists"));this.flags.set(e,n)}},{key:"enable",value:function(e){this.checkForFlag(e),this.flags.set(e,!0)}},{key:"disable",value:function(e){this.checkForFlag(e),this.flags.set(e,!1)}},{key:"merge",value:function(e){var n=this;Object.keys(e).forEach((function(t){n.flags.set(t,e[t])}))}},{key:"mergeWithScope",value:function(e){var n,t=function(e,n){var t="undefined"!==typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!t){if(Array.isArray(e)||(t=E(e))||n&&e&&"number"===typeof e.length){t&&(e=t);var i=0,s=function(){};return{s:s,n:function(){return i>=e.length?{done:!0}:{done:!1,value:e[i++]}},e:function(e){throw e},f:s}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var l,r=!0,a=!1;return{s:function(){t=t.call(e)},n:function(){var e=t.next();return r=e.done,e},e:function(e){a=!0,l=e},f:function(){try{r||null==t.return||t.return()}finally{if(a)throw l}}}}(e.flags);try{for(t.s();!(n=t.n()).done;){var i=p(n.value,2),s=i[0],l=i[1];this.flags.has(s)||this.flags.set(s,l)}}catch(r){t.e(r)}finally{t.f()}}},{key:"enabled",value:function(e){return this.checkForFlag(e),this.flags.get(e)}}],t&&c(n.prototype,t),i&&c(n,i),Object.defineProperty(n,"prototype",{writable:!1}),e}(),w=z(),b=0;b<u.length;b++){var x=u[b];w.add(x.name,x.enabled)}function z(e){return new g(e)}function L(){return w.enabled.apply(w,arguments)}function M(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function y(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?M(Object(t),!0).forEach((function(n){V(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):M(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function R(e){return R="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},R(e)}function S(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function A(e,n){for(var t=0;t<n.length;t++){var i=n[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(e,i.key,i)}}function D(e,n,t){return n&&A(e.prototype,n),t&&A(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}function V(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function T(){return T=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e},T.apply(this,arguments)}function W(e,n){if("function"!==typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),n&&I(e,n)}function U(e){return U=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},U(e)}function I(e,n){return I=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e},I(e,n)}function B(e,n){if(null==e)return{};var t,i,s=function(e,n){if(null==e)return{};var t,i,s={},l=Object.keys(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}function O(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function F(e){var n=function(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}();return function(){var t,i=U(e);if(n){var s=U(this).constructor;t=Reflect.construct(i,arguments,s)}else t=i.apply(this,arguments);return function(e,n){if(n&&("object"===typeof n||"function"===typeof n))return n;if(void 0!==n)throw new TypeError("Derived constructors may only return object or undefined");return O(e)}(this,t)}}function X(e,n){return function(e){if(Array.isArray(e))return e}(e)||function(e,n){var t=null==e?null:"undefined"!==typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null==t)return;var i,s,l=[],r=!0,a=!1;try{for(t=t.call(e);!(r=(i=t.next()).done)&&(l.push(i.value),!n||l.length!==n);r=!0);}catch(d){a=!0,s=d}finally{try{r||null==t.return||t.return()}finally{if(a)throw s}}return l}(e,n)||C(e,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function C(e,n){if(e){if("string"===typeof e)return q(e,n);var t=Object.prototype.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?q(e,n):void 0}}function q(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,i=new Array(n);t<n;t++)i[t]=e[t];return i}!function(){w.merge.apply(w,arguments)}({"enable-css-custom-properties":!0,"enable-css-grid":!0,"enable-v11-release":!0});var H=t(694),k=t.n(H),N=n.createContext("cds");function Y(){return n.useContext(N)}var Z=t(7),P=t.n(Z),G=["align","children","className","disabled","size"];function j(e){var t,i=e.align,s=void 0===i?"end":i,l=e.children,r=e.className,a=e.disabled,d=void 0!==a&&a,_=e.size,o=void 0===_?"md":_,m=B(e,G),v=Y(),f=k()("".concat(v,"--accordion"),r,(V(t={},"".concat(v,"--accordion--").concat(s),s),V(t,"".concat(v,"--accordion--").concat(o),o),t));return n.createElement("ul",T({className:f},m),d?n.Children.toArray(l).map((function(e){return n.cloneElement(e,{disabled:d})})):l)}function K(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function Q(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?K(Object(t),!0).forEach((function(n){J(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):K(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function J(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function $(e,n){if(null==e)return{};var t,i,s=function(e,n){if(null==e)return{};var t,i,s={},l=Object.keys(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}j.propTypes={align:P().oneOf(["start","end"]),children:P().node,className:P().string,disabled:P().bool,size:L("enable-v11-release")?P().oneOf(["sm","md","lg"]):P().oneOf(["sm","md","lg","xl"])};var ee=["width","height","viewBox"],ne=["tabindex"],te={focusable:"false",preserveAspectRatio:"xMidYMid meet"};function ie(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=e.width,t=e.height,i=e.viewBox,s=void 0===i?"0 0 ".concat(n," ").concat(t):i,l=$(e,ee),r=l.tabindex,a=$(l,ne),d=Q(Q(Q({},te),a),{},{width:n,height:t,viewBox:s});return d["aria-label"]||d["aria-labelledby"]||d.title?(d.role="img",void 0!==r&&null!==r&&(d.focusable="true",d.tabindex=r)):d["aria-hidden"]=!0,d}function se(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function le(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?se(Object(t),!0).forEach((function(n){re(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):se(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function re(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function ae(e,n){if(null==e)return{};var t,i,s=function(e,n){if(null==e)return{};var t,i,s={},l=Object.keys(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(i=0;i<l.length;i++)t=l[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var de=["className","children","tabIndex"],_e=["tabindex"],oe=n.forwardRef((function(e,t){var i=e.className,s=e.children,l=e.tabIndex,r=ie(le(le({},ae(e,de)),{},{tabindex:l})),a=r.tabindex,d=ae(r,_e);return i&&(d.className=i),void 0!==a&&null!==a&&(d.tabIndex=a),t&&(d.ref=t),n.createElement("svg",d,s)}));oe.displayName="Icon",oe.propTypes={"aria-hidden":P().string,"aria-label":P().string,"aria-labelledby":P().string,children:P().node,className:P().string,height:P().oneOfType([P().number,P().string]),preserveAspectRatio:P().string,tabIndex:P().string,viewBox:P().string,width:P().oneOfType([P().number,P().string]),xmlns:P().string},oe.defaultProps={xmlns:"http://www.w3.org/2000/svg",preserveAspectRatio:"xMidYMid meet"};var me,ve,fe,ue,ce,pe,Ee,he,ge,we,be,xe,ze,Le,Me,ye,Re,Se,Ae,De,Ve,Te,We,Ue,Ie,Be,Oe,Fe,Xe,Ce,qe,He,ke,Ne,Ye,Ze,Pe,Ge,je,Ke,Qe,Je,$e,en,nn,tn,sn,ln,rn,an,dn,_n,on,mn,vn,fn,un,cn,pn,En,hn,gn,wn,bn,xn,zn,Ln,Mn,yn,Rn,Sn,An,Dn,Vn,Tn,Wn,Un,In,Bn,On,Fn,Xn,Cn,qn,Hn,kn,Nn,Yn,Zn,Pn,Gn,jn,Kn,Qn,Jn,$n,et,nt,tt,it,st,lt,rt,at,dt,_t,ot,mt,vt,ft,ut,ct,pt,Et,ht,gt,wt,bt,xt,zt,Lt,Mt,yt,Rt,St,At,Dt,Vt,Tt,Wt,Ut,It,Bt,Ot,Ft,Xt,Ct,qt,Ht,kt,Nt,Yt,Zt,Pt,Gt,jt,Kt,Qt,Jt,$t,ei,ni,ti,ii,si,li,ri,ai,di,_i,oi,mi,vi,fi,ui,ci,pi,Ei,hi,gi,wi,bi,xi,zi,Li,Mi,yi,Ri,Si,Ai,Di,Vi,Ti,Wi,Ui,Ii,Bi,Oi,Fi,Xi,Ci,qi,Hi,ki,Ni,Yi,Zi,Pi,Gi,ji,Ki,Qi,Ji,$i,es,ns,ts,is,ss,ls,rs,as,ds,_s,os,ms,vs,fs,us,cs,ps,Es,hs,gs,ws,bs,xs,zs,Ls,Ms,ys,Rs,Ss,As,Ds,Vs,Ts,Ws,Us,Is,Bs,Os,Fs,Xs,Cs,qs,Hs,ks,Ns,Ys,Zs,Ps,Gs,js,Ks,Qs,Js,$s,el,nl,tl,il,sl,ll,rl,al,dl,_l,ol={size:P().oneOfType([P().number,P().string])},ml=["children","size"],vl=["children","size"],fl=["children","size"],ul=["children","size"],cl=["children","size"],pl=["children","size"],El=["children","size"],hl=["children","size"],gl=["children","size"],wl=["children","size"],bl=["children","size"],xl=["children","size"],zl=["children","size"],Ll=["children","size"],Ml=["children","size"],yl=["children","size"],Rl=["children","size"],Sl=["children","size"],Al=["children","size"],Dl=["children","size"],Vl=["children","size"],Tl=["children","size"],Wl=["children","size"],Ul=["children","size"],Il=["children","size"],Bl=["children","size"],Ol=["children","size"],Fl=["children","size"],Xl=["children","size"],Cl=["children","size"],ql=["children","size"],Hl=["children","size"],kl=["children","size"],Nl=["children","size"],Yl=["children","size"],Zl=["children","size"],Pl=["children","size"],Gl=["children","size"],jl=["children","size"],Kl=["children","size"],Ql=["children","size"],Jl=["children","size"],$l=["children","size"],er=["children","size"],nr=["children","size"],tr=["children","size"],ir=["children","size"],sr=["children","size"],lr=["children","size"],rr=["children","size"],ar=["children","size"],dr=["children","size"],_r=["children","size"],or=["children","size"],mr=["children","size"],vr=["children","size"],fr=["children","size"],ur=["children","size"],cr=["children","size"],pr=["children","size"],Er=["children","size"],hr=["children","size"],gr=["children","size"],wr=["children","size"],br=["children","size"],xr=["children","size"],zr=["children","size"],Lr=["children","size"],Mr=["children","size"],yr=["children","size"],Rr=["children","size"],Sr=["children","size"],Ar=["children","size"],Dr=["children","size"],Vr=["children","size"],Tr=["children","size"],Wr=["children","size"],Ur=["children","size"],Ir=["children","size"],Br=["children","size"],Or=["children","size"],Fr=["children","size"],Xr=["children","size"],Cr=["children","size"],qr=["children","size"],Hr=["children","size"],kr=["children","size"],Nr=["children","size"],Yr=["children","size"],Zr=["children","size"],Pr=["children","size"],Gr=["children","size"],jr=["children","size"],Kr=["children","size"],Qr=["children","size"],Jr=["children","size"],$r=["children","size"],ea=["children","size"],na=["children","size"],ta=["children","size"],ia=["children","size"],sa=["children","size"],la=["children","size"],ra=["children","size"],aa=["children","size"],da=["children","size"],_a=["children","size"],oa=["children","size"],ma=["children","size"],va=["children","size"],fa=["children","size"],ua=["children","size"],ca=["children","size"],pa=["children","size"],Ea=["children","size"],ha=["children","size"],ga=["children","size"],wa=["children","size"],ba=["children","size"],xa=["children","size"],za=["children","size"],La=["children","size"],Ma=["children","size"],ya=["children","size"],Ra=["children","size"];n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ml);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),me||(me=n.createElement("path",{d:"M28 24H14V16H28zM16 22H26V18H16zM26 12H8V4H26zM10 10H24V6H10z"})),ve||(ve=n.createElement("path",{d:"M30,30H4a2.0023,2.0023,0,0,1-2-2V2H4V28H30Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,vl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),fe||(fe=n.createElement("path",{d:"M4,28V26H26V16H4V14H18V4H4V2H2V28a2,2,0,0,0,2,2H30V28ZM24,18v6H4V22H20V20H4V18ZM16,6v6H4V10h8V8H4V6Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,fl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ue||(ue=n.createElement("path",{d:"M4,28V25H26V17H4V13H18V5H4V2H2V28a2,2,0,0,0,2,2H30V28Zm20-5H14V19H24ZM16,11H10V7h6Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ul);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ce||(ce=n.createElement("path",{d:"M28 17H30V25H28zM20 5H22V13H20z"})),pe||(pe=n.createElement("path",{d:"M4,2H2V28a2,2,0,0,0,2,2H30V28H4V25H26V17H4V13H18V5H4ZM24,19v4H4V19ZM16,7v4H4V7Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,cl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ee||(Ee=n.createElement("path",{d:"M30,30H4a2,2,0,0,1-2-2V2H4V28H30Z"})),he||(he=n.createElement("path",{d:"M10 16a2 2 0 11-2 2 2 2 0 012-2m0-2a4 4 0 104 4 4 4 0 00-4-4zM21 6a4 4 0 11-4 4 4 4 0 014-4m0-2a6 6 0 106 6 6 6 0 00-6-6zM24.5 21A1.5 1.5 0 1123 22.5 1.5 1.5 0 0124.5 21m0-2A3.5 3.5 0 1028 22.5 3.5 3.5 0 0024.5 19z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,pl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ge||(ge=n.createElement("path",{d:"M27.5322,17.1724A8.99,8.99,0,1,0,13.6074,5.88,5.9969,5.9969,0,1,0,5.051,13.2217a6.9967,6.9967,0,1,0,7.9942,11.4844A5.9981,5.9981,0,0,0,25,24c0-.1216-.011-.24-.0181-.3594a3.4873,3.4873,0,1,0,2.55-6.4682ZM21,4a7,7,0,1,1-7,7A7.0078,7.0078,0,0,1,21,4ZM8,4A4,4,0,1,1,4,8,4.0045,4.0045,0,0,1,8,4ZM19,28a4,4,0,1,1,4-4A4.0045,4.0045,0,0,1,19,28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,El);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),we||(we=n.createElement("path",{d:"M30 22H16V21H14v1H2v6H14v1h2V28H30zM4 26V24H14v2zm24 0H16V24H28zM30 13H24V12H22v1H2v6H22v1h2V19h6zM4 17V15H22v2zm24 0H24V15h4zM30 4H10V3H8V4H2v6H8v1h2V10H30zM4 8V6H8V8zM28 8H10V6H28z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,hl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),be||(be=n.createElement("path",{d:"M26 10H24V6H22v4H20V22h2v4h2V22h2zM24 20H22V12h2zM14 8H12V4H10V8H8V18h2v4h2V18h2zm-2 8H10V10h2z"})),xe||(xe=n.createElement("path",{d:"M30,30H4a2,2,0,0,1-2-2V2H4V28H30Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,gl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ze||(ze=n.createElement("path",{d:"M30,30H4a2,2,0,0,1-2-2V2H4V28H30Z"})),Le||(Le=n.createElement("path",{d:"M10 16H12V26H10zM7 22H9V26H7zM26 8H28V26H26zM23 14H25V26H23z"})),Me||(Me=n.createElement("path",{d:"M15 12H17V26H15z",transform:"rotate(-180 16 19)"})),ye||(ye=n.createElement("path",{d:"M18 18H20V26H18z",transform:"rotate(-180 19 22)"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,wl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Re||(Re=n.createElement("path",{d:"M27,28V6H19V28H15V14H7V28H4V2H2V28a2,2,0,0,0,2,2H30V28ZM13,28H9V16h4Zm12,0H21V8h4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,bl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Se||(Se=n.createElement("path",{d:"M28 22H20V4h8zm-6-2h4V6H22zM16 24H8V10h8zm-6-2h4V12H10z"})),Ae||(Ae=n.createElement("path",{d:"M30,30H4a2.0021,2.0021,0,0,1-2-2V2H4V28H30Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,xl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),De||(De=n.createElement("path",{d:"M27 28V6H19V28H15V14H7V28H4V2H2V28a2 2 0 002 2H30V28zM13 28H9V16h4zm12 0H21V8h4zM19 2H27V4H19z"})),Ve||(Ve=n.createElement("path",{d:"M7 10H15V12H7z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,zl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Te||(Te=n.createElement("path",{d:"M27,28V16H19V28H15V12H7V28H4V2H2V28a2,2,0,0,0,2,2H30V28ZM13,28H9V14h4Zm12,0H21V18h4Z"})),We||(We=n.createElement("path",{d:"M22.7856,14a1.9877,1.9877,0,0,1-1.1787-.3865L11.2041,5.987,8.2419,10,6.6374,8.8065l2.9812-4a1.9978,1.9978,0,0,1,2.749-.446l10.4214,7.64,3.6045-4.8613L28,8.3306l-3.6045,4.8611A2.0014,2.0014,0,0,1,22.7856,14Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ll);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ue||(Ue=n.createElement("path",{d:"M27,28V16H19V28H15V12H7V28H4V2H2V28a2,2,0,0,0,2,2H30V28ZM13,14v6H9V14Zm12,4v6H21V18Z"})),Ie||(Ie=n.createElement("path",{d:"M22.7856,14a1.9877,1.9877,0,0,1-1.1787-.3865L11.2041,5.987,8.2419,10,6.6374,8.8065l2.9812-4a1.9978,1.9978,0,0,1,2.749-.446l10.4214,7.64,3.6045-4.8613L28,8.3306l-3.6045,4.8611A2.0014,2.0014,0,0,1,22.7856,14Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ml);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Be||(Be=n.createElement("path",{d:"M29.707,19.293l-3-3a.9994.9994,0,0,0-1.414,0L16,25.5859V30h4.4141l9.2929-9.293A.9994.9994,0,0,0,29.707,19.293ZM19.5859,28H18V26.4141l5-5L24.5859,23ZM26,21.5859,24.4141,20,26,18.4141,27.5859,20Z"})),Oe||(Oe=n.createElement("path",{d:"M17 15H21V17H17z",transform:"rotate(-90 19 16)"})),Fe||(Fe=n.createElement("path",{d:"M12 14H18V16H12z",transform:"rotate(-90 15 15)"})),Xe||(Xe=n.createElement("path",{d:"M6 12H16V14H6z",transform:"rotate(-90 11 13)"})),Ce||(Ce=n.createElement("path",{d:"M12,30H6a2.0021,2.0021,0,0,1-2-2V4A2.0021,2.0021,0,0,1,6,2H22a2.0021,2.0021,0,0,1,2,2V14H22V4H6V28h6Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,yl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),qe||(qe=n.createElement("path",{d:"M22,28V12H18V8h2V6H14V8h2v4H12V28H4V2H2V28a2,2,0,0,0,2,2H30V28ZM14,14h2v4H14Zm6,14H14V20h6Zm0-10H18V14h2Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Rl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),He||(He=n.createElement("path",{d:"M14 10V8H8v2h2v4.1836a2.983 2.983 0 000 5.6328V24H8v2h6V24H12V19.8164a2.983 2.983 0 000-5.6328V10zM26 6V4H20V6h2V8.1836a2.983 2.983 0 000 5.6328V18H20v2h6V18H24V13.8164a2.983 2.983 0 000-5.6328V6z"})),ke||(ke=n.createElement("path",{d:"M30,30H4a2,2,0,0,1-2-2V2H4V28H30Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Sl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ne||(Ne=n.createElement("path",{d:"M25.672 6.207H29.915V8.206H25.672z",transform:"rotate(-45.02 27.793 7.207)"})),Ye||(Ye=n.createElement("path",{d:"M16 20.5L11 15.539 12.59 13.969 16 17.349 23.41 10 25 11.579 16 20.5z"})),Ze||(Ze=n.createElement("path",{d:"M4,28V25.4131L10.4141,19,9,17.585l-5,5V2H2V28a2,2,0,0,0,2,2H30V28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Al);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Pe||(Pe=n.createElement("path",{d:"M15 8L12 8 12 6 10 6 10 20 7 20 7 22 10 22 10 24 12 24 12 10 15 10 15 8zM27 10L24 10 24 6 22 6 22 18 19 18 19 20 22 20 22 24 24 24 24 12 27 12 27 10z"})),Ge||(Ge=n.createElement("path",{d:"M30,30H4a2,2,0,0,1-2-2V2H4V28H30Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Dl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),je||(je=n.createElement("path",{d:"M6,16c2.9727,0,4.2324-2.251,5.3447-4.2373C12.4741,9.7441,13.45,8,16,8s3.5259,1.7441,4.6553,3.7627C21.7676,13.749,23.0273,16,26,16h4V14H26c-1.7129,0-2.4834-1.2207-3.5991-3.2144C21.2075,8.6543,19.7231,6,16,6s-5.2075,2.6543-6.4009,4.7856C8.4834,12.7793,7.7129,14,6,14H4V2H2V28a2,2,0,0,0,2,2H30V28H28V22H26v6H21.9992L22,20H20v8H16V16H14V28H9.9992L10,20H8v8H4V16Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Vl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ke||(Ke=n.createElement("path",{d:"M4.67,28l6.39-12,7.3,6.49a2,2,0,0,0,1.7.47,2,2,0,0,0,1.42-1.07L27,10.9,25.18,10,19.69,21l-7.3-6.49A2,2,0,0,0,10.71,14a2,2,0,0,0-1.42,1L4,25V2H2V28a2,2,0,0,0,2,2H30V28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Tl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Qe||(Qe=n.createElement("path",{d:"M10.06,17.88A4.25,4.25,0,0,0,11,18a4,4,0,0,0,2.23-.68l3.22,2.87a3.88,3.88,0,0,0-.2,3.17A4,4,0,1,0,22.62,19l2.54-5.09a3.78,3.78,0,0,0,2.91-.53A4,4,0,1,0,23.38,13l-2.54,5.09A3.86,3.86,0,0,0,20,18a4,4,0,0,0-2.23.68l-3.22-2.87a3.88,3.88,0,0,0,.2-3.17A4,4,0,1,0,8.3,16.93L4,25V2H2V28a2,2,0,0,0,2,2H30V28H4.67ZM26,8a2,2,0,1,1-2,2A2,2,0,0,1,26,8ZM22,22a2,2,0,1,1-2-2A2,2,0,0,1,22,22ZM11,12a2,2,0,1,1-2,2A2,2,0,0,1,11,12Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Wl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Je||(Je=n.createElement("path",{d:"M13,15c1.4854,0,2.5544,1.4966,3.6863,3.0811C17.9983,19.918,19.4854,22,22,22c5.6709,0,7.78-10.79,8-12l-1.9678-.3584C27.55,12.2827,25.3938,20,22,20c-1.4854,0-2.5544-1.4966-3.6863-3.0811C17.0017,15.082,15.5146,13,13,13c-4.186,0-7.4448,7.4043-9,11.7617V2H2V28a2.0025,2.0025,0,0,0,2,2H30V28H5.0439C6.5544,22.8574,9.9634,15,13,15Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ul);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),$e||($e=n.createElement("path",{d:"M27,3H5A2.0025,2.0025,0,0,0,3,5V27a2.0025,2.0025,0,0,0,2,2H27a2.0025,2.0025,0,0,0,2-2V5A2.0025,2.0025,0,0,0,27,3Zm0,7H21V5h6ZM19,8H13V5h6Zm0,2v8H13V10ZM11,22H5V12h6Zm2-2h6v7H13Zm8-8h6v4H21ZM11,5v5H5V5ZM5,24h6v3H5Zm16,3V18h6v9Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Il);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),en||(en=n.createElement("path",{d:"M8 6H10V8H8zM12 6H14V8H12zM20 6H22V8H20zM24 6H26V8H24zM28 6H30V8H28z"})),nn||(nn=n.createElement("path",{d:"M27.989,28l-.0271-.1631C26.5105,19.0742,24.0662,9.0894,18,8.0889V6H16V8.085c-6.084.978-8.533,10.9775-9.9863,19.7519L5.9866,28H4V8H6V6H4V2H2V28a2,2,0,0,0,2,2H30V28ZM8.0151,28c2.024-12.1084,4.959-18,8.9727-18s6.9487,5.8916,8.9726,18Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Bl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),tn||(tn=n.createElement("path",{d:"M16 22H18V24H16z",transform:"rotate(-90 17 23)"})),sn||(sn=n.createElement("path",{d:"M18,28V26H16v2H4V2H2V28a2,2,0,0,0,2,2H30V28Z"})),ln||(ln=n.createElement("path",{d:"M26.0532,19.6787A3.44,3.44,0,0,1,23,22c-2.17,0-3.3115-3.333-4.52-6.8623-.3557-1.0386-.7239-2.1094-1.1382-3.1377H18V10H16.4221C15.2124,7.7148,13.5811,6,11,6,7.3218,6,6.1016,9.5332,6.0513,9.6836l1.8955.6377A3.44,3.44,0,0,1,11,8c2.92,0,4.2764,3.958,5.5874,7.7861.2544.7422.5105,1.4893.7813,2.2139H16v2h2.2019c1.0828,2.2886,2.4959,4,4.7981,4,3.6782,0,4.8984-3.5332,4.9487-3.6836Z"})),rn||(rn=n.createElement("path",{d:"M16 6H18V8H16z",transform:"rotate(-90 17 7)"})),an||(an=n.createElement("path",{d:"M16 2H18V4H16z",transform:"rotate(-90 17 3)"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ol);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),dn||(dn=n.createElement("path",{d:"M4,28V26H6V24H4V2H2V28a2,2,0,0,0,2,2H30V28Z"})),_n||(_n=n.createElement("path",{d:"M8 24H10V26H8zM12 24H14V26H12zM20 24H22V26H20zM24 24H26V26H24zM28 24H30V26H28z"})),on||(on=n.createElement("path",{d:"M27.9463,4.3281,25.9727,4C23.9487,16.1084,21.0137,22,17,22S10.0513,16.1084,8.0271,4l-1.9734.3281C7.51,13.0566,9.9631,22.93,16,23.9131V26h2V23.9131C24.0371,22.93,26.4907,13.0566,27.9463,4.3281Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Fl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),mn||(mn=n.createElement("path",{d:"M4.5859,28l7.1783-5.998L19.7578,23.94a2.021,2.021,0,0,0,1.314-.1206L28,20.5811l-.8479-1.8121-6.9163,3.229L12.2422,20.06a2.0033,2.0033,0,0,0-1.74.3838L4,25.8818V20.49l7.7642-6.4877L19.7578,15.94a2.021,2.021,0,0,0,1.314-.1206l6.9287-3.2383-.8467-1.812-6.918,3.2285L12.2422,12.06a2.0049,2.0049,0,0,0-1.74.3838L4,17.8818V12.49L11.7642,6.002,19.7578,7.94a2.021,2.021,0,0,0,1.314-.1206L28,4.5859l-.8457-1.8115L20.2358,5.998,12.2422,4.06a2.0033,2.0033,0,0,0-1.74.3838L4,9.8818V2H2V28a2,2,0,0,0,2,2H30V28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Xl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),vn||(vn=n.createElement("path",{d:"M28 22H30V30H28zM24 18H26V30H24zM20 26H22V30H20zM9 16a7 7 0 107 7A7.0078 7.0078 0 009 16zm4.8989 6H10V18.1011A5.0145 5.0145 0 0113.8989 22zM9 28a5 5 0 01-1-9.8989V22a2 2 0 002 2h3.8989A5.0081 5.0081 0 019 28zM22.5352 12l4-6H30V4H25.4648l-4 6H18V2H16V14a2 2 0 002 2H30V14H18V12z"})),fn||(fn=n.createElement("circle",{cx:"11",cy:"7",r:"1"})),un||(un=n.createElement("circle",{cx:"9",cy:"11",r:"1"})),cn||(cn=n.createElement("circle",{cx:"7",cy:"5",r:"1"})),pn||(pn=n.createElement("circle",{cx:"5",cy:"9",r:"1"})),En||(En=n.createElement("circle",{cx:"3",cy:"13",r:"1"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Cl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),hn||(hn=n.createElement("path",{d:"M26,14a2,2,0,0,0,2-2V6a2,2,0,0,0-2-2H20a2,2,0,0,0-2,2v6a2,2,0,0,0,2,2h2v4.1A5,5,0,0,0,18.1,22H14V20a2,2,0,0,0-2-2H10V13.9a5,5,0,1,0-2,0V18H6a2,2,0,0,0-2,2v6a2,2,0,0,0,2,2h6a2,2,0,0,0,2-2V24h4.1A5,5,0,1,0,24,18.1V14ZM6,9a3,3,0,1,1,3,3A3,3,0,0,1,6,9Zm6,17H6V20h6Zm14-3a3,3,0,1,1-3-3A3,3,0,0,1,26,23ZM20,6h6v6H20Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ql);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),gn||(gn=n.createElement("path",{d:"M28,2V5.3071l-6,2.25V2H20V7.5229l-8-3.2V2H10V4.4458l-6,3.75V2H2V30H4V27.6182l6-3V30h2V24.3442l8,2.4V30h2V26.5542l6-3.75V30h2V2Zm0,5.4429V12.5L22,17V9.6929ZM20,9.6768v7.5571l-8-4.8V6.4771ZM10,6.8042v5.7417l-6,5.25V10.5542ZM4,25.3818V20.4541l6-5.25v7.1777Zm8-3.1259v-7.49l8,4.8v5.0894Zm10,1.94V19.5L28,15v5.4458Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Hl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),wn||(wn=n.createElement("path",{d:"M16,4A12,12,0,1,0,28,16,12,12,0,0,0,16,4ZM26,15H17V6.05A10,10,0,0,1,26,15ZM15.42,26A10,10,0,0,1,15,6.05v9a2,2,0,0,0,2,2h9A10,10,0,0,1,15.42,26Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,kl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),bn||(bn=n.createElement("path",{d:"M30,30H4a2.0023,2.0023,0,0,1-2-2V2H4V28H30Z"})),xn||(xn=n.createElement("circle",{cx:"9",cy:"6",r:"3"})),zn||(zn=n.createElement("circle",{cx:"9",cy:"22",r:"3"})),Ln||(Ln=n.createElement("circle",{cx:"18",cy:"14",r:"3"})),Mn||(Mn=n.createElement("path",{d:"M9,17a3,3,0,1,1,3-3A3.0033,3.0033,0,0,1,9,17Zm0-4a1,1,0,1,0,1,1A1.001,1.001,0,0,0,9,13Z"})),yn||(yn=n.createElement("circle",{cx:"27",cy:"6",r:"3"})),Rn||(Rn=n.createElement("circle",{cx:"27",cy:"22",r:"3"})),Sn||(Sn=n.createElement("path",{d:"M27 17a3 3 0 113-3A3.0033 3.0033 0 0127 17zm0-4a1 1 0 101 1A1.001 1.001 0 0027 13zM18 26a3 3 0 113-3A3.0033 3.0033 0 0118 26zm0-4a1 1 0 101 1A1.001 1.001 0 0018 22zM18 8a3 3 0 113-3A3.0033 3.0033 0 0118 8zm0-4a1 1 0 101 1A1.001 1.001 0 0018 4z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Nl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),An||(An=n.createElement("path",{d:"M30,22H17V20h9V14H17V12h5V6H17V2H15V6H10v6h5v2H6v6h9v2H2v6H15v2h2V28H30ZM20,8v2H17V8Zm-8,2V8h3v2Zm12,6v2H17V16ZM8,18V16h7v2ZM4,26V24H15v2Zm24,0H17V24H28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Yl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Dn||(Dn=n.createElement("path",{d:"M16,2,2,13,8,30H24l6-17Zm2.5818,19.2651-5.9861,1.3306-1.4226-7.8252,4.91-4.209,5.4416,4.0816Zm.1977,2.0054L21.3264,28H10.6736l1.7912-3.3267ZM9.59,13.4937,5.74,12.605,15,5.3291V8.8569ZM17,8.75V5.3291l9.26,7.2759-3.15.727ZM4.6143,14.3979l4.6535,1.0738,1.4844,8.164-1.738,3.2281ZM22.9858,26.8638l-2.5766-4.7852,3.0063-6.7646,3.97-.9161Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Zl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Vn||(Vn=n.createElement("path",{d:"M16,30A14.0158,14.0158,0,0,1,2,16H4A12,12,0,1,0,16,4V2a14,14,0,0,1,0,28Z"})),Tn||(Tn=n.createElement("path",{d:"M16,26A10.0115,10.0115,0,0,1,6,16H8a8,8,0,1,0,8-8V6a10,10,0,0,1,0,20Z"})),Wn||(Wn=n.createElement("path",{d:"M16,22a6.0069,6.0069,0,0,1-6-6h2a4,4,0,1,0,4-4V10a6,6,0,0,1,0,12Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Pl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Un||(Un=n.createElement("path",{d:"M26,6a3.9963,3.9963,0,0,0-3.8579,3H17.9305A7.9964,7.9964,0,1,0,9,17.9307v4.2114a4,4,0,1,0,2,0V17.9307a7.951,7.951,0,0,0,3.8976-1.6192l3.6693,3.67A3.9529,3.9529,0,0,0,18,22a4,4,0,1,0,4-4,3.9521,3.9521,0,0,0-2.019.5669l-3.6694-3.6694A7.9493,7.9493,0,0,0,17.9305,11h4.2116A3.9934,3.9934,0,1,0,26,6ZM12,26a2,2,0,1,1-2-2A2.0023,2.0023,0,0,1,12,26ZM10,16a6,6,0,1,1,6-6A6.0066,6.0066,0,0,1,10,16Zm14,6a2,2,0,1,1-2-2A2.0023,2.0023,0,0,1,24,22Zm2-10a2,2,0,1,1,2-2A2.0023,2.0023,0,0,1,26,12Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Gl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),In||(In=n.createElement("path",{d:"M16,2A14,14,0,1,0,30,16,14.0158,14.0158,0,0,0,16,2ZM27.9493,15.001H21.91a5.9825,5.9825,0,0,0-9.3806-3.8853l-4.27-4.27a11.9783,11.9783,0,0,1,19.69,8.1548ZM16,20a4,4,0,1,1,4-4A4.0045,4.0045,0,0,1,16,20ZM4,16A11.937,11.937,0,0,1,6.8455,8.26l4.27,4.2695A5.9836,5.9836,0,0,0,15,21.9106v6.04A12.0105,12.0105,0,0,1,4,16ZM17,27.95v-6.04A6.0069,6.0069,0,0,0,21.91,17h6.04A12.0082,12.0082,0,0,1,17,27.95Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,jl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Bn||(Bn=n.createElement("path",{d:"M12.4326,20.0171l8.0376,4.68a1.958,1.958,0,0,0,1.0508.3012,2.2412,2.2412,0,0,0,.4888-.0556l7.2532-1.9769A1,1,0,0,0,30,22.0007V7.996A1,1,0,0,0,28.74,7.0305L21.5034,8.9829l-8.0371-4.68a1.9917,1.9917,0,0,0-1.8652-.1352L4,7.4727V2H2V28a2,2,0,0,0,2,2H30V28H4V23.6577ZM28,21.2344l-6.4966,1.75-8.0371-4.68a1.9931,1.9931,0,0,0-1.8652-.1353L4,21.4746V16.6572l8.4326-3.6416L20.47,17.6968a1.962,1.962,0,0,0,1.0508.3008,2.2112,2.2112,0,0,0,.4888-.0557L28,16.31ZM12.4326,6.0156l8.0376,4.68a2.0091,2.0091,0,0,0,1.54.2451L28,9.3081v4.9258l-6.4966,1.7505-8.0371-4.6812a1.9917,1.9917,0,0,0-1.8652-.1352L4,14.4736V9.6562Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Kl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),On||(On=n.createElement("path",{d:"M30,17A15.017,15.017,0,0,0,15,2H14V8.0591A9.0122,9.0122,0,0,0,6.0591,16H4v1A11.0109,11.0109,0,0,0,14,27.9492V30h1A13.0084,13.0084,0,0,0,27.9492,18H30ZM16,4.0381A13.0217,13.0217,0,0,1,27.9619,16H16ZM14,10.08V16H8.08A7.0037,7.0037,0,0,1,14,10.08ZM6.0552,18H14v7.939A9.0134,9.0134,0,0,1,6.0552,18ZM16,27.9551V18h9.9551A11.0191,11.0191,0,0,1,16,27.9551Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ql);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Fn||(Fn=n.createElement("path",{d:"M30,30H4a2,2,0,0,1-2-2V2H4V28H30Z"})),Xn||(Xn=n.createElement("circle",{cx:"10",cy:"22",r:"2"})),Cn||(Cn=n.createElement("circle",{cx:"14",cy:"15",r:"2"})),qn||(qn=n.createElement("circle",{cx:"22",cy:"15",r:"2"})),Hn||(Hn=n.createElement("circle",{cx:"26",cy:"6",r:"2"})),kn||(kn=n.createElement("circle",{cx:"14",cy:"8",r:"2"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Jl);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Nn||(Nn=n.createElement("path",{d:"M16,2A13.919,13.919,0,0,0,7.3245,5.0327,1.9728,1.9728,0,0,0,7,5,2,2,0,0,0,5,7a1.9752,1.9752,0,0,0,.0327.3247A13.986,13.986,0,1,0,16,2Zm0,26A11.977,11.977,0,0,1,6.3589,8.8857a1.8311,1.8311,0,0,0,1.1528.04l1.4634,1.4634a8.9862,8.9862,0,0,0,11.8311,13.207,1.9916,1.9916,0,0,0,2.79-2.79,8.9294,8.9294,0,0,0,0-9.6124,1.9916,1.9916,0,0,0-2.79-2.79,8.9445,8.9445,0,0,0-10.417.5713L8.9258,7.5117a1.8294,1.8294,0,0,0-.04-1.1528A11.9925,11.9925,0,1,1,16,28Zm0-14a2,2,0,1,1-2,2A2.0025,2.0025,0,0,1,16,14Zm3.4331-.019,2.0552-2.0552a2.0443,2.0443,0,0,0,.2265.0454,6.9573,6.9573,0,0,1,0,8.0576,2.0443,2.0443,0,0,0-.2265.0454L19.4331,18.019a3.8788,3.8788,0,0,0,0-4.038Zm.5957-3.6958a1.9993,1.9993,0,0,0,.0454.2265L18.019,12.5669a3.8788,3.8788,0,0,0-4.038,0l-2.1653-2.1655a6.9522,6.9522,0,0,1,8.2131-.1162ZM12.5669,13.981A3.951,3.951,0,0,0,12,16a4.0045,4.0045,0,0,0,4,4,3.9521,3.9521,0,0,0,2.019-.5669l2.0552,2.0552a1.9993,1.9993,0,0,0-.0454.2265,6.988,6.988,0,0,1-9.6272-9.8994Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,$l);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Yn||(Yn=n.createElement("path",{d:"M28,28V6H20V28H16V14H8V28H4V2H2V28a2,2,0,0,0,2,2H30V28ZM22,8h4V18H22ZM10,16h4v6H10Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,er);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Zn||(Zn=n.createElement("path",{d:"M14,22V14h8V6h8V4H20v8H12v8H4V2H2V28a2.0025,2.0025,0,0,0,2,2H30V28H4V22Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,nr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Pn||(Pn=n.createElement("path",{d:"M16,2a1,1,0,0,0-1,1v7.09a5.9618,5.9618,0,0,0-2.46,1.043L7.8384,6.4311a1.4554,1.4554,0,0,0-2.087.0244A14.05,14.05,0,0,0,9.8047,28.5972a10.8482,10.8482,0,0,0,1.8989.7676,14.0982,14.0982,0,0,0,13.8443-3.1319,1.4336,1.4336,0,0,0,.0278-2.0639L20.877,19.47A5.963,5.963,0,0,0,21.91,17H29a1,1,0,0,0,1-1A14.0158,14.0158,0,0,0,16,2Zm0,10a4,4,0,1,1-4,4A4.0045,4.0045,0,0,1,16,12ZM6.83,8.251l4.2959,4.2959a5.91,5.91,0,0,0-.0113,6.9243L6.8381,23.7481A12.0168,12.0168,0,0,1,6.83,8.251Zm1.4228,16.91,4.2759-4.2759A5.9589,5.9589,0,0,0,15,21.91v6.042A11.8783,11.8783,0,0,1,8.2529,25.1612ZM17,27.9561V21.9092a5.9631,5.9631,0,0,0,2.4609-1.0273l4.2818,4.2817A11.8905,11.8905,0,0,1,17,27.9561ZM21.91,15A6.0063,6.0063,0,0,0,17,10.09V4.041A12.0208,12.0208,0,0,1,27.9585,15Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,tr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Gn||(Gn=n.createElement("circle",{cx:"10",cy:"20",r:"2"})),jn||(jn=n.createElement("circle",{cx:"10",cy:"28",r:"2"})),Kn||(Kn=n.createElement("circle",{cx:"10",cy:"14",r:"2"})),Qn||(Qn=n.createElement("circle",{cx:"28",cy:"4",r:"2"})),Jn||(Jn=n.createElement("circle",{cx:"22",cy:"6",r:"2"})),$n||($n=n.createElement("circle",{cx:"28",cy:"10",r:"2"})),et||(et=n.createElement("circle",{cx:"20",cy:"12",r:"2"})),nt||(nt=n.createElement("circle",{cx:"28",cy:"22",r:"2"})),tt||(tt=n.createElement("circle",{cx:"26",cy:"28",r:"2"})),it||(it=n.createElement("circle",{cx:"20",cy:"26",r:"2"})),st||(st=n.createElement("circle",{cx:"22",cy:"20",r:"2"})),lt||(lt=n.createElement("circle",{cx:"16",cy:"4",r:"2"})),rt||(rt=n.createElement("circle",{cx:"4",cy:"24",r:"2"})),at||(at=n.createElement("circle",{cx:"4",cy:"16",r:"2"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ir);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),dt||(dt=n.createElement("path",{d:"M28,2H4A2.0023,2.0023,0,0,0,2,4V28a2.0023,2.0023,0,0,0,2,2H28a2.0023,2.0023,0,0,0,2-2V4A2.0023,2.0023,0,0,0,28,2Zm0,12H23V4h5ZM16,4h5V14H16ZM14,4V20H4V4ZM4,22H14v6H4Zm12,6V16H28V28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,sr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),_t||(_t=n.createElement("path",{d:"M20,6a9.92,9.92,0,0,0-4,.84A9.92,9.92,0,0,0,12,6a10,10,0,0,0,0,20,9.92,9.92,0,0,0,4-.84A9.92,9.92,0,0,0,20,26,10,10,0,0,0,20,6ZM12,24A8,8,0,0,1,12,8a7.91,7.91,0,0,1,1.76.2,10,10,0,0,0,0,15.6A7.91,7.91,0,0,1,12,24Zm8-8a8,8,0,0,1-4,6.92A8,8,0,0,1,16,9.08,8,8,0,0,1,20,16Zm0,8a7.91,7.91,0,0,1-1.76-.2,10,10,0,0,0,0-15.6A7.91,7.91,0,0,1,20,8a8,8,0,0,1,0,16Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,lr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ot||(ot=n.createElement("path",{d:"M30,30H4a2,2,0,0,1-2-2V2H4V28H30Z"})),mt||(mt=n.createElement("path",{d:"M14.86 7.8232L13 4.7231V2H11V4.7231l-1.86 3.1A7.9986 7.9986 0 008 11.939v.122a7.9961 7.9961 0 001.14 4.1158l1.86 3.1V26h2V19.2769l1.86-3.1A7.9986 7.9986 0 0016 12.061v-.122A7.9961 7.9961 0 0014.86 7.8232zM12 6.9434l1.145 1.9087A6.0027 6.0027 0 0113.9185 11h-3.837a6.0086 6.0086 0 01.7735-2.1484zm0 10.1132l-1.145-1.9087A6.0027 6.0027 0 0110.0815 13h3.837a6.0086 6.0086 0 01-.7735 2.1484zM27.86 11.8232L26 8.7231V2H24V8.7231l-1.86 3.1A7.9986 7.9986 0 0021 15.939v.122a7.9961 7.9961 0 001.14 4.1158l1.86 3.1V26h2V23.2769l1.86-3.1A7.9986 7.9986 0 0029 16.061v-.122A7.9961 7.9961 0 0027.86 11.8232zm-2.86-.88l1.145 1.9087A6.0027 6.0027 0 0126.9185 15h-3.837a6.0086 6.0086 0 01.7735-2.1484zm0 10.1132l-1.145-1.9087A6.0027 6.0027 0 0123.0815 17h3.837a6.0086 6.0086 0 01-.7735 2.1484z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,rr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),vt||(vt=n.createElement("path",{d:"M28,28V18H26V28H22V4H20V28H10V14H8V28H4V2H2V28a2.0023,2.0023,0,0,0,2,2H30V28Z"})),ft||(ft=n.createElement("path",{d:"M14 4H16V18H14z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ar);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ut||(ut=n.createElement("path",{d:"M30,15H16V6a2.0023,2.0023,0,0,0-2-2H6A2.0023,2.0023,0,0,0,4,6v9H2v2H16v9a2.0023,2.0023,0,0,0,2,2h8a2.0023,2.0023,0,0,0,2-2V17h2ZM6,6h8v9H6ZM26,26H18V17h8Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,dr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ct||(ct=n.createElement("path",{d:"M17.74,30,16,29l4-7h6a2,2,0,0,0,2-2V8a2,2,0,0,0-2-2H6A2,2,0,0,0,4,8V20a2,2,0,0,0,2,2h9v2H6a4,4,0,0,1-4-4V8A4,4,0,0,1,6,4H26a4,4,0,0,1,4,4V20a4,4,0,0,1-4,4H21.16Z"})),pt||(pt=n.createElement("path",{d:"M8 10H24V12H8zM8 16H18V18H8z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,_r);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Et||(Et=n.createElement("path",{d:"M22 4L22 6 26.586 6 20 12.586 21.414 14 28 7.414 28 12 30 12 30 4 22 4zM28 16v4a1.9965 1.9965 0 01-2 2H20l-4 7 1.7358 1 3.4288-6H26a3.9992 3.9992 0 004-4V16zM4 20V8A1.9965 1.9965 0 016 6H18V4H6A3.9986 3.9986 0 002 8V20a3.9992 3.9992 0 004 4h9V22H6A1.9965 1.9965 0 014 20z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,or);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ht||(ht=n.createElement("path",{d:"M28 8V21h2V8a3.9986 3.9986 0 00-4-4H8.2429l2 2H26A1.9965 1.9965 0 0128 8zM30 28.5859L3.4141 2 2 3.4141 3.5039 4.918A3.9181 3.9181 0 002 8V20a3.9992 3.9992 0 004 4h6V22H6a1.9965 1.9965 0 01-2-2V8a1.9814 1.9814 0 01.9194-1.6665L20.5859 22H17l-4 7 1.7358 1 3.4288-6h4.4213l6 6z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,mr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),gt||(gt=n.createElement("path",{d:"M15.586 10.414L19.166 14 19.166 14 15.584 17.587 17 19 22 14 17 9 15.586 10.414z"})),wt||(wt=n.createElement("path",{d:"M20.586 10.414L24.166 14 24.166 14 20.584 17.587 22 19 27 14 22 9 20.586 10.414zM10 9L11.593 12 15 12.414 12.5 14.667 13 18 10 16.125 7 18 7.5 14.667 5 12.414 8.5 12 10 9z"})),bt||(bt=n.createElement("path",{d:"M17.7358,30,16,29l4-7h6a1.9966,1.9966,0,0,0,2-2V8a1.9966,1.9966,0,0,0-2-2H6A1.9966,1.9966,0,0,0,4,8V20a1.9966,1.9966,0,0,0,2,2h9v2H6a3.9993,3.9993,0,0,1-4-4V8A3.9988,3.9988,0,0,1,6,4H26a3.9988,3.9988,0,0,1,4,4V20a3.9993,3.9993,0,0,1-4,4H21.1646Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,vr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),xt||(xt=n.createElement("path",{d:"M16 19a6.9908 6.9908 0 01-5.833-3.1287l1.666-1.1074a5.0007 5.0007 0 008.334 0l1.666 1.1074A6.9908 6.9908 0 0116 19zM20 8a2 2 0 102 2A1.9806 1.9806 0 0020 8zM12 8a2 2 0 102 2A1.9806 1.9806 0 0012 8z"})),zt||(zt=n.createElement("path",{d:"M17.7358,30,16,29l4-7h6a1.9966,1.9966,0,0,0,2-2V6a1.9966,1.9966,0,0,0-2-2H6A1.9966,1.9966,0,0,0,4,6V20a1.9966,1.9966,0,0,0,2,2h9v2H6a3.9993,3.9993,0,0,1-4-4V6A3.9988,3.9988,0,0,1,6,2H26a3.9988,3.9988,0,0,1,4,4V20a3.9993,3.9993,0,0,1-4,4H21.1646Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,fr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Lt||(Lt=n.createElement("path",{d:"M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM6,26V6H26V26Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ur);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Mt||(Mt=n.createElement("path",{d:"M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM6,26V6H26V26Z"})),yt||(yt=n.createElement("path",{d:"M14 21.5L9 16.54 10.59 15 14 18.35 21.41 11 23 12.58 14 21.5z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,cr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Rt||(Rt=n.createElement("path",{d:"M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM14,21.5,9,16.5427,10.5908,15,14,18.3456,21.4087,11l1.5918,1.5772Z"})),St||(St=n.createElement("path",{fill:"none",d:"M14,21.5,9,16.5427,10.5908,15,14,18.3456,21.4087,11l1.5918,1.5772Z","data-icon-path":"inner-path"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,pr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),At||(At=n.createElement("path",{d:"M10 14H22V18H10z"})),Dt||(Dt=n.createElement("path",{d:"M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM6,26V6H26V26Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Er);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Vt||(Vt=n.createElement("path",{d:"M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM22,18H10V14H22Z"})),Tt||(Tt=n.createElement("path",{fill:"none",d:"M22,18H10V14H22Z","data-icon-path":"inner-path"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,hr);return 20===l||"20"===l||"20px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor"},r),Wt||(Wt=n.createElement("path",{d:"M8 13.2L3.6 8.8 2.7 9.7 7.1 14.1 8 15 16.5 6.5 15.6 5.6z"})),Ut||(Ut=n.createElement("path",{d:"M15.6 5.6L8 13.2 3.6 8.8 2.7 9.7 7.1 14.1 8 15 16.5 6.5 15.6 5.6z"})),i):24===l||"24"===l||"24px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor"},r),It||(It=n.createElement("path",{d:"M10 15.9L4.7 10.6 3.6 11.6 8.9 16.9 10 18 20.6 7.4 19.5 6.3z"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Bt||(Bt=n.createElement("path",{d:"M13 24L4 15 5.414 13.586 13 21.171 26.586 7.586 28 9 13 24z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,gr);return 16===l||"16"===l||"16px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),Ot||(Ot=n.createElement("path",{d:"M8,1C4.1,1,1,4.1,1,8c0,3.9,3.1,7,7,7s7-3.1,7-7C15,4.1,11.9,1,8,1z M7,11L4.3,8.3l0.9-0.8L7,9.3l4-3.9l0.9,0.8L7,11z"})),Ft||(Ft=n.createElement("path",{d:"M7,11L4.3,8.3l0.9-0.8L7,9.3l4-3.9l0.9,0.8L7,11z","data-icon-path":"inner-path",opacity:"0"})),i):20===l||"20"===l||"20px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor"},r),Xt||(Xt=n.createElement("path",{d:"M10,1c-4.9,0-9,4.1-9,9s4.1,9,9,9s9-4,9-9S15,1,10,1z M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z"})),Ct||(Ct=n.createElement("path",{fill:"none",d:"M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z","data-icon-path":"inner-path",opacity:"0"})),i):24===l||"24"===l||"24px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor"},r),qt||(qt=n.createElement("path",{d:"M12,1C6,1,1,6,1,12s5,11,11,11s11-4.9,11-11S18.1,1,12,1z M10.4,16.3l-3.9-3.9l1.3-1.2l2.7,2.7l5.8-5.8l1.3,1.3L10.4,16.3z"})),Ht||(Ht=n.createElement("path",{fill:"none",d:"M10.4,16.3l-3.9-3.9l1.3-1.2l2.7,2.7l5.8-5.8l1.3,1.3L10.4,16.3z","data-icon-path":"inner-path",opacity:"0"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),kt||(kt=n.createElement("path",{d:"M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2ZM14,21.5908l-5-5L10.5906,15,14,18.4092,21.41,11l1.5957,1.5859Z"})),Nt||(Nt=n.createElement("path",{fill:"none",d:"M14 21.591L9 16.591 10.591 15 14 18.409 21.41 11 23.005 12.585 14 21.591z","data-icon-path":"inner-path"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,wr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Yt||(Yt=n.createElement("path",{d:"M30,24a6,6,0,1,0-6,6A6.0066,6.0066,0,0,0,30,24Zm-2,0a3.9521,3.9521,0,0,1-.5669,2.019L21.981,20.5669A3.9529,3.9529,0,0,1,24,20,4.0045,4.0045,0,0,1,28,24Zm-8,0a3.9521,3.9521,0,0,1,.5669-2.019l5.4521,5.4521A3.9529,3.9529,0,0,1,24,28,4.0045,4.0045,0,0,1,20,24Z"})),Zt||(Zt=n.createElement("path",{d:"M14,2a12,12,0,1,0,2,23.82V24a8,8,0,0,1,8-8h1.82A11.9348,11.9348,0,0,0,14,2ZM12,18.5908l-4-4L9.5908,13,12,15.4092,17.4092,10,19,11.5908Z"})),Pt||(Pt=n.createElement("path",{fill:"none",d:"M12 18.591L8 14.591 9.591 13 12 15.409 17.409 10 19 11.591 12 18.591z","data-icon-path":"inner-path"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,br);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Gt||(Gt=n.createElement("path",{d:"M14,2a12,12,0,1,0,3.3928,23.5059l3.9246-7.8492A2.9846,2.9846,0,0,1,24,16h1.82A11.9348,11.9348,0,0,0,14,2ZM12,18.5908l-4-4L9.5908,13,12,15.4092,17.4092,10,19,11.5908Z"})),jt||(jt=n.createElement("path",{d:"M27.38,28H20.6178L24,21.2358ZM24,18a1,1,0,0,0-.8947.5527l-5,10A1.0005,1.0005,0,0,0,19,30H29a1,1,0,0,0,.9214-1.3892L24.8946,18.5527A1,1,0,0,0,24,18Z"})),Kt||(Kt=n.createElement("path",{fill:"none",d:"M12 18.591L8 14.591 9.591 13 12 15.409 17.409 10 19 11.591 12 18.591z","data-icon-path":"inner-path"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,xr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Qt||(Qt=n.createElement("path",{d:"M14 21.414L9 16.413 10.413 15 14 18.586 21.585 11 23 12.415 14 21.414z"})),Jt||(Jt=n.createElement("path",{d:"M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,26A12,12,0,1,1,28,16,12,12,0,0,1,16,28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,zr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),$t||($t=n.createElement("path",{d:"M14,24A10,10,0,1,1,24,14h2A12,12,0,1,0,14,26Z"})),ei||(ei=n.createElement("path",{d:"M12 15.59L9.41 13 8 14.41 12 18.41 19 11.41 17.59 10 12 15.59zM30 24a6 6 0 10-6 6A6.0066 6.0066 0 0030 24zm-2 0a3.9521 3.9521 0 01-.5669 2.019L21.981 20.5669A3.9529 3.9529 0 0124 20 4.0045 4.0045 0 0128 24zm-8 0a3.9521 3.9521 0 01.5669-2.019l5.4521 5.4521A3.9529 3.9529 0 0124 28 4.0045 4.0045 0 0120 24z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Lr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ni||(ni=n.createElement("path",{d:"M14,24A10,10,0,1,1,24,14h2A12,12,0,1,0,14,26Z"})),ti||(ti=n.createElement("path",{d:"M12 15.59L9.41 13 8 14.41 12 18.41 19 11.41 17.59 10 12 15.59zM27.38 28H20.6178L24 21.2358zM24 18a1 1 0 00-.8947.5527l-5 10A1.0005 1.0005 0 0019 30H29a1 1 0 00.9214-1.3892L24.8946 18.5527A1 1 0 0024 18z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Mr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ii||(ii=n.createElement("path",{d:"M27.2314,23.6182,20,13.6748V4h2V2H10V4h2v9.6748L4.7686,23.6182A4.0183,4.0183,0,0,0,8.0186,30H23.9814a4.0183,4.0183,0,0,0,3.25-6.3818ZM14,14.3252V4h4V14.3252L20.6728,18H11.3272ZM23.9814,28H8.0186a2.0192,2.0192,0,0,1-1.6329-3.2061L9.8726,20H22.1274l3.4869,4.7939A2.0192,2.0192,0,0,1,23.9814,28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,yr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),si||(si=n.createElement("path",{d:"M4 20L4 22 8.586 22 2 28.586 3.414 30 10 23.414 10 28 12 28 12 20 4 20z"})),li||(li=n.createElement("path",{d:"M20,13.67V4h2V2H10V4h2v9.67L9.58,17h2.4767L14,14.33V4h4V14.33l7.61,10.46a2.0133,2.0133,0,0,1-.44,2.82,2.0406,2.0406,0,0,1-1.19.39H15v2h8.98a4.0154,4.0154,0,0,0,3.25-6.38Z"})),i)})).propTypes=ol;var Sa=n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Rr);return"glyph"===l||"glyph"===l||"glyphpx"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 10 6",fill:"currentColor"},r),ri||(ri=n.createElement("path",{d:"M5 6L0 1 0.7 0.3 5 4.6 9.3 0.3 10 1z"})),i):16===l||"16"===l||"16px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),ai||(ai=n.createElement("path",{d:"M8 11L3 6 3.7 5.3 8 9.6 12.3 5.3 13 6z"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),di||(di=n.createElement("path",{d:"M16 22L6 12 7.4 10.6 16 19.2 24.6 10.6 26 12z"})),i)}));Sa.propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Sr);return"glyph"===l||"glyph"===l||"glyphpx"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 6 10",fill:"currentColor"},r),_i||(_i=n.createElement("path",{d:"M0 5L5 0 5.7 0.7 1.4 5 5.7 9.3 5 10z"})),i):16===l||"16"===l||"16px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),oi||(oi=n.createElement("path",{d:"M5 8L10 3 10.7 3.7 6.4 8 10.7 12.3 10 13z"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),mi||(mi=n.createElement("path",{d:"M10 16L20 6 21.4 7.4 12.8 16 21.4 24.6 20 26z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ar);return 16===l||"16"===l||"16px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),vi||(vi=n.createElement("path",{d:"M15 9L15 15 9 15z"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),fi||(fi=n.createElement("path",{d:"M31 19L31 31 19 31 31 19z"})),i)})).propTypes=ol;var Aa=n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Dr);return"glyph"===l||"glyph"===l||"glyphpx"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 6 10",fill:"currentColor"},r),ui||(ui=n.createElement("path",{d:"M6 5L1 10 0.3 9.3 4.6 5 0.3 0.7 1 0z"})),i):16===l||"16"===l||"16px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),ci||(ci=n.createElement("path",{d:"M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),pi||(pi=n.createElement("path",{d:"M22 16L12 26 10.6 24.6 19.2 16 10.6 7.4 12 6z"})),i)}));Aa.propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Vr);return 16===l||"16"===l||"16px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),Ei||(Ei=n.createElement("path",{d:"M8 14L4.5 10.5 5.2 9.8 8 12.6 10.8 9.8 11.5 10.5zM8 2L11.5 5.5 10.8 6.2 8 3.4 5.2 6.2 4.5 5.5z"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),hi||(hi=n.createElement("path",{d:"M16 28L9 21 10.41 19.59 16 25.17 21.59 19.59 23 21 16 28zM16 4L23 11 21.59 12.41 16 6.83 10.41 12.41 9 11 16 4z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Tr);return 16===l||"16"===l||"16px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),gi||(gi=n.createElement("path",{d:"M8 14L4.5 10.5 5.2 9.8 8 12.6 10.8 9.8 11.5 10.5z"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),wi||(wi=n.createElement("path",{d:"M16 28L9 21 10.4 19.6 16 25.2 21.6 19.6 23 21z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Wr);return 16===l||"16"===l||"16px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),bi||(bi=n.createElement("path",{d:"M8 2L11.5 5.5 10.8 6.2 8 3.4 5.2 6.2 4.5 5.5z"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),xi||(xi=n.createElement("path",{d:"M16 4L23 11 21.6 12.4 16 6.8 10.4 12.4 9 11z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ur);return"glyph"===l||"glyph"===l||"glyphpx"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 10 6",fill:"currentColor"},r),zi||(zi=n.createElement("path",{d:"M5 0L10 5 9.3 5.7 5 1.4 0.7 5.7 0 5z"})),i):16===l||"16"===l||"16px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),Li||(Li=n.createElement("path",{d:"M8 5L13 10 12.3 10.7 8 6.4 3.7 10.7 3 10z"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Mi||(Mi=n.createElement("path",{d:"M16 10L26 20 24.6 21.4 16 12.8 7.4 21.4 6 20z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ir);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),yi||(yi=n.createElement("path",{d:"M11,11V21H21V11Zm8,8H13V13h6Z"})),Ri||(Ri=n.createElement("path",{d:"M30,13V11H26V8a2,2,0,0,0-2-2H21V2H19V6H13V2H11V6H8A2,2,0,0,0,6,8v3H2v2H6v6H2v2H6v3a2,2,0,0,0,2,2h3v4h2V26h6v4h2V26h3a2,2,0,0,0,2-2V21h4V19H26V13ZM24,24H8V8H24Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Br);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Si||(Si=n.createElement("path",{d:"M28 13L28 4 19 4 19 6 24.586 6 16 14.586 7.414 6 13 6 13 4 4 4 4 13 6 13 6 7.414 15 16.414 15 26 4 26 4 28 28 28 28 26 17 26 17 16.414 26 7.414 26 13 28 13z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Or);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ai||(Ai=n.createElement("path",{d:"M28 6H30V26H28zM17 6L15.57 7.393 23.15 15 2 15 2 17 23.15 17 15.57 24.573 17 26 27 16 17 6z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Fr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Di||(Di=n.createElement("path",{d:"M29.2427,4.03l-8-2a1.0065,1.0065,0,0,0-.6143.0415l-9.7,3.88L3.2427,4.03A1,1,0,0,0,2,5V27a1,1,0,0,0,.7573.97l8,2A1.0244,1.0244,0,0,0,11,30a.9953.9953,0,0,0,.3716-.0718l9.7-3.88,7.686,1.9219A1,1,0,0,0,30,27V5A1,1,0,0,0,29.2427,4.03ZM28,11H22V4.2806l6,1.5ZM10,19H4V13h6Zm2-8V7.6771l8-3.2V11Zm8,2v6H12V13Zm-8,8h8v3.3227l-8,3.2Zm10-8h6v6H22ZM10,7.7806V11H4V6.2806ZM4,21h6v6.7192l-6-1.5Zm18,3.2187V21h6v4.7192Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Xr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Vi||(Vi=n.createElement("path",{d:"M30.3335 30H26V28h4V26H28a2.002 2.002 0 01-2-2V21.6665A1.6684 1.6684 0 0127.6665 20H32v2H28v2h2a2.002 2.002 0 012 2v2.3335A1.6684 1.6684 0 0130.3335 30zM22.3335 20h-2.667A1.6665 1.6665 0 0018 21.6665V30h2V26h2v4h2V21.6665A1.6665 1.6665 0 0022.3335 20zM20 24V22h2v2zM12.5 24L11 20 9 20 9 30 11 30 11 23 12.5 27 14 23 14 30 16 30 16 20 14 20 12.5 24zM1 22v6.5A1.4727 1.4727 0 002.5 30H7V28H3V22H7V20H3A2.0059 2.0059 0 001 22zM13 8L11 8 11 11 8 11 8 13 11 13 11 16 13 16 13 13 16 13 16 11 13 11 13 8z"})),Ti||(Ti=n.createElement("path",{d:"M6,6H26V18h2V6a2.0059,2.0059,0,0,0-2-2H6A2.0059,2.0059,0,0,0,4,6V18H6Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Cr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Wi||(Wi=n.createElement("path",{d:"M24 16L19.4 14.6 21.7 10.3 17.4 12.6 16 8 14.6 12.6 10.3 10.3 12.6 14.6 8 16 12.6 17.4 10.3 21.7 14.6 19.4 16 24 17.4 19.4 21.7 21.7 19.4 17.4 24 16z"})),Ui||(Ui=n.createElement("path",{d:"M16,30A14,14,0,1,1,30,16,14.0158,14.0158,0,0,1,16,30ZM16,4A12,12,0,1,0,28,16,12.0137,12.0137,0,0,0,16,4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,qr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ii||(Ii=n.createElement("path",{d:"M28 2H23V4h5V28H23v2h5a2.0059 2.0059 0 002-2V4A2.0059 2.0059 0 0028 2zM14 17H8a.9448.9448 0 00-1 1v6a.9448.9448 0 001 1h6a.9448.9448 0 001-1V18A.9448.9448 0 0014 17zm-1 6H9V19h4z"})),Bi||(Bi=n.createElement("path",{d:"M25 24V18a.9448.9448 0 00-1-1H18a.9448.9448 0 00-1 1v6a.9448.9448 0 001 1h6A1.0021 1.0021 0 0025 24zm-2-1H19V19h4zM14 7H8A.9448.9448 0 007 8v6a.9448.9448 0 001 1h6a.9448.9448 0 001-1V8A.9448.9448 0 0014 7zm-1 6H9V9h4zM18 15h6a.9448.9448 0 001-1V8a.9448.9448 0 00-1-1H18a.9448.9448 0 00-1 1v6A1.0021 1.0021 0 0018 15zm1-6h4v4H19z"})),Oi||(Oi=n.createElement("path",{d:"M4,4H9V2H4A2.0059,2.0059,0,0,0,2,4V28a2.0059,2.0059,0,0,0,2,2H9V28H4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Hr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Fi||(Fi=n.createElement("path",{d:"M22 22L24 22 24 28 22 28 22 30 28 30 28 28 26 28 26 22 28 22 28 20 22 20 22 22zM18 28H16V20H14v8.6A1.4529 1.4529 0 0015.5 30h3A1.4529 1.4529 0 0020 28.6V20H18zM10.2 20L10 28.5 9 22 7 22 6 28.5 5.8 20 4 20 4.72 30 7 30 8 23.5 9 30 11.28 30 12 20 10.2 20zM16 11L13 11 13 8 11 8 11 11 8 11 8 13 11 13 11 16 13 16 13 13 16 13 16 11z"})),Xi||(Xi=n.createElement("path",{d:"M26,4H6A2.0059,2.0059,0,0,0,4,6V18H6V6H26V18h2V6A2.0059,2.0059,0,0,0,26,4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,kr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ci||(Ci=n.createElement("path",{d:"M23.5 18L21 18.7 21 16 19 16 19 18.7 16.5 18 16 19.9 18.4 20.6 17 23 18.7 24 20 21.8 21.3 24 23 23 21.6 20.6 24 19.9 23.5 18zM16 13L16 11 13 11 13 8 11 8 11 11 8 11 8 13 11 13 11 16 13 16 13 13 16 13z"})),qi||(qi=n.createElement("path",{d:"M26,4H6A2.0059,2.0059,0,0,0,4,6V26a2.0059,2.0059,0,0,0,2,2H26a2.0059,2.0059,0,0,0,2-2V6A2.0059,2.0059,0,0,0,26,4ZM6,26V6H26V26Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Nr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Hi||(Hi=n.createElement("path",{d:"M22 2L22 4 26.6 4 20 10.6 21.4 12 28 5.4 28 10 30 10 30 2 22 2zM19 16L19 18.7 16.5 18 16 19.9 18.4 20.6 17 23 18.7 24 20 21.8 21.3 24 23 23 21.6 20.6 24 19.9 23.5 18 21 18.7 21 16 19 16zM13 16L13 13 16 13 16 11 13 11 13 8 11 8 11 11 8 11 8 13 11 13 11 16 13 16z"})),ki||(ki=n.createElement("path",{d:"M26,26H6V6H19V4H6A2.0059,2.0059,0,0,0,4,6V26a2.0059,2.0059,0,0,0,2,2H26a2.0059,2.0059,0,0,0,2-2V13H26Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Yr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ni||(Ni=n.createElement("path",{d:"M26 7H28V10H26zM29 4H32V6H29zM26 0H28V3H26zM22 4H25V6H22zM19 16L19 18.7 16.5 18 16 19.9 18.4 20.6 17 23 18.7 24 20 21.8 21.3 24 23 23 21.6 20.6 24 19.9 23.5 18 21 18.7 21 16 19 16zM13 16L13 13 16 13 16 11 13 11 13 8 11 8 11 11 8 11 8 13 11 13 11 16 13 16z"})),Yi||(Yi=n.createElement("path",{d:"M26,26H6V6H19V4H6A2.0059,2.0059,0,0,0,4,6V26a2.0059,2.0059,0,0,0,2,2H26a2.0059,2.0059,0,0,0,2-2V13H26Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Zr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Zi||(Zi=n.createElement("path",{d:"M8 18.6V17H6v1.6A7.3833 7.3833 0 0013.4 26H15V24H13.4A5.3775 5.3775 0 018 18.6zM28 18H20a2.0059 2.0059 0 00-2 2v8a2.0059 2.0059 0 002 2h8a2.0059 2.0059 0 002-2V20A2.0059 2.0059 0 0028 18zM20 28V20h8v8zM24 13.4V15h2V13.4A7.3833 7.3833 0 0018.6 6H17V8h1.6A5.3775 5.3775 0 0124 13.4zM12 2H4A2.0059 2.0059 0 002 4v8a2.0059 2.0059 0 002 2h8a2.0059 2.0059 0 002-2V4A2.0059 2.0059 0 0012 2zM4 12V4h8v8z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Pr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Pi||(Pi=n.createElement("circle",{cx:"16",cy:"16",r:"10"})),Gi||(Gi=n.createElement("path",{d:"M16,30A14,14,0,1,1,30,16,14.0158,14.0158,0,0,1,16,30ZM16,4A12,12,0,1,0,28,16,12.0137,12.0137,0,0,0,16,4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Gr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ji||(ji=n.createElement("circle",{cx:"16",cy:"16",r:"14"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,jr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ki||(Ki=n.createElement("path",{d:"M7.7 4.7a14.7 14.7 0 00-3 3.1L6.3 9A13.26 13.26 0 018.9 6.3zM4.6 12.3l-1.9-.6A12.51 12.51 0 002 16H4A11.48 11.48 0 014.6 12.3zM2.7 20.4a14.4 14.4 0 002 3.9l1.6-1.2a12.89 12.89 0 01-1.7-3.3zM7.8 27.3a14.4 14.4 0 003.9 2l.6-1.9A12.89 12.89 0 019 25.7zM11.7 2.7l.6 1.9A11.48 11.48 0 0116 4V2A12.51 12.51 0 0011.7 2.7zM24.2 27.3a15.18 15.18 0 003.1-3.1L25.7 23A11.53 11.53 0 0123 25.7zM27.4 19.7l1.9.6A15.47 15.47 0 0030 16H28A11.48 11.48 0 0127.4 19.7zM29.2 11.6a14.4 14.4 0 00-2-3.9L25.6 8.9a12.89 12.89 0 011.7 3.3zM24.1 4.6a14.4 14.4 0 00-3.9-2l-.6 1.9a12.89 12.89 0 013.3 1.7zM20.3 29.3l-.6-1.9A11.48 11.48 0 0116 28v2A21.42 21.42 0 0020.3 29.3z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Kr);return"glyph"===l||"glyph"===l||"glyphpx"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),Qi||(Qi=n.createElement("circle",{cx:"8",cy:"8",r:"6"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),Ji||(Ji=n.createElement("circle",{cx:"8",cy:"8",r:"6"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Qr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),$i||($i=n.createElement("path",{d:"M16,30A14,14,0,1,1,30,16,14,14,0,0,1,16,30ZM16,4A12,12,0,1,0,28,16,12,12,0,0,0,16,4Z"})),es||(es=n.createElement("path",{d:"M21,12.41V16h2V9H16v2h3.59L11,19.59V16H9v7h7V21H12.41Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Jr);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ns||(ns=n.createElement("path",{d:"M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm7.5,7A3.5,3.5,0,1,1,20,12.5,3.5041,3.5041,0,0,1,23.5,9Zm.4348-1.978C23.791,7.0107,23.6467,7,23.5,7a5.4826,5.4826,0,0,0-4.1323,1.8784,8.0109,8.0109,0,0,0-5.5664-4.6675A11.8554,11.8554,0,0,1,23.9348,7.022ZM16,28a4,4,0,1,1,4-4A4.0045,4.0045,0,0,1,16,28ZM12,18a6,6,0,1,1,6-6A6.0067,6.0067,0,0,1,12,18ZM4,16a11.97,11.97,0,0,1,.2112-2.1987,7.9921,7.9921,0,0,0,7.3459,6.1762,5.9581,5.9581,0,0,0-.89,6.7564A12.0025,12.0025,0,0,1,4,16ZM21.3325,26.7339a5.9834,5.9834,0,0,0-4.1782-8.6206,8.02,8.02,0,0,0,1.9126-2.3672,5.4883,5.4883,0,0,0,8.9167-.0679c.003.1079.0164.2134.0164.3218A12.0025,12.0025,0,0,1,21.3325,26.7339Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,$r);return"glyph"===l||"glyph"===l||"glyphpx"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),ts||(ts=n.createElement("path",{d:"M8,4A4,4,0,1,1,4,8,4.0045,4.0045,0,0,1,8,4M8,2a6,6,0,1,0,6,6A6,6,0,0,0,8,2Z"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),is||(is=n.createElement("path",{d:"M8,4A4,4,0,1,1,4,8,4.0045,4.0045,0,0,1,8,4M8,2a6,6,0,1,0,6,6A6,6,0,0,0,8,2Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ea);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ss||(ss=n.createElement("path",{d:"M18 9L18 15 14 15 14 9 12 9 12 23 14 23 14 17 18 17 18 23 20 23 20 9 18 9z"})),ls||(ls=n.createElement("path",{d:"M30,15H26V6a2,2,0,0,0-2-2H8A2,2,0,0,0,6,6v9H2v2H6v9a2,2,0,0,0,2,2H24a2,2,0,0,0,2-2V17h4ZM8,26V6H24V26Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,na);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),rs||(rs=n.createElement("circle",{cx:"15",cy:"19",r:"1"})),as||(as=n.createElement("path",{d:"M27.7,9.3l-7-7A.9087.9087,0,0,0,20,2H10A2.0058,2.0058,0,0,0,8,4V14H6a2.0023,2.0023,0,0,0-2,2v6a2.0023,2.0023,0,0,0,2,2H8v4a2.0058,2.0058,0,0,0,2,2H26a2.0058,2.0058,0,0,0,2-2V10A.9092.9092,0,0,0,27.7,9.3ZM20,4.4,25.6,10H20ZM6,16h9.5972L19,19l-3.3926,3H6ZM26,28H10V24h5.6089a2.0076,2.0076,0,0,0,1.3135-.4927l3.3833-2.9917a2.0015,2.0015,0,0,0,.01-3.0229l-3.4033-3.0083A1.9961,1.9961,0,0,0,15.6089,14H10V4h8v6a2.0058,2.0058,0,0,0,2,2h6Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ta);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ds||(ds=n.createElement("path",{d:"M30 10V2H22v8h3v4H23v2h7V14H27V10zM24 4h4V8H24zM20 23.41L18.59 22 16 24.59 13.41 22 12 23.41 14.59 26 12 28.59 13.41 30 16 27.41 18.59 30 20 28.59 17.41 26 20 23.41zM20 14L12 14 12 16 15 16 15 21 17 21 17 16 20 16 20 14zM7 9.86a4 4 0 10-2 0V14H2v2H9V14H7zM4 6A2 2 0 116 8 2 2 0 014 6z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ia);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),_s||(_s=n.createElement("path",{d:"M20 18H26V20H20z",transform:"rotate(-180 23 19)"})),os||(os=n.createElement("path",{d:"M24 26H30V28H24z",transform:"rotate(-180 27 27)"})),ms||(ms=n.createElement("path",{d:"M22 22H28V24H22z",transform:"rotate(-180 25 23)"})),vs||(vs=n.createElement("path",{d:"M17.0029,20a4.8952,4.8952,0,0,0-2.4044-4.1729L22,3,20.2691,2,12.6933,15.126A5.6988,5.6988,0,0,0,7.45,16.6289C3.7064,20.24,3.9963,28.6821,4.01,29.04a1,1,0,0,0,1,.96H20.0012a1,1,0,0,0,.6-1.8C17.0615,25.5439,17.0029,20.0537,17.0029,20ZM11.93,16.9971A3.11,3.11,0,0,1,15.0041,20c0,.0381.0019.208.0168.4688L9.1215,17.8452A3.8,3.8,0,0,1,11.93,16.9971ZM15.4494,28A5.2,5.2,0,0,1,14,25H12a6.4993,6.4993,0,0,0,.9684,3H10.7451A16.6166,16.6166,0,0,1,10,24H8a17.3424,17.3424,0,0,0,.6652,4H6c.031-1.8364.29-5.8921,1.8027-8.5527l7.533,3.35A13.0253,13.0253,0,0,0,17.5968,28Z"})),i)})).propTypes=ol;var Da=n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,sa);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),fs||(fs=n.createElement("path",{d:"M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"})),i)}));Da.propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,la);return 16===l||"16"===l||"16px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),us||(us=n.createElement("path",{d:"M8,1C4.1,1,1,4.1,1,8s3.1,7,7,7s7-3.1,7-7S11.9,1,8,1z M10.7,11.5L8,8.8l-2.7,2.7l-0.8-0.8L7.2,8L4.5,5.3l0.8-0.8L8,7.2 l2.7-2.7l0.8,0.8L8.8,8l2.7,2.7L10.7,11.5z"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),cs||(cs=n.createElement("path",{d:"M16,2C8.2,2,2,8.2,2,16s6.2,14,14,14s14-6.2,14-14S23.8,2,16,2z M21.4,23L16,17.6L10.6,23L9,21.4l5.4-5.4L9,10.6L10.6,9 l5.4,5.4L21.4,9l1.6,1.6L17.6,16l5.4,5.4L21.4,23z"})),ps||(ps=n.createElement("path",{d:"M14.4 16L9 10.6 10.6 9 16 14.4 21.4 9 23 10.6 17.6 16 23 21.4 21.4 23 16 17.6 10.6 23 9 21.4 14.4 16","data-icon-path":"inner-path",opacity:"0"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ra);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Es||(Es=n.createElement("path",{d:"M16,2C8.2,2,2,8.2,2,16s6.2,14,14,14s14-6.2,14-14S23.8,2,16,2z M16,28C9.4,28,4,22.6,4,16S9.4,4,16,4s12,5.4,12,12 S22.6,28,16,28z"})),hs||(hs=n.createElement("path",{d:"M21.4 23L16 17.6 10.6 23 9 21.4 14.4 16 9 10.6 10.6 9 16 14.4 21.4 9 23 10.6 17.6 16 23 21.4z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,aa);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),gs||(gs=n.createElement("path",{d:"M15 21H10a2 2 0 01-2-2V13a2 2 0 012-2h5v2H10v6h5zM25 21H20a2 2 0 01-2-2V13a2 2 0 012-2h5v2H20v6h5z"})),ws||(ws=n.createElement("path",{d:"M28,26H4a2,2,0,0,1-2-2V8A2,2,0,0,1,4,6H28a2,2,0,0,1,2,2V24A2,2,0,0,1,28,26ZM4,8V24H28V8Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,da);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),bs||(bs=n.createElement("path",{d:"M19 17H25V19H19zM11 17H17V19H11zM6 17H9V19H6zM22 13H26V15H22zM13 13H20V15H13zM6 13H11V15H6z"})),xs||(xs=n.createElement("path",{d:"M17.7358,30,16,29l4-7h6a1.9966,1.9966,0,0,0,2-2V8a1.9966,1.9966,0,0,0-2-2H6A1.9966,1.9966,0,0,0,4,8V20a1.9966,1.9966,0,0,0,2,2h9v2H6a3.9993,3.9993,0,0,1-4-4V8A3.9988,3.9988,0,0,1,6,4H26a3.9988,3.9988,0,0,1,4,4V20a3.9993,3.9993,0,0,1-4,4H21.1646Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,_a);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),zs||(zs=n.createElement("path",{d:"M28,6H4A2,2,0,0,0,2,8V24a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V8A2,2,0,0,0,28,6ZM15,13H10v6h5v2H10a2,2,0,0,1-2-2V13a2,2,0,0,1,2-2h5Zm10,0H20v6h5v2H20a2,2,0,0,1-2-2V13a2,2,0,0,1,2-2h5Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,oa);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ls||(Ls=n.createElement("path",{d:"M16,7h0a7.66,7.66,0,0,1,1.51.15,8,8,0,0,1,6.35,6.34l.26,1.35,1.35.24a5.5,5.5,0,0,1-1,10.92H7.5a5.5,5.5,0,0,1-1-10.92l1.34-.24.26-1.35A8,8,0,0,1,16,7m0-2a10,10,0,0,0-9.83,8.12A7.5,7.5,0,0,0,7.49,28h17a7.5,7.5,0,0,0,1.32-14.88,10,10,0,0,0-7.94-7.94A10.27,10.27,0,0,0,16,5Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ma);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ms||(Ms=n.createElement("path",{d:"M28,17v5H4V6H15V4H4A2,2,0,0,0,2,6V22a2,2,0,0,0,2,2h8v4H8v2H24V28H20V24h8a2,2,0,0,0,2-2V17ZM18,28H14V24h4Z"})),ys||(ys=n.createElement("path",{d:"M29,14H17a1,1,0,0,1-.8574-1.5144l6-10a1,1,0,0,1,1.7154,0l6,10A1,1,0,0,1,29,14ZM18.7661,12h8.4678L23,4.9436Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,va);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Rs||(Rs=n.createElement("path",{d:"M28,16v6H4V6H16V4H4A2,2,0,0,0,2,6V22a2,2,0,0,0,2,2h8v4H8v2H24V28H20V24h8a2,2,0,0,0,2-2V16ZM18,28H14V24h4Z"})),Ss||(Ss=n.createElement("path",{d:"M21 15L16 10.04 17.59 8.47 21 11.85 28.41 4.5 30 6.08 21 15z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,fa);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),As||(As=n.createElement("path",{d:"M28 18H30V28H28zM24 14H26V28H24zM20 22H22V28H20zM22.175 10L23.76 8.7339A9.9522 9.9522 0 0017.89 5.1816 10.0025 10.0025 0 006.17 13.1152 7.5054 7.5054 0 00.0544 21.4087 7.6843 7.6843 0 007.7692 28H16V26H7.6945a5.632 5.632 0 01-5.6023-4.4858 5.5064 5.5064 0 014.4339-6.4307l1.3486-.2441.2139-1.11a8.206 8.206 0 016.7426-6.6426 7.9666 7.9666 0 013.0137.13A7.8037 7.8037 0 0122.175 10z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ua);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ds||(Ds=n.createElement("path",{d:"M23.5,22H23V20h.5a4.5,4.5,0,0,0,.36-9L23,11l-.1-.82a7,7,0,0,0-13.88,0L9,11,8.14,11a4.5,4.5,0,0,0,.36,9H9v2H8.5A6.5,6.5,0,0,1,7.2,9.14a9,9,0,0,1,17.6,0A6.5,6.5,0,0,1,23.5,22Z"})),Vs||(Vs=n.createElement("path",{d:"M17 26.17L17 14 15 14 15 26.17 12.41 23.59 11 25 16 30 21 25 19.59 23.59 17 26.17z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ca);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ts||(Ts=n.createElement("path",{d:"M28 16v6H4V6H15V4H4A2 2 0 002 6V22a2 2 0 002 2h8v4H8v2H24V28H20V24h8a2 2 0 002-2V16zM18 28H14V24h4zM18 4H30V6H18z"})),Ws||(Ws=n.createElement("path",{d:"M18 8H30V10H18zM18 12H24V14H18z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,pa);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Us||(Us=n.createElement("path",{d:"M28,16v6H4V6h7V4H4A2,2,0,0,0,2,6V22a2,2,0,0,0,2,2h8v4H8v2H24V28H20V24h8a2,2,0,0,0,2-2V16ZM18,28H14V24h4Z"})),Is||(Is=n.createElement("path",{d:"M18,18h-.01a1,1,0,0,1-.9511-.7253L15.2456,11H11V9h5a1,1,0,0,1,.9615.7252l1.0742,3.7589,3.0088-9.7783A1.0142,1.0142,0,0,1,22,3a.98.98,0,0,1,.9487.6838L24.7207,9H30v2H24a1,1,0,0,1-.9487-.6838l-1.0132-3.04L18.9556,17.2942A1,1,0,0,1,18,18Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ea);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Bs||(Bs=n.createElement("path",{d:"M24.8008 12.1362a8.8694 8.8694 0 00-.9795-2.5434L30 3.4142 28.5872 2 2 28.5872 3.4142 30l5-5H23.5a6.4974 6.4974 0 001.3008-12.8638zM23.5 23H10.4141L22.3418 11.0723a6.9049 6.9049 0 01.6006 2.0708l.0986.812.8154.0639A4.4975 4.4975 0 0123.5 23zM4.2964 23.4487l1.4313-1.4311A4.4774 4.4774 0 018.144 14.019l.8155-.0639.0991-.812a6.9867 6.9867 0 0110.63-5.0865l1.4431-1.4428A8.9859 8.9859 0 007.2 12.1362 6.4891 6.4891 0 004.2964 23.4487z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ha);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Os||(Os=n.createElement("path",{d:"M28,17v5H4V6H14V4H4A2,2,0,0,0,2,6V22a2,2,0,0,0,2,2h8v4H8v2H24V28H20V24h8a2,2,0,0,0,2-2V17ZM18,28H14V24h4Z"})),Fs||(Fs=n.createElement("path",{d:"M30,10V8H27.8989a4.9678,4.9678,0,0,0-.7319-1.7529l1.49-1.49-1.414-1.414-1.49,1.49A4.9678,4.9678,0,0,0,24,4.1011V2H22V4.1011a4.9678,4.9678,0,0,0-1.7529.7319l-1.49-1.49-1.414,1.414,1.49,1.49A4.9678,4.9678,0,0,0,18.1011,8H16v2h2.1011a4.9678,4.9678,0,0,0,.7319,1.7529l-1.49,1.49,1.414,1.414,1.49-1.49A4.9678,4.9678,0,0,0,22,13.8989V16h2V13.8989a4.9678,4.9678,0,0,0,1.7529-.7319l1.49,1.49,1.414-1.414-1.49-1.49A4.9678,4.9678,0,0,0,27.8989,10Zm-7,2a3,3,0,1,1,3-3A3.0033,3.0033,0,0,1,23,12Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ga);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Xs||(Xs=n.createElement("path",{d:"M11 18L12.41 19.41 15 16.83 15 29 17 29 17 16.83 19.59 19.41 21 18 16 13 11 18z"})),Cs||(Cs=n.createElement("path",{d:"M23.5,22H23V20h.5a4.5,4.5,0,0,0,.36-9L23,11l-.1-.82a7,7,0,0,0-13.88,0L9,11,8.14,11a4.5,4.5,0,0,0,.36,9H9v2H8.5A6.5,6.5,0,0,1,7.2,9.14a9,9,0,0,1,17.6,0A6.5,6.5,0,0,1,23.5,22Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,wa);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),qs||(qs=n.createElement("path",{d:"M25.8289 13.1155A10.02 10.02 0 0016 5.0005V7a8.0233 8.0233 0 017.8649 6.4934l.2591 1.346 1.3488.2441A5.5019 5.5019 0 0124.5076 26H16v2h8.5076a7.5019 7.5019 0 001.3213-14.8845zM8 24H14V26H8zM4 24H6V26H4zM6 20H14V22H6zM2 20H4V22H2zM8 16H14V18H8zM4 16H6V18H4zM10 12H14V14H10zM6 12H8V14H6zM12 8H14V10H12z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ba);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Hs||(Hs=n.createElement("path",{d:"M2 28H11V30H2zM21 28H30V30H21zM17 26.167L17 17.832 19.586 20.414 21 19 16 14 11 19 12.413 20.415 15 17.832 15 26.167 12.413 23.584 11 25 16 30 21 25 19.586 23.586 17 26.167z"})),ks||(ks=n.createElement("path",{d:"M23,16H21V14h2a3,3,0,0,0,0-6c-.0938.0144-.1538.0219-.2153.0263l-.8037.0572L21.7544,7.31a5.9927,5.9927,0,0,0-11.1758-.8655l-.2832.5994-.8423-.0455A3.5008,3.5008,0,0,0,9.5,14H11v2H9.5A5.5,5.5,0,0,1,9.07,5.0166,7.9909,7.9909,0,0,1,23.42,6.0175,5,5,0,0,1,23,16Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,xa);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ns||(Ns=n.createElement("path",{d:"M16,7h0a7.66,7.66,0,0,1,1.51.15,8,8,0,0,1,6.35,6.34l.26,1.35,1.35.24a5.5,5.5,0,0,1-1,10.92H7.5a5.5,5.5,0,0,1-1-10.92l1.34-.24.26-1.35A8,8,0,0,1,16,7m0-2a10,10,0,0,0-9.83,8.12A7.5,7.5,0,0,0,7.49,28h17a7.5,7.5,0,0,0,1.32-14.88,10,10,0,0,0-7.94-7.94A10.27,10.27,0,0,0,16,5Z"})),Ys||(Ys=n.createElement("path",{d:"M14 24H11a2 2 0 01-2-2V19a2 2 0 012-2h3v2H11v3h3zM21 15V13H19a2 2 0 00-2 2v2H16v2h1v5h2V19h2V17H19V15z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,za);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Zs||(Zs=n.createElement("path",{d:"M25 11L25 9 17 9 17 23 19 23 19 17 24 17 24 15 19 15 19 11 25 11zM15 23H9a2 2 0 01-2-2V11A2 2 0 019 9h6v2H9V21h6z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,La);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ps||(Ps=n.createElement("path",{d:"M28 30H23a2.0023 2.0023 0 01-2-2V23a2.0023 2.0023 0 012-2h5a2.0023 2.0023 0 012 2v5A2.0023 2.0023 0 0128 30zm-5-7h-.0012L23 28h5V23zM16 23H11a2.0023 2.0023 0 01-2-2V11a2.0023 2.0023 0 012-2H21a2.0023 2.0023 0 012 2v5H21V11H11V21h5z"})),Gs||(Gs=n.createElement("path",{d:"M16,30H4a2.0023,2.0023,0,0,1-2-2V4A2.0023,2.0023,0,0,1,4,2H28a2.0023,2.0023,0,0,1,2,2V16H28V4H4V28H16Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ma);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),js||(js=n.createElement("circle",{cx:"9",cy:"20",r:"2"})),Ks||(Ks=n.createElement("path",{d:"M16,20a4,4,0,1,1,4-4A4.0118,4.0118,0,0,1,16,20Zm0-6a2,2,0,1,0,2,2A2.0059,2.0059,0,0,0,16,14Z"})),Qs||(Qs=n.createElement("circle",{cx:"23",cy:"12",r:"2"})),Js||(Js=n.createElement("path",{d:"M16,31a.9988.9988,0,0,1-.5039-.1357l-12-7A1.0008,1.0008,0,0,1,3,23V9a.9994.9994,0,0,1,.4961-.8638l12-7a1,1,0,0,1,1.0078,0l12,7L27.4961,9.8638,16,3.1577,5,9.5742V22.4258l11,6.417,11-6.417V15h2v8a1.0008,1.0008,0,0,1-.4961.8643l-12,7A.9988.9988,0,0,1,16,31Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ya);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),$s||($s=n.createElement("path",{d:"M32,26V24H29.8989a4.9678,4.9678,0,0,0-.7319-1.7529l1.49-1.49-1.414-1.414-1.49,1.49A4.9678,4.9678,0,0,0,26,20.1011V18H24v2.1011a4.9678,4.9678,0,0,0-1.7529.7319l-1.49-1.49-1.414,1.414,1.49,1.49A4.9678,4.9678,0,0,0,20.1011,24H18v2h2.1011a4.9678,4.9678,0,0,0,.7319,1.7529l-1.49,1.49,1.414,1.414,1.49-1.49A4.9678,4.9678,0,0,0,24,29.8989V32h2V29.8989a4.9678,4.9678,0,0,0,1.7529-.7319l1.49,1.49,1.414-1.414-1.49-1.49A4.9678,4.9678,0,0,0,29.8989,26Zm-7,2a3,3,0,1,1,3-3A3.0033,3.0033,0,0,1,25,28Z"})),el||(el=n.createElement("circle",{cx:"7",cy:"20",r:"2"})),nl||(nl=n.createElement("path",{d:"M14,20a4,4,0,1,1,4-4A4.0118,4.0118,0,0,1,14,20Zm0-6a2,2,0,1,0,2,2A2.0059,2.0059,0,0,0,14,14Z"})),tl||(tl=n.createElement("circle",{cx:"21",cy:"12",r:"2"})),il||(il=n.createElement("path",{d:"M13.0205,28.2715,3,22.4258V9.5742L14,3.1577,25.4961,9.8638l1.0078-1.7276-12-7a1,1,0,0,0-1.0078,0l-12,7A.9994.9994,0,0,0,1,9V23a1.0008,1.0008,0,0,0,.4961.8643L12.0127,30Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ra);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),sl||(sl=n.createElement("path",{d:"M30.9763,24.9748l-5.0015,5.0015a3.501,3.501,0,0,1-4.9511-4.9511L22.4383,26.44A1.5,1.5,0,0,0,24.56,28.5617L29.5617,23.56A1.5,1.5,0,0,0,27.44,21.4383l-1.4146-1.4146a3.501,3.501,0,0,1,4.9511,4.9511Z"})),ll||(ll=n.createElement("path",{d:"M20.0252,21.0237l-5.0015,5.0015a3.501,3.501,0,0,0,4.9511,4.9511L18.56,29.5617A1.5,1.5,0,0,1,16.4383,27.44L21.44,22.4383A1.5,1.5,0,0,1,23.5617,24.56l1.4146,1.4146a3.501,3.501,0,0,0-4.9511-4.9511Z"})),rl||(rl=n.createElement("circle",{cx:"7",cy:"20",r:"2"})),al||(al=n.createElement("path",{d:"M14,20a4,4,0,1,1,4-4A4.0118,4.0118,0,0,1,14,20Zm0-6a2,2,0,1,0,2,2A2.0059,2.0059,0,0,0,14,14Z"})),dl||(dl=n.createElement("circle",{cx:"21",cy:"12",r:"2"})),_l||(_l=n.createElement("path",{d:"M11.3076,27.2725,3,22.4258V9.5742L14,3.1577,25.4961,9.8638l1.0078-1.7276-12-7a1,1,0,0,0-1.0078,0l-12,7A.9994.9994,0,0,0,1,9V23a1.0008,1.0008,0,0,0,.4961.8643L10.3,29Z"})),i)})).propTypes=ol;var Va=!("undefined"===typeof window||!window.document||!window.document.createElement),Ta=function(){var e=0;return function(){return++e}}(),Wa=Va?n.useLayoutEffect:n.useEffect,Ua=!1;function Ia(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"id",t=X((0,n.useState)((function(){return Ua?"".concat(e,"-").concat(Ta()):null})),2),i=t[0],s=t[1];return Wa((function(){null===i&&s("".concat(e,"-").concat(Ta()))}),[Ta]),(0,n.useEffect)((function(){!1===Ua&&(Ua=!0)}),[]),i}var Ba={};function Oa(e,n){return function(n,t,i){if(void 0!==n[t]){Ba[i]&&Ba[i][t]||(Ba[i]=y(y({},Ba[i]),{},V({},t,!0)));for(var s=arguments.length,l=new Array(s>3?s-3:0),r=3;r<s;r++)l[r-3]=arguments[r];return e.apply(void 0,[n,t,i].concat(l))}}}var Fa=(0,n.createContext)(null),Xa=["as","children","dir"];function Ca(e){var t=e.as,i=void 0===t?"span":t,s=e.children,l=e.dir,r=void 0===l?"auto":l,a=B(e,Xa),d=(0,n.useContext)(Fa),_={},o=y({},d);if(d){var m=d.direction,v=d.getTextDirection;if(v&&v.current){var f=function(e){if("string"===typeof e)return e;var t=n.Children.map(e,(function(e){return"string"===typeof e?e:null})).filter((function(e){return null!==e}));if(1===t.length)return t[0];return t}(s),u=v.current(f);m!==u?(_.dir=u,o.direction=u):"auto"===m&&(_.dir=u)}else m!==r?(_.dir=r,o.direction=r):"auto"===m&&(_.dir=r)}else _.dir=r,o.direction=r;return n.createElement(Fa.Provider,{value:o},n.createElement(i,T({},a,_),s))}function qa(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=n.key,i=n.which,s=n.keyCode;return"string"===typeof e?e===t:"number"===typeof e?e===i||e===s:e.key&&Array.isArray(t)?-1!==t.indexOf(e.key):e.key===t||e.which===i||e.keyCode===s}Ca.propTypes={as:P().oneOfType([P().func,P().string,P().elementType]),children:P().node.isRequired,dir:P().oneOf(["ltr","rtl","auto"])};var Ha={key:["Escape","Esc"],which:27,keyCode:27},ka=["children","className","iconDescription","open","onHeadingClick","renderExpando","renderToggle","title","disabled"],Na=function(e){return n.createElement("button",T({type:"button"},e))};function Ya(e){var t,i=e.children,s=e.className;e.iconDescription;var l=e.open,r=void 0!==l&&l,a=e.onHeadingClick,d=e.renderExpando,_=void 0===d?Na:d,o=e.renderToggle,m=e.title,v=void 0===m?"title":m,f=e.disabled,u=B(e,ka),c=X((0,n.useState)(r),2),p=c[0],E=c[1],h=X((0,n.useState)(r),2),g=h[0],w=h[1],b=X((0,n.useState)(""),2),x=b[0],z=b[1],L=Ia("accordion-item"),M=Y(),y=k()((V(t={},"".concat(M,"--accordion__item"),!0),V(t,"".concat(M,"--accordion__item--active"),p),V(t,"".concat(M,"--accordion__item--").concat(x),x),V(t,"".concat(M,"--accordion__item--disabled"),f),V(t,s,!!s),t)),R=o||_;return r!==g&&(z(p?"collapsing":"expanding"),E(r),w(r)),n.createElement("li",T({className:y},u,{onAnimationEnd:function(e){u.handleAnimationEnd&&u.handleAnimationEnd(e),z("")}}),n.createElement(R,{disabled:f,"aria-controls":L,"aria-expanded":p,className:"".concat(M,"--accordion__heading"),onClick:function(e){var n=!p;z(p?"collapsing":"expanding"),E(n),a&&a({isOpen:n,event:e})},onKeyDown:function(e){p&&qa(e,Ha)&&E(!1)},type:"button"},n.createElement(Aa,{className:"".concat(M,"--accordion__arrow")}),n.createElement(Ca,{as:"div",className:"".concat(M,"--accordion__title")},v)),n.createElement("div",{id:L,className:"".concat(M,"--accordion__content")},i))}Ya.propTypes={children:P().node,className:P().string,disabled:P().bool,onClick:P().func,onHeadingClick:P().func,open:P().bool,renderExpando:Oa(P().func),renderToggle:P().func,title:P().node};var Za=["className","id","labelText","onChange","indeterminate","hideLabel","title"],Pa=n.forwardRef((function(e,t){var i=e.className,s=e.id,l=e.labelText,r=e.onChange,a=e.indeterminate,d=e.hideLabel,_=e.title,o=void 0===_?"":_,m=B(e,Za),v=Y(),f=k()("".concat(v,"--checkbox-label"),[i]),u=k()("".concat(v,"--checkbox-label-text"),V({},"".concat(v,"--visually-hidden"),d)),c=k()("".concat(v,"--form-item"),"".concat(v,"--checkbox-wrapper"),[i]);return n.createElement("div",{className:c},n.createElement("input",T({},m,{type:"checkbox",onChange:function(e){r(e,{checked:e.target.checked,id:s})},className:"".concat(v,"--checkbox"),id:s,ref:function(e){e&&(e.indeterminate=a),"function"===typeof t?t(e):Object(t)===t&&(t.current=e)}})),n.createElement("label",{htmlFor:s,className:f,title:o||null},n.createElement(Ca,{className:u},l)))}));Pa.propTypes={checked:P().bool,className:P().string,defaultChecked:P().bool,disabled:P().bool,hideLabel:P().bool,id:P().string.isRequired,indeterminate:P().bool,labelText:P().node.isRequired,onChange:P().func,title:P().string},Pa.defaultProps={onChange:function(){},indeterminate:!1},Pa.displayName="Checkbox";var Ga=Pa;"undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof t.g?t.g:"undefined"!==typeof self&&self;function ja(e){if(e.__esModule)return e;var n=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(e).forEach((function(t){var i=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(n,t,i.get?i:{enumerable:!0,get:function(){return e[t]}})})),n}var Ka=function(){if("undefined"!==typeof Map)return Map;function e(e,n){var t=-1;return e.some((function(e,i){return e[0]===n&&(t=i,!0)})),t}return function(){function n(){this.__entries__=[]}return Object.defineProperty(n.prototype,"size",{get:function(){return this.__entries__.length},enumerable:!0,configurable:!0}),n.prototype.get=function(n){var t=e(this.__entries__,n),i=this.__entries__[t];return i&&i[1]},n.prototype.set=function(n,t){var i=e(this.__entries__,n);~i?this.__entries__[i][1]=t:this.__entries__.push([n,t])},n.prototype.delete=function(n){var t=this.__entries__,i=e(t,n);~i&&t.splice(i,1)},n.prototype.has=function(n){return!!~e(this.__entries__,n)},n.prototype.clear=function(){this.__entries__.splice(0)},n.prototype.forEach=function(e,n){void 0===n&&(n=null);for(var t=0,i=this.__entries__;t<i.length;t++){var s=i[t];e.call(n,s[1],s[0])}},n}()}(),Qa="undefined"!==typeof window&&"undefined"!==typeof document&&window.document===document,Ja="undefined"!==typeof t.g&&t.g.Math===Math?t.g:"undefined"!==typeof self&&self.Math===Math?self:"undefined"!==typeof window&&window.Math===Math?window:Function("return this")(),$a="function"===typeof requestAnimationFrame?requestAnimationFrame.bind(Ja):function(e){return setTimeout((function(){return e(Date.now())}),1e3/60)};var ed=["top","right","bottom","left","width","height","size","weight"],nd="undefined"!==typeof MutationObserver,td=function(){function e(){this.connected_=!1,this.mutationEventsAdded_=!1,this.mutationsObserver_=null,this.observers_=[],this.onTransitionEnd_=this.onTransitionEnd_.bind(this),this.refresh=function(e,n){var t=!1,i=!1,s=0;function l(){t&&(t=!1,e()),i&&a()}function r(){$a(l)}function a(){var e=Date.now();if(t){if(e-s<2)return;i=!0}else t=!0,i=!1,setTimeout(r,n);s=e}return a}(this.refresh.bind(this),20)}return e.prototype.addObserver=function(e){~this.observers_.indexOf(e)||this.observers_.push(e),this.connected_||this.connect_()},e.prototype.removeObserver=function(e){var n=this.observers_,t=n.indexOf(e);~t&&n.splice(t,1),!n.length&&this.connected_&&this.disconnect_()},e.prototype.refresh=function(){this.updateObservers_()&&this.refresh()},e.prototype.updateObservers_=function(){var e=this.observers_.filter((function(e){return e.gatherActive(),e.hasActive()}));return e.forEach((function(e){return e.broadcastActive()})),e.length>0},e.prototype.connect_=function(){Qa&&!this.connected_&&(document.addEventListener("transitionend",this.onTransitionEnd_),window.addEventListener("resize",this.refresh),nd?(this.mutationsObserver_=new MutationObserver(this.refresh),this.mutationsObserver_.observe(document,{attributes:!0,childList:!0,characterData:!0,subtree:!0})):(document.addEventListener("DOMSubtreeModified",this.refresh),this.mutationEventsAdded_=!0),this.connected_=!0)},e.prototype.disconnect_=function(){Qa&&this.connected_&&(document.removeEventListener("transitionend",this.onTransitionEnd_),window.removeEventListener("resize",this.refresh),this.mutationsObserver_&&this.mutationsObserver_.disconnect(),this.mutationEventsAdded_&&document.removeEventListener("DOMSubtreeModified",this.refresh),this.mutationsObserver_=null,this.mutationEventsAdded_=!1,this.connected_=!1)},e.prototype.onTransitionEnd_=function(e){var n=e.propertyName,t=void 0===n?"":n;ed.some((function(e){return!!~t.indexOf(e)}))&&this.refresh()},e.getInstance=function(){return this.instance_||(this.instance_=new e),this.instance_},e.instance_=null,e}(),id=function(e,n){for(var t=0,i=Object.keys(n);t<i.length;t++){var s=i[t];Object.defineProperty(e,s,{value:n[s],enumerable:!1,writable:!1,configurable:!0})}return e},sd=function(e){return e&&e.ownerDocument&&e.ownerDocument.defaultView||Ja},ld=md(0,0,0,0);function rd(e){return parseFloat(e)||0}function ad(e){for(var n=[],t=1;t<arguments.length;t++)n[t-1]=arguments[t];return n.reduce((function(n,t){return n+rd(e["border-"+t+"-width"])}),0)}function dd(e){var n=e.clientWidth,t=e.clientHeight;if(!n&&!t)return ld;var i=sd(e).getComputedStyle(e),s=function(e){for(var n={},t=0,i=["top","right","bottom","left"];t<i.length;t++){var s=i[t],l=e["padding-"+s];n[s]=rd(l)}return n}(i),l=s.left+s.right,r=s.top+s.bottom,a=rd(i.width),d=rd(i.height);if("border-box"===i.boxSizing&&(Math.round(a+l)!==n&&(a-=ad(i,"left","right")+l),Math.round(d+r)!==t&&(d-=ad(i,"top","bottom")+r)),!function(e){return e===sd(e).document.documentElement}(e)){var _=Math.round(a+l)-n,o=Math.round(d+r)-t;1!==Math.abs(_)&&(a-=_),1!==Math.abs(o)&&(d-=o)}return md(s.left,s.top,a,d)}var _d="undefined"!==typeof SVGGraphicsElement?function(e){return e instanceof sd(e).SVGGraphicsElement}:function(e){return e instanceof sd(e).SVGElement&&"function"===typeof e.getBBox};function od(e){return Qa?_d(e)?function(e){var n=e.getBBox();return md(0,0,n.width,n.height)}(e):dd(e):ld}function md(e,n,t,i){return{x:e,y:n,width:t,height:i}}var vd=function(){function e(e){this.broadcastWidth=0,this.broadcastHeight=0,this.contentRect_=md(0,0,0,0),this.target=e}return e.prototype.isActive=function(){var e=od(this.target);return this.contentRect_=e,e.width!==this.broadcastWidth||e.height!==this.broadcastHeight},e.prototype.broadcastRect=function(){var e=this.contentRect_;return this.broadcastWidth=e.width,this.broadcastHeight=e.height,e},e}(),fd=function(e,n){var t=function(e){var n=e.x,t=e.y,i=e.width,s=e.height,l="undefined"!==typeof DOMRectReadOnly?DOMRectReadOnly:Object,r=Object.create(l.prototype);return id(r,{x:n,y:t,width:i,height:s,top:t,right:n+i,bottom:s+t,left:n}),r}(n);id(this,{target:e,contentRect:t})},ud=function(){function e(e,n,t){if(this.activeObservations_=[],this.observations_=new Ka,"function"!==typeof e)throw new TypeError("The callback provided as parameter 1 is not a function.");this.callback_=e,this.controller_=n,this.callbackCtx_=t}return e.prototype.observe=function(e){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("undefined"!==typeof Element&&Element instanceof Object){if(!(e instanceof sd(e).Element))throw new TypeError('parameter 1 is not of type "Element".');var n=this.observations_;n.has(e)||(n.set(e,new vd(e)),this.controller_.addObserver(this),this.controller_.refresh())}},e.prototype.unobserve=function(e){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("undefined"!==typeof Element&&Element instanceof Object){if(!(e instanceof sd(e).Element))throw new TypeError('parameter 1 is not of type "Element".');var n=this.observations_;n.has(e)&&(n.delete(e),n.size||this.controller_.removeObserver(this))}},e.prototype.disconnect=function(){this.clearActive(),this.observations_.clear(),this.controller_.removeObserver(this)},e.prototype.gatherActive=function(){var e=this;this.clearActive(),this.observations_.forEach((function(n){n.isActive()&&e.activeObservations_.push(n)}))},e.prototype.broadcastActive=function(){if(this.hasActive()){var e=this.callbackCtx_,n=this.activeObservations_.map((function(e){return new fd(e.target,e.broadcastRect())}));this.callback_.call(e,n,e),this.clearActive()}},e.prototype.clearActive=function(){this.activeObservations_.splice(0)},e.prototype.hasActive=function(){return this.activeObservations_.length>0},e}(),cd="undefined"!==typeof WeakMap?new WeakMap:new Ka,pd=function e(n){if(!(this instanceof e))throw new TypeError("Cannot call a class as a function.");if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");var t=td.getInstance(),i=new ud(n,t,this);cd.set(this,i)};["observe","unobserve","disconnect"].forEach((function(e){pd.prototype[e]=function(){var n;return(n=cd.get(this))[e].apply(n,arguments)}}));var Ed="undefined"!==typeof Ja.ResizeObserver?Ja.ResizeObserver:pd;var hd,gd=(hd=ja(e))&&"object"===R(hd)&&"default"in hd?hd.default:hd,wd=n;var bd=function(e){void 0===e&&(e={});var n=wd.useRef(null),t=e.onResize,i=wd.useRef(void 0);i.current=t;var s=wd.useRef(),l=e.ref||n,r=wd.useState({width:void 0,height:void 0}),a=r[0],d=r[1],_=wd.useRef({width:void 0,height:void 0});return wd.useEffect((function(){s.current||(s.current=new gd((function(e){if(Array.isArray(e)&&e.length){var n=e[0],t=Math.round(n.contentRect.width),s=Math.round(n.contentRect.height);if(_.current.width!==t||_.current.height!==s){var l={width:t,height:s};i.current?i.current(l):(_.current.width=t,_.current.height=s,d(l))}}})))}),[]),wd.useEffect((function(){if("object"===R(l)&&null!==l&&l.current instanceof Element){var e=l.current;return s.current.observe(e),function(){return s.current.unobserve(e)}}}),[l]),wd.useMemo((function(){return{ref:l,width:a.width,height:a.height}}),[l,a?a.width:null,a?a.height:null])},xd=t(95),zd=t.n(xd),Ld=function(e){return function(n){for(var t=arguments.length,i=new Array(t>1?t-1:0),s=1;s<t;s++)i[s-1]=arguments[s];for(var l=0;l<e.length&&!n.defaultPrevented;l++)"function"===typeof e[l]&&e[l].apply(e,[n].concat(i))}},Md=["as","children","className","dangerDescription","disabled","hasIconOnly","href","iconDescription","isExpressive","isSelected","kind","onBlur","onClick","onFocus","onMouseEnter","onMouseLeave","renderIcon","size","tabIndex","tooltipAlignment","tooltipPosition","type"],yd=n.forwardRef((function(e,t){var i,s,l=e.as,r=e.children,a=e.className,d=e.dangerDescription,_=void 0===d?"danger":d,o=e.disabled,m=void 0!==o&&o,v=e.hasIconOnly,f=void 0!==v&&v,u=e.href,c=e.iconDescription,p=e.isExpressive,E=void 0!==p&&p,h=e.isSelected,g=e.kind,w=void 0===g?"primary":g,b=e.onBlur,x=e.onClick,z=e.onFocus,L=e.onMouseEnter,M=e.onMouseLeave,R=e.renderIcon,S=e.size,A=void 0===S?"lg":S,D=e.tabIndex,W=void 0===D?0:D,U=e.tooltipAlignment,I=void 0===U?"center":U,O=e.tooltipPosition,F=void 0===O?"top":O,X=e.type,C=void 0===X?"button":X,q=B(e,Md),H=(0,n.useRef)(null),N=Y(),Z={tabIndex:W,className:k()(a,(V(i={},"".concat(N,"--btn"),!0),V(i,"".concat(N,"--btn--sm"),"sm"===A&&!E),V(i,"".concat(N,"--btn--md"),"md"===A&&!E),V(i,"".concat(N,"--btn--xl"),"xl"===A),V(i,"".concat(N,"--btn--2xl"),"2xl"===A),V(i,"".concat(N,"--btn--").concat(w),w),V(i,"".concat(N,"--btn--disabled"),m),V(i,"".concat(N,"--btn--expressive"),E),V(i,"".concat(N,"--btn--icon-only"),f),V(i,"".concat(N,"--btn--selected"),f&&h&&"ghost"===w),i)),ref:t},P=R?n.createElement(R,{"aria-label":c,className:"".concat(N,"--btn__icon"),"aria-hidden":"true"}):null,G=R?n.createElement(R,null):null,j=["danger","danger--tertiary","danger--ghost"],K="button",Q=Ia("danger-description"),J={disabled:m,type:C,"aria-describedby":j.includes(w)?Q:null,"aria-pressed":f&&"ghost"===w?h:null},$={href:u};s=j.includes(w)?n.createElement("span",{id:Q,className:"".concat(N,"--visually-hidden")},_):null,l?(K=l,J=y(y({},J),$)):u&&!m&&(K="a",J=$);var ee,ne=n.createElement(K,y(y(y({onMouseEnter:L,onMouseLeave:M,onFocus:z,onBlur:b,onClick:x},q),Z),J),s,r,P);return f?("top"!==F&&"bottom"!==F||("center"===I&&(ee=F),"end"===I&&(ee="".concat(F,"-right")),"start"===I&&(ee="".concat(F,"-left"))),"right"!==F&&"left"!==F||(ee=F),n.createElement(Bd,T({align:ee,label:c,kind:w,size:A,onMouseEnter:L,onMouseLeave:M,onFocus:z,onBlur:b,onClick:Ld([x,function(e){e.target!==H.current||e.preventDefault()}])},q,Z,J),G||r)):ne}));yd.displayName="Button",yd.propTypes={as:P().oneOfType([P().func,P().string,P().elementType]),children:P().node,className:P().string,dangerDescription:P().string,disabled:P().bool,hasIconOnly:P().bool,href:P().string,iconDescription:function(e){if(e.renderIcon&&!e.children&&!e.iconDescription)return new Error("renderIcon property specified without also providing an iconDescription property.")},isExpressive:P().bool,isSelected:P().bool,kind:P().oneOf(["primary","secondary","danger","ghost","danger--primary","danger--ghost","danger--tertiary","tertiary"]),onBlur:P().func,onClick:P().func,onFocus:P().func,onMouseEnter:P().func,onMouseLeave:P().func,renderIcon:P().oneOfType([P().func,P().object]),role:P().string,size:P().oneOf(["sm","md","lg","xl","2xl"]),tabIndex:P().number,tooltipAlignment:P().oneOf(["start","center","end"]),tooltipPosition:P().oneOf(["top","right","bottom","left"]),type:P().oneOf(["button","reset","submit"])};var Rd=yd,Sd=["align","as","caret","className","children","dropShadow","highContrast","open"],Ad=["className","children"],Dd=n.forwardRef((function(e,t){var i,s=e.align,l=void 0===s?"bottom":s,r=e.as,a=void 0===r?"span":r,d=e.caret,_=void 0===d||d,o=e.className,m=e.children,v=e.dropShadow,f=void 0===v||v,u=e.highContrast,c=void 0!==u&&u,p=e.open,E=B(e,Sd),h=Y(),g=k()((V(i={},"".concat(h,"--popover-container"),!0),V(i,"".concat(h,"--popover--caret"),_),V(i,"".concat(h,"--popover--drop-shadow"),f),V(i,"".concat(h,"--popover--high-contrast"),c),V(i,"".concat(h,"--popover--open"),p),V(i,"".concat(h,"--popover--").concat(l),!0),V(i,o,!!o),i));return n.createElement(a,T({},E,{className:g,ref:t}),m)}));Dd.propTypes={align:P().oneOf(["top","top-left","top-right","bottom","bottom-left","bottom-right","left","left-bottom","left-top","right","right-bottom","right-top"]),as:P().oneOfType([P().string,P().elementType]),caret:P().bool,children:P().node,className:P().string,dropShadow:P().bool,highContrast:P().bool,open:P().bool.isRequired};var Vd=n.forwardRef((function(e,t){var i=e.className,s=e.children,l=B(e,Ad),r=Y();return n.createElement("span",T({},l,{className:"".concat(r,"--popover")}),n.createElement("span",{className:k()("".concat(r,"--popover-content"),i),ref:t},s),n.createElement("span",{className:"".concat(r,"--popover-caret")}))}));function Td(e){if(function(e){if(e.tabIndex<0)return!1;if(e.disabled)return!1;switch(e.nodeName){case"A":return!!e.href&&"ignore"!==e.rel;case"INPUT":return"hidden"!==e.type;case"BUTTON":case"SELECT":case"TEXTAREA":return!0;default:return!1}}(e))return e;var n,t=function(e,n){var t="undefined"!==typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!t){if(Array.isArray(e)||(t=C(e))||n&&e&&"number"===typeof e.length){t&&(e=t);var i=0,s=function(){};return{s:s,n:function(){return i>=e.length?{done:!0}:{done:!1,value:e[i++]}},e:function(e){throw e},f:s}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var l,r=!0,a=!1;return{s:function(){t=t.call(e)},n:function(){var e=t.next();return r=e.done,e},e:function(e){a=!0,l=e},f:function(){try{r||null==t.return||t.return()}finally{if(a)throw l}}}}(e.childNodes);try{for(t.s();!(n=t.n()).done;){var i=Td(n.value);if(i)return i}}catch(s){t.e(s)}finally{t.f()}return null}Vd.propTypes={children:P().node,className:P().string};var Wd=["align","className","children","label","description","enterDelayMs","leaveDelayMs","defaultOpen"];function Ud(e){var t=e.align,i=void 0===t?"top":t,s=e.className,l=e.children,r=e.label,a=e.description,d=e.enterDelayMs,_=void 0===d?100:d,o=e.leaveDelayMs,m=void 0===o?300:o,v=e.defaultOpen,f=void 0!==v&&v,u=B(e,Wd),c=(0,n.useRef)(null),p=(0,n.useRef)(null),E=function(e){var t=X((0,n.useState)(e),2),i=t[0],s=t[1],l=(0,n.useRef)(null),r=(0,n.useCallback)((function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;clearTimeout(l.current),l.current=null,0!==n?l.current=setTimeout((function(){s(e),l.current=null}),n):s(e)}),[]);return(0,n.useEffect)((function(){return function(){clearTimeout(l.current)}}),[]),[i,r]}(f),h=X(E,2),g=h[0],w=h[1],b=Ia("tooltip"),x=Y(),z=n.Children.only(l),L={onFocus:function(){return w(!0)},onBlur:function(){return w(!1)},onMouseEnter:function(){w(!0,_)}};return r?L["aria-labelledby"]=b:L["aria-describedby"]=b,(0,n.useEffect)((function(){Td(c.current)||w(!1)})),n.createElement(Dd,T({},u,{align:i,className:k()("".concat(x,"--tooltip"),s),dropShadow:!1,highContrast:!0,onKeyDown:function(e){g&&qa(e,Ha)&&(e.stopPropagation(),w(!1))},onMouseLeave:function(){w(!1,m)},open:g,ref:c}),n.cloneElement(z,L),n.createElement(Vd,{"aria-hidden":"true",className:"".concat(x,"--tooltip-content"),id:b,ref:p,role:"tooltip"},r||a))}Ud.propTypes={align:P().oneOf(["top","top-left","top-right","bottom","bottom-left","bottom-right","left","left-bottom","left-top","right","right-bottom","right-top"]),children:P().node,className:P().string,defaultOpen:P().bool,description:P().node,enterDelayMs:P().number,label:P().node,leaveDelayMs:P().number};var Id=["align","children","defaultOpen","enterDelayMs","kind","label","leaveDelayMs","size"],Bd=n.forwardRef((function(e,t){var i=e.align,s=e.children,l=e.defaultOpen,r=void 0!==l&&l,a=e.enterDelayMs,d=e.kind,_=e.label,o=e.leaveDelayMs,m=e.size,v=void 0===m?"md":m,f=B(e,Id),u=Y();return n.createElement(Ud,{align:i,className:"".concat(u,"--icon-tooltip"),defaultOpen:r,enterDelayMs:a,label:_,leaveDelayMs:o},n.createElement(Rd,T({},f,{kind:d,ref:t,size:v}),s))}));Bd.propTypes={align:P().oneOf(["top","top-left","top-right","bottom","bottom-left","bottom-right","left","right"]),children:P().node,defaultOpen:P().bool,enterDelayMs:P().number,kind:P().oneOf(["primary","secondary","ghost","tertiary"]),label:P().node.isRequired,leaveDelayMs:P().number,size:P().oneOf(["sm","md","lg"])};var Od,Fd,Xd,Cd,qd,Hd,kd,Nd,Yd,Zd,Pd,Gd,jd,Kd,Qd,Jd,$d,e_,n_,t_,i_,s_,l_,r_,a_,d_,__,o_,m_,v_,f_,u_,c_,p_,E_,h_,g_,w_,b_,x_,z_,L_,M_,y_,R_,S_,A_,D_,V_,T_,W_,U_,I_,B_,O_,F_,X_,C_,q_,H_,k_,N_,Y_,Z_,P_,G_,j_,K_,Q_,J_,$_,eo,no,to,io,so,lo,ro,ao,_o,oo,mo,vo,fo,uo,co,po,Eo,ho,go,wo,bo,xo,zo,Lo,Mo,yo,Ro,So,Ao,Do,Vo,To,Wo,Uo,Io,Bo,Oo,Fo,Xo,Co,qo,Ho,ko,No,Yo,Zo,Po,Go,jo,Ko,Qo,Jo,$o,em,nm,tm,im,sm,lm,rm,am,dm,_m,om,mm,vm,fm,um,cm,pm,Em,hm,gm,wm,bm,xm,zm,Lm,Mm,ym,Rm,Sm,Am,Dm,Vm,Tm,Wm,Um,Im,Bm,Om,Fm,Xm,Cm,qm,Hm,km,Nm,Ym,Zm,Pm,Gm,jm,Km,Qm,Jm,$m,ev,nv,tv,iv,sv,lv,rv,av,dv,_v,ov,mv,vv,fv,uv,cv,pv,Ev,hv,gv,wv,bv,xv,zv,Lv,Mv,yv,Rv,Sv,Av,Dv,Vv,Tv,Wv,Uv,Iv,Bv,Ov,Fv,Xv,Cv,qv,Hv,kv,Nv,Yv,Zv,Pv,Gv,jv,Kv,Qv,Jv,$v,ef,nf,tf,sf,lf,rf,af,df,_f,of,mf,vf,ff,uf,cf,pf,Ef,hf=["children","className","feedback","feedbackTimeout","onAnimationEnd","onClick"];function gf(e){var t,i=e.children,s=e.className,l=e.feedback,r=e.feedbackTimeout,a=e.onAnimationEnd,d=e.onClick,_=B(e,hf),o=X((0,n.useState)(""),2),m=o[0],v=o[1],f=Y(),u=k()(s,"".concat(f,"--copy"),(V(t={},"".concat(f,"--copy-btn--animating"),m),V(t,"".concat(f,"--copy-btn--").concat(m),m),t)),c=(0,n.useCallback)(zd()((function(){v("fade-out")}),r),[r]),p=(0,n.useCallback)((function(){v("fade-in"),c()}),[c]),E=function(e){"hide-feedback"===e.animationName&&v("")};return(0,n.useEffect)((function(){return function(){c.cancel()}}),[c]),L("enable-v11-release")?n.createElement(Bd,T({align:"bottom",className:u,label:m?l:_["aria-label"],onClick:Ld([d,p]),onAnimationEnd:Ld([a,E])},_,{"aria-live":"polite","aria-label":!i&&(m?l:_["aria-label"])||null}),i):n.createElement("button",T({type:"button",className:u,onClick:Ld([d,p]),onAnimationEnd:Ld([a,E])},_,{"aria-live":"polite","aria-label":!i&&(m?l:_["aria-label"])||null}),i,m?l:_["aria-label"],n.createElement("span",{"aria-hidden":"true",className:"".concat(f,"--assistive-text ").concat(f,"--copy-btn__feedback")},l))}gf.propTypes={children:P().node,className:P().string,feedback:P().string,feedbackTimeout:P().number,onAnimationEnd:P().func,onClick:P().func},gf.defaultProps={feedback:"Copied!",feedbackTimeout:2e3,onClick:function(){}};var wf=["children","size"],bf=["children","size"],xf=["children","size"],zf=["children","size"],Lf=["children","size"],Mf=["children","size"],yf=["children","size"],Rf=["children","size"],Sf=["children","size"],Af=["children","size"],Df=["children","size"],Vf=["children","size"],Tf=["children","size"],Wf=["children","size"],Uf=["children","size"],If=["children","size"],Bf=["children","size"],Of=["children","size"],Ff=["children","size"],Xf=["children","size"],Cf=["children","size"],qf=["children","size"],Hf=["children","size"],kf=["children","size"],Nf=["children","size"],Yf=["children","size"],Zf=["children","size"],Pf=["children","size"],Gf=["children","size"],jf=["children","size"],Kf=["children","size"],Qf=["children","size"],Jf=["children","size"],$f=["children","size"],eu=["children","size"],nu=["children","size"],tu=["children","size"],iu=["children","size"],su=["children","size"],lu=["children","size"],ru=["children","size"],au=["children","size"],du=["children","size"],_u=["children","size"],ou=["children","size"],mu=["children","size"],vu=["children","size"],fu=["children","size"],uu=["children","size"],cu=["children","size"],pu=["children","size"],Eu=["children","size"],hu=["children","size"],gu=["children","size"],wu=["children","size"],bu=["children","size"],xu=["children","size"],zu=["children","size"],Lu=["children","size"],Mu=["children","size"],yu=["children","size"],Ru=["children","size"],Su=["children","size"],Au=["children","size"],Du=["children","size"],Vu=["children","size"],Tu=["children","size"],Wu=["children","size"],Uu=["children","size"],Iu=["children","size"],Bu=["children","size"],Ou=["children","size"],Fu=["children","size"],Xu=["children","size"],Cu=["children","size"],qu=["children","size"],Hu=["children","size"],ku=["children","size"],Nu=["children","size"],Yu=["children","size"],Zu=["children","size"],Pu=["children","size"],Gu=["children","size"],ju=["children","size"],Ku=["children","size"],Qu=["children","size"],Ju=["children","size"],$u=["children","size"],ec=["children","size"],nc=["children","size"],tc=["children","size"],ic=["children","size"],sc=["children","size"],lc=["children","size"],rc=["children","size"],ac=["children","size"],dc=["children","size"],_c=["children","size"],oc=["children","size"],mc=["children","size"],vc=["children","size"],fc=["children","size"],uc=["children","size"],cc=["children","size"],pc=["children","size"],Ec=["children","size"],hc=["children","size"],gc=["children","size"],wc=["children","size"],bc=["children","size"],xc=["children","size"],zc=["children","size"],Lc=["children","size"],Mc=["children","size"],yc=["children","size"],Rc=["children","size"],Sc=["children","size"],Ac=["children","size"],Dc=["children","size"],Vc=["children","size"],Tc=["children","size"],Wc=["children","size"],Uc=["children","size"],Ic=["children","size"],Bc=["children","size"];n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,wf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Od||(Od=n.createElement("path",{d:"M29,26a2.97,2.97,0,0,0-1.8551.6607L25,25.4224V23.8157a3,3,0,1,0-2,0v1.6067l-2.1449,1.2383A2.97,2.97,0,0,0,19,26a3.02,3.02,0,1,0,2.9254,2.3525L24,27.1548l2.0746,1.1977A2.9978,2.9978,0,1,0,29,26ZM19,30a1,1,0,1,1,1-1A1.0006,1.0006,0,0,1,19,30Zm5-10a1,1,0,1,1-1,1A1.0009,1.0009,0,0,1,24,20Zm5,10a1,1,0,1,1,1-1A1.0006,1.0006,0,0,1,29,30Z"})),Fd||(Fd=n.createElement("circle",{cx:"7",cy:"20",r:"2"})),Xd||(Xd=n.createElement("path",{d:"M14,20a4,4,0,1,1,4-4A4.0118,4.0118,0,0,1,14,20Zm0-6a2,2,0,1,0,2,2A2.0059,2.0059,0,0,0,14,14Z"})),Cd||(Cd=n.createElement("circle",{cx:"21",cy:"12",r:"2"})),qd||(qd=n.createElement("path",{d:"M13.0205,28.2715,3,22.4258V9.5742L14,3.1577,25.4961,9.8638l1.0078-1.7276-12-7a1,1,0,0,0-1.0078,0l-12,7A.9994.9994,0,0,0,1,9V23a1.0008,1.0008,0,0,0,.4961.8643L12.0127,30Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,bf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Hd||(Hd=n.createElement("path",{d:"M25.8218,10.124a9.9991,9.9991,0,0,0-19.6435,0A7.4964,7.4964,0,0,0,7.5,25H8V23H7.5a5.4961,5.4961,0,0,1-.3769-10.9795l.8364-.0571.09-.8335a7.9979,7.9979,0,0,1,15.9013,0l.09.8335.8364.0571A5.4961,5.4961,0,0,1,24.5,23H24v2h.5a7.4964,7.4964,0,0,0,1.3218-14.876Z"})),kd||(kd=n.createElement("path",{d:"M23,22V20H20.8989a4.9678,4.9678,0,0,0-.7319-1.7529l1.49-1.49-1.414-1.414-1.49,1.49A4.9678,4.9678,0,0,0,17,16.1011V14H15v2.1011a4.9678,4.9678,0,0,0-1.7529.7319l-1.49-1.49-1.414,1.414,1.49,1.49A4.9678,4.9678,0,0,0,11.1011,20H9v2h2.1011a4.9678,4.9678,0,0,0,.7319,1.7529l-1.49,1.49,1.414,1.414,1.49-1.49A4.9678,4.9678,0,0,0,15,25.8989V28h2V25.8989a4.9678,4.9678,0,0,0,1.7529-.7319l1.49,1.49,1.414-1.414-1.49-1.49A4.9678,4.9678,0,0,0,20.8989,22Zm-7,2a3,3,0,1,1,3-3A3.0033,3.0033,0,0,1,16,24Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,xf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Nd||(Nd=n.createElement("path",{d:"M30.0005,15.5005a6.5324,6.5324,0,0,0-5.1992-6.3638,8.9943,8.9943,0,0,0-17.6006,0,6.5321,6.5321,0,0,0-5.2,6.3638,6.4543,6.4543,0,0,0,1.6887,4.35A5.9829,5.9829,0,0,0,8,30H19a5.9764,5.9764,0,0,0,5.6094-8.1016A6.5051,6.5051,0,0,0,30.0005,15.5005ZM19,28H8a3.9925,3.9925,0,0,1-.6731-7.9292L7.99,19.958l.1458-.6562a5.496,5.496,0,0,1,10.7294,0l.1458.6562.6626.1128A3.9925,3.9925,0,0,1,19,28Zm4.5-8h-.0554a5.9562,5.9562,0,0,0-2.7959-1.7564,7.4952,7.4952,0,0,0-14.2984,0,5.9877,5.9877,0,0,0-1.0315.4073A4.4446,4.4446,0,0,1,4,15.5005a4.5171,4.5171,0,0,1,4.144-4.481l.8155-.0639.0991-.812a6.9938,6.9938,0,0,1,13.8838,0l.0986.812.8154.0639a4.4975,4.4975,0,0,1-.3564,8.981Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,zf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Yd||(Yd=n.createElement("path",{d:"M20 17V15a2 2 0 00-2-2H10a2 2 0 00-2 2v2a2 2 0 002 2h8A2 2 0 0020 17zM10 15h8v2H10zM23.42 24.48A2 2 0 0021 23.06l-7.73 2.07a2 2 0 00-1.42 2.44h0l.52 1.93A2 2 0 0014.27 31a3 3 0 00.52-.07l7.73-2.07h0a2 2 0 001.41-2.45zM14.27 29l-.51-1.94L21.48 25 22 26.92zM13.24 6.86L21 8.93h0a2.24 2.24 0 00.51.07 2 2 0 001.94-1.48L24 5.58a2 2 0 00-1.41-2.45L14.79 1.06a2 2 0 00-2.45 1.41h0l-.52 1.93a2 2 0 001.42 2.44zm1-3.86L22 5.07 21.48 7 13.76 4.93zM14 21H16V23H14zM14 9H16V11H14z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Lf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Zd||(Zd=n.createElement("path",{d:"M31 16L24 23 22.59 21.59 28.17 16 22.59 10.41 24 9 31 16zM1 16L8 9 9.41 10.41 3.83 16 9.41 21.59 8 23 1 16z"})),Pd||(Pd=n.createElement("path",{d:"M5.91 15H26.080000000000002V17H5.91z",transform:"rotate(-75 15.996 16)"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Mf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Gd||(Gd=n.createElement("path",{d:"M17.713 13.471L19.576 6.518 17.645 6 16.08 11.838 17.713 13.471zM24.207 19.965L25.621 21.379 31 16 24 9 22.586 10.414 28.172 16 24.207 19.965zM30 28.586L3.414 2 2 3.414 7.793 9.207 1 16 8 23 9.414 21.586 3.828 16 9.207 10.621 14.884 16.298 12.423 25.482 14.355 26 16.517 17.931 28.586 30 30 28.586z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,yf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),jd||(jd=n.createElement("path",{d:"M4 20L4 22 8.586 22 2 28.586 3.414 30 10 23.414 10 28 12 28 12 20 4 20zM30 10L24 4 22.586 5.414 27.172 10 22.586 14.586 24 16 30 10z"})),Kd||(Kd=n.createElement("path",{d:"M8.944 9.001H24.974000000000004V11.001H8.944z",transform:"rotate(-74.995 16.96 10)"})),Qd||(Qd=n.createElement("path",{d:"M4 10L10 4 11.414 5.414 6.828 10 11.414 14.586 10 16 4 10z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Rf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Jd||(Jd=n.createElement("circle",{cx:"25",cy:"20",r:"1"})),$d||($d=n.createElement("path",{d:"M19.4141 30H15V25.5857l5.0337-5.0337A4.6069 4.6069 0 0120 20a5 5 0 114.4478 4.9663zM17 28h1.5859l5.2061-5.2063.5395.1238a3.0351 3.0351 0 10-2.249-2.2488l.1236.5393L17 26.4143zM6 8H8V16H6zM2 8H4V16H2zM18 8H20V14H18zM14 16H12a2 2 0 01-2-2V10a2 2 0 012-2h2a2 2 0 012 2v4A2 2 0 0114 16zm-2-2h2V10H12zM2 18H4V26H2zM14 18H16V22H14zM10 26H8a2 2 0 01-2-2V20a2 2 0 012-2h2a2 2 0 012 2v4A2 2 0 0110 26zM8 24h2V20H8zM2 2H4V6H2zM14 2H16V6H14zM18 2H20V6H18zM10 6H8A2 2 0 016 4V2H8V4h2V2h2V4A2 2 0 0110 6z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Sf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),e_||(e_=n.createElement("path",{d:"M30,13A11,11,0,0,0,19,2H11a9,9,0,0,0-9,9v3a5,5,0,0,0,5,5H8.1A5,5,0,0,0,13,23h1.38l4,7,1.73-1-4-6.89A2,2,0,0,0,14.38,21H13a3,3,0,0,1,0-6h1V13H13a5,5,0,0,0-4.9,4H7a3,3,0,0,1-3-3V12H6A3,3,0,0,0,9,9V8H7V9a1,1,0,0,1-1,1H4.08A7,7,0,0,1,11,4h6V6a1,1,0,0,1-1,1H14V9h2a3,3,0,0,0,3-3V4a9,9,0,0,1,8.05,5H26a3,3,0,0,0-3,3v1h2V12a1,1,0,0,1,1-1h1.77A8.76,8.76,0,0,1,28,13v1a5,5,0,0,1-5,5H20v2h3a7,7,0,0,0,3-.68V21a3,3,0,0,1-3,3H22v2h1a5,5,0,0,0,5-5V18.89A7,7,0,0,0,30,14Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Af);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),n_||(n_=n.createElement("path",{d:"M6 21V20H4v1a7 7 0 007 7h3V26H11A5 5 0 016 21zM24 11v1h2V11a7 7 0 00-7-7H16V6h3A5 5 0 0124 11zM11 11H5a3 3 0 00-3 3v2H4V14a1 1 0 011-1h6a1 1 0 011 1v2h2V14A3 3 0 0011 11zM8 10A4 4 0 104 6 4 4 0 008 10zM8 4A2 2 0 116 6 2 2 0 018 4zM27 25H21a3 3 0 00-3 3v2h2V28a1 1 0 011-1h6a1 1 0 011 1v2h2V28A3 3 0 0027 25zM20 20a4 4 0 104-4A4 4 0 0020 20zm6 0a2 2 0 11-2-2A2 2 0 0126 20z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Df);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),t_||(t_=n.createElement("path",{d:"M30,15H28V7H13V5H28a2.0023,2.0023,0,0,1,2,2Z"})),i_||(i_=n.createElement("path",{d:"M25,20H23V12H8V10H23a2.0023,2.0023,0,0,1,2,2Z"})),s_||(s_=n.createElement("path",{d:"M18,27H4a2.0023,2.0023,0,0,1-2-2V17a2.0023,2.0023,0,0,1,2-2H18a2.0023,2.0023,0,0,1,2,2v8A2.0023,2.0023,0,0,1,18,27ZM4,17v8H18.0012L18,17Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Vf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),l_||(l_=n.createElement("path",{d:"M14 25H28V27H14zM7.17 26L4.59 28.58 6 30 10 26 6 22 4.58 23.41 7.17 26zM14 15H28V17H14zM7.17 16L4.59 18.58 6 20 10 16 6 12 4.58 13.41 7.17 16zM14 5H28V7H14zM7.17 6L4.59 8.58 6 10 10 6 6 2 4.58 3.41 7.17 6z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Tf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),r_||(r_=n.createElement("circle",{cx:"10",cy:"12",r:"2"})),a_||(a_=n.createElement("circle",{cx:"16",cy:"9",r:"2"})),d_||(d_=n.createElement("circle",{cx:"22",cy:"12",r:"2"})),__||(__=n.createElement("circle",{cx:"23",cy:"18",r:"2"})),o_||(o_=n.createElement("circle",{cx:"19",cy:"23",r:"2"})),m_||(m_=n.createElement("path",{d:"M16.54,2A14,14,0,0,0,2,16a4.82,4.82,0,0,0,6.09,4.65l1.12-.31A3,3,0,0,1,13,23.24V27a3,3,0,0,0,3,3A14,14,0,0,0,30,15.46,14.05,14.05,0,0,0,16.54,2Zm8.11,22.31A11.93,11.93,0,0,1,16,28a1,1,0,0,1-1-1V23.24a5,5,0,0,0-5-5,5.07,5.07,0,0,0-1.33.18l-1.12.31A2.82,2.82,0,0,1,4,16,12,12,0,0,1,16.47,4,12.18,12.18,0,0,1,28,15.53,11.89,11.89,0,0,1,24.65,24.32Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Wf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),v_||(v_=n.createElement("path",{d:"M26,4H6A2.0025,2.0025,0,0,0,4,6V26a2.0025,2.0025,0,0,0,2,2H26a2.0025,2.0025,0,0,0,2-2V6A2.0025,2.0025,0,0,0,26,4ZM6,26,26,6V26Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Uf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),f_||(f_=n.createElement("path",{d:"M24 4H26V28H24zM18 6V26H14V6h4m0-2H14a2 2 0 00-2 2V26a2 2 0 002 2h4a2 2 0 002-2V6a2 2 0 00-2-2zM6 4H8V28H6z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,If);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),u_||(u_=n.createElement("path",{d:"M30 3.41L28.59 2 25 5.59 21.41 2 20 3.41 23.59 7 20 10.59 21.41 12 25 8.41 28.59 12 30 10.59 26.41 7 30 3.41z"})),c_||(c_=n.createElement("path",{d:"M24 14V28H18V6H16V28a2.0023 2.0023 0 002 2h6a2.0023 2.0023 0 002-2V14zM10 30H4a2.0021 2.0021 0 01-2-2V8A2.0021 2.0021 0 014 6h6a2.0021 2.0021 0 012 2V28A2.0021 2.0021 0 0110 30zM4 8V28h6V8z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Bf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),p_||(p_=n.createElement("path",{d:"M28 30H22a2.0021 2.0021 0 01-2-2V10a2.0021 2.0021 0 012-2h6a2.0021 2.0021 0 012 2V28A2.0021 2.0021 0 0128 30zM22 10V28h6V10zM16 9L21.586 3.414 20.172 2 16 6.172 11.828 2 10.414 3.414 16 9zM10 30H4a2.0021 2.0021 0 01-2-2V10A2.0021 2.0021 0 014 8h6a2.0021 2.0021 0 012 2V28A2.0021 2.0021 0 0110 30zM4 10V28h6V10z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Of);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),E_||(E_=n.createElement("path",{d:"M30,10V2H22V5H17a2.0023,2.0023,0,0,0-2,2v8H10V12H2v8h8V17h5v8a2.0023,2.0023,0,0,0,2,2h5v3h8V22H22v3H17V17h5v3h8V12H22v3H17V7h5v3ZM8,18H4V14H8Zm16,6h4v4H24Zm0-10h4v4H24ZM24,4h4V8H24Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ff);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),h_||(h_=n.createElement("path",{d:"M30,15H21.91A5.9925,5.9925,0,0,0,10.09,15H2v2h8.09A5.9925,5.9925,0,0,0,21.91,17H30ZM16,20a4,4,0,1,1,4-4A4.0045,4.0045,0,0,1,16,20Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Xf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),g_||(g_=n.createElement("path",{d:"M28 17H18a2.0025 2.0025 0 00-2 2v6a2.0025 2.0025 0 002 2h4V25H18V19H28v6H25.4648l-2.5937 3.8906L24.5352 30l2-3H28a2.0025 2.0025 0 002-2V19A2.0025 2.0025 0 0028 17zM8.6667 24.1086l.8614-.8615a.8334.8334 0 01.8988-.1844l1.0493.42A.8334.8334 0 0112 24.2561v1.9082a.8334.8334 0 01-.8786.8341c-7.3546-.4578-8.84-6.6863-9.1158-9.0723A.8316.8316 0 012.8343 17H4.7085a.8335.8335 0 01.7737.5238l.42 1.0493a.8332.8332 0 01-.1845.8988l-.8614.8614A4.5267 4.5267 0 008.6667 24.1086zM21 9H28V11H21zM21 5H30V7H21zM17 6L14 8.2V6a2.0024 2.0024 0 00-2-2H4A2.0024 2.0024 0 002 6v6a2.0024 2.0024 0 002 2h8a2.0024 2.0024 0 002-2V9.8L17 12zM4 12V6h8v6z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Cf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),w_||(w_=n.createElement("path",{d:"M28,6H18V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V24a2,2,0,0,0,2,2H14v2a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V8A2,2,0,0,0,28,6ZM4,15h6.17L7.59,17.59,9,19l5-5L9,9,7.59,10.41,10.17,13H4V4H16V24H4ZM16,28V26a2,2,0,0,0,2-2V8H28v9H21.83l2.58-2.59L23,13l-5,5,5,5,1.41-1.41L21.83,19H28v9Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,qf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),b_||(b_=n.createElement("path",{d:"M16,4A12,12,0,1,1,4,16,12,12,0,0,1,16,4m0-2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Z"})),x_||(x_=n.createElement("path",{d:"M23,10.41,21.59,9l-4.3,4.3a3,3,0,0,0-4,4L9,21.59,10.41,23l4.3-4.3a3,3,0,0,0,4-4ZM17,16a1,1,0,1,1-1-1A1,1,0,0,1,17,16Z"})),z_||(z_=n.createElement("circle",{cx:"16",cy:"7.5",r:"1.5"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Hf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),L_||(L_=n.createElement("path",{d:"M25.82,10H30V8H25.82a3,3,0,0,0-5.64,0H13V5H5V8H2v2H5v3h8V10h7.18A3,3,0,0,0,22,11.82v7.32A4,4,0,0,0,19.14,22H2v2H19.14a4,4,0,0,0,7.72,0H30V22H26.86A4,4,0,0,0,24,19.14V11.82A3,3,0,0,0,25.82,10ZM11,11H7V7h4ZM25,23a2,2,0,1,1-2-2A2,2,0,0,1,25,23Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,kf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),M_||(M_=n.createElement("path",{d:"M20.8851,19.4711a5.9609,5.9609,0,0,0,0-6.9422L23,10.4141l1.293,1.2929a.9995.9995,0,0,0,1.414,0l4-4a.9994.9994,0,0,0,0-1.414l-4-4a.9994.9994,0,0,0-1.414,0l-4,4a.9994.9994,0,0,0,0,1.414L21.5859,9l-2.1148,2.1149a5.9609,5.9609,0,0,0-6.9422,0L10,8.5859V2H2v8H8.5859l2.529,2.5289a5.9609,5.9609,0,0,0,0,6.9422L9,21.5859,7.707,20.293a.9994.9994,0,0,0-1.414,0l-4,4a.9994.9994,0,0,0,0,1.414l4,4a.9995.9995,0,0,0,1.414,0l4-4a.9994.9994,0,0,0,0-1.414L10.4141,23l2.1148-2.1149a5.9609,5.9609,0,0,0,6.9422,0L22,23.4141V30h8V22H23.4141ZM25,4.4141,27.5859,7,25,9.5859,22.4141,7ZM7,27.5859,4.4141,25,7,22.4141,9.5859,25ZM8,8H4V4H8Zm4,8a4,4,0,1,1,4,4A4.0045,4.0045,0,0,1,12,16Zm12,8h4v4H24Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Nf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),y_||(y_=n.createElement("path",{d:"M10.343 10.343H21.657V21.657H10.343z",transform:"rotate(-45 16 16)"})),R_||(R_=n.createElement("path",{d:"M29.3906,14.5269,17.4731,2.6094a2.0852,2.0852,0,0,0-2.9462,0L2.6094,14.5269a2.0852,2.0852,0,0,0,0,2.9462L14.5269,29.3906a2.0852,2.0852,0,0,0,2.9462,0L29.3906,17.4731a2.0852,2.0852,0,0,0,0-2.9462ZM16,28.0356,3.9646,16,16,3.9644,28.0356,16Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Yf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),S_||(S_=n.createElement("path",{d:"M10.343 10.343H21.657V21.657H10.343z",transform:"rotate(-45 16 16)"})),A_||(A_=n.createElement("path",{d:"M16,4A12,12,0,1,1,4,16,12.0136,12.0136,0,0,1,16,4m0-2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Zf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),D_||(D_=n.createElement("path",{d:"M23,16a7,7,0,0,0-4.18,1.39L14.6,13.17A6.86,6.86,0,0,0,16,9a7,7,0,1,0-2.81,5.59l4.21,4.22A7,7,0,1,0,23,16ZM4,9a5,5,0,1,1,5,5A5,5,0,0,1,4,9Z",transform:"translate(0 .01)"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Pf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),V_||(V_=n.createElement("path",{d:"M28,7H13.8281l3.586-3.5859L16,2,10,8l6,6,1.4141-1.4141L13.8281,9H28V20H11.8989A5.0145,5.0145,0,0,0,8,16.1011V2H6V16.1011a5,5,0,0,0,0,9.7978V30H8V25.8989A5.0145,5.0145,0,0,0,11.8989,22H28a2.0023,2.0023,0,0,0,2-2V9A2.0023,2.0023,0,0,0,28,7ZM7,24a3,3,0,1,1,3-3A3.0033,3.0033,0,0,1,7,24Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Gf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),T_||(T_=n.createElement("path",{d:"M24,10l-1.4141,1.4141L26.1719,15H11.8989A5.0145,5.0145,0,0,0,8,11.1011V2H6v9.1011a5,5,0,0,0,0,9.7978V30H8V20.8989A5.0145,5.0145,0,0,0,11.8989,17h14.273l-3.586,3.5859L24,22l6-6ZM7,19a3,3,0,1,1,3-3A3.0033,3.0033,0,0,1,7,19Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,jf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),W_||(W_=n.createElement("path",{d:"M28 2H30V30H28zM20 10l-1.4141 1.4141L22.1719 15H11.8989a5 5 0 100 2h10.273l-3.586 3.5859L20 22l6-6zM7 19a3 3 0 113-3A3.0033 3.0033 0 017 19z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Kf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),U_||(U_=n.createElement("path",{d:"M8 8H10V12H8zM8 14H10V18H8zM14 8H16V12H14zM14 14H16V18H14zM8 20H10V24H8zM14 20H16V24H14zM30 14L21.83 14 24.41 16.59 23 18 18 13 23 8 24.41 9.41 21.83 12 30 12 30 14z"})),I_||(I_=n.createElement("path",{d:"M28,20v8H22V20H20v8H4V4H20V6h2V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V30H30V20Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Qf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),B_||(B_=n.createElement("path",{d:"M8 8H10V12H8zM8 14H10V18H8zM14 8H16V12H14zM14 14H16V18H14zM8 20H10V24H8zM14 20H16V24H14zM18 14L26.17 14 23.59 16.59 25 18 30 13 25 8 23.59 9.41 26.17 12 18 12 18 14z"})),O_||(O_=n.createElement("path",{d:"M28,20v8H22V20H20v8H4V4H20V6h2V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V30H30V20Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Jf);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),F_||(F_=n.createElement("path",{d:"M8 8H10V12H8zM8 14H10V18H8zM14 8H16V12H14zM14 14H16V18H14zM8 20H10V24H8zM14 20H16V24H14zM30 22L21.83 22 24.41 24.59 23 26 18 21 23 16 24.41 17.41 21.83 20 30 20 30 22zM19 12L27.17 12 24.59 14.59 26 16 31 11 26 6 24.59 7.41 27.17 10 19 10 19 12z"})),X_||(X_=n.createElement("path",{d:"M28,26v2H4V4H20V6h2V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V30H30V26Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,$f);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),C_||(C_=n.createElement("path",{d:"M15 12H17V30H15zM11.33 18.22a7 7 0 010-10.44l1.34 1.49a5 5 0 000 7.46zM20.67 18.22l-1.34-1.49a5 5 0 000-7.46l1.34-1.49a7 7 0 010 10.44z"})),q_||(q_=n.createElement("path",{d:"M8.4 21.8a11 11 0 010-17.6L9.6 5.8a9 9 0 000 14.4zM23.6 21.8l-1.2-1.6a9 9 0 000-14.4l1.2-1.6a11 11 0 010 17.6z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,eu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),H_||(H_=n.createElement("path",{d:"M26,13a8.9089,8.9089,0,0,1-2.5249,6.2339l1.4133,1.4131A10.9795,10.9795,0,0,0,23.6006,4.2l-1.2012,1.6A8.932,8.932,0,0,1,26,13Z"})),k_||(k_=n.createElement("path",{d:"M21 13a5.0022 5.0022 0 01-.9023 2.8564l1.4277 1.4278a6.9831 6.9831 0 00-.8584-9.5015l-1.334 1.49A5.0077 5.0077 0 0121 13zM30 28.5859L3.4143 2 2 3.4141l3.71 3.71A10.9824 10.9824 0 008.3994 21.8008l1.2012-1.6A8.9678 8.9678 0 017.1714 8.5854l2.1963 2.1963a6.9664 6.9664 0 001.9648 7.4351l1.334-1.49A5.0072 5.0072 0 0111 13a4.8854 4.8854 0 01.0393-.5464L15 16.4141V30h2V18.4141L28.5857 30z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,nu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),N_||(N_=n.createElement("path",{d:"M29.34 16.06a1.0007 1.0007 0 00-1.1084.3L24.46 20.8857l-5.4355-.9882-3.602-8.9512A3.014 3.014 0 0012.6138 9h-4.06A3.0018 3.0018 0 007.01 9.4277L2 12.4336v6.4009l5 .9092V30H9V20.1074l3.5652.648L14 24.2V30h2V23.8l-1.0911-2.6182L22.99 22.6509 18.2319 28.36A1 1 0 0019 30H29a1 1 0 001-1V17A1 1 0 0029.34 16.06zM4 17.1655V13.5664l3-1.8v5.9448zm5 .9092V11h3.6138a1.0141 1.0141 0 01.9453.6709l3.14 7.8037zM28 28H21.1353L28 19.7617zM12.5 8A3.5 3.5 0 1116 4.5 3.5042 3.5042 0 0112.5 8zm0-5A1.5 1.5 0 1014 4.5 1.5017 1.5017 0 0012.5 3z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,tu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Y_||(Y_=n.createElement("path",{d:"M17,13V6H8V22H24V13ZM10,8h5v5H10Zm0,7h5v5H10Zm12,5H17V15h5Z"})),Z_||(Z_=n.createElement("path",{d:"M28 11H19V2h9zM21 9h5V4H21zM28 20H26v2h2v6H4V22H6V20H4a2.0024 2.0024 0 00-2 2v6a2.0024 2.0024 0 002 2H28a2.0024 2.0024 0 002-2V22A2.0024 2.0024 0 0028 20z"})),P_||(P_=n.createElement("circle",{cx:"7",cy:"25",r:"1"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,iu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),G_||(G_=n.createElement("path",{d:"M27,22V17a2.0023,2.0023,0,0,0-2-2H17V10h3a2.0023,2.0023,0,0,0,2-2V4a2.0023,2.0023,0,0,0-2-2H12a2.0023,2.0023,0,0,0-2,2V8a2.0023,2.0023,0,0,0,2,2h3v5H7a2.0023,2.0023,0,0,0-2,2v5H2v8h8V22H7V17h8v5H12v8h8V22H17V17h8v5H22v8h8V22ZM12,4h8V8H12ZM8,28H4V24H8Zm10,0H14V24h4Zm10,0H24V24h4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,su);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),j_||(j_=n.createElement("path",{d:"M28,12H20V4h8Zm-6-2h4V6H22Z"})),K_||(K_=n.createElement("path",{d:"M17,15V9H9V23H23V15Zm-6-4h4v4H11Zm4,10H11V17h4Zm6,0H17V17h4Z"})),Q_||(Q_=n.createElement("path",{d:"M26,28H6a2.0023,2.0023,0,0,1-2-2V6A2.0023,2.0023,0,0,1,6,4H16V6H6V26H26V16h2V26A2.0023,2.0023,0,0,1,26,28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,lu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),J_||(J_=n.createElement("circle",{cx:"21",cy:"21",r:"2"})),$_||($_=n.createElement("circle",{cx:"7",cy:"7",r:"2"})),eo||(eo=n.createElement("path",{d:"M27,31a4,4,0,1,1,4-4A4.0118,4.0118,0,0,1,27,31Zm0-6a2,2,0,1,0,2,2A2.0059,2.0059,0,0,0,27,25Z"})),no||(no=n.createElement("path",{d:"M30,16A14.0412,14.0412,0,0,0,16,2,13.0426,13.0426,0,0,0,9.2,3.8l1.1,1.7a24.4254,24.4254,0,0,1,2.4-1A25.1349,25.1349,0,0,0,10,15H4a11.1489,11.1489,0,0,1,1.4-4.7L3.9,9A13.8418,13.8418,0,0,0,2,16,13.9983,13.9983,0,0,0,16,30a13.3656,13.3656,0,0,0,5.2-1l-.6-1.9a11.4416,11.4416,0,0,1-5.2.9h0A21.0713,21.0713,0,0,1,12,17H29.9A3.4019,3.4019,0,0,0,30,16ZM12.8,27.6h0a13.02,13.02,0,0,1-5.3-3.1A12.5053,12.5053,0,0,1,4,17h6A25.0022,25.0022,0,0,0,12.8,27.6ZM12,15A21.4461,21.4461,0,0,1,15.3,4h1.4A21.4461,21.4461,0,0,1,20,15Zm10,0A23.2777,23.2777,0,0,0,19.2,4.4,12.0919,12.0919,0,0,1,27.9,15Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ru);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),to||(to=n.createElement("circle",{cx:"16",cy:"19",r:"2"})),io||(io=n.createElement("path",{d:"M23.7769,18.4785A8.64,8.64,0,0,0,16,13a8.64,8.64,0,0,0-7.7769,5.4785L8,19l.2231.5215A8.64,8.64,0,0,0,16,25a8.64,8.64,0,0,0,7.7769-5.4785L24,19ZM16,23a4,4,0,1,1,4-4A4.0045,4.0045,0,0,1,16,23Z"})),so||(so=n.createElement("path",{d:"M27,3H5A2,2,0,0,0,3,5V27a2,2,0,0,0,2,2H27a2,2,0,0,0,2-2V5A2,2,0,0,0,27,3ZM5,5H27V9H5ZM5,27V11H27V27Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,au);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),lo||(lo=n.createElement("path",{d:"M10 28a1 1 0 01-1-1V5a1 1 0 011.501-.8652l19 11a1 1 0 010 1.73l-19 11A.9975.9975 0 0110 28zM11 6.7344V25.2656L27 16zM4 4H6V28H4z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,du);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ro||(ro=n.createElement("path",{d:"M10 28a1 1 0 01-1-1V5a1 1 0 011.501-.8652l19 11a1 1 0 010 1.73l-19 11A.9975.9975 0 0110 28zM4 4H6V28H4z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,_u);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ao||(ao=n.createElement("path",{d:"M7.7 4.7a14.7029 14.7029 0 00-3 3.1L6.3 9A13.2634 13.2634 0 018.9 6.3zM4.6 12.3l-1.9-.6A12.5111 12.5111 0 002 16H4A11.4756 11.4756 0 014.6 12.3zM11.7 2.7l.6 1.9A11.4756 11.4756 0 0116 4V2A12.5111 12.5111 0 0011.7 2.7zM24.2 27.3a15.18 15.18 0 003.1-3.1L25.7 23A11.526 11.526 0 0123 25.7zM27.4 19.7l1.9.6A15.4747 15.4747 0 0030 16H28A11.4756 11.4756 0 0127.4 19.7zM29.2 11.6a14.4029 14.4029 0 00-2-3.9L25.6 8.9a12.8867 12.8867 0 011.7 3.3zM24.1 4.6a14.4029 14.4029 0 00-3.9-2l-.6 1.9a12.8867 12.8867 0 013.3 1.7zM20.3 29.3l-.6-1.9A11.4756 11.4756 0 0116 28v2A21.4206 21.4206 0 0020.3 29.3zM15.4023 24.248a11.9488 11.9488 0 00-1.7182-3.3354L15.2974 19.73a13.9486 13.9486 0 012.0044 3.893zM11.02 18.2668a11.9215 11.9215 0 00-3.3467-1.6943l.6114-1.9043a13.9242 13.9242 0 013.9072 1.978z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ou);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),_o||(_o=n.createElement("path",{d:"M16 30V28A12.0021 12.0021 0 0019.6924 4.5786l.6152-1.9033A14.0022 14.0022 0 0116 30zM7.7 4.7a14.7029 14.7029 0 00-3 3.1L6.3 9A13.2634 13.2634 0 018.9 6.3zM4.6 12.3l-1.9-.6A12.5111 12.5111 0 002 16H4A11.4756 11.4756 0 014.6 12.3zM11.7 2.7l.6 1.9A11.4756 11.4756 0 0116 4V2A12.5111 12.5111 0 0011.7 2.7z"})),oo||(oo=n.createElement("path",{d:"M15.4023 24.248a11.9488 11.9488 0 00-1.7182-3.3354L15.2974 19.73a13.9486 13.9486 0 012.0044 3.893zM11.02 18.2668a11.9215 11.9215 0 00-3.3467-1.6943l.6114-1.9043a13.9242 13.9242 0 013.9072 1.978z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,mu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),mo||(mo=n.createElement("path",{d:"M7.7 4.7a14.7029 14.7029 0 00-3 3.1L6.3 9A13.2634 13.2634 0 018.9 6.3zM4.6 12.3l-1.9-.6A12.5111 12.5111 0 002 16H4A11.4756 11.4756 0 014.6 12.3zM2.7 20.4a14.4029 14.4029 0 002 3.9l1.6-1.2a12.8867 12.8867 0 01-1.7-3.3zM7.8 27.3a14.4029 14.4029 0 003.9 2l.6-1.9A12.8867 12.8867 0 019 25.7zM11.7 2.7l.6 1.9A11.4756 11.4756 0 0116 4V2A12.5111 12.5111 0 0011.7 2.7zM24.2 27.3a15.18 15.18 0 003.1-3.1L25.7 23A11.526 11.526 0 0123 25.7zM27.4 19.7l1.9.6A15.4747 15.4747 0 0030 16H28A11.4756 11.4756 0 0127.4 19.7zM29.2 11.6a14.4029 14.4029 0 00-2-3.9L25.6 8.9a12.8867 12.8867 0 011.7 3.3zM24.1 4.6a14.4029 14.4029 0 00-3.9-2l-.6 1.9a12.8867 12.8867 0 013.3 1.7zM20.3 29.3l-.6-1.9A11.4756 11.4756 0 0116 28v2A21.4206 21.4206 0 0020.3 29.3zM16 26A10 10 0 1126 16 10.0115 10.0115 0 0116 26zM16 8a8 8 0 108 8A8.0092 8.0092 0 0016 8z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,vu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),vo||(vo=n.createElement("path",{d:"M29.37,11.84a13.6,13.6,0,0,0-1.06-2.51A14.17,14.17,0,0,0,25.9,6.1a14,14,0,1,0,0,19.8,14.17,14.17,0,0,0,2.41-3.23,13.6,13.6,0,0,0,1.06-2.51,14,14,0,0,0,0-8.32ZM4,16A12,12,0,0,1,16,4V28A12,12,0,0,1,4,16Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,fu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),fo||(fo=n.createElement("path",{d:"M26.5 12H19a4 4 0 010-8h.0835A4.7864 4.7864 0 0123 2a4.9816 4.9816 0 014.6543 3.2034A3.4667 3.4667 0 0130 8.5 3.5041 3.5041 0 0126.5 12zM19 6a2 2 0 000 4h7.5A1.5017 1.5017 0 0028 8.5a1.4855 1.4855 0 00-1.2778-1.4739L26.061 6.927l-.1616-.6487a2.9568 2.9568 0 00-5.4873-.7121L20.1143 6zM23 14l-5 5 1.4141 1.4141L22 17.8325V24H16v2h6a2.0025 2.0025 0 002-2V17.8325l2.5874 2.583L28 19zM2 20H12V22H2zM2 24H12V26H2zM2 28H12V30H2z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,uu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),uo||(uo=n.createElement("circle",{cx:"10",cy:"21",r:"2"})),co||(co=n.createElement("circle",{cx:"23",cy:"20",r:"2"})),po||(po=n.createElement("circle",{cx:"13",cy:"10",r:"2"})),Eo||(Eo=n.createElement("circle",{cx:"14",cy:"15",r:"1"})),ho||(ho=n.createElement("circle",{cx:"23",cy:"5",r:"2"})),go||(go=n.createElement("circle",{cx:"29",cy:"3",r:"1"})),wo||(wo=n.createElement("circle",{cx:"16",cy:"23",r:"1"})),bo||(bo=n.createElement("path",{d:"M16,30C8.3,30,2,23.7,2,16S8.3,2,16,2c0.1,0,0.2,0,0.3,0l1.4,0.1l-0.3,1.2c-0.1,0.4-0.2,0.9-0.2,1.3c0,2.8,2.2,5,5,5 c1,0,2-0.3,2.9-0.9l1.3,1.5c-0.4,0.4-0.6,0.9-0.6,1.4c0,1.3,1.3,2.4,2.7,1.9l1.2-0.5l0.2,1.3C30,14.9,30,15.5,30,16 C30,23.7,23.7,30,16,30z M15.3,4C9,4.4,4,9.6,4,16c0,6.6,5.4,12,12,12s12-5.4,12-12c0-0.1,0-0.3,0-0.4c-2.3,0.1-4.2-1.7-4.2-4 c0-0.1,0-0.1,0-0.2c-0.5,0.1-1,0.2-1.6,0.2c-3.9,0-7-3.1-7-7C15.2,4.4,15.2,4.2,15.3,4z"})),i)})).propTypes=ol;var Oc=n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,cu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),xo||(xo=n.createElement("path",{d:"M28,10V28H10V10H28m0-2H10a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V10a2,2,0,0,0-2-2Z"})),zo||(zo=n.createElement("path",{d:"M4,18H2V4A2,2,0,0,1,4,2H18V4H4Z"})),i)}));Oc.propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,pu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Lo||(Lo=n.createElement("path",{d:"M27.4,14.7l-6.1-6.1C21,8.2,20.5,8,20,8h-8c-1.1,0-2,0.9-2,2v18c0,1.1,0.9,2,2,2h14c1.1,0,2-0.9,2-2V16.1 C28,15.6,27.8,15.1,27.4,14.7z M20,10l5.9,6H20V10z M12,28V10h6v6c0,1.1,0.9,2,2,2h6l0,10H12z"})),Mo||(Mo=n.createElement("path",{d:"M6,18H4V4c0-1.1,0.9-2,2-2h14v2H6V18z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Eu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),yo||(yo=n.createElement("path",{d:"M11.9474,19a4.9476,4.9476,0,0,1-3.4991-8.4465l5.1053-5.1043a4.9482,4.9482,0,0,1,6.9981,6.9976l-.5523.5526-1.4158-1.4129.5577-.5579a2.95,2.95,0,0,0-.0039-4.1653,3.02,3.02,0,0,0-4.17,0l-5.1047,5.104a2.9474,2.9474,0,0,0,0,4.1692,3.02,3.02,0,0,0,4.17,0l1.4143,1.4145A4.9176,4.9176,0,0,1,11.9474,19Z"})),Ro||(Ro=n.createElement("path",{d:"M19.9474,17a4.9476,4.9476,0,0,1-3.4991-8.4465l.5526-.5526,1.4143,1.4146-.5526.5523a2.9476,2.9476,0,0,0,0,4.1689,3.02,3.02,0,0,0,4.17,0c.26-.26,4.7293-4.7293,5.1053-5.1045a2.951,2.951,0,0,0,0-4.1687,3.02,3.02,0,0,0-4.17,0L21.5536,3.449a4.9483,4.9483,0,0,1,6.9981,6.9978c-.3765.376-4.844,4.8428-5.1038,5.1035A4.9193,4.9193,0,0,1,19.9474,17Z"})),So||(So=n.createElement("path",{d:"M24,30H4a2.0021,2.0021,0,0,1-2-2V8A2.0021,2.0021,0,0,1,4,6H8V8H4V28H24V18h2V28A2.0021,2.0021,0,0,1,24,30Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,hu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ao||(Ao=n.createElement("path",{d:"M23,16c-.3374,0-.67.02-1,.0508V16C22,8.115,19.0435,2,16.5,2S11,8.115,11,16v5H6v3a6.0067,6.0067,0,0,0,6,6h3A11.0125,11.0125,0,0,0,26,19V16ZM13,16h2V14H13.0728a25.8942,25.8942,0,0,1,.5654-4H16V8H14.2c.81-2.4058,1.8149-3.7715,2.3-3.9863.66.2919,2.2842,2.7036,3.0654,6.9863H18v2h1.8442A29.1625,29.1625,0,0,1,20,16v.4263A11.0554,11.0554,0,0,0,13.79,21H13ZM12,28a4.0045,4.0045,0,0,1-4-4V23h4.7639A10.9033,10.9033,0,0,0,12,27Zm12-9a9.01,9.01,0,0,1-9,9H14V27a9.01,9.01,0,0,1,9-9h1Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,gu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Do||(Do=n.createElement("path",{d:"M28,9H14V6H6v8H9V28h2V14h3V11H28ZM12,12H8V8h4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,wu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Vo||(Vo=n.createElement("circle",{cx:"15.5",cy:"11.5",r:"1.5"})),To||(To=n.createElement("circle",{cx:"20.5",cy:"15.5",r:"1.5"})),Wo||(Wo=n.createElement("circle",{cx:"16",cy:"16",r:"1"})),Uo||(Uo=n.createElement("circle",{cx:"16.5",cy:"20.5",r:"1.5"})),Io||(Io=n.createElement("circle",{cx:"11.5",cy:"16.5",r:"1.5"})),Bo||(Bo=n.createElement("path",{d:"M28,13v2H25.9492a9.9476,9.9476,0,0,0-2.2143-5.3213l1.4367-1.4365,1.4143,1.4145L28,8.2427,23.7578,4l-1.414,1.4141,1.414,1.414-1.437,1.4365A9.9464,9.9464,0,0,0,17,6.0508V4h2V2H13V4h2V6.0508A9.9464,9.9464,0,0,0,9.6792,8.2646L8.2422,6.8281l1.414-1.414L8.2422,4,4,8.2427l1.4141,1.414L6.8284,8.2422,8.2651,9.6787A9.9476,9.9476,0,0,0,6.0508,15H4V13H2v6H4V17H6.0508a9.9476,9.9476,0,0,0,2.2143,5.3213L6.8284,23.7578,5.4141,22.3433,4,23.7573,8.2422,28l1.414-1.4141-1.414-1.414,1.437-1.4365A9.9464,9.9464,0,0,0,15,25.9492V28H13v2h6V28H17V25.9492a9.9464,9.9464,0,0,0,5.3208-2.2138l1.437,1.4365-1.414,1.414L23.7578,28,28,23.7573l-1.4141-1.414-1.4143,1.4145-1.4367-1.4365A9.9476,9.9476,0,0,0,25.9492,17H28v2h2V13ZM16,24a8,8,0,1,1,8-8A8.0092,8.0092,0,0,1,16,24Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,bu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Oo||(Oo=n.createElement("path",{d:"M16,23a7,7,0,1,1,7-7A7.0078,7.0078,0,0,1,16,23Zm0-12a5,5,0,1,0,5,5A5.0057,5.0057,0,0,0,16,11Z"})),Fo||(Fo=n.createElement("path",{d:"M30,6.4141,28.5859,5l-3.35,3.35A12.0812,12.0812,0,0,0,23.65,6.7637L27,3.4141,25.5859,2,21.9766,5.6094A11.9792,11.9792,0,0,0,5.6094,21.9766L2,25.5859,3.4141,27l3.35-3.35A12.0812,12.0812,0,0,0,8.35,25.2363L5,28.5859,6.4141,30l3.6093-3.6094A11.9792,11.9792,0,0,0,26.3906,10.0234ZM16,26A10,10,0,1,1,26,16,10.0114,10.0114,0,0,1,16,26Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,xu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Xo||(Xo=n.createElement("path",{d:"M10 13H22V15H10zM10 18H22V20H10z"})),Co||(Co=n.createElement("path",{d:"M30,6.4141,28.5859,5l-3.35,3.35A12.0812,12.0812,0,0,0,23.65,6.7637L27,3.4141,25.5859,2,21.9766,5.6094A11.9792,11.9792,0,0,0,5.6094,21.9766L2,25.5859,3.4141,27l3.35-3.35A12.0812,12.0812,0,0,0,8.35,25.2363L5,28.5859,6.4141,30l3.6093-3.6094A11.9792,11.9792,0,0,0,26.3906,10.0234ZM16,26A10,10,0,1,1,26,16,10.0114,10.0114,0,0,1,16,26Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,zu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),qo||(qo=n.createElement("path",{d:"M26,30H24V27H20a5.0055,5.0055,0,0,1-5-5V20.7207l-2.3162-.772a1,1,0,0,1-.5412-1.4631L15,13.7229V11a9.01,9.01,0,0,1,9-9h5V4H24a7.0078,7.0078,0,0,0-7,7v3a.9991.9991,0,0,1-.1426.5144l-2.3586,3.9312,1.8174.6057A1,1,0,0,1,17,20v2a3.0033,3.0033,0,0,0,3,3h5a1,1,0,0,1,1,1Z"})),Ho||(Ho=n.createElement("circle",{cx:"9",cy:"23",r:"1"})),ko||(ko=n.createElement("circle",{cx:"6",cy:"20",r:"1"})),No||(No=n.createElement("circle",{cx:"6",cy:"26",r:"1"})),Yo||(Yo=n.createElement("circle",{cx:"3",cy:"17",r:"1"})),Zo||(Zo=n.createElement("circle",{cx:"3",cy:"29",r:"1"})),Po||(Po=n.createElement("circle",{cx:"3",cy:"23",r:"1"})),Go||(Go=n.createElement("path",{d:"M19 12H23V14H19z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Lu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),jo||(jo=n.createElement("path",{d:"M24,30H8a2.0023,2.0023,0,0,1-2-2V4A2.002,2.002,0,0,1,8,2H24a2.0023,2.0023,0,0,1,2,2V20.6182l-5-2.5-5,2.5V4H8V28H24V24h2v4A2.0027,2.0027,0,0,1,24,30ZM21,15.8818l3,1.5V4H18V17.3818Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Mu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ko||(Ko=n.createElement("circle",{cx:"8",cy:"16",r:"2"})),Qo||(Qo=n.createElement("circle",{cx:"14",cy:"8",r:"2"})),Jo||(Jo=n.createElement("circle",{cx:"28",cy:"12",r:"2"})),$o||($o=n.createElement("circle",{cx:"21",cy:"18",r:"2"})),em||(em=n.createElement("path",{d:"M30,3.4141,28.5859,2,4,26.5859V2H2V28a2,2,0,0,0,2,2H30V28H5.4141ZM4,28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,yu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),nm||(nm=n.createElement("path",{d:"M16 22a4 4 0 10-4-4A4 4 0 0016 22zm0-6a2 2 0 11-2 2A2 2 0 0116 16zM14 6H18V8H14z"})),tm||(tm=n.createElement("path",{d:"M24,2H8A2.002,2.002,0,0,0,6,4V28a2.0023,2.0023,0,0,0,2,2H24a2.0027,2.0027,0,0,0,2-2V4A2.0023,2.0023,0,0,0,24,2ZM20,28H12V26a1,1,0,0,1,1-1h6a1,1,0,0,1,1,1Zm2,0V26a3,3,0,0,0-3-3H13a3,3,0,0,0-3,3v2H8V4H24V28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ru);return"glyph"===l||"glyph"===l||"glyphpx"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),im||(im=n.createElement("path",{d:"M12.887 11.4727a5.9936 5.9936 0 00-8.36-8.3594zM3.113 4.5273a5.9936 5.9936 0 008.36 8.3594z"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),sm||(sm=n.createElement("path",{d:"M12.887 11.4727a5.9936 5.9936 0 00-8.36-8.3594zM3.113 4.5273a5.9936 5.9936 0 008.36 8.3594z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Su);return"glyph"===l||"glyph"===l||"glyphpx"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),lm||(lm=n.createElement("path",{d:"M13 13L3 13 3 3 13 13z"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),rm||(rm=n.createElement("path",{d:"M13 13L3 13 3 3 13 13z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Au);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),am||(am=n.createElement("path",{d:"M25,20H23V9H12V7H23a2,2,0,0,1,2,2Z"})),dm||(dm=n.createElement("path",{d:"M9,23V2H7V7H2V9H7V23a2,2,0,0,0,2,2H23v5h2V25h5V23Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Du);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),_m||(_m=n.createElement("path",{d:"M26,13a4.0045,4.0045,0,0,0,4-4V6H27a3.979,3.979,0,0,0-2.7468,1.1064A6.0041,6.0041,0,0,0,19,4H16V7a6.0066,6.0066,0,0,0,6,6h1V26H11V21h1a4.0045,4.0045,0,0,0,4-4V14H13a3.979,3.979,0,0,0-2.7468,1.1064A6.0041,6.0041,0,0,0,5,12H2v3a6.0066,6.0066,0,0,0,6,6H9v5H2v2H30V26H25V13Zm-1-3a2.002,2.002,0,0,1,2-2h1V9a2.002,2.002,0,0,1-2,2H25ZM11,18a2.002,2.002,0,0,1,2-2h1v1a2.002,2.002,0,0,1-2,2H11ZM9,19H8a4.0045,4.0045,0,0,1-4-4V14H5a4.0045,4.0045,0,0,1,4,4Zm14-8H22a4.0045,4.0045,0,0,1-4-4V6h1a4.0045,4.0045,0,0,1,4,4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Vu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),om||(om=n.createElement("path",{d:"M2 28H10V30H2zM17 29a1 1 0 01-.7808-.3752L12.52 24H2V22H13a1 1 0 01.7808.3752l3.146 3.9322 5.2412-7.8621A1 1 0 0123.8 18.4L26.5 22H30v2H26a.9991.9991 0 01-.8-.4l-2.1523-2.8694-5.2159 7.824a.9986.9986 0 01-.7885.4443zM11 16V11h1a4.0045 4.0045 0 004-4V4H13a3.9779 3.9779 0 00-2.7468 1.1067A6.0034 6.0034 0 005 2H2V5a6.0066 6.0066 0 006 6H9v5H2v2H16V16zM13 6h1V7a2.002 2.002 0 01-2 2H11V8A2.002 2.002 0 0113 6zM8 9A4.0045 4.0045 0 014 5V4H5A4.0045 4.0045 0 019 8V9z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Tu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),mm||(mm=n.createElement("path",{d:"M11 24H15V26H11zM5 24H9V26H5zM23 24H27V26H23zM17 24H21V26H17zM9 22a4.92 4.92 0 014-2h6a5.22 5.22 0 014 2h2.3A6.87 6.87 0 0019 18H13a6.87 6.87 0 00-6.3 4zM24 28H26V30H24zM6 28H8V30H6zM16 16a7 7 0 117-7A7 7 0 0116 16zM16 4a5 5 0 00-5 5A5 5 0 0021 9 5 5 0 0016 4z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Wu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),vm||(vm=n.createElement("path",{d:"M28,2H10A2.0023,2.0023,0,0,0,8,4V7H4A2.0023,2.0023,0,0,0,2,9V28a2.0023,2.0023,0,0,0,2,2H28a2.0023,2.0023,0,0,0,2-2V4A2.0023,2.0023,0,0,0,28,2ZM10,4H28V7H10ZM28,14H20V9h8ZM10,21V16h8v5Zm8,2v5H10V23ZM8,21H4V16H8ZM18,9v5H10V9Zm2,7h8v5H20ZM8,9v5H4V9ZM4,23H8v5H4Zm16,5V23h8v5Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Uu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),fm||(fm=n.createElement("path",{d:"M26.5859,6.5859A1.9862,1.9862,0,0,0,25.1719,6H17V2H15V12H6.8281a1.9862,1.9862,0,0,0-1.414.5859L2,16l3.4141,3.4141A1.9862,1.9862,0,0,0,6.8281,20H15V30h2V14h8.1719a1.9862,1.9862,0,0,0,1.414-.5859L30,10ZM6.8281,18l-2-2,2-2H15v4Zm18.3438-6H17V8h8.1719l2,2Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Iu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),um||(um=n.createElement("path",{d:"M16.832,19.5547l-1.664-1.1094L17.4648,15H20V10H12v5h2v2H12a2.0021,2.0021,0,0,1-2-2V10a2.0021,2.0021,0,0,1,2-2h8a2.0021,2.0021,0,0,1,2,2v5a2.0021,2.0021,0,0,1-2,2H18.5352Z"})),cm||(cm=n.createElement("path",{d:"M16,30,7.5645,20.0513c-.0479-.0571-.3482-.4515-.3482-.4515A10.8888,10.8888,0,0,1,5,13a11,11,0,0,1,22,0,10.8844,10.8844,0,0,1-2.2148,6.5973l-.0015.0025s-.3.3944-.3447.4474ZM8.8125,18.395c.001.0007.2334.3082.2866.3744L16,26.9079l6.91-8.15c.0439-.0552.2783-.3649.2788-.3657A8.901,8.901,0,0,0,25,13,9,9,0,0,0,7,13a8.9054,8.9054,0,0,0,1.8125,5.395Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Bu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),pm||(pm=n.createElement("path",{fill:"none",d:"M16.832,19.5547l-1.664-1.1094L17.4648,15H20V10H12v5h2v2H12a2.0021,2.0021,0,0,1-2-2V10a2.0021,2.0021,0,0,1,2-2h8a2.0021,2.0021,0,0,1,2,2v5a2.0021,2.0021,0,0,1-2,2H18.5352Z"})),Em||(Em=n.createElement("path",{d:"M16,2A11.0134,11.0134,0,0,0,5,13a10.8885,10.8885,0,0,0,2.2163,6.6s.3.3945.3482.4517L16,30l8.439-9.9526c.0444-.0533.3447-.4478.3447-.4478l.0015-.0024A10.8846,10.8846,0,0,0,27,13,11.0134,11.0134,0,0,0,16,2Zm6,13a2.0023,2.0023,0,0,1-2,2H18.5352L16.832,19.5547l-1.664-1.1094L17.4648,15H20V10H12v5h2v2H12a2.0023,2.0023,0,0,1-2-2V10a2.0023,2.0023,0,0,1,2-2h8a2.0023,2.0023,0,0,1,2,2Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ou);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),hm||(hm=n.createElement("path",{d:"M28 9L26 22 24 9 22 9 24.516 23 27.484 23 30 9 28 9zM18 23H12V21h6V17H14a2.002 2.002 0 01-2-2V11a2.002 2.002 0 012-2h6v2H14v4h4a2.002 2.002 0 012 2v4A2.002 2.002 0 0118 23zM10 23H4a2.0023 2.0023 0 01-2-2V11A2.002 2.002 0 014 9h6v2H4V21h6z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Fu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),gm||(gm=n.createElement("path",{d:"M10 23H5a2 2 0 01-2-2V15a2 2 0 012-2h5v2H5v6h5zM18 23H14a2 2 0 01-2-2V9h2V21h4V9h2V21A2 2 0 0118 23zM27 21L27 9.01 22 9.01 22 11.01 25 11.01 25 21 22 21 22 23 30 23 30 21 27 21z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Xu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),wm||(wm=n.createElement("path",{d:"M10 23H5a2 2 0 01-2-2V15a2 2 0 012-2h5v2H5v6h5zM18 23H14a2 2 0 01-2-2V9h2V21h4V9h2V21A2 2 0 0118 23zM28 9H22v2h6v4H23v2h5v4H22v2h6a2 2 0 002-2V11A2 2 0 0028 9z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Cu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),bm||(bm=n.createElement("path",{d:"M28.5039,8.1362l-12-7a1,1,0,0,0-1.0078,0l-12,7A1,1,0,0,0,3,9V23a1,1,0,0,0,.4961.8638l12,7a1,1,0,0,0,1.0078,0l12-7A1,1,0,0,0,29,23V9A1,1,0,0,0,28.5039,8.1362ZM16,3.1577,26.0156,9,16,14.8423,5.9844,9ZM5,10.7412l10,5.833V28.2588L5,22.4258ZM17,28.2588V16.5742l10-5.833V22.4258Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,qu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),xm||(xm=n.createElement("circle",{cx:"16",cy:"16",r:"2"})),zm||(zm=n.createElement("path",{d:"M23.7769,15.4785A8.64,8.64,0,0,0,16,10a8.64,8.64,0,0,0-7.7769,5.4785L8,16l.2231.5215A8.64,8.64,0,0,0,16,22a8.64,8.64,0,0,0,7.7769-5.4785L24,16ZM16,20a4,4,0,1,1,4-4A4.0045,4.0045,0,0,1,16,20Z"})),Lm||(Lm=n.createElement("path",{d:"M28.5039,8.1362l-12-7a1,1,0,0,0-1.0078,0l-12,7A1,1,0,0,0,3,9V23a1,1,0,0,0,.4961.8638l12,7a1,1,0,0,0,1.0078,0l12-7A1,1,0,0,0,29,23V9A1,1,0,0,0,28.5039,8.1362ZM27,22.4258,16,28.8423,5,22.4258V9.5742L16,3.1577,27,9.5742Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Hu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Mm||(Mm=n.createElement("path",{d:"M21,12V10H17V7H15v3H13a2.002,2.002,0,0,0-2,2v3a2.002,2.002,0,0,0,2,2h6v3H11v2h4v3h2V22h2a2.0023,2.0023,0,0,0,2-2V17a2.002,2.002,0,0,0-2-2H13V12Z"})),ym||(ym=n.createElement("path",{d:"M16,4A12,12,0,1,1,4,16,12.0353,12.0353,0,0,1,16,4m0-2A14,14,0,1,0,30,16,14.0412,14.0412,0,0,0,16,2Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ku);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Rm||(Rm=n.createElement("path",{d:"M21.4023,15.6426A4.9727,4.9727,0,0,0,23,12V11a5.0059,5.0059,0,0,0-5-5H17V3H15V6H10V26h5v3h2V26h2a5.0059,5.0059,0,0,0,5-5V20A4.9834,4.9834,0,0,0,21.4023,15.6426ZM12,8h6a3.0033,3.0033,0,0,1,3,3v1a3.0033,3.0033,0,0,1-3,3H12ZM22,21a3.0033,3.0033,0,0,1-3,3H12V17h7a3.0033,3.0033,0,0,1,3,3Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Nu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Sm||(Sm=n.createElement("path",{d:"M23,20.5151c0-4.6152-3.78-5.1411-6.8171-5.563-3.31-.4609-5.1829-.86-5.1829-3.71C11,8.8491,13.5071,8,15.6538,8a6.7538,6.7538,0,0,1,5.5681,2.6279l1.5562-1.2558A8.6508,8.6508,0,0,0,17,6.0962V3H15V6.022c-3.6152.2192-6,2.26-6,5.22,0,4.73,3.83,5.2627,6.9075,5.69C19.16,17.3848,21,17.7744,21,20.5151,21,23.5474,17.8674,24,16,24c-3.4294,0-4.8782-.9639-6.2219-2.6279L8.2219,22.6279A8.4382,8.4382,0,0,0,15,25.9648V29h2V25.9551C20.7256,25.6509,23,23.6279,23,20.5151Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Yu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Am||(Am=n.createElement("path",{d:"M17,26c-3.6162,0-6.3328-2.2974-7.4456-6H19V18H9.1321A15.2782,15.2782,0,0,1,9,16c0-.33.01-.6641.0259-1H19V13H9.2371C9.8447,9.3525,11.81,6,17,6c3.8533,0,5.5315,1.6465,7.1282,4.4893l1.7436-.9786C24.2649,6.6484,22.0779,4,17,4,10.6448,4,7,8.374,7,16c0,7.0654,4.1121,12,10,12,5.0779,0,7.2649-2.6484,8.8718-5.5107l-1.7436-.9786C22.5315,24.3535,20.8533,26,17,26Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Zu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Dm||(Dm=n.createElement("path",{d:"M23,19a6.0066,6.0066,0,0,1-6,6H13V18.1079L21.2139,15V13L13,16.1079v-3L21.2139,10V8L13,11.1079V5H11v6.8647L8,13v2l3-1.1353v3L8,18v2l3-1.1353V27h6a8.0092,8.0092,0,0,0,8-8Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Pu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Vm||(Vm=n.createElement("path",{d:"M12.4531,25A8.7775,8.7775,0,0,0,14,20a10.6,10.6,0,0,0-.18-2H22V16H13.2175c-.0842-.2109-.17-.4194-.2556-.624A9.8586,9.8586,0,0,1,12,11a4.792,4.792,0,0,1,5-5,6.1234,6.1234,0,0,1,5.2222,2.6279l1.5556-1.2558A8.11,8.11,0,0,0,17,4a6.7781,6.7781,0,0,0-7,7,11.65,11.65,0,0,0,1.0559,5H8v2h3.7729A8.209,8.209,0,0,1,12,20c0,2.5234-1.4858,5-3,5v2H24V25Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Gu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Tm||(Tm=n.createElement("path",{d:"M19,4H10V15H7v2h3v3H7v2h3v6h2V22h9V20H12V17h7a6.0067,6.0067,0,0,0,6-6V10A6.0067,6.0067,0,0,0,19,4Zm4,7a4.0045,4.0045,0,0,1-4,4H12V6h7a4.0045,4.0045,0,0,1,4,4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ju);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Wm||(Wm=n.createElement("path",{d:"M24,7V5H8V7h5.5a4.4906,4.4906,0,0,1,4.45,4H8v2h9.95A4.4906,4.4906,0,0,1,13.5,17H8v2.3452L17.6169,28l1.3379-1.4863L10.606,19H13.5a6.5041,6.5041,0,0,0,6.4746-6H24V11H19.9746A6.4719,6.4719,0,0,0,18.18,7Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ku);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Um||(Um=n.createElement("path",{d:"M9,27H7V5h8a5.0057,5.0057,0,0,1,5,5V22H18V10a3.0033,3.0033,0,0,0-3-3H9Z"})),Im||(Im=n.createElement("path",{d:"M20,27H12V10h2V25h6a3.0033,3.0033,0,0,0,3-3V5h2V22A5.0057,5.0057,0,0,1,20,27Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Qu);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Bm||(Bm=n.createElement("path",{d:"M28 14L28 12 23.045 12 24 5 22 5 20 23 17 8 15 8 12 23 10 5 8 5 8.955 12 4 12 4 14 9.227 14 9.636 17 4 17 4 19 9.909 19 11 27 13 27 16 12 19 27 21 27 22.091 19 28 19 28 17 22.364 17 22.773 14 28 14z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ju);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Om||(Om=n.createElement("path",{d:"M24.271 5L22 5 16 16 10 5 7.729 5 13.794 16 8 16 8 18 15 18 15 21 8 21 8 23 15 23 15 27 17 27 17 23 24 23 24 21 17 21 17 18 24 18 24 16 18.206 16 24.271 5z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,$u);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Fm||(Fm=n.createElement("path",{d:"M23,28a1,1,0,0,1-.71-.29l-6.13-6.14-3.33,5a1,1,0,0,1-1,.44,1,1,0,0,1-.81-.7l-6-20A1,1,0,0,1,6.29,5l20,6a1,1,0,0,1,.7.81,1,1,0,0,1-.44,1l-5,3.33,6.14,6.13a1,1,0,0,1,0,1.42l-4,4A1,1,0,0,1,23,28Zm0-2.41L25.59,23l-7.16-7.15,5.25-3.5L7.49,7.49l4.86,16.19,3.5-5.25Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ec);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Xm||(Xm=n.createElement("path",{d:"M27.34,12.06l-22-8A1,1,0,0,0,4.06,5.34l8,22A1,1,0,0,0,13,28h0a1,1,0,0,0,.93-.63l3.84-9.6,9.6-3.84a1,1,0,0,0,0-1.87Zm-10.71,4h0l-.4.16-.16.4h0L13,24.2,6.67,6.67,24.2,13Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,nc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Cm||(Cm=n.createElement("path",{d:"M26.5,19.63,20.24,16l6.26-3.63a5,5,0,0,0-1.21-9.2A5.19,5.19,0,0,0,24,3a5,5,0,0,0-4.33,7.53,5,5,0,0,0,2.39,2.1l-3.82,2.21L4,6.6,3,8.34,16.24,16,3,23.68l1,1.74,14.24-8.26,3.82,2.21a5,5,0,0,0-2.39,2.1A5,5,0,0,0,24,29a5.19,5.19,0,0,0,1.29-.17,5,5,0,0,0,1.21-9.2ZM21.4,9.53a3,3,0,0,1,1.1-4.12,3,3,0,0,1,4.1,1.11,3,3,0,0,1-1.1,4.11h0A3,3,0,0,1,21.4,9.53Zm5.2,16a3,3,0,0,1-4.1,1.11,3,3,0,0,1-1.1-4.12,3,3,0,0,1,4.1-1.1h0A3,3,0,0,1,26.6,25.48Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,tc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),qm||(qm=n.createElement("path",{d:"M28,4H4A2.0023,2.0023,0,0,0,2,6V26a2.0023,2.0023,0,0,0,2,2H28a2.0023,2.0023,0,0,0,2-2V6A2.0023,2.0023,0,0,0,28,4ZM4,6H16V26H4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ic);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Hm||(Hm=n.createElement("path",{d:"M19.05 13.7326L18.05 12 7.928 17.8457 6.9312 17.27a2.9524 2.9524 0 00.6672-.769A3 3 0 103.5 17.5986l2.428 1.4019L3.5 20.4023a3.0342 3.0342 0 103.4407.3223l.987-.5693L14.5914 24l1-1.7294-5.6634-3.27zM4.0344 15.26a1 1 0 11.4658.6069A.9929.9929 0 014.0344 15.26zM4.9988 22a1 1 0 11-.8645 1.5A1 1 0 014.9988 22zM17 26H21V28H17zM10 26H14V28H10z"})),km||(km=n.createElement("path",{d:"M28,28H24V26h4V4H7V8H5V4A2.0023,2.0023,0,0,1,7,2H28a2.0023,2.0023,0,0,1,2,2V26A2.0023,2.0023,0,0,1,28,28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,sc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Nm||(Nm=n.createElement("path",{d:"M15 23H10a2 2 0 01-2-2V15a2 2 0 012-2h5v2H10v6h5zM24 9L22 9 20 16 18 9 16 9 19 18 19 23 21 23 21 18 24 9z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,lc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ym||(Ym=n.createElement("path",{d:"M25 30a6 6 0 116-6A6.0069 6.0069 0 0125 30zm0-10a4 4 0 104 4A4.0045 4.0045 0 0025 20zM7 30a6 6 0 116-6A6.0069 6.0069 0 017 30zM7 20a4 4 0 104 4A4.0045 4.0045 0 007 20z"})),Zm||(Zm=n.createElement("path",{d:"M17 27H15V20.4139L9.5849 15a2.003 2.003 0 010-2.8292l4.5859-4.5859a2.0024 2.0024 0 012.8286 0L21.414 12H27v1.9993L20.5853 14l-5-5L11 13.5849l6 6zM21.5 8A3.5 3.5 0 1125 4.5 3.5042 3.5042 0 0121.5 8zm0-5A1.5 1.5 0 1023 4.5 1.5017 1.5017 0 0021.5 3z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,rc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Pm||(Pm=n.createElement("path",{d:"M14 23H9a2 2 0 01-2-2V15a2 2 0 012-2h5v2H9v6h5zM24 9L16 9 16 11 22 11 16 21 16 23 24 23 24 21 18 21 24 11 24 9z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ac);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Gm||(Gm=n.createElement("path",{d:"M24 21H26V26H24zM20 16H22V26H20zM11 26a5.0059 5.0059 0 01-5-5H8a3 3 0 103-3V16a5 5 0 010 10z"})),jm||(jm=n.createElement("path",{d:"M28,2H4A2.002,2.002,0,0,0,2,4V28a2.0023,2.0023,0,0,0,2,2H28a2.0027,2.0027,0,0,0,2-2V4A2.0023,2.0023,0,0,0,28,2Zm0,9H14V4H28ZM12,4v7H4V4ZM4,28V13H28.0007l.0013,15Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,dc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Km||(Km=n.createElement("path",{d:"M4 20L4 22 8.586 22 2 28.586 3.414 30 10 23.414 10 28 12 28 12 20 4 20zM24 21H26V26H24zM20 16H22V26H20zM16 18H18V26H16z"})),Qm||(Qm=n.createElement("path",{d:"M28,2H4A2.002,2.002,0,0,0,2,4V16H4V13H28.001l.001,15H16v2H28a2.0027,2.0027,0,0,0,2-2V4A2.0023,2.0023,0,0,0,28,2ZM12,11H4V4h8Zm2,0V4H28l.0007,7Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,_c);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Jm||(Jm=n.createElement("path",{d:"M15 6H28V8H15zM15 24H28V26H15zM4 15H17V17H4zM7 11a4 4 0 114-4A4 4 0 017 11zM7 5A2 2 0 109 7 2 2 0 007 5zM7 29a4 4 0 114-4A4 4 0 017 29zm0-6a2 2 0 102 2A2 2 0 007 23zM25 20a4 4 0 114-4A4 4 0 0125 20zm0-6a2 2 0 102 2A2 2 0 0025 14z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,oc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),$m||($m=n.createElement("path",{d:"M4 6H15V8H4zM18 6H28V8H18zM21 12H28V14H21zM11 12H18V14H11zM4 12H8V14H4zM4 18H28V20H4zM4 24H21V26H4zM24 24H28V26H24z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,mc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ev||(ev=n.createElement("path",{d:"M24,3H8A2,2,0,0,0,6,5V27a2,2,0,0,0,2,2H24a2,2,0,0,0,2-2V5A2,2,0,0,0,24,3Zm0,2v6H8V5ZM8,19V13H24v6Zm0,8V21H24v6Z"})),nv||(nv=n.createElement("circle",{cx:"11",cy:"8",r:"1"})),tv||(tv=n.createElement("circle",{cx:"11",cy:"16",r:"1"})),iv||(iv=n.createElement("circle",{cx:"11",cy:"24",r:"1"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,vc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),sv||(sv=n.createElement("path",{d:"M7 8H12V10H7zM7 12H12V14H7zM7 16H12V18H7zM20 8H25V10H20zM20 12H25V14H20zM20 16H25V18H20z"})),lv||(lv=n.createElement("path",{d:"M28,4H4A2.0023,2.0023,0,0,0,2,6V28a2.0023,2.0023,0,0,0,2,2H28a2.0023,2.0023,0,0,0,2-2V6A2.0023,2.0023,0,0,0,28,4ZM4,6H15V28H4ZM17,28V6H28V28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,fc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),rv||(rv=n.createElement("path",{d:"M28,10H23V6a2.0023,2.0023,0,0,0-2-2H11A2.0023,2.0023,0,0,0,9,6v4H4a2.0023,2.0023,0,0,0-2,2V28a2.0023,2.0023,0,0,0,2,2H28a2.0023,2.0023,0,0,0,2-2V12A2.0023,2.0023,0,0,0,28,10ZM4,28V12H9v2H7v2H9v2H7v2H9v2H7v2H9v4Zm17,0H11V6H21Zm7,0H23V24h2V22H23V20h2V18H23V16h2V14H23V12h5Z"})),av||(av=n.createElement("path",{d:"M14 8H18V10H14zM14 12H18V14H14zM14 16H18V18H14z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,uc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),dv||(dv=n.createElement("path",{d:"M23 27.18L20.41 24.59 19 26 23 30 30 23 28.59 21.59 23 27.18z"})),_v||(_v=n.createElement("circle",{cx:"11",cy:"8",r:"1"})),ov||(ov=n.createElement("circle",{cx:"11",cy:"16",r:"1"})),mv||(mv=n.createElement("circle",{cx:"11",cy:"24",r:"1"})),vv||(vv=n.createElement("path",{d:"M24,3H8A2,2,0,0,0,6,5V27a2,2,0,0,0,2,2h8V27H8V21H26V5A2,2,0,0,0,24,3Zm0,16H8V13H24Zm0-8H8V5H24Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,cc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),fv||(fv=n.createElement("path",{d:"M30 30L24 30 24 28 28 28 28 4 24 4 24 2 30 2 30 30z"})),uv||(uv=n.createElement("path",{d:"M24.91,19.59a4.51,4.51,0,0,0-2.66-3.24,4.55,4.55,0,0,0-3.5,0,4.94,4.94,0,0,0-.64.35L15.3,13.89a4.53,4.53,0,1,0-1.41,1.41l2.81,2.81a4.48,4.48,0,0,0-.61,3.3,4.51,4.51,0,0,0,2.66,3.24,4.55,4.55,0,0,0,3.5,0,4.51,4.51,0,0,0,2.66-3.24,4.65,4.65,0,0,0,0-1.82ZM11.5,14A2.5,2.5,0,1,1,14,11.5,2.5,2.5,0,0,1,11.5,14Z"})),cv||(cv=n.createElement("path",{d:"M8 30L2 30 2 2 8 2 8 4 4 4 4 28 8 28 8 30z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,pc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),pv||(pv=n.createElement("circle",{cx:"11",cy:"8",r:"1"})),Ev||(Ev=n.createElement("circle",{cx:"11",cy:"16",r:"1"})),hv||(hv=n.createElement("circle",{cx:"11",cy:"24",r:"1"})),gv||(gv=n.createElement("path",{d:"M24,3H8A2,2,0,0,0,6,5V27a2,2,0,0,0,2,2H18V27H8V21H26V5A2,2,0,0,0,24,3Zm0,16H8V13H24Zm0-8H8V5H24Z"})),wv||(wv=n.createElement("path",{d:"M29 24.415L27.586 23 25 25.587 22.414 23 21 24.415 23.586 27 21 29.586 22.414 31 25 28.414 27.586 31 29 29.586 26.414 27 29 24.415z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ec);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),bv||(bv=n.createElement("path",{d:"M18 11H26V13H18zM6 19H14V21H6zM10 16a4 4 0 114-4A4.0045 4.0045 0 0110 16zm0-6a2 2 0 102 2A2.002 2.002 0 0010 10zM22 24a4 4 0 114-4A4.0045 4.0045 0 0122 24zm0-6a2 2 0 102 2A2.002 2.002 0 0022 18z"})),xv||(xv=n.createElement("path",{d:"M28,30H4a2.0021,2.0021,0,0,1-2-2V4A2.0021,2.0021,0,0,1,4,2H28a2.0021,2.0021,0,0,1,2,2V28A2.0021,2.0021,0,0,1,28,30ZM4,4V28H28V4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,hc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),zv||(zv=n.createElement("path",{d:"M25 13L25 4 23 4 23 6 20 6 20 8 23 8 23 13 20 13 20 15 28 15 28 13 25 13zM8.5 6A3.5 3.5 0 115 9.5 3.504 3.504 0 018.5 6m0-2A5.5 5.5 0 1014 9.5 5.5 5.5 0 008.5 4zM23.5 20A3.5 3.5 0 1120 23.5 3.504 3.504 0 0123.5 20m0-2A5.5 5.5 0 1029 23.5 5.5 5.5 0 0023.5 18zM6 19L6 21 9.586 21 4 26.586 5.414 28 11 22.414 11 26 13 26 13 19 6 19z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,gc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Lv||(Lv=n.createElement("path",{d:"M25 13L25 4 23 4 23 6 20 6 20 8 23 8 23 13 20 13 20 15 28 15 28 13 25 13zM8.5 6A3.5 3.5 0 115 9.5 3.5 3.5 0 018.5 6m0-2A5.5 5.5 0 1014 9.5 5.5 5.5 0 008.5 4zM8.5 20A3.5 3.5 0 115 23.5 3.5 3.5 0 018.5 20m0-2A5.5 5.5 0 1014 23.5 5.5 5.5 0 008.5 18zM23.5 20A3.5 3.5 0 1120 23.5 3.5 3.5 0 0123.5 20m0-2A5.5 5.5 0 1029 23.5 5.5 5.5 0 0023.5 18z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,wc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Mv||(Mv=n.createElement("circle",{cx:"9",cy:"7",r:"1"})),yv||(yv=n.createElement("path",{d:"M27,22.14V18a2,2,0,0,0-2-2H17V12h9a2,2,0,0,0,2-2V4a2,2,0,0,0-2-2H6A2,2,0,0,0,4,4v6a2,2,0,0,0,2,2h9v4H7a2,2,0,0,0-2,2v4.14a4,4,0,1,0,2,0V18h8v4H12v8h8V22H17V18h8v4.14a4,4,0,1,0,2,0ZM8,26a2,2,0,1,1-2-2A2,2,0,0,1,8,26Zm10-2v4H14V24ZM6,10V4H26v6ZM26,28a2,2,0,1,1,2-2A2,2,0,0,1,26,28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,bc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Rv||(Rv=n.createElement("path",{d:"M6 24a2 2 0 11-2 2 2 2 0 012-2m0-2a4 4 0 104 4A4 4 0 006 22zM16 4a2 2 0 11-2 2 2 2 0 012-2m0-2a4 4 0 104 4A4 4 0 0016 2zM26 4a2 2 0 11-2 2 2 2 0 012-2m0-2a4 4 0 104 4A4 4 0 0026 2zM18 24v4H14V24h4m2-2H12v8h8z"})),Sv||(Sv=n.createElement("path",{d:"M27,22.14V17a2,2,0,0,0-2-2H7V10h3V2H2v8H5v5a2,2,0,0,0,2,2H25v5.14a4,4,0,1,0,2,0ZM4,4H8V8H4ZM26,28a2,2,0,1,1,2-2A2,2,0,0,1,26,28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,xc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Av||(Av=n.createElement("circle",{cx:"22",cy:"24",r:"2"})),Dv||(Dv=n.createElement("path",{d:"M29.7769,23.4785A8.64,8.64,0,0,0,22,18a8.64,8.64,0,0,0-7.7769,5.4785L14,24l.2231.5215A8.64,8.64,0,0,0,22,30a8.64,8.64,0,0,0,7.7769-5.4785L30,24ZM22,28a4,4,0,1,1,4-4A4.0045,4.0045,0,0,1,22,28Z"})),Vv||(Vv=n.createElement("circle",{cx:"8",cy:"8",r:"1"})),Tv||(Tv=n.createElement("circle",{cx:"8",cy:"16",r:"1"})),Wv||(Wv=n.createElement("circle",{cx:"8",cy:"24",r:"1"})),Uv||(Uv=n.createElement("path",{d:"M5,21h7V19H5V13H21v3h2V5a2,2,0,0,0-2-2H5A2,2,0,0,0,3,5V27a2,2,0,0,0,2,2h7V27H5ZM5,5H21v6H5Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,zc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Iv||(Iv=n.createElement("circle",{cx:"22",cy:"24",r:"2"})),Bv||(Bv=n.createElement("path",{d:"M29.7769 23.4785A8.64 8.64 0 0022 18a8.64 8.64 0 00-7.7769 5.4785L14 24l.2231.5215A8.64 8.64 0 0022 30a8.64 8.64 0 007.7769-5.4785L30 24zM22 28a4 4 0 114-4A4.0045 4.0045 0 0122 28zM7 17H12V19H7zM7 12H19V14H7zM7 7H19V9H7z"})),Ov||(Ov=n.createElement("path",{d:"M22,2,4,2A2.0058,2.0058,0,0,0,2,4V28a2.0058,2.0058,0,0,0,2,2h8V28H4V4H22V15h2V4A2.0058,2.0058,0,0,0,22,2Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Lc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Fv||(Fv=n.createElement("path",{d:"M28,20H26v2h2v6H4V22H6V20H4a2.0024,2.0024,0,0,0-2,2v6a2.0024,2.0024,0,0,0,2,2H28a2.0024,2.0024,0,0,0,2-2V22A2.0024,2.0024,0,0,0,28,20Z"})),Xv||(Xv=n.createElement("circle",{cx:"7",cy:"25",r:"1"})),Cv||(Cv=n.createElement("path",{d:"M21,13a2.9609,2.9609,0,0,0-1.2854.3008L17.4141,11l2.3-2.3008A2.9609,2.9609,0,0,0,21,9a3,3,0,1,0-3-3,2.9665,2.9665,0,0,0,.3,1.2852L16,9.5859,13.7,7.2852A2.9665,2.9665,0,0,0,14,6a3,3,0,1,0-3,3,2.9609,2.9609,0,0,0,1.2854-.3008L14.5859,11l-2.3005,2.3008A2.9609,2.9609,0,0,0,11,13a3,3,0,1,0,3,3,2.9665,2.9665,0,0,0-.3-1.2852L16,12.4141l2.3,2.3007A2.9665,2.9665,0,0,0,18,16a3,3,0,1,0,3-3Zm0-8a1,1,0,1,1-1,1A1.0009,1.0009,0,0,1,21,5ZM10,6a1,1,0,1,1,1,1A1.0009,1.0009,0,0,1,10,6Zm1,11a1,1,0,1,1,1-1A1.0009,1.0009,0,0,1,11,17Zm10,0a1,1,0,1,1,1-1A1.0009,1.0009,0,0,1,21,17Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Mc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),qv||(qv=n.createElement("circle",{cx:"7",cy:"7",r:"1"})),Hv||(Hv=n.createElement("circle",{cx:"7",cy:"15",r:"1"})),kv||(kv=n.createElement("circle",{cx:"7",cy:"23",r:"1"})),Nv||(Nv=n.createElement("path",{d:"M12,26H4V20h8V18H4V12H22V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V26a2,2,0,0,0,2,2h8ZM4,4H20v6H4Z"})),Yv||(Yv=n.createElement("path",{d:"M28,17v2.4131A6.996,6.996,0,1,0,22,30V28a5,5,0,1,1,4.5762-7H24v2h6V17Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,yc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Zv||(Zv=n.createElement("path",{d:"M28 2H20a2.0023 2.0023 0 00-2 2V28a2.0023 2.0023 0 002 2h8a2.0023 2.0023 0 002-2V4A2.0023 2.0023 0 0028 2zm0 2v7H20V4zm0 9v6H20V13zM20 28V21h8v7zM12 15L10 15 10 13 8 13 8 15 6 15 6 17 8 17 8 19 10 19 10 17 12 17 12 15z"})),Pv||(Pv=n.createElement("path",{d:"M16,6V4H10A2.0023,2.0023,0,0,0,8,6V9.08A6.99,6.99,0,0,0,8,22.92V26a2.0023,2.0023,0,0,0,2,2h6V26H10V22.92A6.99,6.99,0,0,0,10,9.08V6ZM14,16a5,5,0,1,1-5-5A5.0059,5.0059,0,0,1,14,16Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Rc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Gv||(Gv=n.createElement("path",{d:"M28,30H4a2.0021,2.0021,0,0,1-2-2V4A2.0021,2.0021,0,0,1,4,2H28a2.0021,2.0021,0,0,1,2,2V28A2.0021,2.0021,0,0,1,28,30ZM4,4V28H28V4Z"})),jv||(jv=n.createElement("path",{d:"M13 7H15V14H13zM8 7H10V14H8zM22 14H20a2.0021 2.0021 0 01-2-2V9a2.0021 2.0021 0 012-2h2a2.0021 2.0021 0 012 2v3A2.0021 2.0021 0 0122 14zM20 9v3h2V9zM22 18H24V25H22zM8 18H10V25H8zM17 25H15a2.0021 2.0021 0 01-2-2V20a2.0021 2.0021 0 012-2h2a2.0021 2.0021 0 012 2v3A2.0021 2.0021 0 0117 25zm-2-5v3h2V20z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Sc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Kv||(Kv=n.createElement("path",{d:"M26,16a3.9612,3.9612,0,0,0-2.02.5657l-2.8586-2.8585,2.293-2.293a2,2,0,0,0,0-2.8284l-6-6a2,2,0,0,0-2.8284,0l-6,6a2,2,0,0,0,0,2.8284l2.293,2.293L8.02,16.5657A4.043,4.043,0,1,0,9.4343,17.98l2.8585-2.8586,2.293,2.293A1.9773,1.9773,0,0,0,15,17.7233V22H12v8h8V22H17V17.7233a1.9773,1.9773,0,0,0,.4142-.3091l2.293-2.293L22.5657,17.98A3.9885,3.9885,0,1,0,26,16ZM8,20a2,2,0,1,1-2-2A2.0023,2.0023,0,0,1,8,20Zm10,4v4H14V24h4Zm-2-8-6-6,6-6,6,6Zm10,6a2,2,0,1,1,2-2A2.0023,2.0023,0,0,1,26,22Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ac);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Qv||(Qv=n.createElement("circle",{cx:"16",cy:"16",r:"2"})),Jv||(Jv=n.createElement("path",{d:"M30 17L30 15 23.83 15 26.41 12.41 25 11 20 16 25 21 26.41 19.59 23.83 17 30 17zM15 23.83L15 30 17 30 17 23.83 19.59 26.41 21 25 16 20 11 25 12.41 26.41 15 23.83zM7 11L5.59 12.41 8.17 15 2 15 2 17 8.17 17 5.59 19.59 7 21 12 16 7 11zM17 8.17L17 2 15 2 15 8.17 12.41 5.59 11 7 16 12 21 7 19.59 5.59 17 8.17z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Dc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),$v||($v=n.createElement("circle",{cx:"14",cy:"14",r:"2"})),ef||(ef=n.createElement("path",{d:"M20,30a.9967.9967,0,0,1-.707-.293L8.5859,19A2.0126,2.0126,0,0,1,8,17.5859V10a2.002,2.002,0,0,1,2-2h7.5859A1.9864,1.9864,0,0,1,19,8.5859L29.707,19.293a.9994.9994,0,0,1,0,1.414l-9,9A.9967.9967,0,0,1,20,30ZM10,10v7.5859l10,10L27.5859,20l-10-10Z"})),nf||(nf=n.createElement("path",{d:"M12,30H4a2.0021,2.0021,0,0,1-2-2V4A2.0021,2.0021,0,0,1,4,2H28a2.0021,2.0021,0,0,1,2,2v8H28V4H4V28h8Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Vc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),tf||(tf=n.createElement("path",{d:"M30,15H27V7H25v8H22V7H20v7.8262L7.5239,7.1484A1,1,0,0,0,6,8v7H2v2H6v7a1,1,0,0,0,1.5239.8516L20,17.1738V25h2V17h3v8h2V17h3ZM8,22.21V9.79L18.0918,16Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Tc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),sf||(sf=n.createElement("path",{d:"M28 13H30V15H28z"})),lf||(lf=n.createElement("path",{d:"M24.2 3.8H26.2V5.8H24.2z",transform:"rotate(-45.001 25.192 4.808)"})),rf||(rf=n.createElement("path",{d:"M15 0H17V2H15z"})),af||(af=n.createElement("path",{d:"M5.8 3.8H7.8V5.8H5.8z",transform:"rotate(-134.999 6.808 4.808)"})),df||(df=n.createElement("path",{d:"M2 13H4V15H2zM20 13L17 13 17 10 15 10 15 13 12 13 12 15 15 15 15 18 17 18 17 15 20 15zM13 30H19V32H13zM11 26H21V28H11z"})),_f||(_f=n.createElement("path",{d:"M16,4C10.5,4,6,8.5,6,14c0,4.4,2,6.3,3.5,7.6c1,0.9,1.5,1.5,1.5,2.4h2c0-1.8-1.1-2.9-2.2-3.9C9.4,18.9,8,17.5,8,14 c0-4.4,3.6-8,8-8s8,3.6,8,8c0,3.5-1.4,4.9-2.8,6.1c-1.1,1-2.2,2-2.2,3.9h2c0-0.9,0.5-1.5,1.5-2.4C24,20.3,26,18.4,26,14 C26,8.5,21.5,4,16,4z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Wc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),of||(of=n.createElement("path",{d:"M28 24v2H15.8164a2.983 2.983 0 00-5.6328 0H4V24H2v6H4V28h6.1836a2.983 2.983 0 005.6328 0H28v2h2V24zM13 7.5L13 16.499 13 16.499 21 12 13 7.5z"})),mf||(mf=n.createElement("path",{d:"M16,22A10,10,0,1,1,26,12,10.0113,10.0113,0,0,1,16,22ZM16,4a8,8,0,1,0,8,8A8.0092,8.0092,0,0,0,16,4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Uc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),vf||(vf=n.createElement("path",{d:"M7,30a5,5,0,1,1,5-5A5.0059,5.0059,0,0,1,7,30Zm0-8a3,3,0,1,0,3,3A3.0033,3.0033,0,0,0,7,22Z"})),ff||(ff=n.createElement("path",{d:"M24,26H14V24H24V17H8a2.0021,2.0021,0,0,1-2-2V8A2.0021,2.0021,0,0,1,8,6H18V8H8v7H24a2.0021,2.0021,0,0,1,2,2v7A2.0021,2.0021,0,0,1,24,26Z"})),uf||(uf=n.createElement("path",{d:"M28,12H22a2.0023,2.0023,0,0,1-2-2V4a2.0023,2.0023,0,0,1,2-2h6a2.0023,2.0023,0,0,1,2,2v6A2.0023,2.0023,0,0,1,28,12ZM22,4v6h6V4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ic);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),cf||(cf=n.createElement("path",{d:"M4 20L4 22 8.586 22 2 28.586 3.414 30 10 23.414 10 28 12 28 12 20 4 20zM28 12H22a2.0023 2.0023 0 01-2-2V4a2.0023 2.0023 0 012-2h6a2.0023 2.0023 0 012 2v6A2.0023 2.0023 0 0128 12zM22 4v6h6V4z"})),pf||(pf=n.createElement("path",{d:"M24,26H16V24h8V17H8a2.0021,2.0021,0,0,1-2-2V8A2.0021,2.0021,0,0,1,8,6H18V8H8v7H24a2.0021,2.0021,0,0,1,2,2v7A2.0021,2.0021,0,0,1,24,26Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Bc);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ef||(Ef=n.createElement("path",{d:"M5 25V15.8281l-3.5859 3.586L0 18l6-6 6 6-1.4141 1.4141L7 15.8281V25H19v2H7A2.0024 2.0024 0 015 25zM24 22h4a2.002 2.002 0 012 2v4a2.002 2.002 0 01-2 2H24a2.002 2.002 0 01-2-2V24A2.002 2.002 0 0124 22zm4 6V24H23.9985L24 28zM27 6v9.1719l3.5859-3.586L32 13l-6 6-6-6 1.4141-1.4141L25 15.1719V6H13V4H25A2.0024 2.0024 0 0127 6zM2 6H8V8H2zM2 2H10V4H2z"})),i)})).propTypes=ol;var Fc=["iconDescription","className"];function Xc(e){var t=e.iconDescription,i=e.className,s=B(e,Fc),l=Y();return n.createElement(gf,T({className:k()(i,"".concat(l,"--copy-btn")),"aria-label":t,title:t},s),n.createElement(Oc,{className:"".concat(l,"--snippet__icon")}))}Xc.propTypes={className:P().string,feedback:P().string,feedbackTimeout:P().number,iconDescription:P().string,onClick:P().func},Xc.defaultProps={iconDescription:"Copy to clipboard",feedback:"Copied!",feedbackTimeout:2e3,onClick:function(){}};var Cc=0;var qc,Hc,kc,Nc,Yc,Zc,Pc,Gc,jc,Kc,Qc,Jc,$c,ep,np,tp,ip,sp,lp,rp,ap,dp,_p,op,mp,vp,fp,up,cp,pp,Ep,hp,gp,wp,bp,xp,zp,Lp,Mp,yp,Rp,Sp,Ap,Dp,Vp,Tp,Wp,Up,Ip,Bp,Op,Fp,Xp,Cp,qp,Hp,kp,Np,Yp,Zp,Pp,Gp,jp,Kp,Qp,Jp,$p,eE,nE,tE,iE,sE,lE,rE,aE,dE,_E,oE,mE,vE,fE,uE,cE,pE,EE,hE,gE,wE,bE,xE,zE,LE,ME,yE,RE,SE,AE,DE,VE,TE,WE,UE,IE,BE,OE,FE,XE,CE,qE,HE,kE,NE,YE,ZE,PE,GE,jE,KE,QE,JE,$E,eh,nh,th,ih,sh,lh,rh,ah,dh,_h,oh,mh,vh,fh,uh,ch,ph,Eh,hh,gh,wh,bh,xh,zh,Lh,Mh,yh,Rh,Sh,Ah,Dh,Vh,Th,Wh,Uh,Ih,Bh,Oh,Fh,Xh,Ch,qh,Hh,kh,Nh,Yh,Zh,Ph,Gh,jh,Kh,Qh,Jh,$h,eg,ng,tg,ig,sg,lg,rg,ag,dg,_g,og,mg,vg,fg,ug,cg,pg,Eg,hg,gg,wg,bg,xg,zg,Lg,Mg,yg,Rg,Sg,Ag,Dg,Vg,Tg,Wg,Ug,Ig,Bg,Og,Fg,Xg=t(998),Cg=t.n(Xg),qg=["className","type","children","disabled","feedback","feedbackTimeout","onClick","ariaLabel","copyText","copyButtonDescription","light","showMoreText","showLessText","hideCopyButton","wrapText","maxCollapsedNumberOfRows","maxExpandedNumberOfRows","minCollapsedNumberOfRows","minExpandedNumberOfRows"],Hg=16;function kg(e){var t,i=e.className,s=e.type,l=e.children,r=e.disabled,a=e.feedback,d=e.feedbackTimeout,_=e.onClick,o=e.ariaLabel,m=e.copyText,v=e.copyButtonDescription,f=e.light,u=e.showMoreText,c=e.showLessText,p=e.hideCopyButton,E=e.wrapText,h=e.maxCollapsedNumberOfRows,g=void 0===h?15:h,w=e.maxExpandedNumberOfRows,b=void 0===w?0:w,x=e.minCollapsedNumberOfRows,z=void 0===x?3:x,L=e.minExpandedNumberOfRows,M=void 0===L?16:L,y=B(e,qg),R=X((0,n.useState)(!1),2),S=R[0],A=R[1],D=X((0,n.useState)(!1),2),W=D[0],U=D[1],I=(0,n.useRef)(function(){return Cc++,"".concat(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"id").concat(Cc)}()),O=I.current,F=(0,n.useRef)(),C=(0,n.useRef)(),q=(0,n.useRef)(),H=X((0,n.useState)(!1),2),N=H[0],Z=H[1],P=X((0,n.useState)(!1),2),G=P[0],j=P[1],K=(0,n.useCallback)((function(){return"single"===s?C:"multi"===s?F:void 0}),[s]),Q=Y(),J=(0,n.useCallback)((function(){var e=K().current,n=e.clientWidth,t=e.scrollLeft,i=e.scrollWidth;return{horizontalOverflow:i>n,codeClientWidth:n,codeScrollWidth:i,codeScrollLeft:t}}),[K]),$=(0,n.useCallback)((function(){if("inline"!==s&&("single"!==s||null!==C&&void 0!==C&&C.current)&&("multi"!==s||null!==F&&void 0!==F&&F.current)){var e=J(),n=e.horizontalOverflow,t=e.codeClientWidth,i=e.codeScrollWidth,l=e.codeScrollLeft;Z(n&&!!l),j(n&&l+t!==i)}}),[s,J]);bd({ref:K(),onResize:function(){if(null!==F&&void 0!==F&&F.current&&"multi"===s){var e=F.current.getBoundingClientRect().height;U(g>0&&(b<=0||b>g)&&e>g*Hg),S&&M>0&&e<=M*Hg&&A(!1)}(null!==F&&void 0!==F&&F.current&&"multi"===s||null!==C&&void 0!==C&&C.current&&"single"===s)&&$()}},[s,g,b,M,Hg]),(0,n.useEffect)((function(){$()}),[$]);var ee=function(e){var n;(m||null!==q&&void 0!==q&&q.current)&&Cg()(null!==m&&void 0!==m?m:null===q||void 0===q||null===(n=q.current)||void 0===n?void 0:n.innerText);_&&_(e)},ne=k()(i,"".concat(Q,"--snippet"),(V(t={},"".concat(Q,"--snippet--").concat(s),s),V(t,"".concat(Q,"--snippet--disabled"),"inline"!==s&&r),V(t,"".concat(Q,"--snippet--expand"),S),V(t,"".concat(Q,"--snippet--light"),f),V(t,"".concat(Q,"--snippet--no-copy"),p),V(t,"".concat(Q,"--snippet--wraptext"),E),t)),te=S?c:u;if("inline"===s)return p?n.createElement("span",{className:ne},n.createElement("code",{id:O,ref:q},l)):n.createElement(gf,T({},y,{onClick:ee,"aria-label":o,"aria-describedby":O,className:ne,feedback:a,feedbackTimeout:d}),n.createElement("code",{id:O,ref:q},l));var ie={};if("multi"===s){var se={};S?(b>0&&(se.maxHeight=b*Hg),M>0&&(se.minHeight=M*Hg)):(g>0&&(se.maxHeight=g*Hg),z>0&&(se.minHeight=z*Hg)),Object.keys(se).length&&(ie.style=se)}return n.createElement("div",T({},y,{className:ne}),n.createElement("div",T({ref:C,role:"single"===s?"textbox":null,tabIndex:"single"!==s||r?null:0,className:"".concat(Q,"--snippet-container"),"aria-label":o||"code-snippet",onScroll:"single"===s&&$||null},ie),n.createElement("pre",{ref:F,onScroll:"multi"===s&&$||null},n.createElement("code",{ref:q},l))),N&&n.createElement("div",{className:"".concat(Q,"--snippet__overflow-indicator--left")}),G&&n.createElement("div",{className:"".concat(Q,"--snippet__overflow-indicator--right")}),!p&&n.createElement(Xc,{disabled:r,onClick:ee,feedback:a,feedbackTimeout:d,iconDescription:v}),W&&n.createElement(Rd,{kind:"ghost",size:"field",className:"".concat(Q,"--snippet-btn--expand"),disabled:r,onClick:function(){return A(!S)}},n.createElement("span",{className:"".concat(Q,"--snippet-btn--text")},te),n.createElement(Sa,{"aria-label":te,className:"".concat(Q,"--icon-chevron--down ").concat(Q,"--snippet__icon"),name:"chevron--down",role:"img"})))}kg.propTypes={ariaLabel:P().string,children:P().node,className:P().string,copyButtonDescription:P().string,copyText:P().string,disabled:P().bool,feedback:P().string,feedbackTimeout:P().number,hideCopyButton:P().bool,light:P().bool,maxCollapsedNumberOfRows:P().number,maxExpandedNumberOfRows:P().number,minCollapsedNumberOfRows:P().number,minExpandedNumberOfRows:P().number,onClick:P().func,showLessText:P().string,showMoreText:P().string,type:P().oneOf(["single","inline","multi"]),wrapText:P().bool},kg.defaultProps={ariaLabel:"Copy to clipboard",type:"single",showMoreText:"Show more",showLessText:"Show less",wrapText:!1};var Ng=["children","size"],Yg=["children","size"],Zg=["children","size"],Pg=["children","size"],Gg=["children","size"],jg=["children","size"],Kg=["children","size"],Qg=["children","size"],Jg=["children","size"],$g=["children","size"],ew=["children","size"],nw=["children","size"],tw=["children","size"],iw=["children","size"],sw=["children","size"],lw=["children","size"],rw=["children","size"],aw=["children","size"],dw=["children","size"],_w=["children","size"],ow=["children","size"],mw=["children","size"],vw=["children","size"],fw=["children","size"],uw=["children","size"],cw=["children","size"],pw=["children","size"],Ew=["children","size"],hw=["children","size"],gw=["children","size"],ww=["children","size"],bw=["children","size"],xw=["children","size"],zw=["children","size"],Lw=["children","size"],Mw=["children","size"],yw=["children","size"],Rw=["children","size"],Sw=["children","size"],Aw=["children","size"],Dw=["children","size"],Vw=["children","size"],Tw=["children","size"],Ww=["children","size"],Uw=["children","size"],Iw=["children","size"],Bw=["children","size"],Ow=["children","size"],Fw=["children","size"],Xw=["children","size"],Cw=["children","size"],qw=["children","size"],Hw=["children","size"],kw=["children","size"],Nw=["children","size"],Yw=["children","size"],Zw=["children","size"],Pw=["children","size"],Gw=["children","size"],jw=["children","size"],Kw=["children","size"],Qw=["children","size"],Jw=["children","size"],$w=["children","size"],eb=["children","size"],nb=["children","size"],tb=["children","size"],ib=["children","size"],sb=["children","size"],lb=["children","size"],rb=["children","size"],ab=["children","size"],db=["children","size"],_b=["children","size"],ob=["children","size"],mb=["children","size"],vb=["children","size"],fb=["children","size"],ub=["children","size"],cb=["children","size"],pb=["children","size"],Eb=["children","size"],hb=["children","size"],gb=["children","size"],wb=["children","size"],bb=["children","size"],xb=["children","size"],zb=["children","size"],Lb=["children","size"],Mb=["children","size"],yb=["children","size"],Rb=["children","size"],Sb=["children","size"],Ab=["children","size"],Db=["children","size"],Vb=["children","size"],Tb=["children","size"],Wb=["children","size"],Ub=["children","size"],Ib=["children","size"],Bb=["children","size"],Ob=["children","size"],Fb=["children","size"],Xb=["children","size"],Cb=["children","size"],qb=["children","size"],Hb=["children","size"],kb=["children","size"],Nb=["children","size"],Yb=["children","size"],Zb=["children","size"],Pb=["children","size"],Gb=["children","size"],jb=["children","size"],Kb=["children","size"],Qb=["children","size"],Jb=["children","size"],$b=["children","size"],ex=["children","size"],nx=["children","size"],tx=["children","size"],ix=["children","size"],sx=["children","size"],lx=["children","size"],rx=["children","size"];n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ng);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),qc||(qc=n.createElement("path",{d:"M16 31H14v-.228a3.0135 3.0135 0 00-1.9468-2.8091L8.5215 26.6384A3.9034 3.9034 0 016 23H8a1.8946 1.8946 0 001.2236 1.7659L12.7554 26.09A5.0226 5.0226 0 0116 30.772zM30 31H28v-.228a3.0135 3.0135 0 00-1.9468-2.8091l-3.5317-1.3245A3.9034 3.9034 0 0120 23h2a1.8946 1.8946 0 001.2236 1.7659L26.7554 26.09A5.0226 5.0226 0 0130 30.772zM11 13H17V15H11z"})),Hc||(Hc=n.createElement("path",{d:"M23.4409,8,22.1687,3.45A2.009,2.009,0,0,0,20.2456,2H7.7544A2.0089,2.0089,0,0,0,5.8313,3.4507L4.5315,8H2v2H4v7a2.0025,2.0025,0,0,0,2,2v2H8V19H20v2h2V19a2.0025,2.0025,0,0,0,2-2V10h2V8ZM7.7544,4H20.2458l1.4285,5H6.3257ZM22,13H20v2h2v2H6V15H8V13H6V11H22Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Yg);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),kc||(kc=n.createElement("path",{d:"M12 30H4a2.0023 2.0023 0 01-2-2V24a2.0023 2.0023 0 012-2h8a2.0023 2.0023 0 012 2v4A2.0023 2.0023 0 0112 30zM4 24v4h8V24zM28 20H12a2.0023 2.0023 0 01-2-2V14a2.0023 2.0023 0 012-2H28a2.0023 2.0023 0 012 2v4A2.0023 2.0023 0 0128 20zM12 14v4H28V14zM16 10H4A2.0023 2.0023 0 012 8V4A2.0023 2.0023 0 014 2H16a2.0023 2.0023 0 012 2V8A2.0023 2.0023 0 0116 10zM4 4V8H16V4z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Zg);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Nc||(Nc=n.createElement("path",{d:"M6.34 19H17.65V21H6.34z",transform:"rotate(-45 11.995 20.002)"})),Yc||(Yc=n.createElement("path",{d:"M17,30a1,1,0,0,1-.37-.07,1,1,0,0,1-.62-.79l-1-7,2-.28.75,5.27L21,24.52V17a1,1,0,0,1,.29-.71l4.07-4.07A8.94,8.94,0,0,0,28,5.86V4H26.14a8.94,8.94,0,0,0-6.36,2.64l-4.07,4.07A1,1,0,0,1,15,11H7.48L4.87,14.26l5.27.75-.28,2-7-1a1,1,0,0,1-.79-.62,1,1,0,0,1,.15-1l4-5A1,1,0,0,1,7,9h7.59l3.77-3.78A10.92,10.92,0,0,1,26.14,2H28a2,2,0,0,1,2,2V5.86a10.92,10.92,0,0,1-3.22,7.78L23,17.41V25a1,1,0,0,1-.38.78l-5,4A1,1,0,0,1,17,30Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Pg);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Zc||(Zc=n.createElement("path",{d:"M17.91 26.82l.35 2a12.9 12.9 0 004.24-1.54l-1-1.73A10.88 10.88 0 0117.91 26.82zM24.42 23.07L26 24.35a13 13 0 002.24-3.91l-1.87-.68A11 11 0 0124.42 23.07zM9.5 27.25a12.9 12.9 0 004.24 1.54l.35-2a10.88 10.88 0 01-3.59-1.3zM5.67 19.76l-1.87.68A13 13 0 006 24.35l.32-.26 1.22-1h0a11 11 0 01-1.91-3.31zM29 16a12.85 12.85 0 00-.8-4.44l-1.87.68A11.18 11.18 0 0127 16zM26 7.65a13 13 0 00-20 0V4H4v8h8V10H6.81A11 11 0 0124.42 8.93z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Gg);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Pc||(Pc=n.createElement("path",{d:"M14.0913 26.8235l-.3467 1.968a12.8956 12.8956 0 01-4.24-1.5418l1-1.7307A10.9086 10.9086 0 0014.0913 26.8235zM7.5767 23.0682L6.0449 24.3533a12.9811 12.9811 0 01-2.25-3.9112l1.8775-.6834A10.9808 10.9808 0 007.5767 23.0682zM22.4951 27.25a12.8956 12.8956 0 01-4.24 1.5418l-.3467-1.968a10.9086 10.9086 0 003.5869-1.3045zM26.3271 19.7587l1.8775.6834a12.9811 12.9811 0 01-2.2495 3.9112l-.3115-.2614-1.22-1.0237h0a10.9822 10.9822 0 001.9038-3.3093zM13.6616 5.2559c-.1592.0346-.3144.08-.4712.1215-.2131.0562-.4258.1138-.6335.1822-.1643.0547-.325.1167-.4859.1782-.1926.0742-.3835.1509-.57.2349-.1611.0727-.3193.15-.4763.23q-.2677.1363-.5262.2867c-.153.0893-.3046.18-.4531.2758-.1679.1089-.3308.2242-.4922.3413-.1406.1026-.2817.2037-.417.3125-.1616.1294-.3156.2676-.47.4063-.1225.11-.2478.2168-.3652.332-.1668.1636-.3223.3379-.4785.5117A10.9438 10.9438 0 005 16H3A12.9363 12.9363 0 016.05 7.65l-.0047-.0039c.0918-.1094.197-.2061.2925-.3125.1841-.2051.3672-.41.5635-.603.1382-.1358.2856-.2613.43-.3907.1831-.1645.3657-.3286.5581-.4824.1592-.1279.3244-.2466.4895-.3667.1921-.14.3855-.2768.5854-.4062.1743-.1128.3523-.2188.5322-.3238q.3081-.1786.6253-.3408c.1846-.0942.37-.1846.56-.27.2224-.1.449-.1914.678-.2793.1894-.0723.3777-.1455.5713-.209.2463-.0815.498-.1494.7507-.2163.1848-.0493.3674-.1025.5554-.1431.29-.0634.5865-.1074.8833-.1508.159-.023.3145-.0552.4754-.0728A12.9331 12.9331 0 0126 7.7031V4h2v8H20V10h5.1885A10.961 10.961 0 0016 5a11.1114 11.1114 0 00-1.189.0669c-.1362.0146-.268.042-.4026.0615C14.1575 5.165 13.907 5.2026 13.6616 5.2559z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,jg);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Gc||(Gc=n.createElement("path",{d:"M25.95,7.65l.0047-.0039c-.0918-.1094-.197-.2061-.2925-.3125-.1841-.2051-.3672-.41-.5635-.603-.1382-.1358-.2856-.2613-.43-.3907-.1831-.1645-.3657-.3286-.5581-.4824-.1592-.1279-.3244-.2466-.4895-.3667-.1921-.14-.3855-.2768-.5854-.4062-.1743-.1128-.3523-.2188-.5322-.3238q-.3081-.1786-.6253-.3408c-.1846-.0942-.37-.1846-.56-.27-.2224-.1-.449-.1914-.678-.2793-.1894-.0723-.3777-.1455-.5713-.209-.2463-.0815-.498-.1494-.7507-.2163-.1848-.0493-.3674-.1025-.5554-.1431-.29-.0634-.5865-.1074-.8833-.1508-.159-.023-.3145-.0552-.4754-.0728A12.9331,12.9331,0,0,0,6,7.7031V4H4v8h8V10H6.8115A10.961,10.961,0,0,1,16,5a11.1114,11.1114,0,0,1,1.189.0669c.1362.0146.268.042.4026.0615.2509.0366.5014.0742.7468.1275.1592.0346.3144.08.4712.1215.2131.0562.4258.1138.6335.1822.1643.0547.325.1167.4859.1782.1926.0742.3835.1509.5705.2349.1611.0727.3193.15.4763.23q.2677.1363.5262.2867c.153.0893.3046.18.4531.2758.1679.1089.3308.2242.4922.3413.1406.1026.2817.2037.417.3125.1616.1294.3156.2676.47.4063.1225.11.2478.2168.3652.332.1668.1636.3223.3379.4785.5117A10.9928,10.9928,0,1,1,5,16H3A13,13,0,1,0,25.95,7.65Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Kg);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),jc||(jc=n.createElement("path",{d:"M28 30H16a2.0023 2.0023 0 01-2-2V16a2.0023 2.0023 0 012-2H28a2.0023 2.0023 0 012 2V28A2.0023 2.0023 0 0128 30zM16 16V28H28.0012L28 16zM15 2L13.59 3.41 16.17 6H11a7.0078 7.0078 0 00-7 7v5H6V13a5.0057 5.0057 0 015-5h5.17l-2.58 2.59L15 12l5-5z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Qg);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Kc||(Kc=n.createElement("path",{d:"M16 30H4a2.0023 2.0023 0 01-2-2V16a2.0023 2.0023 0 012-2H16a2.0023 2.0023 0 012 2V28A2.0023 2.0023 0 0116 30zM4 16V28H16.0012L16 16zM30 15l-1.41-1.41L26 16.17V11a7.0078 7.0078 0 00-7-7H14V6h5a5.0057 5.0057 0 015 5v5.17l-2.59-2.58L20 15l5 5z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Jg);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Qc||(Qc=n.createElement("path",{d:"M16 30H4a2.0023 2.0023 0 01-2-2V16a2.0023 2.0023 0 012-2H16a2.0023 2.0023 0 012 2V28A2.0023 2.0023 0 0116 30zM30 15l-1.41-1.41L26 16.17V11a7.0078 7.0078 0 00-7-7H14V6h5a5.0057 5.0057 0 015 5v5.17l-2.59-2.58L20 15l5 5z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,$g);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Jc||(Jc=n.createElement("path",{d:"M28 30H16a2.0023 2.0023 0 01-2-2V16a2.0023 2.0023 0 012-2H28a2.0023 2.0023 0 012 2V28A2.0023 2.0023 0 0128 30zM15 2L13.59 3.41 16.17 6H11a7.0078 7.0078 0 00-7 7v5H6V13a5.0057 5.0057 0 015-5h5.17l-2.58 2.59L15 12l5-5z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ew);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),$c||($c=n.createElement("path",{d:"M2 28V16a2.0023 2.0023 0 012-2H16a2.0023 2.0023 0 012 2V28a2.0023 2.0023 0 01-2 2H4A2.0023 2.0023 0 012 28zM4 16L3.9988 28H16V16zM17 2l1.41 1.41L15.83 6H21a7.0078 7.0078 0 017 7v5H26V13a5.0057 5.0057 0 00-5-5H15.83l2.58 2.59L17 12 12 7z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,nw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ep||(ep=n.createElement("path",{d:"M14 28V16a2.0023 2.0023 0 012-2H28a2.0023 2.0023 0 012 2V28a2.0023 2.0023 0 01-2 2H16A2.0023 2.0023 0 0114 28zm2-12l-.0012 12H28V16zM2 15l1.41-1.41L6 16.17V11a7.0078 7.0078 0 017-7h5V6H13a5.0057 5.0057 0 00-5 5v5.17l2.59-2.58L12 15 7 20z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,tw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),np||(np=n.createElement("path",{d:"M14 28V16a2.0023 2.0023 0 012-2H28a2.0023 2.0023 0 012 2V28a2.0023 2.0023 0 01-2 2H16A2.0023 2.0023 0 0114 28zM2 15l1.41-1.41L6 16.17V11a7.0078 7.0078 0 017-7h5V6H13a5.0057 5.0057 0 00-5 5v5.17l2.59-2.58L12 15 7 20z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,iw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),tp||(tp=n.createElement("path",{d:"M2 28V16a2.0023 2.0023 0 012-2H16a2.0023 2.0023 0 012 2V28a2.0023 2.0023 0 01-2 2H4A2.0023 2.0023 0 012 28zM17 2l1.41 1.41L15.83 6H21a7.0078 7.0078 0 017 7v5H26V13a5.0057 5.0057 0 00-5-5H15.83l2.58 2.59L17 12 12 7z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,sw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ip||(ip=n.createElement("path",{d:"M21 7L16 2 11 7 12.409 8.419 15 5.847 15 13 17 13 17 5.794 19.591 8.419 21 7zM21 25L16 30 11 25 12.409 23.581 15 26.153 15 19 17 19 17 26.206 19.591 23.581 21 25zM24 11L19 16 24 21 25.419 19.591 22.847 17 30 17 30 15 22.794 15 25.419 12.409 24 11zM8 11L13 16 8 21 6.581 19.591 9.153 17 2 17 2 15 9.206 15 6.581 12.409 8 11z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,lw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),sp||(sp=n.createElement("path",{d:"M21 25L16 30 11 25 12.409 23.581 15 26.153 15 19 17 19 17 26.206 19.591 23.581 21 25zM24 11L19 16 24 21 25.419 19.591 22.847 17 30 17 30 15 22.794 15 25.419 12.409 24 11zM8 11L13 16 8 21 6.581 19.591 9.153 17 2 17 2 15 9.206 15 6.581 12.409 8 11zM12.4289 5.8227v1.63a1.1269 1.1269 0 01-.6767 1.026l-1.39.5967A1.1218 1.1218 0 019.14 8.8424L7.3208 7.0233a1.1165 1.1165 0 01.0125-1.579l.0348-.0328c7.393-6.527 14.6913-2.0374 17.2127-.0473a1.1166 1.1166 0 01.1746 1.5693 1.1011 1.1011 0 01-.0873.0971L22.9108 8.7878a1.1114 1.1114 0 01-1.2225.2329l-1.39-.5967a1.1112 1.1112 0 01-.68-1.0223v-1.63S15.9726 3.0648 12.4289 5.8227z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,rw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),lp||(lp=n.createElement("circle",{cx:"16",cy:"13.5",r:"1.5"})),rp||(rp=n.createElement("path",{d:"M19.5356,10.4648a5,5,0,0,0-7.0717,0L11.05,9.0508a6.9992,6.9992,0,0,1,9.9,0Z"})),ap||(ap=n.createElement("path",{d:"M23.0713 6.929a10 10 0 00-14.1426 0L7.5146 5.5144a12.0011 12.0011 0 0116.9708 0zM21 25L16 30 11 25 12.409 23.581 15 26.153 15 19 17 19 17 26.206 19.591 23.581 21 25zM24 11L19 16 24 21 25.419 19.591 22.847 17 30 17 30 15 22.794 15 25.419 12.409 24 11zM8 11L13 16 8 21 6.581 19.591 9.153 17 2 17 2 15 9.206 15 6.581 12.409 8 11z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,aw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),dp||(dp=n.createElement("path",{d:"M4 24H28V26H4zM26 18H6V14H26v4m2 0V14a2 2 0 00-2-2H6a2 2 0 00-2 2v4a2 2 0 002 2H26a2 2 0 002-2zM4 6H28V8H4z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,dw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),_p||(_p=n.createElement("path",{d:"M26 20H6a2 2 0 00-2 2v4a2 2 0 002 2H26a2 2 0 002-2V22A2 2 0 0026 20zm0 6H6V22H26zM17 7.828L19.586 10.414 21 9 16 4 11 9 12.414 10.414 15 7.828 15 14 4 14 4 16 28 16 28 14 17 14 17 7.828z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,_w);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),op||(op=n.createElement("path",{d:"M24 30H4a2.0021 2.0021 0 01-2-2V22a2.0021 2.0021 0 012-2H24a2.0021 2.0021 0 012 2v6A2.0021 2.0021 0 0124 30zM4 22H3.9985L4 28H24V22zM30 3.41L28.59 2 25 5.59 21.41 2 20 3.41 23.59 7 20 10.59 21.41 12 25 8.41 28.59 12 30 10.59 26.41 7 30 3.41z"})),mp||(mp=n.createElement("path",{d:"M4,14V8H18V6H4A2.0023,2.0023,0,0,0,2,8v6a2.0023,2.0023,0,0,0,2,2H26V14Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ow);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),vp||(vp=n.createElement("path",{d:"M4 18L15 18 15 24.172 12.414 21.586 11 23 16 28 21 23 19.586 21.586 17 24.172 17 18 28 18 28 16 4 16 4 18zM26 4H6A2 2 0 004 6v4a2 2 0 002 2H26a2 2 0 002-2V6A2 2 0 0026 4zm0 6H6V6H26z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,mw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),fp||(fp=n.createElement("path",{d:"M28 12H10a2.0021 2.0021 0 01-2-2V4a2.0021 2.0021 0 012-2H28a2.0021 2.0021 0 012 2v6A2.0021 2.0021 0 0128 12zM10 4v6H28V4zM28 30H10a2.0021 2.0021 0 01-2-2V22a2.0021 2.0021 0 012-2H28a2.0021 2.0021 0 012 2v6A2.0021 2.0021 0 0128 30zM10 22v6H28V22zM9 16L3.414 10.414 2 11.828 6.172 16 2 20.172 3.414 21.586 9 16z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,vw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),up||(up=n.createElement("path",{d:"M8 18c-3.3 0-6 2.7-6 6s2.7 6 6 6 6-2.7 6-6C14 20.7 11.3 18 8 18zM8 28c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4C12 26.2 10.2 28 8 28zM30 24h-2C28 13 19 4 8 4V2C20.1 2 30 11.9 30 24z"})),cp||(cp=n.createElement("path",{d:"M22,24h-2c0-6.6-5.4-12-12-12v-2C15.7,10,22,16.3,22,24z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,fw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),pp||(pp=n.createElement("path",{d:"M10 16H22V18H10zM10 10H22V12H10z"})),Ep||(Ep=n.createElement("path",{d:"M16,30,9.8242,26.7071A10.9815,10.9815,0,0,1,4,17V4A2.0022,2.0022,0,0,1,6,2H26a2.0022,2.0022,0,0,1,2,2V17a10.9815,10.9815,0,0,1-5.8242,9.7069ZM6,4V17a8.9852,8.9852,0,0,0,4.7656,7.9423L16,27.7333l5.2344-2.791A8.9852,8.9852,0,0,0,26,17V4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,uw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),hp||(hp=n.createElement("path",{d:"M30 24a6 6 0 10-6 6A6.0066 6.0066 0 0030 24zm-2 0a3.9521 3.9521 0 01-.5669 2.019L21.981 20.5669A3.9529 3.9529 0 0124 20 4.0045 4.0045 0 0128 24zm-8 0a3.9521 3.9521 0 01.5669-2.019l5.4521 5.4521A3.9529 3.9529 0 0124 28 4.0045 4.0045 0 0120 24zM8 16H18V18H8zM8 10H20V12H8z"})),gp||(gp=n.createElement("path",{d:"M14,27.7334l-5.2344-2.791A8.9858,8.9858,0,0,1,4,17V4H24l0,11h2L26,4a2.0023,2.0023,0,0,0-2-2H4A2.0023,2.0023,0,0,0,2,4V17a10.9814,10.9814,0,0,0,5.8242,9.707L14,30Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,cw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),wp||(wp=n.createElement("path",{d:"M29.707 19.293l-3-3a.9994.9994 0 00-1.414 0L16 25.5859V30h4.4141l9.2929-9.293A.9994.9994 0 0029.707 19.293zM19.5859 28H18V26.4141l5-5L24.5859 23zM26 21.5859L24.4141 20 26 18.4141 27.5859 20zM8 16H18V18H8zM8 10H20V12H8z"})),bp||(bp=n.createElement("path",{d:"M26,4a2.0023,2.0023,0,0,0-2-2H4A2.0023,2.0023,0,0,0,2,4V17a10.9814,10.9814,0,0,0,5.8242,9.707L13,29.4668V27.2L8.7656,24.9424A8.9858,8.9858,0,0,1,4,17V4H24v9h2Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,pw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),xp||(xp=n.createElement("path",{fill:"none",d:"M9 16H23V18H9z","data-icon-path":"inner-path"})),zp||(zp=n.createElement("path",{fill:"none",d:"M9 10H23V12H9z"})),Lp||(Lp=n.createElement("path",{d:"M26,2H6A2.0023,2.0023,0,0,0,4,4V17a10.9814,10.9814,0,0,0,5.8242,9.707L16,30l6.1758-3.293A10.9814,10.9814,0,0,0,28,17V4A2.0023,2.0023,0,0,0,26,2ZM23,18H9V16H23Zm0-6H9V10H23Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ew);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Mp||(Mp=n.createElement("path",{d:"M23,30a7,7,0,1,1,7-7A7.0078,7.0078,0,0,1,23,30Zm0-12a5,5,0,1,0,5,5A5.0055,5.0055,0,0,0,23,18Z"})),yp||(yp=n.createElement("path",{d:"M26 24.586L24 22.586 24 20 22 20 22 23.414 24.586 26 26 24.586zM8 16H14V18H8zM8 10H20V12H8z"})),Rp||(Rp=n.createElement("path",{d:"M26,4a2.0023,2.0023,0,0,0-2-2H4A2.0023,2.0023,0,0,0,2,4V17a10.9814,10.9814,0,0,0,5.8242,9.707L13,29.4668V27.2L8.7656,24.9424A8.9858,8.9858,0,0,1,4,17V4H24v9h2Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,hw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Sp||(Sp=n.createElement("path",{d:"M29,10H3a1,1,0,0,0-1,1V21a1,1,0,0,0,1,1H29a1,1,0,0,0,1-1V11A1,1,0,0,0,29,10ZM28,20H4V12H8v4h2V12h5v4h2V12h5v4h2V12h4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,gw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ap||(Ap=n.createElement("path",{d:"M29.41,21.67,10.34,2.58a2,2,0,0,0-2.83,0L2.59,7.51a2,2,0,0,0,0,2.82L21.66,29.42a2,2,0,0,0,1.42.58,2,2,0,0,0,1.41-.58l4.92-4.93A2,2,0,0,0,29.41,21.67ZM23.08,28,4,8.92,8.92,4l3.79,3.79L10.46,10l1.41,1.41L14.12,9.2l4.13,4.13L16,15.58,17.42,17l2.25-2.25,4.13,4.13-2.25,2.25L23,22.54l2.25-2.25L28,23.08Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ww);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Dp||(Dp=n.createElement("path",{d:"M21,16a6,6,0,1,1-6,6,6,6,0,0,1,6-6m0-2a8,8,0,1,0,8,8,8,8,0,0,0-8-8Z"})),Vp||(Vp=n.createElement("path",{d:"M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2h4V26H6V12H28V6A2,2,0,0,0,26,4ZM6,10V6H26v4Z"})),Tp||(Tp=n.createElement("path",{d:"M19 19L19 25 24 22 19 19z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,bw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Wp||(Wp=n.createElement("path",{d:"M18,23H12V21h6V17H14a2,2,0,0,1-2-2V11a2,2,0,0,1,2-2h6v2H14v4h4a2,2,0,0,1,2,2v4A2,2,0,0,1,18,23Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,xw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Up||(Up=n.createElement("path",{d:"M24 9L22 9 22 7 20 7 20 9 18 9 18 11 20 11 20 17 22 17 22 11 24 11 24 9zM14 23H8V21h6V17H10a2 2 0 01-2-2V11a2 2 0 012-2h6v2H10v4h4a2 2 0 012 2v4A2 2 0 0114 23z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,zw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ip||(Ip=n.createElement("path",{d:"M24.7808,26,25.97,21.2422A1,1,0,0,0,25,20H20V17h5a1,1,0,0,0,.9082-1.4189l-6-13a1.0006,1.0006,0,0,0-1.7021-.19L8.2075,15.3906A1,1,0,0,0,9,17h9v3H7a1,1,0,0,0-.97,1.2422L7.2192,26H2v2H30V26ZM20,7.5527,23.437,15H20ZM11.0308,15,18,5.94V15ZM22.7192,26H9.2808l-1-4H23.7192Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Lw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Bp||(Bp=n.createElement("path",{d:"M6.9692,25H9.0308l-.75-3H23.7192l-.75,3h2.0616l.9394-3.7578A1,1,0,0,0,25,20H20V17h5a1,1,0,0,0,.9082-1.4189l-6-13a1.0006,1.0006,0,0,0-1.7021-.19L8.2075,15.3906A1,1,0,0,0,9,17h9v3H7a1,1,0,0,0-.97,1.2422ZM20,7.5527,23.437,15H20ZM11.0308,15,18,5.94V15Z"})),Op||(Op=n.createElement("path",{d:"M26.9058,25.751A2.998,2.998,0,0,1,24,28a3.4376,3.4376,0,0,1-3.0513-2.3164A1.007,1.007,0,0,0,20,25a.9894.9894,0,0,0-.9468.6787A3.44,3.44,0,0,1,16,28a3.4376,3.4376,0,0,1-3.0513-2.3164A1.007,1.007,0,0,0,12,25a.971.971,0,0,0-.9468.6787A3.44,3.44,0,0,1,8,28a2.998,2.998,0,0,1-2.9058-2.249l-1.9365.498A4.9965,4.9965,0,0,0,8,30a4.9316,4.9316,0,0,0,4-1.9873,5.0192,5.0192,0,0,0,8,0A4.9316,4.9316,0,0,0,24,30a4.9965,4.9965,0,0,0,4.8423-3.751Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Mw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Fp||(Fp=n.createElement("path",{d:"M28,2V8.0439c-1.9634.1968-6.3162,1.2325-10.5637,6.2764-.198-.2768-.3982-.5464-.5882-.8506C11.9736,5.6714,6.3191,4.2759,4,4.042V2H2V30H4V26.0464a14.8661,14.8661,0,0,0,9.9185-3.96C18.47,27.46,25.2363,28.0381,27.9341,28.0381c.0244,0,.0422-.001.0659-.001V30h2V2Zm0,8.0552v9.99a12.8834,12.8834,0,0,1-9.2756-4.1328C22.5032,11.2666,26.2915,10.26,28,10.0552ZM15.1519,14.53c.3242.5185.663.9907,1.0078,1.4409-.3384.4741-.6753.9707-1.0078,1.5029a16.1346,16.1346,0,0,1-1.0313,1.4531c-.0825-.1372-.1675-.27-.2466-.4126C9.3279,10.3315,5.7871,8.4438,4,8.0684V6.0508C5.9932,6.2905,10.8228,7.6035,15.1519,14.53ZM4,24.0488V10.1406c1.3254.4644,4.2034,2.2847,8.126,9.3448.1894.3413.396.6523.6.9667A12.8784,12.8784,0,0,1,4,24.0488Zm11.3179-3.4209a18.0563,18.0563,0,0,0,1.53-2.0937c.2212-.354.4454-.67.6687-.9951A14.8686,14.8686,0,0,0,28,22.0425v3.9863C25.67,26.019,19.374,25.5088,15.3179,20.6279Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,yw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Xp||(Xp=n.createElement("path",{d:"M30,2H2V16H8.1113a7.0359,7.0359,0,0,1,3.13.7393L15.7637,19l-4.522,2.2607A7.0359,7.0359,0,0,1,8.1113,22H2v8H9.2231a9.0446,9.0446,0,0,0,4.0249-.95L21.87,24.7393A7.0359,7.0359,0,0,1,25,24h5V14H25a7.0359,7.0359,0,0,1-3.13-.7393L15.3481,10H30ZM8,4H24V8H8ZM4,4H6V14H4ZM4,24H6v4H4Zm16.9751-1.05-8.6216,4.3105A7.0359,7.0359,0,0,1,9.2231,28H8V24h.1113a9.0446,9.0446,0,0,0,4.0249-.95L18,20.1182l1.8638.9316a9.0446,9.0446,0,0,0,4.0249.95H24v.0586A9.0515,9.0515,0,0,0,20.9751,22.95ZM28,22H26V16h2ZM12.3535,10.7393l8.6216,4.31A9.0515,9.0515,0,0,0,24,15.9414V20h-.1113a7.0359,7.0359,0,0,1-3.13-.7393l-8.6221-4.31A9.0446,9.0446,0,0,0,8.1113,14H8V10H9.2231A7.0359,7.0359,0,0,1,12.3535,10.7393ZM28,8H26V4h2Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Rw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Cp||(Cp=n.createElement("path",{d:"M22.9141,16.5l2.7929-2.793a.9994.9994,0,0,0,0-1.414L23.4141,10,25.5,7.9141,28.5859,11,30,9.5859,22.4141,2,21,3.4141,24.0859,6.5,22,8.5859,19.707,6.293a.9994.9994,0,0,0-1.414,0L15.5,9.0859,8.707,2.293a.9994.9994,0,0,0-1.414,0l-5,5a.9994.9994,0,0,0,0,1.414L9.0859,15.5,6.293,18.293a.9994.9994,0,0,0,0,1.414L8.5859,22,6.5,24.0859,3.4141,21,2,22.4141,9.5859,30,11,28.5859,7.9141,25.5,10,23.4141l2.293,2.2929a.9995.9995,0,0,0,1.414,0L16.5,22.9141l6.793,6.7929a.9995.9995,0,0,0,1.414,0l5-5a.9994.9994,0,0,0,0-1.414ZM4.4141,8,8,4.4141,10.0859,6.5,6.5,10.0859Zm3.5,3.5L11.5,7.9141,14.0859,10.5,10.5,14.0859ZM13,23.5859,8.4141,19,19,8.4141,23.5859,13ZM17.9141,21.5,21.5,17.9141,24.0859,20.5,20.5,24.0859ZM24,27.5859,21.9141,25.5,25.5,21.9141,27.5859,24Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Sw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),qp||(qp=n.createElement("path",{d:"M30,14H28A10.0113,10.0113,0,0,0,18,4V2A12.0137,12.0137,0,0,1,30,14Z"})),Hp||(Hp=n.createElement("path",{d:"M26 14H24a6.0067 6.0067 0 00-6-6V6A8.0092 8.0092 0 0126 14zM16 28V24.96a9.9124 9.9124 0 007.3179-2.208 1.8482 1.8482 0 00.6777-1.3344 1.8 1.8 0 00-.5239-1.36L18.4141 15 21 12.4141 19.5859 11 17 13.5859 11.9419 8.5273a1.8145 1.8145 0 00-1.36-.5229 1.845 1.845 0 00-1.3339.6782 9.9566 9.9566 0 00-.5127 11.95L6.2793 28H2v2H30V28zM10.68 10.0938L21.9058 21.32A8.0011 8.0011 0 0110.68 10.0938zM14 28H8.3875l1.8757-5.627A9.9894 9.9894 0 0014 24.5435z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Aw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),kp||(kp=n.createElement("path",{d:"M26.5 12H19a4 4 0 010-8h.0835A4.7864 4.7864 0 0123 2a4.9816 4.9816 0 014.6543 3.2034A3.4667 3.4667 0 0130 8.5 3.5041 3.5041 0 0126.5 12zM19 6a2 2 0 000 4h7.5A1.5017 1.5017 0 0028 8.5a1.4855 1.4855 0 00-1.2778-1.4739L26.061 6.927l-.1616-.6487a2.9568 2.9568 0 00-5.4873-.7121L20.1143 6zM13 28V24.8882a7.9363 7.9363 0 004.707-2.2818.9995.9995 0 000-1.414L13.4644 16.95 16 14.4141 14.5859 13 12.05 15.5356 7.8076 11.293a.9994.9994 0 00-1.414 0 7.9993 7.9993 0 000 11.3134c.1621.1622.3327.3125.5058.459L4.4321 28H2v2H30V28zm-2 0H6.6685L8.59 24.1567A7.8927 7.8927 0 0011 24.873zM7.8076 21.1924a6.0036 6.0036 0 01-.6489-7.72l8.3686 8.3681a6.0026 6.0026 0 01-7.72-.6484z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Dw);return 16===l||"16"===l||"16px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),Np||(Np=n.createElement("path",{d:"M13.9,4.6l-2.5-2.5C11.3,2.1,11.1,2,11,2H3C2.4,2,2,2.4,2,3v10c0,0.6,0.4,1,1,1h10c0.6,0,1-0.4,1-1V5 C14,4.9,13.9,4.7,13.9,4.6z M6,3h4v2H6V3z M10,13H6V9h4V13z M11,13V9c0-0.6-0.4-1-1-1H6C5.4,8,5,8.4,5,9v4H3V3h2v2c0,0.6,0.4,1,1,1 h4c0.6,0,1-0.4,1-1V3.2l2,2V13H11z"})),i):20===l||"20"===l||"20px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor"},r),Yp||(Yp=n.createElement("path",{d:"M17.8,5.5l-3.3-3.3C14.3,2.1,14.2,2,14,2H3.3C2.6,2,2,2.6,2,3.3v13.3C2,17.4,2.6,18,3.3,18h13.3c0.7,0,1.4-0.5,1.4-1.2V6.1 C18,5.7,17.9,5.7,17.8,5.5z M7.3,3.3h5.3v3.3H7.3V3.3z M12.7,16.7H7.3v-5.3h5.3L12.7,16.7L12.7,16.7z M14,16.7v-5.3 c0-0.7-0.6-1.3-1.3-1.3H7.3C6.6,10,6,10.6,6,11.3v5.3H3.3V3.3H6v3.3C6,7.4,6.6,8,7.3,8h5.3C13.4,8,14,7.4,14,6.7v-3l2.7,2.7v10.4 L14,16.7L14,16.7z"})),i):24===l||"24"===l||"24px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor"},r),Zp||(Zp=n.createElement("path",{d:"M20.8,7L17,3.2C16.9,3.1,16.7,3,16.5,3h-12C3.7,3,3,3.7,3,4.5v15C3,20.3,3.7,21,4.5,21h15c0.8,0,1.5-0.7,1.5-1.5v-12 C21,7.3,20.9,7.1,20.8,7z M9,4.5h6v3H9V4.5z M15,19.5H9v-6h6V19.5z M16.5,19.5v-6c0-0.8-0.7-1.5-1.5-1.5H9c-0.8,0-1.5,0.7-1.5,1.5v6 h-3v-15h3v3C7.5,8.3,8.2,9,9,9h6c0.8,0,1.5-0.7,1.5-1.5V4.8l3,3v11.7H16.5z"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Pp||(Pp=n.createElement("path",{d:"M27.71,9.29l-5-5A1,1,0,0,0,22,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V10A1,1,0,0,0,27.71,9.29ZM12,6h8v4H12Zm8,20H12V18h8Zm2,0V18a2,2,0,0,0-2-2H12a2,2,0,0,0-2,2v8H6V6h4v4a2,2,0,0,0,2,2h8a2,2,0,0,0,2-2V6.41l4,4V26Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Vw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Gp||(Gp=n.createElement("path",{d:"M21.56,15.1l-3.48-4.35A2,2,0,0,0,16.52,10H4a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H20a2,2,0,0,0,2-2V16.35A2,2,0,0,0,21.56,15.1ZM9,12h6v3H9Zm6,16H9V22h6Zm2,0V22a2,2,0,0,0-2-2H9a2,2,0,0,0-2,2v6H4V12H7v3a2,2,0,0,0,2,2h6a2,2,0,0,0,2-2V12.6l3,3.75V28Z"})),jp||(jp=n.createElement("path",{d:"M28,20H25V18h3V4H8V7H6V4A2,2,0,0,1,8,2H28a2,2,0,0,1,2,2V18A2,2,0,0,1,28,20Z"})),Kp||(Kp=n.createElement("path",{d:"M20 6H26V8H20zM22 10H26V12H22z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Tw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Qp||(Qp=n.createElement("path",{d:"M21.56,15.1l-3.48-4.35A2,2,0,0,0,16.52,10H4a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H20a2,2,0,0,0,2-2V16.35A2,2,0,0,0,21.56,15.1ZM9,12h6v3H9Zm6,16H9V22h6Zm2,0V22a2,2,0,0,0-2-2H9a2,2,0,0,0-2,2v6H4V12H7v3a2,2,0,0,0,2,2h6a2,2,0,0,0,2-2V12.6l3,3.75V28Z"})),Jp||(Jp=n.createElement("path",{d:"M28,20H25V18h3V4H14V7H12V4a2,2,0,0,1,2-2H28a2,2,0,0,1,2,2V18A2,2,0,0,1,28,20Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ww);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),$p||($p=n.createElement("path",{d:"M26,20l1.4272,1.9028L23,26.9629l-4.4272-5.06L20,20h6m1-2H19l-3,4,7,8,7-8-3-4Z"})),eE||(eE=n.createElement("path",{d:"M16,26H12V18h2V16H12a2,2,0,0,0-2,2v8H6V6h4v4a2,2,0,0,0,2,2h8a2,2,0,0,0,2-2V6.41l4,4V16h2V10a1,1,0,0,0-.29-.71l-5-5A.9989.9989,0,0,0,22,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H16ZM12,6h8v4H12Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Uw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),nE||(nE=n.createElement("path",{d:"M21.56,15.1l-3.48-4.35A2,2,0,0,0,16.52,10H4a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H20a2,2,0,0,0,2-2V16.35A2,2,0,0,0,21.56,15.1ZM9,12h6v3H9Zm6,16H9V22h6Zm2,0V22a2,2,0,0,0-2-2H9a2,2,0,0,0-2,2v6H4V12H7v3a2,2,0,0,0,2,2h6a2,2,0,0,0,2-2V12.6l3,3.75V28Z"})),tE||(tE=n.createElement("path",{d:"M27,21H25V7H11V5H25a2,2,0,0,1,2,2Z"})),iE||(iE=n.createElement("path",{d:"M32,14H30V2H18V0H30a2,2,0,0,1,2,2Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Iw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),sE||(sE=n.createElement("path",{d:"M13,17H7a2,2,0,0,0-2,2v6a2,2,0,0,0,2,2h6a2,2,0,0,0,2-2V19A2,2,0,0,0,13,17ZM7,25V19h6v6Z"})),lE||(lE=n.createElement("path",{d:"M19,21v2h6a2,2,0,0,0,2-2V7a2,2,0,0,0-2-2H11A2,2,0,0,0,9,7v6h2V7H25V21"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Bw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),rE||(rE=n.createElement("path",{d:"M20,16a5,5,0,0,0,10,0,1,1,0,0,0-.1055-.4473L25.896,7.5562a.8913.8913,0,0,0-.0454-.0816A1,1,0,0,0,25,7H18.8218A3.0155,3.0155,0,0,0,17,5.1841V2H15V5.1841A3.0155,3.0155,0,0,0,13.1782,7H7a1,1,0,0,0-.8945.5527l-4,8A1,1,0,0,0,2,16a5,5,0,0,0,10,0,1,1,0,0,0-.1055-.4473L8.6182,9h4.56A3.0147,3.0147,0,0,0,15,10.8154V28H6v2H26V28H17V10.8159A3.0155,3.0155,0,0,0,18.8218,9h4.56l-3.2763,6.5527A1,1,0,0,0,20,16ZM7,19a2.9958,2.9958,0,0,1-2.8152-2h5.63A2.9956,2.9956,0,0,1,7,19Zm2.3821-4H4.6179L7,10.2363ZM16,9a1,1,0,1,1,1-1A1.0009,1.0009,0,0,1,16,9Zm9,10a2.9958,2.9958,0,0,1-2.8152-2h5.63A2.9956,2.9956,0,0,1,25,19Zm0-8.7637L27.3821,15H22.6179Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ow);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),aE||(aE=n.createElement("path",{d:"M20,13a5,5,0,0,0,10,0,1,1,0,0,0-.1055-.4473l-4-8a1,1,0,0,0-1.2109-.5014l-6.3308,2.11A3.0322,3.0322,0,0,0,17,5.1841V2H15V5.1841a2.9949,2.9949,0,0,0-1.9956,2.76l-6.3208,2.107a1,1,0,0,0-.5781.5014l-4,8A1,1,0,0,0,2,19a5,5,0,0,0,10,0,1,1,0,0,0-.1055-.4473L8.41,11.584l5.237-1.7456A3.0285,3.0285,0,0,0,15,10.8154V28H6v2H26V28H17V10.8159a2.9951,2.9951,0,0,0,1.9956-2.76l4.03-1.3438-2.92,5.8408A1,1,0,0,0,20,13ZM7,22a2.9956,2.9956,0,0,1-2.8152-2h5.63A2.9956,2.9956,0,0,1,7,22Zm2.3821-4H4.6179L7,13.2363ZM16,9a1,1,0,1,1,1-1A1.0009,1.0009,0,0,1,16,9Zm9,7a2.9958,2.9958,0,0,1-2.8152-2h5.63A2.9956,2.9956,0,0,1,25,16Zm0-8.7637L27.3821,12H22.6179Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Fw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),dE||(dE=n.createElement("path",{d:"M28.83,5.17a4.1,4.1,0,0,0-5.66,0L.34,28H9.59a5,5,0,0,0,3.53-1.46L28.83,10.83a4,4,0,0,0,0-5.66ZM12.29,18.88l2.09-2.09,2.83,2.83-2.09,2.09Zm-.58,6.24A3,3,0,0,1,9.59,26H5.17l5.71-5.71,2.83,2.83ZM27.41,9.41l-8.79,8.8-2.83-2.83,8.8-8.79a2,2,0,0,1,2.82,0,2,2,0,0,1,0,2.82Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Xw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),_E||(_E=n.createElement("path",{d:"M28.8281 7.1338a4.0941 4.0941 0 00-5.6562 0L.3433 29.9619H9.5889a4.9682 4.9682 0 003.5356-1.4648L28.8281 12.79a3.9984 3.9984 0 000-5.6562zM12.2928 20.8406l2.086-2.0858 2.8293 2.8293L15.1224 23.67zM11.71 27.083a2.9824 2.9824 0 01-2.1215.8789H5.1714l5.7073-5.7072 2.83 2.83zM27.4141 11.376L18.6221 20.17l-2.8293-2.8292 8.7931-8.7928a2.0471 2.0471 0 012.8282 0 1.9993 1.9993 0 010 2.8281zM13 4L4 4 4 13 6 13 6 6 13 6 13 4z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Cw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),oE||(oE=n.createElement("path",{d:"M28.8281 7.1338a4.0941 4.0941 0 00-5.6562 0L.3433 29.9619H9.5889a4.9682 4.9682 0 003.5356-1.4648L28.8281 12.79a3.9984 3.9984 0 000-5.6562zM12.2928 20.8406l2.086-2.0858 2.8293 2.8293L15.1224 23.67zM11.71 27.083a2.9824 2.9824 0 01-2.1215.8789H5.1714l5.7073-5.7072 2.83 2.83zM27.4141 11.376L18.6221 20.17l-2.8293-2.8292 8.7931-8.7928a2.0471 2.0471 0 012.8282 0 1.9993 1.9993 0 010 2.8281zM11 2H7a4.9843 4.9843 0 00-3.8633 8.1528A2.9586 2.9586 0 003 11a2.9945 2.9945 0 002 2.8154V14a2.0025 2.0025 0 01-2 2H2v2H3a4.0045 4.0045 0 004-4v-.1841A2.9959 2.9959 0 008.8157 12H11A5 5 0 0011 2zM6 12a1 1 0 111-1A1.0009 1.0009 0 016 12zm5-2H8.8157A2.974 2.974 0 004.394 8.4746 2.9908 2.9908 0 017 4h4a3 3 0 010 6z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,qw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),mE||(mE=n.createElement("path",{d:"M28.8281 7.1719a4.0941 4.0941 0 00-5.6562 0L.3433 30H9.5889a4.9682 4.9682 0 003.5356-1.4648L28.8281 12.8281a3.9984 3.9984 0 000-5.6562zM12.2928 20.8787l2.086-2.0859 2.8293 2.8294-2.0857 2.0862zM11.71 27.1211A2.9824 2.9824 0 019.5889 28H5.1714l5.7073-5.7072 2.83 2.83zm15.7037-15.707l-8.792 8.7939-2.8293-2.8292 8.7931-8.7929a2.0473 2.0473 0 012.8282 0 1.9995 1.9995 0 010 2.8282zM15 2a2.9948 2.9948 0 00-2.8157 2H7.8156A2.9925 2.9925 0 104 7.8154v4.3687a3 3 0 102 0V7.8159A2.9959 2.9959 0 007.8156 6h4.3686A2.9947 2.9947 0 1015 2zM5 16a1 1 0 111-1A1.0008 1.0008 0 015 16zM5 6A1 1 0 116 5 1.0008 1.0008 0 015 6zM15 6a1 1 0 111-1A1.0008 1.0008 0 0115 6z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Hw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),vE||(vE=n.createElement("path",{d:"M21,29H5a2,2,0,0,1-2-2V5A2,2,0,0,1,5,3H21V5H5V27H21Z"})),fE||(fE=n.createElement("path",{d:"M15 9H17V23H15zM27 9H29V23H27zM21 9H23V23H21z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,kw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),uE||(uE=n.createElement("path",{d:"M22 24H10a2 2 0 01-2-2V19h2v3H22V19h2v3A2 2 0 0122 24zM2 15H30V17H2zM24 13H22V10H10v3H8V10a2 2 0 012-2H22a2 2 0 012 2zM30 10L28 10 28 4 22 4 22 2 30 2 30 10zM4 10L2 10 2 2 10 2 10 4 4 4 4 10zM10 30L2 30 2 22 4 22 4 28 10 28 10 30zM30 30L22 30 22 28 28 28 28 22 30 22 30 30z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Nw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),cE||(cE=n.createElement("path",{d:"M29.3826 2.0762a.9993.9993 0 00-1.09.2168l-26 26A1 1 0 003 30h8V28H5.4143l4-4H22a2.0021 2.0021 0 002-2V9.4146l4-4V11h2V3A1 1 0 0029.3826 2.0762zM22 22H11.4143L22 11.4146zM10 17.7554V10h7.7554l2-2H10a2.0025 2.0025 0 00-2 2v9.7554zM11 2L2 2 2 11 4 11 4 4 11 4 11 2zM21 30L30 30 30 21 28 21 28 28 21 28 21 30zM4 23.755L4 21 2 21 2 25.754 4 23.755zM25.755 2L21 2 21 4 23.755 4 25.755 2z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Yw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),pE||(pE=n.createElement("circle",{cx:"9.5",cy:"9.5",r:"2.5"})),EE||(EE=n.createElement("circle",{cx:"9.5",cy:"22.5",r:"2.5"})),hE||(hE=n.createElement("circle",{cx:"22.5",cy:"22.5",r:"2.5"})),gE||(gE=n.createElement("path",{d:"M28,2H4A2.0023,2.0023,0,0,0,2,4V28a2.0023,2.0023,0,0,0,2,2H28a2.0023,2.0023,0,0,0,2-2V4A2.0023,2.0023,0,0,0,28,2Zm0,13H17V4H28ZM15,4V15H4V4ZM4,17H15V28H4ZM17,28V17H28V28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Zw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),wE||(wE=n.createElement("path",{d:"M27,19.001A4.0056,4.0056,0,0,0,22.9991,15H9.0011A2.0031,2.0031,0,0,1,7,12.9991V9.858A3.9949,3.9949,0,0,0,9.8581,7h12.284a4,4,0,1,0,0-2H9.8581A3.9916,3.9916,0,1,0,5,9.858v3.1411A4.0057,4.0057,0,0,0,9.0011,17h13.998A2.003,2.003,0,0,1,25,19.001V22H22v3H9.8581a4,4,0,1,0,0,2H22v3h8V22H27ZM26,4a2,2,0,1,1-2,2A2.0019,2.0019,0,0,1,26,4ZM4,6A2,2,0,1,1,6,8,2.0019,2.0019,0,0,1,4,6ZM6,28a2,2,0,1,1,2-2A2.002,2.002,0,0,1,6,28Zm22-4v4H24V24Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Pw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),bE||(bE=n.createElement("path",{d:"M27,19c-0.3,0-0.7,0.1-1,0.2L20.4,12c1-1.1,1.6-2.5,1.6-4c0-3.3-2.7-6-6-6s-6,2.7-6,6c0,1.6,0.6,3,1.6,4L6,19.2 C5.7,19.1,5.3,19,5,19c-1.7,0-3,1.3-3,3s1.3,3,3,3s3-1.3,3-3c0-0.6-0.2-1.1-0.5-1.6l5.6-7.1c0.6,0.3,1.2,0.5,1.9,0.6v10.3 c-1.2,0.4-2,1.5-2,2.8c0,1.7,1.3,3,3,3s3-1.3,3-3c0-1.3-0.8-2.4-2-2.8V13.9c0.7-0.1,1.3-0.3,1.9-0.6l5.6,7.1c-0.3,0.5-0.5,1-0.5,1.6 c0,1.7,1.3,3,3,3s3-1.3,3-3S28.7,19,27,19z M16,4c2.2,0,4,1.8,4,4s-1.8,4-4,4s-4-1.8-4-4S13.8,4,16,4z M5,23c-0.6,0-1-0.4-1-1 s0.4-1,1-1s1,0.4,1,1S5.6,23,5,23z M16,28c-0.6,0-1-0.4-1-1s0.4-1,1-1s1,0.4,1,1S16.6,28,16,28z M27,23c-0.6,0-1-0.4-1-1s0.4-1,1-1 s1,0.4,1,1S27.6,23,27,23z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Gw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),xE||(xE=n.createElement("path",{d:"M23,23v3H8.5a4.5,4.5,0,0,1,0-9H9V15H8.5a6.5,6.5,0,0,0,0,13H23v3h8V23Zm6,6H25V25h4Z"})),zE||(zE=n.createElement("path",{d:"M21 22H19V19H13v3H11V19a2.0023 2.0023 0 012-2h6a2.0023 2.0023 0 012 2zM16 16a3 3 0 113-3A3.0033 3.0033 0 0116 16zm0-4a1 1 0 101 1A1.0013 1.0013 0 0016 12z"})),LE||(LE=n.createElement("path",{d:"M23.5,4H9V1H1V9H9V6H23.5a4.5,4.5,0,0,1,0,9H23v2h.5a6.5,6.5,0,0,0,0-13ZM7,7H3V3H7Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,jw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ME||(ME=n.createElement("path",{d:"M26 28a4 4 0 114-4A4.0045 4.0045 0 0126 28zm0-6a2 2 0 102 2A2.0023 2.0023 0 0026 22zM24 8H18v2h6a1 1 0 010 2H21a1 1 0 00-.98 1.1963l.9241 4.6211L18.4338 22h-2.69l-2.5723-8.5752A1.988 1.988 0 0011.2559 12H6v2h5.2561l.6 2H7a5.0057 5.0057 0 00-5 5v2a1 1 0 001 1H4a4 4 0 008 0h7a1 1 0 00.8574-.4854l3-5a1 1 0 00.1231-.7109L22.22 14H24a3 3 0 000-6zM8 26a2.0025 2.0025 0 01-2-2h4A2.0025 2.0025 0 018 26zM4 22V21a3.0033 3.0033 0 013-3h5.4561l1.2 4z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Kw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),yE||(yE=n.createElement("path",{d:"M15 19H17V28H15z"})),RE||(RE=n.createElement("path",{d:"M23,10V8H20a2.0025,2.0025,0,0,0-2-2H14a2.0025,2.0025,0,0,0-2,2H9v2h3v4.1841A2.9957,2.9957,0,0,0,10,17v7h2V17a1.0008,1.0008,0,0,1,1-1h6a1.0008,1.0008,0,0,1,1,1v7h2V17a2.9957,2.9957,0,0,0-2-2.8159V10ZM18,8v6H14V8Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Qw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),SE||(SE=n.createElement("path",{d:"M28,4H4A2,2,0,0,0,2,6V22a2,2,0,0,0,2,2h8v4H8v2H24V28H20V24h8a2,2,0,0,0,2-2V6A2,2,0,0,0,28,4ZM18,28H14V24h4Zm10-6H4V6H28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Jw);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),AE||(AE=n.createElement("path",{d:"M28,22H11.41L30,3.41,28.59,2l-2,2H4A2,2,0,0,0,2,6V22H4V6H24.59L2,28.59,3.41,30l6-6H12v4H8v2H24V28H20V24h8a2,2,0,0,0,2-2V9H28ZM18,28H14V24h4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,$w);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),DE||(DE=n.createElement("path",{d:"M18.83 26L21.41 23.42 20 22 16 26 20 30 21.42 28.59 18.83 26zM27.17 26L24.59 28.58 26 30 30 26 26 22 24.58 23.41 27.17 26z"})),VE||(VE=n.createElement("path",{d:"M14,28H8V4h8v6a2.0058,2.0058,0,0,0,2,2h6v6h2V10a.9092.9092,0,0,0-.3-.7l-7-7A.9087.9087,0,0,0,18,2H8A2.0058,2.0058,0,0,0,6,4V28a2.0058,2.0058,0,0,0,2,2h6ZM18,4.4,23.6,10H18Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,eb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),TE||(TE=n.createElement("path",{d:"M4 20L4 22 8.586 22 2 28.586 3.414 30 10 23.414 10 28 12 28 12 20 4 20zM27.17 26L24.59 28.58 26 30 30 26 26 22 24.58 23.41 27.17 26zM18.83 26L21.41 23.42 20 22 16 26 20 30 21.42 28.59 18.83 26zM25.7 9.3l-7-7A.9087.9087 0 0018 2H8A2.0058 2.0058 0 006 4V16H8V4h8v6a2.0058 2.0058 0 002 2h6v6h2V10A.9092.9092 0 0025.7 9.3zM18 10V4.4L23.6 10z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,nb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),WE||(WE=n.createElement("path",{d:"M30 9L27.9 9 24 15.6 24 9 22 9 22 23 24 23 24 18.7 24.9 17.2 27.9 23 30 23 26.1 15.4 30 9zM16 23H12V9h4a4.0118 4.0118 0 014 4v6A4.0118 4.0118 0 0116 23zm-2-2h2a2.0059 2.0059 0 002-2V13a2.0059 2.0059 0 00-2-2H14zM8 23H2V21H8V17H4a2.0059 2.0059 0 01-2-2V11A2.0059 2.0059 0 014 9h6v2H4v4H8a2.0059 2.0059 0 012 2v4A2.0059 2.0059 0 018 23z"})),i)})).propTypes=ol;var ax,dx=n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,tb);return 16===l||"16"===l||"16px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),UE||(UE=n.createElement("path",{d:"M15,14.3L10.7,10c1.9-2.3,1.6-5.8-0.7-7.7S4.2,0.7,2.3,3S0.7,8.8,3,10.7c2,1.7,5,1.7,7,0l4.3,4.3L15,14.3z M2,6.5 C2,4,4,2,6.5,2S11,4,11,6.5S9,11,6.5,11S2,9,2,6.5z"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),IE||(IE=n.createElement("path",{d:"M29,27.5859l-7.5521-7.5521a11.0177,11.0177,0,1,0-1.4141,1.4141L27.5859,29ZM4,13a9,9,0,1,1,9,9A9.01,9.01,0,0,1,4,13Z"})),i)}));dx.propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ib);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),BE||(BE=n.createElement("path",{d:"M30 6L26 6 26 2 24 2 24 6 20 6 20 8 24 8 24 12 26 12 26 8 30 8 30 6zM24 28.5859l-5.9751-5.9751a9.0234 9.0234 0 10-1.4141 1.4141L22.5859 30zM4 17a7 7 0 117 7A7.0078 7.0078 0 014 17z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,sb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),OE||(OE=n.createElement("path",{d:"M30 28.5859l-4.6885-4.6884a8.028 8.028 0 10-1.414 1.414L28.5859 30zM19 25a6 6 0 116-6A6.0066 6.0066 0 0119 25zM2 12H10V14H2zM2 2H18V4H2zM2 7H18V9H2z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,lb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),FE||(FE=n.createElement("path",{d:"M14 16.59L11.41 14 10 15.41 14 19.41 22 11.41 20.59 10 14 16.59z"})),XE||(XE=n.createElement("path",{d:"M16,30,9.8242,26.7071A10.9818,10.9818,0,0,1,4,17V4A2.0021,2.0021,0,0,1,6,2H26a2.0021,2.0021,0,0,1,2,2V17a10.9818,10.9818,0,0,1-5.8242,9.7071ZM6,4V17a8.9852,8.9852,0,0,0,4.7656,7.9423L16,27.7333l5.2344-2.791A8.9852,8.9852,0,0,0,26,17V4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,rb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),CE||(CE=n.createElement("path",{d:"M30,24V22H27.8989a4.9678,4.9678,0,0,0-.7319-1.7529l1.49-1.49-1.414-1.414-1.49,1.49A4.9678,4.9678,0,0,0,24,18.1011V16H22v2.1011a4.9678,4.9678,0,0,0-1.7529.7319l-1.49-1.49-1.414,1.414,1.49,1.49A4.9678,4.9678,0,0,0,18.1011,22H16v2h2.1011a4.9678,4.9678,0,0,0,.7319,1.7529l-1.49,1.49,1.414,1.414,1.49-1.49A4.9678,4.9678,0,0,0,22,27.8989V30h2V27.8989a4.9678,4.9678,0,0,0,1.7529-.7319l1.49,1.49,1.414-1.414-1.49-1.49A4.9678,4.9678,0,0,0,27.8989,24Zm-7,2a3,3,0,1,1,3-3A3.0033,3.0033,0,0,1,23,26Z"})),qE||(qE=n.createElement("path",{d:"M14,26.667l-3.2344-1.7246A8.9858,8.9858,0,0,1,6,17V4H26V14h2V4a2.0023,2.0023,0,0,0-2-2H6A2.0023,2.0023,0,0,0,4,4V17a10.9814,10.9814,0,0,0,5.8242,9.707L14,28.9336Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ab);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),HE||(HE=n.createElement("path",{d:"M12 6L8 6 8 2 6 2 6 6 2 6 2 8 6 8 6 12 8 12 8 8 12 8 12 6zM16 6H20V8H16zM24 6V8h4v4h2V8a2 2 0 00-2-2zM6 16H8V20H6zM8 28V24H6v4a2 2 0 002 2h4V28zM28 16H30V20H28zM16 28H20V30H16zM28 24v4H24v2h4a2 2 0 002-2V24z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,db);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),kE||(kE=n.createElement("path",{d:"M12 6L8 6 8 2 6 2 6 6 2 6 2 8 6 8 6 12 8 12 8 8 12 8 12 6zM30 10V4H24V6H16V8h8v2h2V24H24v2H10V24H8V16H6v8H4v6h6V28H24v2h6V24H28V10zM8 28H6V26H8zm20 0H26V26h2zM26 6h2V8H26z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,_b);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),NE||(NE=n.createElement("path",{d:"M8 26H4a2.0021 2.0021 0 01-2-2V20H4v4H8zM2 12H4V16H2zM26 8H24V4H20V2h4a2.0021 2.0021 0 012 2zM12 2H16V4H12zM4 8H2V4A2.0021 2.0021 0 014 2H8V4H4zM27 32a.9967.9967 0 01-.707-.293l-6.1377-6.1377L16.832 30.5547a1 1 0 01-1.79-.2676l-6-20A1 1 0 0110.2871 9.042l20 6a1 1 0 01.2676 1.79l-4.9854 3.3233L31.707 26.293a.9994.9994 0 010 1.414l-4 4A.9967.9967 0 0127 32zm0-2.4141L29.5859 27 22.431 19.845l5.2458-3.4978L11.4917 11.4917l4.8555 16.1851L19.845 22.431z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ob);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),YE||(YE=n.createElement("path",{d:"M27.45,15.11l-22-11a1,1,0,0,0-1.08.12,1,1,0,0,0-.33,1L7,16,4,26.74A1,1,0,0,0,5,28a1,1,0,0,0,.45-.11l22-11a1,1,0,0,0,0-1.78Zm-20.9,10L8.76,17H18V15H8.76L6.55,6.89,24.76,16Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,mb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ZE||(ZE=n.createElement("path",{d:"M27.71,4.29a1,1,0,0,0-1.05-.23l-22,8a1,1,0,0,0,0,1.87l9.6,3.84,3.84,9.6A1,1,0,0,0,19,28h0a1,1,0,0,0,.92-.66l8-22A1,1,0,0,0,27.71,4.29ZM19,24.2l-2.79-7L21,12.41,19.59,11l-4.83,4.83L7.8,13,25.33,6.67Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,vb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),PE||(PE=n.createElement("path",{d:"M27.71,4.29a1,1,0,0,0-1.05-.23l-22,8a1,1,0,0,0,0,1.87l8.59,3.43L19.59,11,21,12.41l-6.37,6.37,3.44,8.59A1,1,0,0,0,19,28h0a1,1,0,0,0,.92-.66l8-22A1,1,0,0,0,27.71,4.29Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,fb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),GE||(GE=n.createElement("path",{d:"M27.45,15.11l-22-11a1,1,0,0,0-1.08.12,1,1,0,0,0-.33,1L6.69,15H18v2H6.69L4,26.74A1,1,0,0,0,5,28a1,1,0,0,0,.45-.11l22-11a1,1,0,0,0,0-1.78Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ub);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),jE||(jE=n.createElement("path",{d:"M4 7H2V4A2.0023 2.0023 0 014 2H7V4H4zM7 22H4a2.0023 2.0023 0 01-2-2V17H4v3H7zM2 10H4V14H2zM22 7H20V4H17V2h3a2.0023 2.0023 0 012 2zM10 2H14V4H10zM28 30H12a2.0023 2.0023 0 01-2-2V12a2.0023 2.0023 0 012-2H28a2.0023 2.0023 0 012 2V28A2.0023 2.0023 0 0128 30zM12 12V28H28V12z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,cb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),KE||(KE=n.createElement("path",{d:"M28,10H22V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V20a2,2,0,0,0,2,2h6v6a2.0023,2.0023,0,0,0,2,2H28a2.0023,2.0023,0,0,0,2-2V12A2.0023,2.0023,0,0,0,28,10ZM12,28V12H28l.0015,16Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,pb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),QE||(QE=n.createElement("path",{d:"M16 2a8 8 0 108 8A8.0092 8.0092 0 0016 2zm5.91 7H19.4724a15.2457 15.2457 0 00-.7917-4.36A6.0088 6.0088 0 0121.91 9zM16.022 15.999h-.0076c-.3813-.1206-1.3091-1.8213-1.479-4.999h2.9292C17.2952 14.1763 16.3711 15.877 16.022 15.999zM14.5354 9c.1694-3.1763 1.0935-4.877 1.4426-4.999h.0076c.3813.1206 1.3091 1.8213 1.479 4.999zM13.3193 4.64A15.2457 15.2457 0 0012.5276 9H10.09A6.0088 6.0088 0 0113.3193 4.64zM10.09 11h2.4373a15.2457 15.2457 0 00.7917 4.36A6.0088 6.0088 0 0110.09 11zm8.59 4.36A15.2457 15.2457 0 0019.4724 11H21.91A6.0088 6.0088 0 0118.6807 15.36zM28 30H4a2.0021 2.0021 0 01-2-2V22a2.0021 2.0021 0 012-2H28a2.0021 2.0021 0 012 2v6A2.0021 2.0021 0 0128 30zM4 22v6H28V22z"})),JE||(JE=n.createElement("circle",{cx:"7",cy:"25",r:"1"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Eb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),$E||($E=n.createElement("path",{d:"M6,30H26a2,2,0,0,0,2-2V22a2,2,0,0,0-2-2H6a2,2,0,0,0-2,2v6A2,2,0,0,0,6,30Zm0-8H26v6H6Z"})),eh||(eh=n.createElement("circle",{cx:"9",cy:"25",r:"1"})),nh||(nh=n.createElement("path",{d:"M26,2,24.59,3.41,27.17,6H22.315A6.9835,6.9835,0,0,0,9.08,10H4.83L7.41,7.41,6,6,1,11l5,5,1.41-1.41L4.83,12H9.685A6.9835,6.9835,0,0,0,22.92,8h4.25l-2.58,2.59L26,12l5-5ZM21,9a4.983,4.983,0,0,1-8.9745,3H16V10H11.1011a4.9852,4.9852,0,0,1,8.8734-4H16V8h4.8989A5.0019,5.0019,0,0,1,21,9Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,hb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),th||(th=n.createElement("path",{d:"M28,30H4a2.0021,2.0021,0,0,1-2-2V22a2.0021,2.0021,0,0,1,2-2H28a2.0021,2.0021,0,0,1,2,2v6A2.0021,2.0021,0,0,1,28,30ZM4,22v6H28V22Z"})),ih||(ih=n.createElement("circle",{cx:"7",cy:"25",r:"1"})),sh||(sh=n.createElement("path",{d:"M19 11.586L17 9.586 17 6 15 6 15 10.414 17.586 13 19 11.586z"})),lh||(lh=n.createElement("path",{d:"M16,18a8,8,0,1,1,8-8A8.0092,8.0092,0,0,1,16,18ZM16,4a6,6,0,1,0,6,6A6.0067,6.0067,0,0,0,16,4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,gb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),rh||(rh=n.createElement("path",{d:"M28,24V22A12.01,12.01,0,0,0,17,10.0507V8h3V6H12V8h3v2.0507A12.01,12.01,0,0,0,4,22v2H2v2H30V24ZM16,12a10.0167,10.0167,0,0,1,9.7984,8H6.2015A10.0165,10.0165,0,0,1,16,12ZM6,22H26v2H6Z",transform:"translate(0 .005)"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,wb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ah||(ah=n.createElement("path",{d:"M26,8,24.59,9.41,27.17,12H16a5.967,5.967,0,0,0-4,1.54V6.83l2.59,2.58L16,8,11,3,6,8,7.41,9.41,10,6.83V18a5.969,5.969,0,0,0,1.54,4H4.83l2.58-2.59L6,18,1,23l5,5,1.41-1.41L4.83,24H16A5.99,5.99,0,0,0,20.46,14h6.71l-2.58,2.59L26,18l5-5ZM20,18a4,4,0,1,1-4-4A4.0045,4.0045,0,0,1,20,18Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,bb);return 16===l||"16"===l||"16px"===l?n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 16",fill:"currentColor"},r),dh||(dh=n.createElement("path",{d:"M13.5,8.4c0-0.1,0-0.3,0-0.4c0-0.1,0-0.3,0-0.4l1-0.8c0.4-0.3,0.4-0.9,0.2-1.3l-1.2-2C13.3,3.2,13,3,12.6,3 c-0.1,0-0.2,0-0.3,0.1l-1.2,0.4c-0.2-0.1-0.4-0.3-0.7-0.4l-0.3-1.3C10.1,1.3,9.7,1,9.2,1H6.8c-0.5,0-0.9,0.3-1,0.8L5.6,3.1 C5.3,3.2,5.1,3.3,4.9,3.4L3.7,3C3.6,3,3.5,3,3.4,3C3,3,2.7,3.2,2.5,3.5l-1.2,2C1.1,5.9,1.2,6.4,1.6,6.8l0.9,0.9c0,0.1,0,0.3,0,0.4 c0,0.1,0,0.3,0,0.4L1.6,9.2c-0.4,0.3-0.5,0.9-0.2,1.3l1.2,2C2.7,12.8,3,13,3.4,13c0.1,0,0.2,0,0.3-0.1l1.2-0.4 c0.2,0.1,0.4,0.3,0.7,0.4l0.3,1.3c0.1,0.5,0.5,0.8,1,0.8h2.4c0.5,0,0.9-0.3,1-0.8l0.3-1.3c0.2-0.1,0.4-0.2,0.7-0.4l1.2,0.4 c0.1,0,0.2,0.1,0.3,0.1c0.4,0,0.7-0.2,0.9-0.5l1.1-2c0.2-0.4,0.2-0.9-0.2-1.3L13.5,8.4z M12.6,12l-1.7-0.6c-0.4,0.3-0.9,0.6-1.4,0.8 L9.2,14H6.8l-0.4-1.8c-0.5-0.2-0.9-0.5-1.4-0.8L3.4,12l-1.2-2l1.4-1.2c-0.1-0.5-0.1-1.1,0-1.6L2.2,6l1.2-2l1.7,0.6 C5.5,4.2,6,4,6.5,3.8L6.8,2h2.4l0.4,1.8c0.5,0.2,0.9,0.5,1.4,0.8L12.6,4l1.2,2l-1.4,1.2c0.1,0.5,0.1,1.1,0,1.6l1.4,1.2L12.6,12z"})),_h||(_h=n.createElement("path",{d:"M8,11c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3C11,9.6,9.7,11,8,11C8,11,8,11,8,11z M8,6C6.9,6,6,6.8,6,7.9C6,7.9,6,8,6,8 c0,1.1,0.8,2,1.9,2c0,0,0.1,0,0.1,0c1.1,0,2-0.8,2-1.9c0,0,0-0.1,0-0.1C10,6.9,9.2,6,8,6C8.1,6,8,6,8,6z"})),i):n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),oh||(oh=n.createElement("path",{d:"M27,16.76c0-.25,0-.5,0-.76s0-.51,0-.77l1.92-1.68A2,2,0,0,0,29.3,11L26.94,7a2,2,0,0,0-1.73-1,2,2,0,0,0-.64.1l-2.43.82a11.35,11.35,0,0,0-1.31-.75l-.51-2.52a2,2,0,0,0-2-1.61H13.64a2,2,0,0,0-2,1.61l-.51,2.52a11.48,11.48,0,0,0-1.32.75L7.43,6.06A2,2,0,0,0,6.79,6,2,2,0,0,0,5.06,7L2.7,11a2,2,0,0,0,.41,2.51L5,15.24c0,.25,0,.5,0,.76s0,.51,0,.77L3.11,18.45A2,2,0,0,0,2.7,21L5.06,25a2,2,0,0,0,1.73,1,2,2,0,0,0,.64-.1l2.43-.82a11.35,11.35,0,0,0,1.31.75l.51,2.52a2,2,0,0,0,2,1.61h4.72a2,2,0,0,0,2-1.61l.51-2.52a11.48,11.48,0,0,0,1.32-.75l2.42.82a2,2,0,0,0,.64.1,2,2,0,0,0,1.73-1L29.3,21a2,2,0,0,0-.41-2.51ZM25.21,24l-3.43-1.16a8.86,8.86,0,0,1-2.71,1.57L18.36,28H13.64l-.71-3.55a9.36,9.36,0,0,1-2.7-1.57L6.79,24,4.43,20l2.72-2.4a8.9,8.9,0,0,1,0-3.13L4.43,12,6.79,8l3.43,1.16a8.86,8.86,0,0,1,2.71-1.57L13.64,4h4.72l.71,3.55a9.36,9.36,0,0,1,2.7,1.57L25.21,8,27.57,12l-2.72,2.4a8.9,8.9,0,0,1,0,3.13L27.57,20Z"})),mh||(mh=n.createElement("path",{d:"M16,22a6,6,0,1,1,6-6A5.94,5.94,0,0,1,16,22Zm0-10a3.91,3.91,0,0,0-4,4,3.91,3.91,0,0,0,4,4,3.91,3.91,0,0,0,4-4A3.91,3.91,0,0,0,16,12Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,xb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),vh||(vh=n.createElement("path",{d:"M30 8h-4.1c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2v2h14.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30V8zM21 12c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3S22.7 12 21 12zM2 24h4.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30v-2H15.9c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2V24zM11 20c1.7 0 3 1.3 3 3s-1.3 3-3 3-3-1.3-3-3S9.3 20 11 20z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,zb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),fh||(fh=n.createElement("path",{d:"M16,22a6,6,0,1,1,6-6A5.9364,5.9364,0,0,1,16,22Zm0-10a3.9123,3.9123,0,0,0-4,4,3.9123,3.9123,0,0,0,4,4,3.9123,3.9123,0,0,0,4-4A3.9123,3.9123,0,0,0,16,12Z"})),uh||(uh=n.createElement("path",{d:"M29.3047,11.044,26.9441,6.9562a1.9977,1.9977,0,0,0-2.3728-.8946l-2.4341.8233a11.0419,11.0419,0,0,0-1.312-.7583L20.3215,3.608A2,2,0,0,0,18.36,2H13.64A2,2,0,0,0,11.6785,3.608l-.5037,2.5186A10.9666,10.9666,0,0,0,9.8481,6.88L7.4287,6.0616a1.9977,1.9977,0,0,0-2.3728.8946L2.6953,11.044a2.0006,2.0006,0,0,0,.4119,2.5025l1.9309,1.6968C5.021,15.4947,5,15.7447,5,16c0,.2578.01.5127.0278.7656l-1.9206,1.688a2.0006,2.0006,0,0,0-.4119,2.5025L5.0559,25.044a1.9977,1.9977,0,0,0,2.3728.8946l2.4341-.8233a10.9736,10.9736,0,0,0,1.312.7583l.5037,2.5186A2,2,0,0,0,13.64,30H18V28H13.64l-.71-3.5508a9.0953,9.0953,0,0,1-2.6948-1.5713L6.7878,24.044l-2.36-4.0878,2.7253-2.3951a8.9263,8.9263,0,0,1-.007-3.1279L4.4275,12.044,6.7886,7.9562l3.4267,1.1591a9.0305,9.0305,0,0,1,2.7141-1.5644L13.64,4H18.36l.71,3.5508a9.0978,9.0978,0,0,1,2.6948,1.5713l3.4468-1.166,2.36,4.0878-2.7978,2.4522L26.0923,16l2.8-2.4536A2.0006,2.0006,0,0,0,29.3047,11.044Z"})),ch||(ch=n.createElement("path",{d:"M23 26.18L20.41 23.59 19 25 23 29 30 22 28.59 20.59 23 26.18z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Lb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ph||(ph=n.createElement("path",{d:"M29,25H27V23h1V19H24v1H22V18a1,1,0,0,1,1-1h6a1,1,0,0,1,1,1v6A1,1,0,0,1,29,25Z"})),Eh||(Eh=n.createElement("path",{d:"M24 30H18a1 1 0 01-1-1V23a1 1 0 011-1h6a1 1 0 011 1v6A1 1 0 0124 30zm-5-2h4V24H19zM15 19.8579A3.9934 3.9934 0 1120 16h2a6 6 0 10-7 5.91z"})),hh||(hh=n.createElement("path",{d:"M28.89,13.55l-2.31,2.03-1.42-1.42,2.41-2.12L25.21,7.96,21.77,9.12a9.3684,9.3684,0,0,0-2.7-1.57L18.36,4H13.64l-.71,3.55a8.8609,8.8609,0,0,0-2.71,1.57L6.79,7.96,4.43,12.04l2.72,2.39a8.8948,8.8948,0,0,0,0,3.13l-2.72,2.4,2.36,4.08,3.44-1.16a9.3684,9.3684,0,0,0,2.7,1.57L13.64,28H15v2H13.64a2.0007,2.0007,0,0,1-1.96-1.61l-.51-2.52a11.412,11.412,0,0,1-1.31-.75l-2.43.82a2.038,2.038,0,0,1-.64.1,1.973,1.973,0,0,1-1.73-1L2.7,20.96a2,2,0,0,1,.41-2.51l1.92-1.68C5.01,16.51,5,16.26,5,16s.02-.51.04-.76L3.11,13.55a2,2,0,0,1-.41-2.51L5.06,6.96a1.973,1.973,0,0,1,1.73-1,2.038,2.038,0,0,1,.64.1l2.42.82a11.5416,11.5416,0,0,1,1.32-.75l.51-2.52A2.0007,2.0007,0,0,1,13.64,2h4.72a2.0007,2.0007,0,0,1,1.96,1.61l.51,2.52a11.412,11.412,0,0,1,1.31.75l2.43-.82a2.038,2.038,0,0,1,.64-.1,1.973,1.973,0,0,1,1.73,1l2.36,4.08A2,2,0,0,1,28.89,13.55Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Mb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),gh||(gh=n.createElement("circle",{cx:"23",cy:"24",r:"2"})),wh||(wh=n.createElement("path",{d:"M30.7769 23.4785A8.64 8.64 0 0023 18a8.64 8.64 0 00-7.7769 5.4785L15 24l.2231.5215A8.64 8.64 0 0023 30a8.64 8.64 0 007.7769-5.4785L31 24zM23 28a4 4 0 114-4A4.0045 4.0045 0 0123 28zM12.3989 20.8A6 6 0 1122 16H20a4 4 0 10-6.4 3.2z"})),bh||(bh=n.createElement("path",{d:"M29.3047,11.0439,26.9441,6.9561a1.9977,1.9977,0,0,0-2.3728-.8946l-2.4341.8233a11.0419,11.0419,0,0,0-1.312-.7583l-.5037-2.5186A2,2,0,0,0,18.36,2H13.64a2,2,0,0,0-1.9611,1.6079l-.5037,2.5186A10.9666,10.9666,0,0,0,9.8481,6.88L7.4287,6.0615a1.9977,1.9977,0,0,0-2.3728.8946L2.6953,11.0439a2.0006,2.0006,0,0,0,.4119,2.5025l1.9309,1.6968C5.021,15.4946,5,15.7446,5,16c0,.2578.01.5127.0278.7656l-1.9206,1.688a2.0006,2.0006,0,0,0-.4119,2.5025l2.3606,4.0878a1.9977,1.9977,0,0,0,2.3728.8946l2.4341-.8233a10.9736,10.9736,0,0,0,1.312.7583l.5037,2.5186A2,2,0,0,0,13.64,30H15V28H13.64l-.71-3.5508a9.0953,9.0953,0,0,1-2.6948-1.5713l-3.4468,1.166-2.36-4.0878L7.1528,17.561a8.9263,8.9263,0,0,1-.007-3.1279L4.4275,12.0439,6.7886,7.9561l3.4267,1.1591a9.0305,9.0305,0,0,1,2.7141-1.5644L13.64,4H18.36l.71,3.5508a9.0978,9.0978,0,0,1,2.6948,1.5713l3.4468-1.166,2.36,4.0878-2.7978,2.4522L26.0923,16l2.8-2.4536A2.0006,2.0006,0,0,0,29.3047,11.0439Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,yb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),xh||(xh=n.createElement("path",{d:"M28,10H22V4a2.0023,2.0023,0,0,0-2-2H4A2.0025,2.0025,0,0,0,2,4V20a2.0025,2.0025,0,0,0,2,2h6v6a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V12A2,2,0,0,0,28,10ZM12,20V12h8v8ZM3.9988,4H20v6H12a2.0023,2.0023,0,0,0-2,2v8H4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Rb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),zh||(zh=n.createElement("path",{d:"M12,10H22V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V20a2,2,0,0,0,2,2h6V12A2,2,0,0,1,12,10Z"})),Lh||(Lh=n.createElement("path",{d:"M28,10H22V20a2,2,0,0,1-2,2H10v6a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V12A2,2,0,0,0,28,10Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Sb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Mh||(Mh=n.createElement("path",{d:"M28,10H22V4a2.0025,2.0025,0,0,0-2-2H4A2.0025,2.0025,0,0,0,2,4V20a2.0025,2.0025,0,0,0,2,2h6v6a2.0025,2.0025,0,0,0,2,2H28a2.0025,2.0025,0,0,0,2-2V12A2.0025,2.0025,0,0,0,28,10ZM4,20V4H20v6H12a2.0025,2.0025,0,0,0-2,2v8Zm8,8V22h8a2.0025,2.0025,0,0,0,2-2V12h6V28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ab);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),yh||(yh=n.createElement("path",{d:"M28,10H22V4a2.0025,2.0025,0,0,0-2-2H4A2.0025,2.0025,0,0,0,2,4V20a2.0025,2.0025,0,0,0,2,2h6v6a2.0025,2.0025,0,0,0,2,2H28a2.0025,2.0025,0,0,0,2-2V12A2.0025,2.0025,0,0,0,28,10ZM4,20V4h6V20Zm18,8V12h6V28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Db);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Rh||(Rh=n.createElement("path",{d:"M28,10H22V4a2,2,0,0,0-2-2H4A2,2,0,0,0,2,4V20a2,2,0,0,0,2,2h6v6a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V12A2,2,0,0,0,28,10Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Vb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Sh||(Sh=n.createElement("path",{d:"M23,20a5,5,0,0,0-3.89,1.89L11.8,17.32a4.46,4.46,0,0,0,0-2.64l7.31-4.57A5,5,0,1,0,18,7a4.79,4.79,0,0,0,.2,1.32l-7.31,4.57a5,5,0,1,0,0,6.22l7.31,4.57A4.79,4.79,0,0,0,18,25a5,5,0,1,0,5-5ZM23,4a3,3,0,1,1-3,3A3,3,0,0,1,23,4ZM7,19a3,3,0,1,1,3-3A3,3,0,0,1,7,19Zm16,9a3,3,0,1,1,3-3A3,3,0,0,1,23,28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Tb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ah||(Ah=n.createElement("path",{d:"M27 25H21a3 3 0 00-3 3v2h2V28a1 1 0 011-1h6a1 1 0 011 1v2h2V28A3 3 0 0027 25zM20 20a4 4 0 104-4A4 4 0 0020 20zm6 0a2 2 0 11-2-2A2 2 0 0126 20zM6 21V20H4v1a7 7 0 007 7h3V26H11A5 5 0 016 21zM19 10H26V12H19zM19 6H29V8H19zM19 2H29V4H19zM11 11H5a3 3 0 00-3 3v2H4V14a1 1 0 011-1h6a1 1 0 011 1v2h2V14A3 3 0 0011 11zM8 10A4 4 0 104 6 4 4 0 008 10zM8 4A2 2 0 116 6 2 2 0 018 4z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Wb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Dh||(Dh=n.createElement("path",{d:"M28.76,11.35A1,1,0,0,0,28,11H22V7a3,3,0,0,0-3-3H13a3,3,0,0,0-3,3v4H4a1,1,0,0,0-1,1.15L4.88,24.3a2,2,0,0,0,2,1.7H25.14a2,2,0,0,0,2-1.7L29,12.15A1,1,0,0,0,28.76,11.35ZM12,7a1,1,0,0,1,1-1h6a1,1,0,0,1,1,1v4H12ZM25.14,24H6.86L5.17,13H26.83Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ub);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Vh||(Vh=n.createElement("circle",{cx:"10",cy:"28",r:"2"})),Th||(Th=n.createElement("circle",{cx:"24",cy:"28",r:"2"})),Wh||(Wh=n.createElement("path",{d:"M28,7H5.82L5,2.8A1,1,0,0,0,4,2H0V4H3.18L7,23.2A1,1,0,0,0,8,24H26V22H8.82L8,18H26a1,1,0,0,0,1-.78l2-9A1,1,0,0,0,28,7Zm-2.8,9H7.62L6.22,9H26.75Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ib);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Uh||(Uh=n.createElement("circle",{cx:"10",cy:"28",r:"2"})),Ih||(Ih=n.createElement("circle",{cx:"24",cy:"28",r:"2"})),Bh||(Bh=n.createElement("path",{d:"M4.9806,2.8039A1,1,0,0,0,4,2H0V4H3.18L7.0194,23.1961A1,1,0,0,0,8,24H26V22H8.82l-.8-4H26a1,1,0,0,0,.9762-.783L29.2445,7H27.1971l-1.9989,9H7.62Z"})),Oh||(Oh=n.createElement("path",{d:"M21.586 6.586L18 10.172 18 2 16 2 16 10.172 12.414 6.586 11 8 17 14 23 8 21.586 6.586z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Bb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Fh||(Fh=n.createElement("circle",{cx:"10",cy:"28",r:"2"})),Xh||(Xh=n.createElement("circle",{cx:"24",cy:"28",r:"2"})),Ch||(Ch=n.createElement("path",{d:"M4.9806,2.8039A1,1,0,0,0,4,2H0V4H3.18L7.0194,23.1961A1,1,0,0,0,8,24H26V22H8.82l-.8-4H26a1,1,0,0,0,.9762-.783L29.2445,7H27.1971l-1.9989,9H7.62Z"})),qh||(qh=n.createElement("path",{d:"M21.586 9.414L18 5.828 18 14 16 14 16 5.828 12.414 9.414 11 8 17 2 23 8 21.586 9.414z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Ob);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Hh||(Hh=n.createElement("circle",{cx:"10",cy:"28",r:"2"})),kh||(kh=n.createElement("circle",{cx:"24",cy:"28",r:"2"})),Nh||(Nh=n.createElement("path",{d:"M4.9806,2.8039A1,1,0,0,0,4,2H0V4H3.18L7.0194,23.1961A1,1,0,0,0,8,24H26V22H8.82l-.8-4H26a1,1,0,0,0,.9762-.783L29.2445,7H27.1971l-1.9989,9H7.62Z"})),Yh||(Yh=n.createElement("path",{d:"M18.41 8L22 4.41 20.59 3 17 6.59 13.41 3 12 4.41 15.59 8 12 11.59 13.41 13 17 9.41 20.59 13 22 11.59 18.41 8z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Fb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Zh||(Zh=n.createElement("circle",{cx:"10",cy:"28",r:"2"})),Ph||(Ph=n.createElement("circle",{cx:"24",cy:"28",r:"2"})),Gh||(Gh=n.createElement("path",{d:"M4.9806,2.8039A1,1,0,0,0,4,2H0V4H3.18L7.0194,23.1961A1,1,0,0,0,8,24H26V22H8.82l-.8-4H26a1,1,0,0,0,.9762-.783L29.2445,7H27.1971l-1.9989,9H7.62Z"})),jh||(jh=n.createElement("path",{d:"M17,2a6,6,0,1,0,6,6A6.0066,6.0066,0,0,0,17,2Zm0,2a3.9521,3.9521,0,0,1,2.019.5669L13.5669,10.019A3.9529,3.9529,0,0,1,13,8,4.0045,4.0045,0,0,1,17,4Zm0,8a3.9521,3.9521,0,0,1-2.019-.5669L20.4331,5.981A3.9529,3.9529,0,0,1,21,8,4.0045,4.0045,0,0,1,17,12Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Xb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Kh||(Kh=n.createElement("circle",{cx:"10",cy:"28",r:"2"})),Qh||(Qh=n.createElement("circle",{cx:"24",cy:"28",r:"2"})),Jh||(Jh=n.createElement("path",{d:"M4.9806,2.8039A1,1,0,0,0,4,2H0V4H3.18L7.0194,23.1961A1,1,0,0,0,8,24H26V22H8.82l-.8-4H26a1,1,0,0,0,.9762-.783L29.2445,7H27.1971l-1.9989,9H7.62Z"})),$h||($h=n.createElement("path",{d:"M12 6L12 8 22 8 22 6 12 6z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Cb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),eg||(eg=n.createElement("circle",{cx:"10",cy:"28",r:"2"})),ng||(ng=n.createElement("circle",{cx:"24",cy:"28",r:"2"})),tg||(tg=n.createElement("path",{d:"M4.9806,2.8039A1,1,0,0,0,4,2H0V4H3.18L7.0194,23.1961A1,1,0,0,0,8,24H26V22H8.82l-.8-4H26a1,1,0,0,0,.9762-.783L29.2445,7H27.1971l-1.9989,9H7.62Z"})),ig||(ig=n.createElement("path",{d:"M18 6L18 2 16 2 16 6 12 6 12 8 16 8 16 12 18 12 18 8 22 8 22 6 18 6z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,qb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),sg||(sg=n.createElement("path",{d:"M17 24H21V28H17zM24 24H28V28H24zM17 17H21V21H17zM24 17H28V21H24z"})),lg||(lg=n.createElement("path",{d:"M28,11h-6V7c0-1.7-1.3-3-3-3h-6c-1.7,0-3,1.3-3,3v4H4c-0.6,0-1,0.4-1,1c0,0.1,0,0.1,0,0.2l1.9,12.1c0.1,1,1,1.7,2,1.7H15v-2 H6.9L5.2,13H28V11z M12,7c0-0.6,0.4-1,1-1h6c0.6,0,1,0.4,1,1v4h-8V7z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Hb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),rg||(rg=n.createElement("path",{d:"M28 10H4A2.0022 2.0022 0 012 8V4A2.0021 2.0021 0 014 2H28a2.0021 2.0021 0 012 2V8A2.0022 2.0022 0 0128 10zM4 4V8H28V4zM28 30H4a2.0022 2.0022 0 01-2-2V24a2.0021 2.0021 0 012-2H28a2.0021 2.0021 0 012 2v4A2.0022 2.0022 0 0128 30zM4 24v4H28V24zM28 20H4a2.0022 2.0022 0 01-2-2V14a2.0021 2.0021 0 012-2H28a2.0021 2.0021 0 012 2v4A2.0022 2.0022 0 0128 20zM4 14v4H28V14z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,kb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ag||(ag=n.createElement("path",{d:"M28 28H17a2.0023 2.0023 0 01-2-2V20a2.0023 2.0023 0 012-2H28a2.0027 2.0027 0 012 2v6A2.0027 2.0027 0 0128 28zM17 20v6H28.002L28 20zM12 10L12 13.586 7.707 9.293 6.293 10.707 10.586 15 7 15 7 17 14 17 14 10 12 10z"})),dg||(dg=n.createElement("path",{d:"M13,22H4a2.0023,2.0023,0,0,1-2-2V7A2.002,2.002,0,0,1,4,5H26a2.0023,2.0023,0,0,1,2,2v9H26V7H4V20h9Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Nb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),_g||(_g=n.createElement("rect",{width:"15",height:"10",x:"15",y:"18",rx:"2"})),og||(og=n.createElement("path",{d:"M12 10L12 13.586 7.707 9.293 6.293 10.707 10.586 15 7 15 7 17 14 17 14 10 12 10z"})),mg||(mg=n.createElement("path",{d:"M13,22H4a2.0023,2.0023,0,0,1-2-2V7A2.002,2.002,0,0,1,4,5H26a2.0023,2.0023,0,0,1,2,2v9H26V7H4V20h9Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Yb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),vg||(vg=n.createElement("path",{d:"M22.59,19.41,26.17,23H19.55l-4.37-7,4.37-7h6.62l-3.58,3.59L24,14l6-6L24,2,22.59,3.41,26.17,7H19.55a2,2,0,0,0-1.69.94L14,14.11,10.14,7.94A2,2,0,0,0,8.45,7H2V9H8.45l4.37,7L8.45,23H2v2H8.45a2,2,0,0,0,1.69-.94L14,17.89l3.86,6.17a2,2,0,0,0,1.69.94h6.62l-3.58,3.59L24,30l6-6-6-6Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Zb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),fg||(fg=n.createElement("path",{d:"M29.81,16l-7-9.56A1,1,0,0,0,22,6H3A1,1,0,0,0,2,7V24a1,1,0,0,0,1,1H5.14a4,4,0,0,0,7.72,0h6.28a4,4,0,0,0,7.72,0H29a1,1,0,0,0,1-1V16.56A1,1,0,0,0,29.81,16ZM20,8h1.49l5.13,7H20ZM4,8H18v7H4ZM9,26a2,2,0,1,1,2-2A2,2,0,0,1,9,26Zm14,0a2,2,0,1,1,2-2A2,2,0,0,1,23,26Zm5-3H26.86a4,4,0,0,0-7.72,0H12.86a4,4,0,0,0-7.72,0H4V17H28Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Pb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),ug||(ug=n.createElement("path",{d:"M10 12H12V14H10zM6 12H8V14H6zM2 12H4V14H2zM26 30H24V27H20a5.0055 5.0055 0 01-5-5V20.7207l-2.3162-.772a1 1 0 01-.5412-1.4631L15 13.7229V11a9.01 9.01 0 019-9h5V4H24a7.0078 7.0078 0 00-7 7v3a.9991.9991 0 01-.1426.5144l-2.3586 3.9312 1.8174.6057A1 1 0 0117 20v2a3.0033 3.0033 0 003 3h5a1 1 0 011 1z"})),cg||(cg=n.createElement("path",{d:"M19 12H23V14H19z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Gb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),pg||(pg=n.createElement("path",{d:"M24 5L7 5 7 7.414 15.586 16 7 24.586 7 27 24 27 24 25 9.414 25 18.414 16 9.414 7 24 7 24 5z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,jb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Eg||(Eg=n.createElement("path",{d:"M26 6H28V26H26zM18 11H20V26H18zM11 16H13V26H11zM4 20H6V26H4z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Kb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),hg||(hg=n.createElement("path",{d:"M21,9H8a2.0023,2.0023,0,0,0-2,2V21a2.0023,2.0023,0,0,0,2,2H21a2.0023,2.0023,0,0,0,2-2V11A2.0023,2.0023,0,0,0,21,9Zm0,4H18V11h3Zm-3,2h3v2H18Zm-2-4V21H13V14a1,1,0,0,0-1-1H8V11Zm-5,6H8V15h3ZM8,19h3v2H8Zm10,2V19h3v2Z"})),gg||(gg=n.createElement("path",{d:"M23.5317,27H4a2.0021,2.0021,0,0,1-2-2V7A2.0021,2.0021,0,0,1,4,5H28a2.0021,2.0021,0,0,1,2,2V19.6379a2.0044,2.0044,0,0,1-.4639,1.2808L25.0679,26.28A1.9944,1.9944,0,0,1,23.5317,27ZM4,7V25H23.5317L28,19.6379V7Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Qb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),wg||(wg=n.createElement("path",{d:"M30 30H22V4h8zm-6-2h4V6H24zM20 30H12V12h8zm-6-2h4V14H14zM10 30H2V18h8zM4 28H8V20H4z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,Jb);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),bg||(bg=n.createElement("path",{d:"M30 30H22V4h8zM20 30H12V12h8zM10 30H2V18h8z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,$b);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),xg||(xg=n.createElement("path",{d:"M30 30H22V4h8zm-6-2h4V6H24zM20 30H12V12h8zm-6-2h4V14H14zM10 30H2V18h8z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ex);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),zg||(zg=n.createElement("path",{d:"M30 30H22V4h8zm-6-2h4V6H24zM20 30H12V12h8zM10 30H2V18h8z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,nx);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Lg||(Lg=n.createElement("path",{d:"M27 28a1 1 0 01-.5-.13l-19-11a1 1 0 010-1.74l19-11a1 1 0 011 0A1 1 0 0128 5V27a1 1 0 01-1 1zM10 16l16 9.27V6.73zM2 4H4V28H2z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,tx);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Mg||(Mg=n.createElement("path",{d:"M27 28a.9975.9975 0 01-.501-.1348l-19-11a1 1 0 010-1.73l19-11A1 1 0 0128 5V27a1 1 0 01-1 1zM2 4H4V28H2z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,ix);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),yg||(yg=n.createElement("path",{d:"M23,22a1.0037,1.0037,0,0,1-.4858-.1257l-9-5a1,1,0,0,1,0-1.7485l9-5A1,1,0,0,1,24,11V21a1,1,0,0,1-1,1Zm-6.9409-6L22,19.3006V12.7Z"})),Rg||(Rg=n.createElement("path",{d:"M9 10H11V22H9z",transform:"rotate(-180 10 16)"})),Sg||(Sg=n.createElement("path",{d:"M16,30A14,14,0,1,1,30,16,14.0158,14.0158,0,0,1,16,30ZM16,4A12,12,0,1,0,28,16,12.0137,12.0137,0,0,0,16,4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,sx);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Ag||(Ag=n.createElement("path",{d:"M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2ZM10,22H8V10h2Zm14-1a1,1,0,0,1-1.4858.874l-9-5a1,1,0,0,1,0-1.748l9-5A1,1,0,0,1,24,11Z"})),Dg||(Dg=n.createElement("path",{d:"M22 19.301L22 12.699 16.059 16 22 19.301z"})),Vg||(Vg=n.createElement("path",{fill:"none",d:"M23,22a1.0037,1.0037,0,0,1-.4858-.1257l-9-5a1,1,0,0,1,0-1.7486l9-5A1,1,0,0,1,24,11V21a1,1,0,0,1-1,1Zm-6.9409-6L22,19.3005V12.7Z"})),Tg||(Tg=n.createElement("path",{fill:"none",d:"M8 10H10V22H8z",transform:"rotate(-180 9 16)"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,lx);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Wg||(Wg=n.createElement("path",{d:"M23,22a1.0037,1.0037,0,0,1-.4858-.1257l-9-5a1,1,0,0,1,0-1.7485l9-5A1,1,0,0,1,24,11V21a1,1,0,0,1-1,1Z"})),Ug||(Ug=n.createElement("path",{d:"M9 10H11V22H9z",transform:"rotate(-180 10 16)"})),Ig||(Ig=n.createElement("path",{d:"M16,30A14,14,0,1,1,30,16,14.0158,14.0158,0,0,1,16,30ZM16,4A12,12,0,1,0,28,16,12.0137,12.0137,0,0,0,16,4Z"})),i)})).propTypes=ol,n.forwardRef((function(e,t){var i=e.children,s=e.size,l=void 0===s?16:s,r=ae(e,rx);return n.createElement(oe,le({width:l,height:l,ref:t,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32",fill:"currentColor"},r),Bg||(Bg=n.createElement("path",{d:"M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2ZM10,22H8V10h2Zm14-1a1,1,0,0,1-1.4858.874l-9-5a1,1,0,0,1,0-1.748l9-5A1,1,0,0,1,24,11Z"})),Og||(Og=n.createElement("path",{fill:"none",d:"M23,22a1.0037,1.0037,0,0,1-.4858-.1257l-9-5a1,1,0,0,1,0-1.7486l9-5A1,1,0,0,1,24,11V21a1,1,0,0,1-1,1Z"})),Fg||(Fg=n.createElement("path",{fill:"none",d:"M8 10H10V22H8z",transform:"rotate(-180 9 16)"})),i)})).propTypes=ol;var _x=["autoComplete","className","closeButtonLabelText","defaultValue","disabled","id","labelText","light","onChange","onClear","onKeyDown","onExpand","placeholder","renderIcon","role","size","type","value"],ox=n.forwardRef((function(e,t){var i,s,l,r=e.autoComplete,a=void 0===r?"off":r,d=e.className,_=e.closeButtonLabelText,o=void 0===_?"Clear search input":_,m=e.defaultValue,v=e.disabled,f=e.id,u=e.labelText,c=e.light,p=e.onChange,E=void 0===p?function(){}:p,h=e.onClear,g=void 0===h?function(){}:h,w=e.onKeyDown,b=e.onExpand,x=e.placeholder,z=void 0===x?"":x,L=e.renderIcon,M=e.role,y=void 0===M?"searchbox":M,R=e.size,S=void 0===R?"md":R,A=e.type,D=void 0===A?"text":A,W=e.value,U=B(e,_x),I=Y(),O=(0,n.useRef)(null),F=(l=[t,O],(0,n.useCallback)((function(e){l.forEach((function(n){"function"===typeof n?n(e):null!==n&&void 0!==n&&(n.current=e)}))}),l)),C=Ia("search-input"),q=f||C,H="".concat(q,"-search"),N=X((0,n.useState)(W||m||!1),2),Z=N[0],P=N[1],G=X((0,n.useState)(W),2),j=G[0],K=G[1],Q=k()((V(i={},"".concat(I,"--search"),!0),V(i,"".concat(I,"--search--sm"),"sm"===S),V(i,"".concat(I,"--search--md"),"md"===S),V(i,"".concat(I,"--search--lg"),"lg"===S),V(i,"".concat(I,"--search--light"),c),V(i,"".concat(I,"--search--disabled"),v),V(i,d,d),i)),J=k()((V(s={},"".concat(I,"--search-close"),!0),V(s,"".concat(I,"--search-close--hidden"),!Z),s));function $(e){if(W){var n=Object.assign({},e.target,{target:{value:""}});E(n)}else O.current.value="",E(e);g(),P(!1),function(e){var n=e.current||e;n&&n.focus&&document.activeElement!==n&&n.focus()}(O)}return W!==j&&(P(!!W),K(W)),n.createElement("div",{role:"search","aria-labelledby":H,className:Q},n.createElement("div",{role:b?"button":null,className:"".concat(I,"--search-magnifier"),onClick:function(){b&&b()}},n.createElement(mx,{icon:L})),n.createElement("label",{id:H,htmlFor:q,className:"".concat(I,"--label")},u),n.createElement("input",T({},U,{autoComplete:a,className:"".concat(I,"--search-input"),defaultValue:m,disabled:v,role:y,ref:F,id:q,onChange:Ld([E,function(e){P(""!==e.target.value)}]),onKeyDown:Ld([w,function(e){qa(e,Ha)&&(e.stopPropagation(),$(e))}]),placeholder:z,type:D,value:W})),n.createElement("button",{"aria-label":o,className:J,disabled:v,onClick:$,type:"button"},ax||(ax=n.createElement(Da,null))))}));function mx(e){var t=e.icon,i=Y();return t?n.cloneElement(t,{className:"".concat(i,"--search-magnifier-icon")}):n.createElement(dx,{className:"".concat(i,"--search-magnifier-icon")})}ox.propTypes={autoComplete:P().string,className:P().string,closeButtonLabelText:P().string,defaultValue:P().oneOfType([P().string,P().number]),disabled:P().bool,id:P().string,labelText:P().node.isRequired,light:Oa(P().bool),onChange:P().func,onClear:P().func,onExpand:P().func,onKeyDown:P().func,placeholder:P().string,renderIcon:P().oneOfType([P().func,P().object]),role:P().string,size:P().oneOf(["sm","md","lg"]),type:P().string,value:P().oneOfType([P().string,P().number])},mx.propTypes={icon:P().oneOfType([P().func,P().object])};var vx,fx=ox,ux=(0,n.createContext)(w);P().node,P().objectOf(P().bool);var cx=["className","type","id","placeHolderText","placeholder","labelText","closeButtonLabelText","small","size","light","disabled","onChange","onKeyDown","renderIcon","onClear"],px=function(e){W(i,e);var t=F(i);function i(){var e;S(this,i);for(var n=arguments.length,s=new Array(n),l=0;l<n;l++)s[l]=arguments[l];return V(O(e=t.call.apply(t,[this].concat(s))),"state",{hasContent:e.props.value||e.props.defaultValue||!1,prevValue:e.props.value}),V(O(e),"clearInput",(function(n){if(e.props.value){var t=Object.assign({},n.target,{target:{value:""}});e.props.onChange(t)}else e.input.value="",e.props.onChange(n);e.props.onClear(),e.setState({hasContent:!1},(function(){return e.input.focus()}))})),V(O(e),"handleChange",(function(n){e.setState({hasContent:""!==n.target.value})})),V(O(e),"handleKeyDown",(function(n){qa(n,Ha)&&e.clearInput(n)})),e}return D(i,[{key:"render",value:function(){var e=this,t=this.props,i=t.className,s=t.type,l=t.id,r=void 0===l?this._inputId=this._inputId||"search__input__id_".concat(Math.random().toString(36).substr(2)):l,a=t.placeHolderText,d=t.placeholder,_=t.labelText,o=t.closeButtonLabelText,m=t.small,v=t.size,f=void 0===v?m?"sm":"xl":v,u=t.light,c=t.disabled,p=t.onChange,E=t.onKeyDown,h=t.renderIcon;t.onClear;var g,w=B(t,cx),b=this.state.hasContent,x=this.context;return x.enabled&&(g=x.enabled("enable-v11-release")),n.createElement(N.Consumer,null,(function(t){var l,m,v,x=k()((V(l={},"".concat(t,"--search"),!0),V(l,"".concat(t,"--search--sm"),"sm"===f),V(l,"".concat(t,"--search--lg"),g?"md"===f:"lg"===f),V(l,"".concat(t,"--search--xl"),g?"lg"===f:"xl"===f),V(l,"".concat(t,"--search--light"),u),V(l,"".concat(t,"--search--disabled"),c),V(l,i,i),l)),z=k()((V(m={},"".concat(t,"--search-close"),!0),V(m,"".concat(t,"--search-close--hidden"),!b),m));h&&(v=n.cloneElement(h,{className:"".concat(t,"--search-magnifier-icon")}));var L="".concat(r,"-search"),M=h?v:n.createElement(dx,{className:"".concat(t,"--search-magnifier-icon")});return n.createElement("div",{role:"search","aria-labelledby":L,className:x},n.createElement("div",{className:"".concat(t,"--search-magnifier"),ref:function(n){e.magnifier=n}},M),n.createElement("label",{id:L,htmlFor:r,className:"".concat(t,"--label")},_),n.createElement("input",T({role:"searchbox",autoComplete:"off"},w,{type:s,disabled:c,className:"".concat(t,"--search-input"),id:r,placeholder:a||d,onChange:Ld([p,e.handleChange]),onKeyDown:Ld([E,e.handleKeyDown]),ref:function(n){e.input=n}})),n.createElement("button",{className:z,disabled:c,onClick:e.clearInput,type:"button","aria-label":o},vx||(vx=n.createElement(Da,null))))}))}}],[{key:"getDerivedStateFromProps",value:function(e,n){var t=e.value;return n.prevValue===t?null:{hasContent:!!t,prevValue:t}}}]),i}(n.Component);V(px,"propTypes",{className:P().string,closeButtonLabelText:P().string,defaultValue:P().oneOfType([P().string,P().number]),disabled:P().bool,id:P().string,labelText:P().node.isRequired,light:P().bool,onChange:P().func,onClear:P().func,onKeyDown:P().func,placeHolderText:Oa(P().string),placeholder:P().string,renderIcon:P().oneOfType([P().func,P().object]),size:P().oneOf(["sm","md","lg","xl"]),small:Oa(P().bool),type:P().string,value:P().oneOfType([P().string,P().number])}),V(px,"contextType",ux),V(px,"defaultProps",{type:"text",placeholder:"",closeButtonLabelText:"Clear search input",onChange:function(){},onClear:function(){}});var Ex=L("enable-v11-release")?fx:px;var hx,gx=(hx={"aria-label":P().string,"aria-labelledby":P().string},Object.keys(hx).reduce((function(e,n){return y(y({},e),{},V({},n,(t=hx[n],function(e,n,i){for(var s=arguments.length,l=new Array(s>3?s-3:0),r=3;r<s;r++)l[r-3]=arguments[r];return t.apply(void 0,[e,n,i].concat(l))})));var t}),{})),wx=["aria-label","aria-labelledby","children","className"],bx=function(e){W(i,e);var t=F(i);function i(e){var s;return S(this,i),V(O(s=t.call(this,e)),"handleItemRef",(function(e){return function(n){s.items[e]=n}})),V(O(s),"_renderNavItem",(function(e,t){if(n.isValidElement(e))return n.cloneElement(e,{ref:s.handleItemRef(t)})})),s.items=[],s.state={selectedIndex:0},s}return D(i,[{key:"render",value:function(){var e=this.context,t=this.props,i=t["aria-label"],s=t["aria-labelledby"],l=t.children,r=t.className,a=B(t,wx),d=k()("".concat(e,"--header__nav"),r),_={"aria-label":i,"aria-labelledby":s};return n.createElement("nav",T({},a,_,{className:d}),n.createElement("ul",T({},_,{className:"".concat(e,"--header__menu-bar")}),n.Children.map(l,this._renderNavItem)))}}]),i}(n.Component);V(bx,"propTypes",y(y({},gx),{},{children:P().node,className:P().string})),V(bx,"contextType",N);var xx=function(e){var t,i=e.children,s=e.className,l=e.small,r=Y(),a=k()((V(t={},"".concat(r,"--side-nav__icon"),!0),V(t,"".concat(r,"--side-nav__icon--small"),l),V(t,s,!!s),t));return n.createElement("div",{className:a},i)};xx.propTypes={children:P().node.isRequired,className:P().string,small:P().bool.isRequired},xx.defaultProps={small:!1};var zx,Lx=xx,Mx=function(e){W(i,e);var t=F(i);function i(e){var n;return S(this,i),V(O(n=t.call(this,e)),"handleToggleExpand",(function(){n.setState((function(e){return{isExpanded:!e.isExpanded}}))})),V(O(n),"handleKeyDown",(function(e){qa(e,Ha)&&n.setState((function(){return{isExpanded:!1}}))})),n.state={isExpanded:e.defaultExpanded||!1,wasPreviouslyExpanded:e.defaultExpanded||!1},n}return D(i,[{key:"render",value:function(){var e,t,i=this.context,s=this.props,l=s.buttonRef,r=s.className,a=s.children,d=s.renderIcon,_=s.isActive,o=s.title,m=s.large,v=this.state.isExpanded;a&&(t=Array.isArray(a)?a.some((function(e){return!(!e.props||!0!==e.props.isActive&&!e.props["aria-current"])})):a.props&&(!0===a.props.isActive||a.props["aria-current"]));var f=k()((V(e={},"".concat(i,"--side-nav__item"),!0),V(e,"".concat(i,"--side-nav__item--active"),_||t&&!v),V(e,"".concat(i,"--side-nav__item--icon"),d),V(e,"".concat(i,"--side-nav__item--large"),m),V(e,r,!!r),e));return n.createElement("li",{className:f,onKeyDown:this.handleKeyDown},n.createElement("button",{"aria-expanded":v,className:"".concat(i,"--side-nav__submenu"),onClick:this.handleToggleExpand,ref:l,type:"button"},d&&n.createElement(Lx,null,n.createElement(d,null)),n.createElement("span",{className:"".concat(i,"--side-nav__submenu-title")},o),n.createElement(Lx,{className:"".concat(i,"--side-nav__submenu-chevron"),small:!0},zx||(zx=n.createElement(Sa,{size:20})))),n.createElement("ul",{className:"".concat(i,"--side-nav__menu")},a))}}]),i}(n.Component);V(Mx,"contextType",N),V(Mx,"propTypes",{buttonRef:P().oneOfType([P().func,P().shape({current:P().any})]),children:P().node,className:P().string,defaultExpanded:P().bool,isActive:P().bool,isSideNavExpanded:P().bool,large:P().bool,renderIcon:P().oneOfType([P().func,P().object]),title:P().string.isRequired}),V(Mx,"defaultProps",{defaultExpanded:!1,isActive:!1,large:!1}),V(Mx,"getDerivedStateFromProps",(function(e,n){var t=null;return!1===e.isSideNavExpanded&&!0===n.isExpanded?t={isExpanded:e.isSideNavExpanded,wasPreviouslyExpanded:!0}:!0===e.isSideNavExpanded&&!0===n.wasPreviouslyExpanded&&(t={isExpanded:e.isSideNavExpanded,wasPreviouslyExpanded:!1}),t}));var yx=n.forwardRef((function(e,t){return n.createElement(Mx,T({},e,{buttonRef:t}))}));yx.displayName="SideNavMenu";var Rx,Sx=yx,Ax=n.forwardRef((function(e,t){var i,s=e.className,l=e.children,r=e.defaultExpanded,a=void 0!==r&&r,d=e.isActive,_=void 0!==d&&d,o=e.large,m=void 0!==o&&o,v=e.renderIcon,f=e.isSideNavExpanded,u=e.title,c=Y(),p=X((0,n.useState)(a),2),E=p[0],h=p[1],g=X((0,n.useState)(a),2),w=g[0],b=g[1],x=k()((V(i={},"".concat(c,"--side-nav__item"),!0),V(i,"".concat(c,"--side-nav__item--active"),_||function(e){if(Array.isArray(e))return e.some((function(e){return!!e.props&&(!0===e.props.isActive||!!e.props["aria-current"])}));if(e.props&&(!0===e.props.isActive||e.props["aria-current"]))return!0;return!1}(l)&&!E),V(i,"".concat(c,"--side-nav__item--icon"),v),V(i,"".concat(c,"--side-nav__item--large"),m),V(i,s,!!s),i));return!1===f&&!0===E?(h(!1),b(!0)):!0===f&&!0===w&&(h(!0),b(!1)),n.createElement("li",{className:x,onKeyDown:function(e){qa(e,Ha)&&h(!1)}},n.createElement("button",{"aria-expanded":E,className:"".concat(c,"--side-nav__submenu"),onClick:function(){h(!E)},ref:t,type:"button"},v&&n.createElement(Lx,null,n.createElement(v,null)),n.createElement("span",{className:"".concat(c,"--side-nav__submenu-title")},u),n.createElement(Lx,{className:"".concat(c,"--side-nav__submenu-chevron"),small:!0},Rx||(Rx=n.createElement(Sa,{size:20})))),n.createElement("ul",{className:"".concat(c,"--side-nav__menu")},l))}));Ax.propTypes={children:P().node,className:P().string,defaultExpanded:P().bool,isActive:P().bool,isSideNavExpanded:P().bool,large:P().bool,renderIcon:P().oneOfType([P().func,P().object]),title:P().string.isRequired};var Dx=["aria-label","aria-labelledby","children","className"];function Vx(e){var t=e["aria-label"],i=e["aria-labelledby"],s=e.children,l=e.className,r=B(e,Dx),a=Y(),d=k()("".concat(a,"--header__nav"),l),_={"aria-label":t,"aria-labelledby":i};return n.createElement("nav",T({},r,_,{className:d}),n.createElement("ul",{className:"".concat(a,"--header__menu-bar")},s))}Vx.propTypes=y(y({},gx),{},{children:P().node,className:P().string});var Tx=L("enable-v11-release")?Vx:bx,Wx=(L("enable-v11-release"),["className","children"]),Ux=function(e){var t=e.className,i=e.children,s=B(e,Wx),l=Y(),r=k()("".concat(l,"--header"),t);return n.createElement("header",T({},s,{className:r}),i)};Ux.propTypes=y(y({},gx),{},{className:P().string});var Ix=Ux,Bx=["element","isSideNavExpanded"],Ox=n.forwardRef((function(e,t){var i=e.element;e.isSideNavExpanded;var s=B(e,Bx);return n.createElement(i,y(y({},s),{},{ref:t}))})),Fx={element:P().elementType,isSideNavExpanded:P().bool};Ox.displayName="Link",Ox.propTypes=Fx,Ox.defaultProps={element:"a"};var Xx=Ox,Cx=["className","isCurrentPage","aria-current","children","role","tabIndex"],qx=n.forwardRef((function(e,t){var i,s=e.className,l=e.isCurrentPage,r=e["aria-current"],a=e.children,d=e.role,_=e.tabIndex,o=void 0===_?0:_,m=B(e,Cx),v=Y(),f=k()((V(i={},"".concat(v,"--header__menu-item"),!0),V(i,"".concat(v,"--header__menu-item--current"),l&&"page"!==r),i));return n.createElement("li",{className:s,role:d},n.createElement(Xx,T({},m,{"aria-current":r,className:f,ref:t,tabIndex:o}),n.createElement("span",{className:"".concat(v,"--text-truncate--end")},a)))}));qx.displayName="HeaderMenuItem",qx.propTypes=y(y({},Fx),{},{children:P().node.isRequired,className:P().string,isCurrentPage:P().bool,role:P().string,tabIndex:P().number});var Hx=qx,kx=["children","className","prefix","href"],Nx=function(e){var t=e.children,i=e.className,s=e.prefix,l=e.href,r=B(e,kx),a=Y(),d=k()("".concat(a,"--header__name"),i);return n.createElement(Xx,T({},r,{className:d,href:l}),s&&n.createElement(n.Fragment,null,n.createElement("span",{className:"".concat(a,"--header__name--prefix")},s),"\xa0"),t)};Nx.propTypes=y(y({},Fx),{},{children:P().node.isRequired,className:P().string,href:P().string,prefix:P().string}),Nx.defaultProps={prefix:"IBM"};var Yx=Nx,Zx=t(184),Px=function(e){d(t,e);var n=v(t);function t(){return s(this,t),n.apply(this,arguments)}return r(t,[{key:"render",value:function(){var e=this.props,n=(e.isDarkMode,e.toggleDarkMode);return(0,Zx.jsx)("div",{children:(0,Zx.jsxs)(Ix,{"aria-label":"RISC-V ISA",children:[(0,Zx.jsx)(Yx,{href:"#",prefix:"RISC-V",children:"ISA Reference"}),(0,Zx.jsxs)(Tx,{"aria-label":"ISA",children:[(0,Zx.jsx)(Hx,{children:"|"}),(0,Zx.jsx)(Hx,{href:"https://riscv.org",children:"RISC-V International"}),(0,Zx.jsx)(Hx,{href:"https://riscv.org/technical/specifications/",children:"RISC-V Specifications"}),(0,Zx.jsx)(Hx,{href:"https://GitHub.com/riscv/sail-riscv",children:"RISC-V Sail Model"}),(0,Zx.jsx)(Hx,{href:"https://github.com/ThinkOpenly/sail/tree/json",children:"RISC-V Sail to JSON"})]}),(0,Zx.jsxs)("button",{id:"theme-switch",onClick:n,children:[(0,Zx.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",height:"24px",viewBox:"0 -960 960 960",width:"24px",fill:"#5f6368",children:(0,Zx.jsx)("path",{d:"M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Z"})}),(0,Zx.jsx)("svg",{xmlns:"http://www.w3.org/2000/svg",height:"24px",viewBox:"0 -960 960 960",width:"24px",fill:"#e8e8e8",children:(0,Zx.jsx)("path",{d:"M480-280q-83 0-141.5-58.5T280-480q0-83 58.5-141.5T480-680q83 0 141.5 58.5T680-480q0 83-58.5 141.5T480-280ZM200-440H40v-80h160v80Zm720 0H760v-80h160v80ZM440-760v-160h80v160h-80Zm0 720v-160h80v160h-80ZM256-650l-101-97 57-59 96 100-52 56Zm492 496-97-101 53-55 101 97-57 59Zm-98-550 97-101 59 57-100 96-56-52ZM154-212l101-97 55 53-97 101-59-57Z"})})]})]})})}}]),t}(n.Component),Gx=Px,jx=JSON.parse('{"NE":[{"mnemonic":"add","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"rop"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ADD  => rs1_val + rs2_val,\\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\\n    RISCV_AND  => rs1_val & rs2_val,\\n    RISCV_OR   => rs1_val | rs2_val,\\n    RISCV_XOR  => rs1_val ^ rs2_val,\\n    RISCV_SLL  => if   sizeof(xlen) == 32\\n                  then rs1_val << (rs2_val[4..0])\\n                  else rs1_val << (rs2_val[5..0]),\\n    RISCV_SRL  => if   sizeof(xlen) == 32\\n                  then rs1_val >> (rs2_val[4..0])\\n                  else rs1_val >> (rs2_val[5..0]),\\n    RISCV_SUB  => rs1_val - rs2_val,\\n    RISCV_SRA  => if   sizeof(xlen) == 32\\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe R-type (Register-type) instruction format is used for operations\\nthat involve three registers. The specific operation is determined\\nby the opcode and funct7 fields. The result is written to the\\ndestination register (rd), and the source operands are specified\\nby the source registers (rs1 and rs2). The format is common for\\narithmetic, logical, and shift operations.\\n "},{"mnemonic":"add.uw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"bropw_zba"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zba"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let shamt : bits(2) = match op {\\n    RISCV_ADDUW    => 0b00,\\n    RISCV_SH1ADDUW => 0b01,\\n    RISCV_SH2ADDUW => 0b10,\\n    RISCV_SH3ADDUW => 0b11\\n  };\\n  let result : xlenbits = (zero_extend(rs1_val[31..0]) << shamt) + rs2_val;\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"addi","name":"TBD","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"iop"}],"syntax":"rd,rs1,imm","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"encdec_iop(op)","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let immext : xlenbits = sign_extend(imm);\\n  let result : xlenbits = match op {\\n    RISCV_ADDI  => rs1_val + immext,\\n    RISCV_SLTI  => zero_extend(bool_to_bits(rs1_val <_s immext)),\\n    RISCV_SLTIU => zero_extend(bool_to_bits(rs1_val <_u immext)),\\n    RISCV_ANDI  => rs1_val & immext,\\n    RISCV_ORI   => rs1_val | immext,\\n    RISCV_XORI  => rs1_val ^ immext\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe ITYPE instruction operates on an immediate value, adding, comparing, or\\nperforming bitwise operations with the contents of register rs1.\\nThe immediate value, rs1, and the operation code (iop) determine the operation.\\nThe result is stored in register rd.\\nThe supported immediate operations (iop) include:\\n  - \\"addi\\"  : Add immediate\\n  - \\"slti\\"  : Set less than immediate (signed)\\n  - \\"sltiu\\" : Set less than immediate (unsigned)\\n  - \\"andi\\"  : AND immediate\\n  - \\"ori\\"   : OR immediate\\n  - \\"xori\\"  : XOR immediate\\n *\\nNote: The immediate value is sign-extended before performing the operation.\\n "},{"mnemonic":"addiw","name":"Add Immediate Word","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,imm","format":"I","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":[],"function":"{\\n  let result : xlenbits = sign_extend(imm) + X(rs1);\\n  X(rd) = sign_extend(result[31..0]);\\n  RETIRE_SUCCESS\\n}","description":"\\nThe ADDIW instruction involves adding a sign-extended\\n12-bit immediate value to the content of register rs1. The result is a 32-bit\\nvalue, and overflow is disregarded. The final outcome is the lower 32 bits of\\nthe result, sign-extended to 64 bits. If the immediate value is set to zero\\nin the ADDIW rd, rs1, 0 operation, the sign-extension of the lower 32 bits\\nof register rs1 is written to register rd.\\n "},{"mnemonic":"addw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"ropw"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = (X(rs1))[31..0];\\n  let rs2_val = (X(rs2))[31..0];\\n  let result : bits(32) = match op {\\n    RISCV_ADDW => rs1_val + rs2_val,\\n    RISCV_SUBW => rs1_val - rs2_val,\\n    RISCV_SLLW => rs1_val << (rs2_val[4..0]),\\n    RISCV_SRLW => rs1_val >> (rs2_val[4..0]),\\n    RISCV_SRAW => shift_right_arith32(rs1_val, rs2_val[4..0])\\n  };\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"\\nThe RTYPEW instruction set operates on 32-bit values,\\nand the result is sign-extended to 64 bits. The available operations are\\nADDW (addition), SUBW (subtraction), SLLW (logical left shift),\\nSRLW (logical right shift), and SRAW (arithmetic right shift).\\nThese operations are only applicable when the width of the target\\narchitecture is 64 bits.\\n "},{"mnemonic":"aes32dsi","name":"TBD","operands":[{"name":"bs","type":"bits(2)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2,bs","format":"TBD","fields":[{"field":"bs","size":2},{"field":"0b10101","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknd"],"function":"{\\n  let shamt   : bits( 5) = bs @ 0b000; /* shamt = bs*8 */\\n  let si      : bits( 8) = (X(rs2) >> shamt)[7..0]; /* SBox Input */\\n  let so      : bits(32) = 0x000000 @ aes_sbox_inv(si);\\n  let result  : bits(32) = X(rs1)[31..0] ^ (so <<< shamt);\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"aes32dsmi","name":"TBD","operands":[{"name":"bs","type":"bits(2)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2,bs","format":"TBD","fields":[{"field":"bs","size":2},{"field":"0b10111","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknd"],"function":"{\\n  let shamt   : bits( 5) = bs @ 0b000; /* shamt = bs*8 */\\n  let si      : bits( 8) = (X(rs2) >> shamt)[7..0]; /* SBox Input */\\n  let so      : bits( 8) = aes_sbox_inv(si);\\n  let mixed   : bits(32) = aes_mixcolumn_byte_inv(so);\\n  let result  : bits(32) = X(rs1)[31..0] ^ (mixed <<< shamt);\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"aes32esi","name":"TBD","operands":[{"name":"bs","type":"bits(2)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2,bs","format":"TBD","fields":[{"field":"bs","size":2},{"field":"0b10001","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zkne"],"function":"{\\n  let shamt   : bits( 5) = bs @ 0b000; /* shamt = bs*8 */\\n  let si      : bits( 8) = (X(rs2) >> shamt)[7..0]; /* SBox Input */\\n  let so      : bits(32) = 0x000000 @ aes_sbox_fwd(si);\\n  let result  : bits(32) = X(rs1)[31..0] ^ (so <<< shamt);\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"aes32esmi","name":"TBD","operands":[{"name":"bs","type":"bits(2)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2,bs","format":"TBD","fields":[{"field":"bs","size":2},{"field":"0b10011","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zkne"],"function":"{\\n  let shamt   : bits( 5) = bs @ 0b000; /* shamt = bs*8 */\\n  let si      : bits( 8) = (X(rs2) >> shamt)[7..0]; /* SBox Input */\\n  let so      : bits( 8) = aes_sbox_fwd(si);\\n  let mixed   : bits(32) = aes_mixcolumn_byte_fwd(so);\\n  let result  : bits(32) = X(rs1)[31..0] ^ (mixed <<< shamt);\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"aes64ds","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b11101","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknd"],"function":"{\\n  assert(sizeof(xlen) == 64);\\n  let sr : bits(64) = aes_rv64_shiftrows_inv(X(rs2), X(rs1));\\n  let wd : bits(64) = sr[63..0];\\n  X(rd) = aes_apply_inv_sbox_to_each_byte(wd);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"aes64dsm","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b11111","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknd"],"function":"{\\n  assert(sizeof(xlen) == 64);\\n  let sr : bits(64) = aes_rv64_shiftrows_inv(X(rs2), X(rs1));\\n  let wd : bits(64) = sr[63..0];\\n  let sb : bits(64) = aes_apply_inv_sbox_to_each_byte(wd);\\n  X(rd) = aes_mixcolumn_inv(sb[63..32]) @ aes_mixcolumn_inv(sb[31..0]);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"aes64es","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b11001","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zkne"],"function":"{\\n  assert(sizeof(xlen) == 64);\\n  let sr : bits(64) = aes_rv64_shiftrows_fwd(X(rs2), X(rs1));\\n  let wd : bits(64) = sr[63..0];\\n  X(rd) = aes_apply_fwd_sbox_to_each_byte(wd);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"aes64esm","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b11011","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zkne"],"function":"{\\n  assert(sizeof(xlen) == 64);\\n  let sr : bits(64) = aes_rv64_shiftrows_fwd(X(rs2), X(rs1));\\n  let wd : bits(64) = sr[63..0];\\n  let sb : bits(64) = aes_apply_fwd_sbox_to_each_byte(wd);\\n  X(rd)  = aes_mixcolumn_fwd(sb[63..32]) @ aes_mixcolumn_fwd(sb[31..0]);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"aes64im","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b11000","size":5},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknd"],"function":"{\\n  assert(sizeof(xlen) == 64);\\n  let w0 : bits(32) = aes_mixcolumn_inv(X(rs1)[31.. 0]);\\n  let w1 : bits(32) = aes_mixcolumn_inv(X(rs1)[63..32]);\\n  X(rd)  = w1 @ w0;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"aes64ks1i","name":"TBD","operands":[{"name":"rnum","type":"bits(4)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rnum","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b11000","size":5},{"field":"0b1","size":1},{"field":"rnum","size":4},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zkne","Zknd"],"function":"{\\n  assert(sizeof(xlen) == 64);\\n  let prev     : bits(32) = X(rs1)[63..32];\\n  let subwords : bits(32) = aes_subword_fwd(prev);\\n  let result   : bits(32) = if (rnum == 0xA) then subwords\\n                            else (subwords >>> 8) ^ aes_decode_rcon(rnum);\\n  X(rd) = result @ result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"aes64ks2","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b01","size":2},{"field":"0b11111","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zkne","Zknd"],"function":"{\\n  assert(sizeof(xlen) == 64);\\n  let w0 : bits(32) = X(rs1)[63..32] ^ X(rs2)[31..0];\\n  let w1 : bits(32) = X(rs1)[63..32] ^ X(rs2)[31..0] ^ X(rs2)[63..32];\\n  X(rd)  = w1 @ w0;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"amoadd.b","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoadd.b.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoadd.b.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoadd.b.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoadd.d","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoadd.d.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoadd.d.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoadd.d.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoadd.h","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoadd.h.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoadd.h.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoadd.h.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoadd.w","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoadd.w.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoadd.w.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoadd.w.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoand.b","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoand.b.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoand.b.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoand.b.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoand.d","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoand.d.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoand.d.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoand.d.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoand.h","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoand.h.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoand.h.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoand.h.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoand.w","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoand.w.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoand.w.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoand.w.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomax.b","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomax.b.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomax.b.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomax.b.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomax.d","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomax.d.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomax.d.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomax.d.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomax.h","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomax.h.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomax.h.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomax.h.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomax.w","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomax.w.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomax.w.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomax.w.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomaxu.b","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomaxu.b.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomaxu.b.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomaxu.b.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomaxu.d","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomaxu.d.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomaxu.d.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomaxu.d.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomaxu.h","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomaxu.h.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomaxu.h.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomaxu.h.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomaxu.w","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomaxu.w.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomaxu.w.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomaxu.w.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomin.b","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomin.b.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomin.b.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomin.b.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomin.d","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomin.d.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomin.d.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomin.d.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomin.h","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomin.h.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomin.h.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomin.h.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomin.w","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomin.w.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomin.w.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amomin.w.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amominu.b","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amominu.b.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amominu.b.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amominu.b.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amominu.d","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amominu.d.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amominu.d.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amominu.d.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amominu.h","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amominu.h.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amominu.h.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amominu.h.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amominu.w","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amominu.w.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amominu.w.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amominu.w.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoor.b","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoor.b.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoor.b.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoor.b.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoor.d","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoor.d.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoor.d.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoor.d.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoor.h","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoor.h.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoor.h.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoor.h.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoor.w","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoor.w.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoor.w.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoor.w.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoswap.b","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoswap.b.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoswap.b.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoswap.b.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoswap.d","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoswap.d.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoswap.d.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoswap.d.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoswap.h","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoswap.h.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoswap.h.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoswap.h.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoswap.w","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoswap.w.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoswap.w.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoswap.w.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoxor.b","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoxor.b.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoxor.b.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoxor.b.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoxor.d","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoxor.d.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoxor.d.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoxor.d.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoxor.h","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoxor.h.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoxor.h.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoxor.h.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoxor.w","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoxor.w.aq","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoxor.w.aq.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"amoxor.w.rl","name":"TBD","operands":[{"name":"op","type":"amoop"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs2,(rs1)","format":"TBD","fields":[{"field":"encdec_amoop(op)","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Some extensions perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), ReadWrite(Data, Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        match translateAddr(vaddr, ReadWrite(Data, Data)) {\\n          TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n          TR_Address(addr, _) => {\\n            let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n              (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n              (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n              (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n              (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n              _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n            };\\n            let is_unsigned : bool = match op {\\n              AMOMINU => true,\\n              AMOMAXU => true,\\n              _       => false\\n            };\\n            let rs2_val : xlenbits = match width {\\n              BYTE   => if is_unsigned then zero_extend(X(rs2)[7..0])  else sign_extend(X(rs2)[7..0]),\\n              HALF   => if is_unsigned then zero_extend(X(rs2)[15..0]) else sign_extend(X(rs2)[15..0]),\\n              WORD   => if is_unsigned then zero_extend(X(rs2)[31..0]) else sign_extend(X(rs2)[31..0]),\\n              DOUBLE => X(rs2)\\n            };\\n            match (eares) {\\n              MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n              MemValue(_) => {\\n                let mval : MemoryOpResult(xlenbits) = match (width, sizeof(xlen)) {\\n                  (BYTE, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 1, aq, aq & rl, true)),\\n                  (HALF, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 2, aq, aq & rl, true)),\\n                  (WORD, _)    => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 4, aq, aq & rl, true)),\\n                  (DOUBLE, 64) => extend_value(is_unsigned, mem_read(ReadWrite(Data, Data), addr, 8, aq, aq & rl, true)),\\n                  _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                };\\n                match (mval) {\\n                  MemException(e)  => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                  MemValue(loaded) => {\\n                    let result : xlenbits =\\n                      match op {\\n                        AMOSWAP => rs2_val,\\n                        AMOADD  => rs2_val + loaded,\\n                        AMOXOR  => rs2_val ^ loaded,\\n                        AMOAND  => rs2_val & loaded,\\n                        AMOOR   => rs2_val | loaded,\\n\\n                        /* These operations convert bitvectors to integer values using [un]signed,\\n                         * and back using to_bits().\\n                         */\\n                        AMOMIN  => to_bits(sizeof(xlen), min(signed(rs2_val),   signed(loaded))),\\n                        AMOMAX  => to_bits(sizeof(xlen), max(signed(rs2_val),   signed(loaded))),\\n                        AMOMINU => to_bits(sizeof(xlen), min(unsigned(rs2_val), unsigned(loaded))),\\n                        AMOMAXU => to_bits(sizeof(xlen), max(unsigned(rs2_val), unsigned(loaded)))\\n                      };\\n                    let rval : xlenbits = match width {\\n                      BYTE   => sign_extend(loaded[7..0]),\\n                      HALF   => sign_extend(loaded[15..0]),\\n                      WORD   => sign_extend(loaded[31..0]),\\n                      DOUBLE => loaded\\n                    };\\n                    let wval : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                      (BYTE, _)    => mem_write_value(addr, 1, result[7..0],  aq & rl, rl, true),\\n                      (HALF, _)    => mem_write_value(addr, 2, result[15..0], aq & rl, rl, true),\\n                      (WORD, _)    => mem_write_value(addr, 4, result[31..0], aq & rl, rl, true),\\n                      (DOUBLE, 64) => mem_write_value(addr, 8, result,        aq & rl, rl, true),\\n                      _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                    };\\n                    match (wval) {\\n                      MemValue(true)  => { X(rd) = rval; RETIRE_SUCCESS },\\n                      MemValue(false) => { internal_error(__FILE__, __LINE__, \\"AMO got false from mem_write_value\\") },\\n                      MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"and","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"rop"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ADD  => rs1_val + rs2_val,\\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\\n    RISCV_AND  => rs1_val & rs2_val,\\n    RISCV_OR   => rs1_val | rs2_val,\\n    RISCV_XOR  => rs1_val ^ rs2_val,\\n    RISCV_SLL  => if   sizeof(xlen) == 32\\n                  then rs1_val << (rs2_val[4..0])\\n                  else rs1_val << (rs2_val[5..0]),\\n    RISCV_SRL  => if   sizeof(xlen) == 32\\n                  then rs1_val >> (rs2_val[4..0])\\n                  else rs1_val >> (rs2_val[5..0]),\\n    RISCV_SUB  => rs1_val - rs2_val,\\n    RISCV_SRA  => if   sizeof(xlen) == 32\\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe R-type (Register-type) instruction format is used for operations\\nthat involve three registers. The specific operation is determined\\nby the opcode and funct7 fields. The result is written to the\\ndestination register (rd), and the source operands are specified\\nby the source registers (rs1 and rs2). The format is common for\\narithmetic, logical, and shift operations.\\n "},{"mnemonic":"andi","name":"TBD","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"iop"}],"syntax":"rd,rs1,imm","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"encdec_iop(op)","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let immext : xlenbits = sign_extend(imm);\\n  let result : xlenbits = match op {\\n    RISCV_ADDI  => rs1_val + immext,\\n    RISCV_SLTI  => zero_extend(bool_to_bits(rs1_val <_s immext)),\\n    RISCV_SLTIU => zero_extend(bool_to_bits(rs1_val <_u immext)),\\n    RISCV_ANDI  => rs1_val & immext,\\n    RISCV_ORI   => rs1_val | immext,\\n    RISCV_XORI  => rs1_val ^ immext\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe ITYPE instruction operates on an immediate value, adding, comparing, or\\nperforming bitwise operations with the contents of register rs1.\\nThe immediate value, rs1, and the operation code (iop) determine the operation.\\nThe result is stored in register rd.\\nThe supported immediate operations (iop) include:\\n  - \\"addi\\"  : Add immediate\\n  - \\"slti\\"  : Set less than immediate (signed)\\n  - \\"sltiu\\" : Set less than immediate (unsigned)\\n  - \\"andi\\"  : AND immediate\\n  - \\"ori\\"   : OR immediate\\n  - \\"xori\\"  : XOR immediate\\n *\\nNote: The immediate value is sign-extended before performing the operation.\\n "},{"mnemonic":"andn","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zbb"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ANDN => rs1_val & ~(rs2_val),\\n    RISCV_ORN  => rs1_val | ~(rs2_val),\\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_ROL  => if sizeof(xlen) == 32\\n                  then rs1_val <<< rs2_val[4..0]\\n                  else rs1_val <<< rs2_val[5..0],\\n    RISCV_ROR  => if sizeof(xlen) == 32\\n                  then rs1_val >>> rs2_val[4..0]\\n                  else rs1_val >>> rs2_val[5..0]\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"auipc","name":"TBD","operands":[{"name":"imm","type":"bits(20)"},{"name":"rd","type":"regidx"},{"name":"op","type":"uop"}],"syntax":"rd,imm","format":"TBD","fields":[{"field":"imm","size":20},{"field":"rd","size":5},{"field":"encdec_uop(op)","size":7}],"extensions":[],"function":"{\\n  let off : xlenbits = sign_extend(imm @ 0x000);\\n  let ret : xlenbits = match op {\\n    RISCV_LUI   => off,\\n    RISCV_AUIPC => get_arch_pc() + off\\n  };\\n  X(rd) = ret;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"bclr","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zbs"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbs"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let mask : xlenbits = if sizeof(xlen) == 32\\n                        then zero_extend(0b1) << rs2_val[4..0]\\n                        else zero_extend(0b1) << rs2_val[5..0];\\n  let result : xlenbits = match op {\\n    RISCV_BCLR => rs1_val & ~(mask),\\n    RISCV_BEXT => zero_extend(bool_to_bits((rs1_val & mask) != zeros())),\\n    RISCV_BINV => rs1_val ^ mask,\\n    RISCV_BSET => rs1_val | mask\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"bclri","name":"TBD","operands":[{"name":"shamt","type":"bits(6)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"biop_zbs"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b001010","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbs"],"function":"{\\n  let rs1_val = X(rs1);\\n  let mask : xlenbits = if sizeof(xlen) == 32\\n                        then zero_extend(0b1) << shamt[4..0]\\n                        else zero_extend(0b1) << shamt;\\n  let result : xlenbits = match op {\\n    RISCV_BCLRI => rs1_val & ~(mask),\\n    RISCV_BEXTI => zero_extend(bool_to_bits((rs1_val & mask) != zeros())),\\n    RISCV_BINVI => rs1_val ^ mask,\\n    RISCV_BSETI => rs1_val | mask\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"beq","name":"Conditional Branch","operands":[{"name":"imm","type":"bits(13)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"op","type":"bop"}],"syntax":"rs1,rs2,imm","format":"TBD","fields":[{"field":"imm7_6","size":1},{"field":"imm7_5_0","size":6},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_bop(op)","size":3},{"field":"imm5_4_1","size":4},{"field":"imm5_0","size":1},{"field":"0b1100011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let taken : bool = match op {\\n    RISCV_BEQ  => rs1_val == rs2_val,\\n    RISCV_BNE  => rs1_val != rs2_val,\\n    RISCV_BLT  => rs1_val <_s rs2_val,\\n    RISCV_BGE  => rs1_val >=_s rs2_val,\\n    RISCV_BLTU => rs1_val <_u rs2_val,\\n    RISCV_BGEU => rs1_val >=_u rs2_val\\n  };\\n  let t : xlenbits = PC + sign_extend(imm);\\n  if taken then {\\n    /* Extensions get the first checks on the prospective target address. */\\n    match ext_control_check_pc(t) {\\n      Ext_ControlAddr_Error(e) => {\\n        ext_handle_control_check_error(e);\\n        RETIRE_FAIL\\n      },\\n      Ext_ControlAddr_OK(target) => {\\n        if bit_to_bool(target[1]) & not(extension(\\"C\\")) then {\\n          handle_mem_exception(target, E_Fetch_Addr_Align());\\n          RETIRE_FAIL;\\n        } else {\\n          set_next_pc(target);\\n          RETIRE_SUCCESS\\n        }\\n      }\\n    }\\n  } else RETIRE_SUCCESS\\n}","description":"\\nThe target address for this branch instruction is determined by combining\\nthe sign-extended 13-bit immediate value with the contents of register rs1.\\nAdditionally, the least-significant bit of the result is set to zero.\\nThe condition for the branch is based on the specified operation (bop),\\nwhich can be one of the following mnemonic codes:\\n  - \\"beq\\"   : Branch if equal\\n  - \\"bne\\"   : Branch if not equal\\n  - \\"blt\\"   : Branch if less than (signed)\\n  - \\"bge\\"   : Branch if greater than or equal to (signed)\\n  - \\"bltu\\"  : Branch if less than (unsigned)\\n  - \\"bgeu\\"  : Branch if greater than or equal to (unsigned)\\n *\\nThe branch is taken if the specified condition is true, leading to a jump\\nto the target address. If the branch is not taken, the execution proceeds\\nto the next instruction.\\n "},{"mnemonic":"bext","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zbs"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbs"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let mask : xlenbits = if sizeof(xlen) == 32\\n                        then zero_extend(0b1) << rs2_val[4..0]\\n                        else zero_extend(0b1) << rs2_val[5..0];\\n  let result : xlenbits = match op {\\n    RISCV_BCLR => rs1_val & ~(mask),\\n    RISCV_BEXT => zero_extend(bool_to_bits((rs1_val & mask) != zeros())),\\n    RISCV_BINV => rs1_val ^ mask,\\n    RISCV_BSET => rs1_val | mask\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"bexti","name":"TBD","operands":[{"name":"shamt","type":"bits(6)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"biop_zbs"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b001010","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbs"],"function":"{\\n  let rs1_val = X(rs1);\\n  let mask : xlenbits = if sizeof(xlen) == 32\\n                        then zero_extend(0b1) << shamt[4..0]\\n                        else zero_extend(0b1) << shamt;\\n  let result : xlenbits = match op {\\n    RISCV_BCLRI => rs1_val & ~(mask),\\n    RISCV_BEXTI => zero_extend(bool_to_bits((rs1_val & mask) != zeros())),\\n    RISCV_BINVI => rs1_val ^ mask,\\n    RISCV_BSETI => rs1_val | mask\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"bge","name":"Conditional Branch","operands":[{"name":"imm","type":"bits(13)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"op","type":"bop"}],"syntax":"rs1,rs2,imm","format":"TBD","fields":[{"field":"imm7_6","size":1},{"field":"imm7_5_0","size":6},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_bop(op)","size":3},{"field":"imm5_4_1","size":4},{"field":"imm5_0","size":1},{"field":"0b1100011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let taken : bool = match op {\\n    RISCV_BEQ  => rs1_val == rs2_val,\\n    RISCV_BNE  => rs1_val != rs2_val,\\n    RISCV_BLT  => rs1_val <_s rs2_val,\\n    RISCV_BGE  => rs1_val >=_s rs2_val,\\n    RISCV_BLTU => rs1_val <_u rs2_val,\\n    RISCV_BGEU => rs1_val >=_u rs2_val\\n  };\\n  let t : xlenbits = PC + sign_extend(imm);\\n  if taken then {\\n    /* Extensions get the first checks on the prospective target address. */\\n    match ext_control_check_pc(t) {\\n      Ext_ControlAddr_Error(e) => {\\n        ext_handle_control_check_error(e);\\n        RETIRE_FAIL\\n      },\\n      Ext_ControlAddr_OK(target) => {\\n        if bit_to_bool(target[1]) & not(extension(\\"C\\")) then {\\n          handle_mem_exception(target, E_Fetch_Addr_Align());\\n          RETIRE_FAIL;\\n        } else {\\n          set_next_pc(target);\\n          RETIRE_SUCCESS\\n        }\\n      }\\n    }\\n  } else RETIRE_SUCCESS\\n}","description":"\\nThe target address for this branch instruction is determined by combining\\nthe sign-extended 13-bit immediate value with the contents of register rs1.\\nAdditionally, the least-significant bit of the result is set to zero.\\nThe condition for the branch is based on the specified operation (bop),\\nwhich can be one of the following mnemonic codes:\\n  - \\"beq\\"   : Branch if equal\\n  - \\"bne\\"   : Branch if not equal\\n  - \\"blt\\"   : Branch if less than (signed)\\n  - \\"bge\\"   : Branch if greater than or equal to (signed)\\n  - \\"bltu\\"  : Branch if less than (unsigned)\\n  - \\"bgeu\\"  : Branch if greater than or equal to (unsigned)\\n *\\nThe branch is taken if the specified condition is true, leading to a jump\\nto the target address. If the branch is not taken, the execution proceeds\\nto the next instruction.\\n "},{"mnemonic":"bgeu","name":"Conditional Branch","operands":[{"name":"imm","type":"bits(13)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"op","type":"bop"}],"syntax":"rs1,rs2,imm","format":"TBD","fields":[{"field":"imm7_6","size":1},{"field":"imm7_5_0","size":6},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_bop(op)","size":3},{"field":"imm5_4_1","size":4},{"field":"imm5_0","size":1},{"field":"0b1100011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let taken : bool = match op {\\n    RISCV_BEQ  => rs1_val == rs2_val,\\n    RISCV_BNE  => rs1_val != rs2_val,\\n    RISCV_BLT  => rs1_val <_s rs2_val,\\n    RISCV_BGE  => rs1_val >=_s rs2_val,\\n    RISCV_BLTU => rs1_val <_u rs2_val,\\n    RISCV_BGEU => rs1_val >=_u rs2_val\\n  };\\n  let t : xlenbits = PC + sign_extend(imm);\\n  if taken then {\\n    /* Extensions get the first checks on the prospective target address. */\\n    match ext_control_check_pc(t) {\\n      Ext_ControlAddr_Error(e) => {\\n        ext_handle_control_check_error(e);\\n        RETIRE_FAIL\\n      },\\n      Ext_ControlAddr_OK(target) => {\\n        if bit_to_bool(target[1]) & not(extension(\\"C\\")) then {\\n          handle_mem_exception(target, E_Fetch_Addr_Align());\\n          RETIRE_FAIL;\\n        } else {\\n          set_next_pc(target);\\n          RETIRE_SUCCESS\\n        }\\n      }\\n    }\\n  } else RETIRE_SUCCESS\\n}","description":"\\nThe target address for this branch instruction is determined by combining\\nthe sign-extended 13-bit immediate value with the contents of register rs1.\\nAdditionally, the least-significant bit of the result is set to zero.\\nThe condition for the branch is based on the specified operation (bop),\\nwhich can be one of the following mnemonic codes:\\n  - \\"beq\\"   : Branch if equal\\n  - \\"bne\\"   : Branch if not equal\\n  - \\"blt\\"   : Branch if less than (signed)\\n  - \\"bge\\"   : Branch if greater than or equal to (signed)\\n  - \\"bltu\\"  : Branch if less than (unsigned)\\n  - \\"bgeu\\"  : Branch if greater than or equal to (unsigned)\\n *\\nThe branch is taken if the specified condition is true, leading to a jump\\nto the target address. If the branch is not taken, the execution proceeds\\nto the next instruction.\\n "},{"mnemonic":"binv","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zbs"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbs"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let mask : xlenbits = if sizeof(xlen) == 32\\n                        then zero_extend(0b1) << rs2_val[4..0]\\n                        else zero_extend(0b1) << rs2_val[5..0];\\n  let result : xlenbits = match op {\\n    RISCV_BCLR => rs1_val & ~(mask),\\n    RISCV_BEXT => zero_extend(bool_to_bits((rs1_val & mask) != zeros())),\\n    RISCV_BINV => rs1_val ^ mask,\\n    RISCV_BSET => rs1_val | mask\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"binvi","name":"TBD","operands":[{"name":"shamt","type":"bits(6)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"biop_zbs"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b001010","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbs"],"function":"{\\n  let rs1_val = X(rs1);\\n  let mask : xlenbits = if sizeof(xlen) == 32\\n                        then zero_extend(0b1) << shamt[4..0]\\n                        else zero_extend(0b1) << shamt;\\n  let result : xlenbits = match op {\\n    RISCV_BCLRI => rs1_val & ~(mask),\\n    RISCV_BEXTI => zero_extend(bool_to_bits((rs1_val & mask) != zeros())),\\n    RISCV_BINVI => rs1_val ^ mask,\\n    RISCV_BSETI => rs1_val | mask\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"blt","name":"Conditional Branch","operands":[{"name":"imm","type":"bits(13)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"op","type":"bop"}],"syntax":"rs1,rs2,imm","format":"TBD","fields":[{"field":"imm7_6","size":1},{"field":"imm7_5_0","size":6},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_bop(op)","size":3},{"field":"imm5_4_1","size":4},{"field":"imm5_0","size":1},{"field":"0b1100011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let taken : bool = match op {\\n    RISCV_BEQ  => rs1_val == rs2_val,\\n    RISCV_BNE  => rs1_val != rs2_val,\\n    RISCV_BLT  => rs1_val <_s rs2_val,\\n    RISCV_BGE  => rs1_val >=_s rs2_val,\\n    RISCV_BLTU => rs1_val <_u rs2_val,\\n    RISCV_BGEU => rs1_val >=_u rs2_val\\n  };\\n  let t : xlenbits = PC + sign_extend(imm);\\n  if taken then {\\n    /* Extensions get the first checks on the prospective target address. */\\n    match ext_control_check_pc(t) {\\n      Ext_ControlAddr_Error(e) => {\\n        ext_handle_control_check_error(e);\\n        RETIRE_FAIL\\n      },\\n      Ext_ControlAddr_OK(target) => {\\n        if bit_to_bool(target[1]) & not(extension(\\"C\\")) then {\\n          handle_mem_exception(target, E_Fetch_Addr_Align());\\n          RETIRE_FAIL;\\n        } else {\\n          set_next_pc(target);\\n          RETIRE_SUCCESS\\n        }\\n      }\\n    }\\n  } else RETIRE_SUCCESS\\n}","description":"\\nThe target address for this branch instruction is determined by combining\\nthe sign-extended 13-bit immediate value with the contents of register rs1.\\nAdditionally, the least-significant bit of the result is set to zero.\\nThe condition for the branch is based on the specified operation (bop),\\nwhich can be one of the following mnemonic codes:\\n  - \\"beq\\"   : Branch if equal\\n  - \\"bne\\"   : Branch if not equal\\n  - \\"blt\\"   : Branch if less than (signed)\\n  - \\"bge\\"   : Branch if greater than or equal to (signed)\\n  - \\"bltu\\"  : Branch if less than (unsigned)\\n  - \\"bgeu\\"  : Branch if greater than or equal to (unsigned)\\n *\\nThe branch is taken if the specified condition is true, leading to a jump\\nto the target address. If the branch is not taken, the execution proceeds\\nto the next instruction.\\n "},{"mnemonic":"bltu","name":"Conditional Branch","operands":[{"name":"imm","type":"bits(13)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"op","type":"bop"}],"syntax":"rs1,rs2,imm","format":"TBD","fields":[{"field":"imm7_6","size":1},{"field":"imm7_5_0","size":6},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_bop(op)","size":3},{"field":"imm5_4_1","size":4},{"field":"imm5_0","size":1},{"field":"0b1100011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let taken : bool = match op {\\n    RISCV_BEQ  => rs1_val == rs2_val,\\n    RISCV_BNE  => rs1_val != rs2_val,\\n    RISCV_BLT  => rs1_val <_s rs2_val,\\n    RISCV_BGE  => rs1_val >=_s rs2_val,\\n    RISCV_BLTU => rs1_val <_u rs2_val,\\n    RISCV_BGEU => rs1_val >=_u rs2_val\\n  };\\n  let t : xlenbits = PC + sign_extend(imm);\\n  if taken then {\\n    /* Extensions get the first checks on the prospective target address. */\\n    match ext_control_check_pc(t) {\\n      Ext_ControlAddr_Error(e) => {\\n        ext_handle_control_check_error(e);\\n        RETIRE_FAIL\\n      },\\n      Ext_ControlAddr_OK(target) => {\\n        if bit_to_bool(target[1]) & not(extension(\\"C\\")) then {\\n          handle_mem_exception(target, E_Fetch_Addr_Align());\\n          RETIRE_FAIL;\\n        } else {\\n          set_next_pc(target);\\n          RETIRE_SUCCESS\\n        }\\n      }\\n    }\\n  } else RETIRE_SUCCESS\\n}","description":"\\nThe target address for this branch instruction is determined by combining\\nthe sign-extended 13-bit immediate value with the contents of register rs1.\\nAdditionally, the least-significant bit of the result is set to zero.\\nThe condition for the branch is based on the specified operation (bop),\\nwhich can be one of the following mnemonic codes:\\n  - \\"beq\\"   : Branch if equal\\n  - \\"bne\\"   : Branch if not equal\\n  - \\"blt\\"   : Branch if less than (signed)\\n  - \\"bge\\"   : Branch if greater than or equal to (signed)\\n  - \\"bltu\\"  : Branch if less than (unsigned)\\n  - \\"bgeu\\"  : Branch if greater than or equal to (unsigned)\\n *\\nThe branch is taken if the specified condition is true, leading to a jump\\nto the target address. If the branch is not taken, the execution proceeds\\nto the next instruction.\\n "},{"mnemonic":"bne","name":"Conditional Branch","operands":[{"name":"imm","type":"bits(13)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"op","type":"bop"}],"syntax":"rs1,rs2,imm","format":"TBD","fields":[{"field":"imm7_6","size":1},{"field":"imm7_5_0","size":6},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_bop(op)","size":3},{"field":"imm5_4_1","size":4},{"field":"imm5_0","size":1},{"field":"0b1100011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let taken : bool = match op {\\n    RISCV_BEQ  => rs1_val == rs2_val,\\n    RISCV_BNE  => rs1_val != rs2_val,\\n    RISCV_BLT  => rs1_val <_s rs2_val,\\n    RISCV_BGE  => rs1_val >=_s rs2_val,\\n    RISCV_BLTU => rs1_val <_u rs2_val,\\n    RISCV_BGEU => rs1_val >=_u rs2_val\\n  };\\n  let t : xlenbits = PC + sign_extend(imm);\\n  if taken then {\\n    /* Extensions get the first checks on the prospective target address. */\\n    match ext_control_check_pc(t) {\\n      Ext_ControlAddr_Error(e) => {\\n        ext_handle_control_check_error(e);\\n        RETIRE_FAIL\\n      },\\n      Ext_ControlAddr_OK(target) => {\\n        if bit_to_bool(target[1]) & not(extension(\\"C\\")) then {\\n          handle_mem_exception(target, E_Fetch_Addr_Align());\\n          RETIRE_FAIL;\\n        } else {\\n          set_next_pc(target);\\n          RETIRE_SUCCESS\\n        }\\n      }\\n    }\\n  } else RETIRE_SUCCESS\\n}","description":"\\nThe target address for this branch instruction is determined by combining\\nthe sign-extended 13-bit immediate value with the contents of register rs1.\\nAdditionally, the least-significant bit of the result is set to zero.\\nThe condition for the branch is based on the specified operation (bop),\\nwhich can be one of the following mnemonic codes:\\n  - \\"beq\\"   : Branch if equal\\n  - \\"bne\\"   : Branch if not equal\\n  - \\"blt\\"   : Branch if less than (signed)\\n  - \\"bge\\"   : Branch if greater than or equal to (signed)\\n  - \\"bltu\\"  : Branch if less than (unsigned)\\n  - \\"bgeu\\"  : Branch if greater than or equal to (unsigned)\\n *\\nThe branch is taken if the specified condition is true, leading to a jump\\nto the target address. If the branch is not taken, the execution proceeds\\nto the next instruction.\\n "},{"mnemonic":"brev8","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b011010000111","size":12},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbkb"],"function":"{\\n  let rs1_val = X(rs1);\\n  result : xlenbits = zeros();\\n  foreach (i from 0 to (sizeof(xlen) - 8) by 8)\\n    result[i+7..i] = reverse(rs1_val[i+7..i]);\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"bset","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zbs"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbs"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let mask : xlenbits = if sizeof(xlen) == 32\\n                        then zero_extend(0b1) << rs2_val[4..0]\\n                        else zero_extend(0b1) << rs2_val[5..0];\\n  let result : xlenbits = match op {\\n    RISCV_BCLR => rs1_val & ~(mask),\\n    RISCV_BEXT => zero_extend(bool_to_bits((rs1_val & mask) != zeros())),\\n    RISCV_BINV => rs1_val ^ mask,\\n    RISCV_BSET => rs1_val | mask\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"bseti","name":"TBD","operands":[{"name":"shamt","type":"bits(6)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"biop_zbs"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b001010","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbs"],"function":"{\\n  let rs1_val = X(rs1);\\n  let mask : xlenbits = if sizeof(xlen) == 32\\n                        then zero_extend(0b1) << shamt[4..0]\\n                        else zero_extend(0b1) << shamt;\\n  let result : xlenbits = match op {\\n    RISCV_BCLRI => rs1_val & ~(mask),\\n    RISCV_BEXTI => zero_extend(bool_to_bits((rs1_val & mask) != zeros())),\\n    RISCV_BINVI => rs1_val ^ mask,\\n    RISCV_BSETI => rs1_val | mask\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"c.add","name":"TBD","operands":[{"name":"rsd","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rsd,rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b1","size":1},{"field":"rsd","size":5},{"field":"rs2","size":5},{"field":"0b10","size":2}],"extensions":["C"],"function":"execute(RTYPE(rs2, rsd, rsd, RISCV_ADD))","description":"TBD"},{"mnemonic":"c.add.hint.","name":"TBD","operands":[{"name":"rs2","type":"regidx"}],"syntax":"rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b1","size":1},{"field":"0b00000","size":5},{"field":"rs2","size":5},{"field":"0b10","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.addi","name":"TBD","operands":[{"name":"nzi","type":"bits(6)"},{"name":"rsd","type":"regidx"}],"syntax":"rsd,nzi","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"nzi5","size":1},{"field":"rsd","size":5},{"field":"nzi40","size":5},{"field":"0b01","size":2}],"extensions":["C"],"function":"{\\n  let imm : bits(12) = sign_extend(nzi);\\n  execute(ITYPE(imm, rsd, rsd, RISCV_ADDI))\\n}","description":"TBD"},{"mnemonic":"c.addi.hint.","name":"TBD","operands":[{"name":"rsd","type":"regidx"}],"syntax":"rsd","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"0b0","size":1},{"field":"rsd","size":5},{"field":"0b00000","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.addi16sp","name":"TBD","operands":[{"name":"imm","type":"bits(6)"}],"syntax":"imm","format":"TBD","fields":[{"field":"0b011","size":3},{"field":"nzi9","size":1},{"field":"0b00010","size":5},{"field":"nzi4","size":1},{"field":"nzi6","size":1},{"field":"nzi87","size":2},{"field":"nzi5","size":1},{"field":"0b01","size":2}],"extensions":["C"],"function":"{\\n  let imm : bits(12) = sign_extend(imm @ 0x0);\\n  execute(ITYPE(imm, sp, sp, RISCV_ADDI))\\n}","description":"TBD"},{"mnemonic":"c.addi4spn","name":"TBD","operands":[{"name":"rdc","type":"cregidx"},{"name":"nzimm","type":"bits(8)"}],"syntax":"rdc,nzimm,0b00","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"nz54","size":2},{"field":"nz96","size":4},{"field":"nz2","size":1},{"field":"nz3","size":1},{"field":"rd","size":3},{"field":"0b00","size":2}],"extensions":["C"],"function":"{\\n  let imm : bits(12) = (0b00 @ nzimm @ 0b00);\\n  let rd = creg2reg_idx(rdc);\\n  execute(ITYPE(imm, sp, rd, RISCV_ADDI))\\n}","description":"TBD"},{"mnemonic":"c.addiw","name":"TBD","operands":[{"name":"imm","type":"bits(6)"},{"name":"rsd","type":"regidx"}],"syntax":"rsd,imm","format":"TBD","fields":[{"field":"0b001","size":3},{"field":"imm5","size":1},{"field":"rsd","size":5},{"field":"imm40","size":5},{"field":"0b01","size":2}],"extensions":["C"],"function":"execute(ADDIW(sign_extend(imm), rsd, rsd))","description":"TBD"},{"mnemonic":"c.addw","name":"TBD","operands":[{"name":"rsd","type":"cregidx"},{"name":"rs2","type":"cregidx"}],"syntax":"rsd,rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b1","size":1},{"field":"0b11","size":2},{"field":"rsd","size":3},{"field":"0b01","size":2},{"field":"rs2","size":3},{"field":"0b01","size":2}],"extensions":["C"],"function":"{\\n  let rsd = creg2reg_idx(rsd);\\n  let rs2 = creg2reg_idx(rs2);\\n  execute(RTYPEW(rs2, rsd, rsd, RISCV_ADDW))\\n}","description":"TBD"},{"mnemonic":"c.and","name":"TBD","operands":[{"name":"rsd","type":"cregidx"},{"name":"rs2","type":"cregidx"}],"syntax":"rsd,rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"rsd","size":3},{"field":"0b11","size":2},{"field":"rs2","size":3},{"field":"0b01","size":2}],"extensions":["C"],"function":"{\\n  let rsd = creg2reg_idx(rsd);\\n  let rs2 = creg2reg_idx(rs2);\\n  execute(RTYPE(rs2, rsd, rsd, RISCV_AND))\\n}","description":"TBD"},{"mnemonic":"c.andi","name":"TBD","operands":[{"name":"imm","type":"bits(6)"},{"name":"rsd","type":"cregidx"}],"syntax":"rsd,imm","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"i5","size":1},{"field":"0b10","size":2},{"field":"rsd","size":3},{"field":"i40","size":5},{"field":"0b01","size":2}],"extensions":["C"],"function":"{\\n  let rsd = creg2reg_idx(rsd);\\n  execute(ITYPE(sign_extend(imm), rsd, rsd, RISCV_ANDI))\\n}","description":"TBD"},{"mnemonic":"c.beqz","name":"TBD","operands":[{"name":"imm","type":"bits(8)"},{"name":"rs","type":"cregidx"}],"syntax":"rs,imm","format":"TBD","fields":[{"field":"0b110","size":3},{"field":"i8","size":1},{"field":"i43","size":2},{"field":"rs","size":3},{"field":"i76","size":2},{"field":"i21","size":2},{"field":"i5","size":1},{"field":"0b01","size":2}],"extensions":["C"],"function":"execute(BTYPE(sign_extend(imm @ 0b0), zreg, creg2reg_idx(rs), RISCV_BEQ))","description":"TBD"},{"mnemonic":"c.bnez","name":"TBD","operands":[{"name":"imm","type":"bits(8)"},{"name":"rs","type":"cregidx"}],"syntax":"rs,imm","format":"TBD","fields":[{"field":"0b111","size":3},{"field":"i8","size":1},{"field":"i43","size":2},{"field":"rs","size":3},{"field":"i76","size":2},{"field":"i21","size":2},{"field":"i5","size":1},{"field":"0b01","size":2}],"extensions":["C"],"function":"execute(BTYPE(sign_extend(imm @ 0b0), zreg, creg2reg_idx(rs), RISCV_BNE))","description":"TBD"},{"mnemonic":"c.ebreak","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b1","size":1},{"field":"0b00000","size":5},{"field":"0b00000","size":5},{"field":"0b10","size":2}],"extensions":["C"],"function":"execute(EBREAK())","description":"TBD"},{"mnemonic":"c.fld","name":"TBD","operands":[{"name":"uimm","type":"bits(5)"},{"name":"rsc","type":"cregidx"},{"name":"rdc","type":"cregidx"}],"syntax":"rdc,rsc,uimm,0b000","format":"TBD","fields":[{"field":"0b001","size":3},{"field":"ui53","size":3},{"field":"rs1","size":3},{"field":"ui76","size":2},{"field":"rd","size":3},{"field":"0b00","size":2}],"extensions":["C","D"],"function":"{\\n  let imm : bits(12) = zero_extend(uimm @ 0b000);\\n  let rd = creg2reg_idx(rdc);\\n  let rs = creg2reg_idx(rsc);\\n  execute(LOAD_FP(imm, rs, rd, DOUBLE))\\n}","description":"TBD"},{"mnemonic":"c.fldsp","name":"TBD","operands":[{"name":"uimm","type":"bits(6)"},{"name":"rd","type":"regidx"}],"syntax":"rd,uimm","format":"TBD","fields":[{"field":"0b001","size":3},{"field":"ui5","size":1},{"field":"rd","size":5},{"field":"ui43","size":2},{"field":"ui86","size":3},{"field":"0b10","size":2}],"extensions":["C","D"],"function":"{\\n  let imm : bits(12) = zero_extend(uimm @ 0b000);\\n  execute(LOAD_FP(imm, sp, rd, DOUBLE))\\n}","description":"TBD"},{"mnemonic":"c.flw","name":"TBD","operands":[{"name":"uimm","type":"bits(5)"},{"name":"rsc","type":"cregidx"},{"name":"rdc","type":"cregidx"}],"syntax":"rdc,rsc,uimm,0b00","format":"TBD","fields":[{"field":"0b011","size":3},{"field":"ui53","size":3},{"field":"rs1","size":3},{"field":"ui2","size":1},{"field":"ui6","size":1},{"field":"rd","size":3},{"field":"0b00","size":2}],"extensions":["C","F"],"function":"{\\n  let imm : bits(12) = zero_extend(uimm @ 0b00);\\n  let rd = creg2reg_idx(rdc);\\n  let rs = creg2reg_idx(rsc);\\n  execute(LOAD_FP(imm, rs, rd, WORD))\\n}","description":"TBD"},{"mnemonic":"c.flwsp","name":"TBD","operands":[{"name":"imm","type":"bits(6)"},{"name":"rd","type":"regidx"}],"syntax":"rd,imm","format":"TBD","fields":[{"field":"0b011","size":3},{"field":"ui5","size":1},{"field":"rd","size":5},{"field":"ui42","size":3},{"field":"ui76","size":2},{"field":"0b10","size":2}],"extensions":["C","F"],"function":"{\\n  let imm : bits(12) = zero_extend(imm @ 0b00);\\n  execute(LOAD_FP(imm, sp, rd, WORD))\\n}","description":"TBD"},{"mnemonic":"c.fsd","name":"TBD","operands":[{"name":"uimm","type":"bits(5)"},{"name":"rsc1","type":"cregidx"},{"name":"rsc2","type":"cregidx"}],"syntax":"rsc1,rsc2,uimm,0b000","format":"TBD","fields":[{"field":"0b101","size":3},{"field":"ui53","size":3},{"field":"rs1","size":3},{"field":"ui76","size":2},{"field":"rs2","size":3},{"field":"0b00","size":2}],"extensions":["C","D"],"function":"{\\n  let imm : bits(12) = zero_extend(uimm @ 0b000);\\n  let rs1 = creg2reg_idx(rsc1);\\n  let rs2 = creg2reg_idx(rsc2);\\n  execute(STORE_FP(imm, rs2, rs1, DOUBLE))\\n}","description":"TBD"},{"mnemonic":"c.fsdsp","name":"TBD","operands":[{"name":"uimm","type":"bits(6)"},{"name":"rs2","type":"regidx"}],"syntax":"rs2,uimm","format":"TBD","fields":[{"field":"0b101","size":3},{"field":"ui53","size":3},{"field":"ui86","size":3},{"field":"rs2","size":5},{"field":"0b10","size":2}],"extensions":["C","D"],"function":"{\\n  let imm : bits(12) = zero_extend(uimm @ 0b000);\\n  execute(STORE_FP(imm, rs2, sp, DOUBLE))\\n}","description":"TBD"},{"mnemonic":"c.fsw","name":"TBD","operands":[{"name":"uimm","type":"bits(5)"},{"name":"rsc1","type":"cregidx"},{"name":"rsc2","type":"cregidx"}],"syntax":"rsc1,rsc2,uimm,0b00","format":"TBD","fields":[{"field":"0b111","size":3},{"field":"ui53","size":3},{"field":"rs1","size":3},{"field":"ui2","size":1},{"field":"ui6","size":1},{"field":"rs2","size":3},{"field":"0b00","size":2}],"extensions":["C","F"],"function":"{\\n  let imm : bits(12) = zero_extend(uimm @ 0b00);\\n  let rs1 = creg2reg_idx(rsc1);\\n  let rs2 = creg2reg_idx(rsc2);\\n  execute(STORE_FP(imm, rs2, rs1, WORD))\\n}","description":"TBD"},{"mnemonic":"c.fswsp","name":"TBD","operands":[{"name":"uimm","type":"bits(6)"},{"name":"rs2","type":"regidx"}],"syntax":"rs2,uimm","format":"TBD","fields":[{"field":"0b111","size":3},{"field":"ui52","size":4},{"field":"ui76","size":2},{"field":"rs2","size":5},{"field":"0b10","size":2}],"extensions":["C","F"],"function":"{\\n  let imm : bits(12) = zero_extend(uimm @ 0b00);\\n  execute(STORE_FP(imm, rs2, sp, WORD))\\n}","description":"TBD"},{"mnemonic":"c.illegal","name":"TBD","operands":[{"name":"s","type":"half"}],"syntax":"s","format":"TBD","fields":[{"field":"s","size":16}],"extensions":[],"function":"{ handle_illegal(); RETIRE_FAIL }","description":"TBD"},{"mnemonic":"c.j","name":"TBD","operands":[{"name":"imm","type":"bits(11)"}],"syntax":"imm","format":"TBD","fields":[{"field":"0b101","size":3},{"field":"i11","size":1},{"field":"i4","size":1},{"field":"i98","size":2},{"field":"i10","size":1},{"field":"i6","size":1},{"field":"i7","size":1},{"field":"i31","size":3},{"field":"i5","size":1},{"field":"0b01","size":2}],"extensions":["C"],"function":"execute(RISCV_JAL(sign_extend(imm @ 0b0), zreg))","description":"TBD"},{"mnemonic":"c.jal","name":"TBD","operands":[{"name":"imm","type":"bits(11)"}],"syntax":"imm,0b0","format":"TBD","fields":[{"field":"0b001","size":3},{"field":"i11","size":1},{"field":"i4","size":1},{"field":"i98","size":2},{"field":"i10","size":1},{"field":"i6","size":1},{"field":"i7","size":1},{"field":"i31","size":3},{"field":"i5","size":1},{"field":"0b01","size":2}],"extensions":["C"],"function":"execute(RISCV_JAL(sign_extend(imm @ 0b0), ra))","description":"TBD"},{"mnemonic":"c.jalr","name":"TBD","operands":[{"name":"rs1","type":"regidx"}],"syntax":"rs1","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b1","size":1},{"field":"rs1","size":5},{"field":"0b00000","size":5},{"field":"0b10","size":2}],"extensions":["C"],"function":"execute(RISCV_JALR(zero_extend(0b0), rs1, ra))","description":"TBD"},{"mnemonic":"c.jr","name":"TBD","operands":[{"name":"rs1","type":"regidx"}],"syntax":"rs1","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"rs1","size":5},{"field":"0b00000","size":5},{"field":"0b10","size":2}],"extensions":["C"],"function":"execute(RISCV_JALR(zero_extend(0b0), rs1, zreg))","description":"TBD"},{"mnemonic":"c.ld","name":"TBD","operands":[{"name":"uimm","type":"bits(5)"},{"name":"rsc","type":"cregidx"},{"name":"rdc","type":"cregidx"}],"syntax":"rdc,rsc,uimm,0b000","format":"TBD","fields":[{"field":"0b011","size":3},{"field":"ui53","size":3},{"field":"rs1","size":3},{"field":"ui76","size":2},{"field":"rd","size":3},{"field":"0b00","size":2}],"extensions":["C"],"function":"{\\n  let imm : bits(12) = zero_extend(uimm @ 0b000);\\n  let rd = creg2reg_idx(rdc);\\n  let rs = creg2reg_idx(rsc);\\n  execute(LOAD(imm, rs, rd, false, DOUBLE, false, false))\\n}","description":"TBD"},{"mnemonic":"c.ldsp","name":"TBD","operands":[{"name":"uimm","type":"bits(6)"},{"name":"rd","type":"regidx"}],"syntax":"rd,uimm","format":"TBD","fields":[{"field":"0b011","size":3},{"field":"ui5","size":1},{"field":"rd","size":5},{"field":"ui43","size":2},{"field":"ui86","size":3},{"field":"0b10","size":2}],"extensions":["C"],"function":"{\\n  let imm : bits(12) = zero_extend(uimm @ 0b000);\\n  execute(LOAD(imm, sp, rd, false, DOUBLE, false, false))\\n}","description":"TBD"},{"mnemonic":"c.li","name":"TBD","operands":[{"name":"imm","type":"bits(6)"},{"name":"rd","type":"regidx"}],"syntax":"rd,imm","format":"TBD","fields":[{"field":"0b010","size":3},{"field":"imm5","size":1},{"field":"rd","size":5},{"field":"imm40","size":5},{"field":"0b01","size":2}],"extensions":["C"],"function":"{\\n  let imm : bits(12) = sign_extend(imm);\\n  execute(ITYPE(imm, zreg, rd, RISCV_ADDI))\\n}","description":"TBD"},{"mnemonic":"c.li.hint.","name":"TBD","operands":[{"name":"imm","type":"bits(6)"}],"syntax":"imm","format":"TBD","fields":[{"field":"0b010","size":3},{"field":"imm5","size":1},{"field":"0b00000","size":5},{"field":"imm40","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.lui","name":"TBD","operands":[{"name":"imm","type":"bits(6)"},{"name":"rd","type":"regidx"}],"syntax":"rd,imm","format":"TBD","fields":[{"field":"0b011","size":3},{"field":"imm17","size":1},{"field":"rd","size":5},{"field":"imm1612","size":5},{"field":"0b01","size":2}],"extensions":["C"],"function":"{\\n  let res : bits(20) = sign_extend(imm);\\n  execute(UTYPE(res, rd, RISCV_LUI))\\n}","description":"TBD"},{"mnemonic":"c.lui.hint.","name":"TBD","operands":[{"name":"imm","type":"bits(6)"}],"syntax":"imm","format":"TBD","fields":[{"field":"0b011","size":3},{"field":"imm17","size":1},{"field":"0b00000","size":5},{"field":"imm1612","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.lw","name":"TBD","operands":[{"name":"uimm","type":"bits(5)"},{"name":"rsc","type":"cregidx"},{"name":"rdc","type":"cregidx"}],"syntax":"rdc,rsc,uimm,0b00","format":"TBD","fields":[{"field":"0b010","size":3},{"field":"ui53","size":3},{"field":"rs1","size":3},{"field":"ui2","size":1},{"field":"ui6","size":1},{"field":"rd","size":3},{"field":"0b00","size":2}],"extensions":["C"],"function":"{\\n  let imm : bits(12) = zero_extend(uimm @ 0b00);\\n  let rd = creg2reg_idx(rdc);\\n  let rs = creg2reg_idx(rsc);\\n  execute(LOAD(imm, rs, rd, false, WORD, false, false))\\n}","description":"TBD"},{"mnemonic":"c.lwsp","name":"TBD","operands":[{"name":"uimm","type":"bits(6)"},{"name":"rd","type":"regidx"}],"syntax":"rd,uimm","format":"TBD","fields":[{"field":"0b010","size":3},{"field":"ui5","size":1},{"field":"rd","size":5},{"field":"ui42","size":3},{"field":"ui76","size":2},{"field":"0b10","size":2}],"extensions":["C"],"function":"{\\n  let imm : bits(12) = zero_extend(uimm @ 0b00);\\n  execute(LOAD(imm, sp, rd, false, WORD, false, false))\\n}","description":"TBD"},{"mnemonic":"c.mv","name":"TBD","operands":[{"name":"rd","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rd,rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"rd","size":5},{"field":"rs2","size":5},{"field":"0b10","size":2}],"extensions":["C"],"function":"execute(RTYPE(rs2, zreg, rd, RISCV_ADD))","description":"TBD"},{"mnemonic":"c.mv.hint.","name":"TBD","operands":[{"name":"rs2","type":"regidx"}],"syntax":"rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"0b00000","size":5},{"field":"rs2","size":5},{"field":"0b10","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.nop","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"0b0","size":1},{"field":"0b00000","size":5},{"field":"0b00000","size":5},{"field":"0b01","size":2}],"extensions":["C"],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.nop.hint.","name":"TBD","operands":[{"name":"imm","type":"bits(6)"}],"syntax":"imm","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"im5","size":1},{"field":"0b00000","size":5},{"field":"im40","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.or","name":"TBD","operands":[{"name":"rsd","type":"cregidx"},{"name":"rs2","type":"cregidx"}],"syntax":"rsd,rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"rsd","size":3},{"field":"0b10","size":2},{"field":"rs2","size":3},{"field":"0b01","size":2}],"extensions":["C"],"function":"{\\n  let rsd = creg2reg_idx(rsd);\\n  let rs2 = creg2reg_idx(rs2);\\n  execute(RTYPE(rs2, rsd, rsd, RISCV_OR))\\n}","description":"TBD"},{"mnemonic":"c.sd","name":"TBD","operands":[{"name":"uimm","type":"bits(5)"},{"name":"rsc1","type":"cregidx"},{"name":"rsc2","type":"cregidx"}],"syntax":"rsc1,rsc2,uimm,0b000","format":"TBD","fields":[{"field":"0b111","size":3},{"field":"ui53","size":3},{"field":"rs1","size":3},{"field":"ui76","size":2},{"field":"rs2","size":3},{"field":"0b00","size":2}],"extensions":["C"],"function":"{\\n  let imm : bits(12) = zero_extend(uimm @ 0b000);\\n  let rs1 = creg2reg_idx(rsc1);\\n  let rs2 = creg2reg_idx(rsc2);\\n  execute(STORE(imm, rs2, rs1, DOUBLE, false, false))\\n}","description":"TBD"},{"mnemonic":"c.sdsp","name":"TBD","operands":[{"name":"uimm","type":"bits(6)"},{"name":"rs2","type":"regidx"}],"syntax":"rs2,uimm","format":"TBD","fields":[{"field":"0b111","size":3},{"field":"ui53","size":3},{"field":"ui86","size":3},{"field":"rs2","size":5},{"field":"0b10","size":2}],"extensions":["C"],"function":"{\\n  let imm : bits(12) = zero_extend(uimm @ 0b000);\\n  execute(STORE(imm, rs2, sp, DOUBLE, false, false))\\n}","description":"TBD"},{"mnemonic":"c.slli","name":"TBD","operands":[{"name":"shamt","type":"bits(6)"},{"name":"rsd","type":"regidx"}],"syntax":"rsd,shamt","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"nzui5","size":1},{"field":"rsd","size":5},{"field":"nzui40","size":5},{"field":"0b10","size":2}],"extensions":["C"],"function":"execute(SHIFTIOP(shamt, rsd, rsd, RISCV_SLLI))","description":"TBD"},{"mnemonic":"c.slli.hint.","name":"TBD","operands":[{"name":"shamt","type":"bits(6)"},{"name":"rsd","type":"regidx"}],"syntax":"rsd,shamt","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"nzui5","size":1},{"field":"rsd","size":5},{"field":"nzui40","size":5},{"field":"0b10","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.srai","name":"TBD","operands":[{"name":"shamt","type":"bits(6)"},{"name":"rsd","type":"cregidx"}],"syntax":"rsd,shamt","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"nzui5","size":1},{"field":"0b01","size":2},{"field":"rsd","size":3},{"field":"nzui40","size":5},{"field":"0b01","size":2}],"extensions":["C"],"function":"{\\n  let rsd = creg2reg_idx(rsd);\\n  execute(SHIFTIOP(shamt, rsd, rsd, RISCV_SRAI))\\n}","description":"TBD"},{"mnemonic":"c.srai.hint.","name":"TBD","operands":[{"name":"rsd","type":"cregidx"}],"syntax":"rsd","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"rsd","size":3},{"field":"0b00000","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.srli","name":"TBD","operands":[{"name":"shamt","type":"bits(6)"},{"name":"rsd","type":"cregidx"}],"syntax":"rsd,shamt","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"nzui5","size":1},{"field":"0b00","size":2},{"field":"rsd","size":3},{"field":"nzui40","size":5},{"field":"0b01","size":2}],"extensions":["C"],"function":"{\\n  let rsd = creg2reg_idx(rsd);\\n  execute(SHIFTIOP(shamt, rsd, rsd, RISCV_SRLI))\\n}","description":"TBD"},{"mnemonic":"c.srli.hint.","name":"TBD","operands":[{"name":"rsd","type":"cregidx"}],"syntax":"rsd","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"rsd","size":3},{"field":"0b00000","size":5},{"field":"0b01","size":2}],"extensions":[],"function":"RETIRE_SUCCESS","description":"TBD"},{"mnemonic":"c.sub","name":"TBD","operands":[{"name":"rsd","type":"cregidx"},{"name":"rs2","type":"cregidx"}],"syntax":"rsd,rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"rsd","size":3},{"field":"0b00","size":2},{"field":"rs2","size":3},{"field":"0b01","size":2}],"extensions":["C"],"function":"{\\n  let rsd = creg2reg_idx(rsd);\\n  let rs2 = creg2reg_idx(rs2);\\n  execute(RTYPE(rs2, rsd, rsd, RISCV_SUB))\\n}","description":"TBD"},{"mnemonic":"c.subw","name":"TBD","operands":[{"name":"rsd","type":"cregidx"},{"name":"rs2","type":"cregidx"}],"syntax":"rsd,rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b1","size":1},{"field":"0b11","size":2},{"field":"rsd","size":3},{"field":"0b00","size":2},{"field":"rs2","size":3},{"field":"0b01","size":2}],"extensions":["C"],"function":"{\\n  let rsd = creg2reg_idx(rsd);\\n  let rs2 = creg2reg_idx(rs2);\\n  execute(RTYPEW(rs2, rsd, rsd, RISCV_SUBW))\\n}","description":"TBD"},{"mnemonic":"c.sw","name":"TBD","operands":[{"name":"uimm","type":"bits(5)"},{"name":"rsc1","type":"cregidx"},{"name":"rsc2","type":"cregidx"}],"syntax":"rsc1,rsc2,uimm,0b00","format":"TBD","fields":[{"field":"0b110","size":3},{"field":"ui53","size":3},{"field":"rs1","size":3},{"field":"ui2","size":1},{"field":"ui6","size":1},{"field":"rs2","size":3},{"field":"0b00","size":2}],"extensions":["C"],"function":"{\\n  let imm : bits(12) = zero_extend(uimm @ 0b00);\\n  let rs1 = creg2reg_idx(rsc1);\\n  let rs2 = creg2reg_idx(rsc2);\\n  execute(STORE(imm, rs2, rs1, WORD, false, false))\\n}","description":"TBD"},{"mnemonic":"c.swsp","name":"TBD","operands":[{"name":"uimm","type":"bits(6)"},{"name":"rs2","type":"regidx"}],"syntax":"rs2,uimm","format":"TBD","fields":[{"field":"0b110","size":3},{"field":"ui52","size":4},{"field":"ui76","size":2},{"field":"rs2","size":5},{"field":"0b10","size":2}],"extensions":["C"],"function":"{\\n  let imm : bits(12) = zero_extend(uimm @ 0b00);\\n  execute(STORE(imm, rs2, sp, WORD, false, false))\\n}","description":"TBD"},{"mnemonic":"c.xor","name":"TBD","operands":[{"name":"rsd","type":"cregidx"},{"name":"rs2","type":"cregidx"}],"syntax":"rsd,rs2","format":"TBD","fields":[{"field":"0b100","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"rsd","size":3},{"field":"0b01","size":2},{"field":"rs2","size":3},{"field":"0b01","size":2}],"extensions":["C"],"function":"{\\n  let rsd = creg2reg_idx(rsd);\\n  let rs2 = creg2reg_idx(rs2);\\n  execute(RTYPE(rs2, rsd, rsd, RISCV_XOR))\\n}","description":"TBD"},{"mnemonic":"clmul","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbc","Zbkc"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  result : xlenbits = zeros();\\n  foreach (i from 0 to (xlen_val - 1))\\n    if rs2_val[i] == bitone then result = result ^ (rs1_val << i);\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"clmulh","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbc","Zbkc"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  result : xlenbits = zeros();\\n  foreach (i from 0 to (xlen_val - 1))\\n    if rs2_val[i] == bitone then result = result ^ (rs1_val >> (xlen_val - i));\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"clmulr","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b010","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbc"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  result : xlenbits = zeros();\\n  foreach (i from 0 to (xlen_val - 1))\\n    if rs2_val[i] == bitone then result = result ^ (rs1_val >> (xlen_val - i - 1));\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"clz","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b011000000000","size":12},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbb"],"function":"{\\n  let rs1_val = X(rs1);\\n  result : nat = 0;\\n  done : bool = false;\\n  foreach (i from (sizeof(xlen) - 1) downto 0)\\n    if not(done) then if rs1_val[i] == bitzero\\n                    then result = result + 1\\n                    else done = true;\\n  X(rd) = to_bits(sizeof(xlen), result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"clzw","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b011000000000","size":12},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":["Zbb"],"function":"{\\n  let rs1_val = X(rs1);\\n  result : nat = 0;\\n  done : bool = false;\\n  foreach (i from 31 downto 0)\\n    if not(done) then if rs1_val[i] == bitzero\\n                    then result = result + 1\\n                    else done = true;\\n  X(rd) = to_bits(sizeof(xlen), result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"cpop","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b011000000010","size":12},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbb"],"function":"{\\n  let rs1_val = X(rs1);\\n  result : nat = 0;\\n  foreach (i from 0 to (xlen_val - 1))\\n    if rs1_val[i] == bitone then result = result + 1;\\n  X(rd) = to_bits(sizeof(xlen), result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"cpopw","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b011000000010","size":12},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":["Zbb"],"function":"{\\n  let rs1_val = X(rs1);\\n  result : nat = 0;\\n  foreach (i from 0 to 31)\\n    if rs1_val[i] == bitone then result = result + 1;\\n  X(rd) = to_bits(sizeof(xlen), result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"csrrc","name":"TBD","operands":[{"name":"csr","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_imm","type":"bool"},{"name":"op","type":"csrop"}],"syntax":"rd,csr,rs1","format":"TBD","fields":[{"field":"csr","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_imm)","size":1},{"field":"encdec_csrop(op)","size":2},{"field":"rd","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{\\n  let rs1_val : xlenbits = if is_imm then zero_extend(rs1) else X(rs1);\\n  let isWrite : bool = match op {\\n    CSRRW  => true,\\n    _      => if is_imm then unsigned(rs1_val) != 0 else unsigned(rs1) != 0\\n  };\\n  if not(check_CSR(csr, cur_privilege, isWrite))\\n  then { handle_illegal(); RETIRE_FAIL }\\n  else if not(ext_check_CSR(csr, cur_privilege, isWrite))\\n  then { ext_check_CSR_fail(); RETIRE_FAIL }\\n  else {\\n    let csr_val = readCSR(csr); /* could have side-effects, so technically shouldn\'t perform for CSRW[I] with rd == 0 */\\n    if isWrite then {\\n      let new_val : xlenbits = match op {\\n        CSRRW => rs1_val,\\n        CSRRS => csr_val | rs1_val,\\n        CSRRC => csr_val & ~(rs1_val)\\n      };\\n      writeCSR(csr, new_val)\\n    };\\n    X(rd) = csr_val;\\n    RETIRE_SUCCESS\\n  }\\n}","description":"TBD"},{"mnemonic":"csrrci","name":"TBD","operands":[{"name":"csr","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_imm","type":"bool"},{"name":"op","type":"csrop"}],"syntax":"rd,csr,rs1","format":"TBD","fields":[{"field":"csr","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_imm)","size":1},{"field":"encdec_csrop(op)","size":2},{"field":"rd","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{\\n  let rs1_val : xlenbits = if is_imm then zero_extend(rs1) else X(rs1);\\n  let isWrite : bool = match op {\\n    CSRRW  => true,\\n    _      => if is_imm then unsigned(rs1_val) != 0 else unsigned(rs1) != 0\\n  };\\n  if not(check_CSR(csr, cur_privilege, isWrite))\\n  then { handle_illegal(); RETIRE_FAIL }\\n  else if not(ext_check_CSR(csr, cur_privilege, isWrite))\\n  then { ext_check_CSR_fail(); RETIRE_FAIL }\\n  else {\\n    let csr_val = readCSR(csr); /* could have side-effects, so technically shouldn\'t perform for CSRW[I] with rd == 0 */\\n    if isWrite then {\\n      let new_val : xlenbits = match op {\\n        CSRRW => rs1_val,\\n        CSRRS => csr_val | rs1_val,\\n        CSRRC => csr_val & ~(rs1_val)\\n      };\\n      writeCSR(csr, new_val)\\n    };\\n    X(rd) = csr_val;\\n    RETIRE_SUCCESS\\n  }\\n}","description":"TBD"},{"mnemonic":"csrrs","name":"TBD","operands":[{"name":"csr","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_imm","type":"bool"},{"name":"op","type":"csrop"}],"syntax":"rd,csr,rs1","format":"TBD","fields":[{"field":"csr","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_imm)","size":1},{"field":"encdec_csrop(op)","size":2},{"field":"rd","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{\\n  let rs1_val : xlenbits = if is_imm then zero_extend(rs1) else X(rs1);\\n  let isWrite : bool = match op {\\n    CSRRW  => true,\\n    _      => if is_imm then unsigned(rs1_val) != 0 else unsigned(rs1) != 0\\n  };\\n  if not(check_CSR(csr, cur_privilege, isWrite))\\n  then { handle_illegal(); RETIRE_FAIL }\\n  else if not(ext_check_CSR(csr, cur_privilege, isWrite))\\n  then { ext_check_CSR_fail(); RETIRE_FAIL }\\n  else {\\n    let csr_val = readCSR(csr); /* could have side-effects, so technically shouldn\'t perform for CSRW[I] with rd == 0 */\\n    if isWrite then {\\n      let new_val : xlenbits = match op {\\n        CSRRW => rs1_val,\\n        CSRRS => csr_val | rs1_val,\\n        CSRRC => csr_val & ~(rs1_val)\\n      };\\n      writeCSR(csr, new_val)\\n    };\\n    X(rd) = csr_val;\\n    RETIRE_SUCCESS\\n  }\\n}","description":"TBD"},{"mnemonic":"csrrsi","name":"TBD","operands":[{"name":"csr","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_imm","type":"bool"},{"name":"op","type":"csrop"}],"syntax":"rd,csr,rs1","format":"TBD","fields":[{"field":"csr","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_imm)","size":1},{"field":"encdec_csrop(op)","size":2},{"field":"rd","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{\\n  let rs1_val : xlenbits = if is_imm then zero_extend(rs1) else X(rs1);\\n  let isWrite : bool = match op {\\n    CSRRW  => true,\\n    _      => if is_imm then unsigned(rs1_val) != 0 else unsigned(rs1) != 0\\n  };\\n  if not(check_CSR(csr, cur_privilege, isWrite))\\n  then { handle_illegal(); RETIRE_FAIL }\\n  else if not(ext_check_CSR(csr, cur_privilege, isWrite))\\n  then { ext_check_CSR_fail(); RETIRE_FAIL }\\n  else {\\n    let csr_val = readCSR(csr); /* could have side-effects, so technically shouldn\'t perform for CSRW[I] with rd == 0 */\\n    if isWrite then {\\n      let new_val : xlenbits = match op {\\n        CSRRW => rs1_val,\\n        CSRRS => csr_val | rs1_val,\\n        CSRRC => csr_val & ~(rs1_val)\\n      };\\n      writeCSR(csr, new_val)\\n    };\\n    X(rd) = csr_val;\\n    RETIRE_SUCCESS\\n  }\\n}","description":"TBD"},{"mnemonic":"csrrw","name":"TBD","operands":[{"name":"csr","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_imm","type":"bool"},{"name":"op","type":"csrop"}],"syntax":"rd,csr,rs1","format":"TBD","fields":[{"field":"csr","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_imm)","size":1},{"field":"encdec_csrop(op)","size":2},{"field":"rd","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{\\n  let rs1_val : xlenbits = if is_imm then zero_extend(rs1) else X(rs1);\\n  let isWrite : bool = match op {\\n    CSRRW  => true,\\n    _      => if is_imm then unsigned(rs1_val) != 0 else unsigned(rs1) != 0\\n  };\\n  if not(check_CSR(csr, cur_privilege, isWrite))\\n  then { handle_illegal(); RETIRE_FAIL }\\n  else if not(ext_check_CSR(csr, cur_privilege, isWrite))\\n  then { ext_check_CSR_fail(); RETIRE_FAIL }\\n  else {\\n    let csr_val = readCSR(csr); /* could have side-effects, so technically shouldn\'t perform for CSRW[I] with rd == 0 */\\n    if isWrite then {\\n      let new_val : xlenbits = match op {\\n        CSRRW => rs1_val,\\n        CSRRS => csr_val | rs1_val,\\n        CSRRC => csr_val & ~(rs1_val)\\n      };\\n      writeCSR(csr, new_val)\\n    };\\n    X(rd) = csr_val;\\n    RETIRE_SUCCESS\\n  }\\n}","description":"TBD"},{"mnemonic":"csrrwi","name":"TBD","operands":[{"name":"csr","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_imm","type":"bool"},{"name":"op","type":"csrop"}],"syntax":"rd,csr,rs1","format":"TBD","fields":[{"field":"csr","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_imm)","size":1},{"field":"encdec_csrop(op)","size":2},{"field":"rd","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{\\n  let rs1_val : xlenbits = if is_imm then zero_extend(rs1) else X(rs1);\\n  let isWrite : bool = match op {\\n    CSRRW  => true,\\n    _      => if is_imm then unsigned(rs1_val) != 0 else unsigned(rs1) != 0\\n  };\\n  if not(check_CSR(csr, cur_privilege, isWrite))\\n  then { handle_illegal(); RETIRE_FAIL }\\n  else if not(ext_check_CSR(csr, cur_privilege, isWrite))\\n  then { ext_check_CSR_fail(); RETIRE_FAIL }\\n  else {\\n    let csr_val = readCSR(csr); /* could have side-effects, so technically shouldn\'t perform for CSRW[I] with rd == 0 */\\n    if isWrite then {\\n      let new_val : xlenbits = match op {\\n        CSRRW => rs1_val,\\n        CSRRS => csr_val | rs1_val,\\n        CSRRC => csr_val & ~(rs1_val)\\n      };\\n      writeCSR(csr, new_val)\\n    };\\n    X(rd) = csr_val;\\n    RETIRE_SUCCESS\\n  }\\n}","description":"TBD"},{"mnemonic":"ctz","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b011000000001","size":12},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbb"],"function":"{\\n  let rs1_val = X(rs1);\\n  result : nat = 0;\\n  done : bool = false;\\n  foreach (i from 0 to (sizeof(xlen) - 1))\\n    if not(done) then if rs1_val[i] == bitzero\\n                    then result = result + 1\\n                    else done = true;\\n  X(rd) = to_bits(sizeof(xlen), result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"ctzw","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b011000000001","size":12},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":["Zbb"],"function":"{\\n  let rs1_val = X(rs1);\\n  result : nat = 0;\\n  done : bool = false;\\n  foreach (i from 0 to 31)\\n    if not(done) then if rs1_val[i] == bitzero\\n                    then result = result + 1\\n                    else done = true;\\n  X(rd) = to_bits(sizeof(xlen), result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"czero.eqz","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"RISCV_CZERO_NEZ","type":"zicondop"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000111","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b111","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zicond"],"function":"{\\n  let value = X(rs1);\\n  let condition = X(rs2);\\n  let result : xlenbits = if (condition != zeros()) then zeros()\\n\\t\\t\\t\\t\\t\\t    else value;\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"czero.nez","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"RISCV_CZERO_NEZ","type":"zicondop"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000111","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b111","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zicond"],"function":"{\\n  let value = X(rs1);\\n  let condition = X(rs2);\\n  let result : xlenbits = if (condition != zeros()) then zeros()\\n\\t\\t\\t\\t\\t\\t    else value;\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"div","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"s","type":"bool"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b10","size":2},{"field":"bool_not_bits(s)","size":1},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["M"],"function":"{\\n  if extension(\\"M\\") then {\\n    let rs1_val = X(rs1);\\n    let rs2_val = X(rs2);\\n    let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val);\\n    let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val);\\n    let q : int = if rs2_int == 0 then -1 else quot_round_zero(rs1_int, rs2_int);\\n    /* check for signed overflow */\\n    let q\': int = if s & q > xlen_max_signed then xlen_min_signed else q;\\n    X(rd) = to_bits(sizeof(xlen), q\');\\n    RETIRE_SUCCESS\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"divu","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"s","type":"bool"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b10","size":2},{"field":"bool_not_bits(s)","size":1},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["M"],"function":"{\\n  if extension(\\"M\\") then {\\n    let rs1_val = X(rs1);\\n    let rs2_val = X(rs2);\\n    let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val);\\n    let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val);\\n    let q : int = if rs2_int == 0 then -1 else quot_round_zero(rs1_int, rs2_int);\\n    /* check for signed overflow */\\n    let q\': int = if s & q > xlen_max_signed then xlen_min_signed else q;\\n    X(rd) = to_bits(sizeof(xlen), q\');\\n    RETIRE_SUCCESS\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"divuw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"s","type":"bool"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b10","size":2},{"field":"bool_not_bits(s)","size":1},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["M"],"function":"{\\n  if extension(\\"M\\") then {\\n    let rs1_val = X(rs1)[31..0];\\n    let rs2_val = X(rs2)[31..0];\\n    let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val);\\n    let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val);\\n    let q : int = if rs2_int == 0 then -1 else quot_round_zero(rs1_int, rs2_int);\\n    /* check for signed overflow */\\n    let q\': int = if s & q > (2 ^ 31 - 1) then  (0 - 2^31) else q;\\n    X(rd) = sign_extend(to_bits(32, q\'));\\n    RETIRE_SUCCESS\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"divw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"s","type":"bool"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b10","size":2},{"field":"bool_not_bits(s)","size":1},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["M"],"function":"{\\n  if extension(\\"M\\") then {\\n    let rs1_val = X(rs1)[31..0];\\n    let rs2_val = X(rs2)[31..0];\\n    let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val);\\n    let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val);\\n    let q : int = if rs2_int == 0 then -1 else quot_round_zero(rs1_int, rs2_int);\\n    /* check for signed overflow */\\n    let q\': int = if s & q > (2 ^ 31 - 1) then  (0 - 2^31) else q;\\n    X(rd) = sign_extend(to_bits(32, q\'));\\n    RETIRE_SUCCESS\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"ebreak","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b000000000001","size":12},{"field":"0b00000","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{\\n  handle_mem_exception(PC, E_Breakpoint());\\n  RETIRE_FAIL\\n}","description":"TBD"},{"mnemonic":"ecall","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b000000000000","size":12},{"field":"0b00000","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{\\n  let t : sync_exception =\\n    struct { trap = match (cur_privilege) {\\n                      User       => E_U_EnvCall(),\\n                      Supervisor => E_S_EnvCall(),\\n                      Machine    => E_M_EnvCall()\\n                    },\\n             excinfo = (None() : option(xlenbits)),\\n             ext     = None() };\\n  set_next_pc(exception_handler(cur_privilege, CTL_TRAP(t), PC));\\n  RETIRE_FAIL\\n}","description":"TBD"},{"mnemonic":"fadd.d","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_bin_rm_op_D"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_64b = F_or_X_D(rs1);\\n  let rs2_val_64b = F_or_X_D(rs2);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op {\\n        FADD_D  => riscv_f64Add (rm_3b, rs1_val_64b, rs2_val_64b),\\n        FSUB_D  => riscv_f64Sub (rm_3b, rs1_val_64b, rs2_val_64b),\\n        FMUL_D  => riscv_f64Mul (rm_3b, rs1_val_64b, rs2_val_64b),\\n        FDIV_D  => riscv_f64Div (rm_3b, rs1_val_64b, rs2_val_64b)\\n      };\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_64b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fadd.h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_bin_rm_op_H"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001110","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_16b = F_or_X_H(rs1);\\n  let rs2_val_16b = F_or_X_H(rs2);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op {\\n        FADD_H  => riscv_f16Add (rm_3b, rs1_val_16b, rs2_val_16b),\\n        FSUB_H  => riscv_f16Sub (rm_3b, rs1_val_16b, rs2_val_16b),\\n        FMUL_H  => riscv_f16Mul (rm_3b, rs1_val_16b, rs2_val_16b),\\n        FDIV_H  => riscv_f16Div (rm_3b, rs1_val_16b, rs2_val_16b)\\n      };\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_16b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fadd.s","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_bin_rm_op_S"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_32b = F_or_X_S(rs1);\\n  let rs2_val_32b = F_or_X_S(rs2);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op {\\n        FADD_S  => riscv_f32Add (rm_3b, rs1_val_32b, rs2_val_32b),\\n        FSUB_S  => riscv_f32Sub (rm_3b, rs1_val_32b, rs2_val_32b),\\n        FMUL_S  => riscv_f32Mul (rm_3b, rs1_val_32b, rs2_val_32b),\\n        FDIV_S  => riscv_f32Div (rm_3b, rs1_val_32b, rs2_val_32b)\\n      };\\n      accrue_fflags(fflags);\\n      F_or_X_S(rd) = rd_val_32b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fclass.d","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FMV_D_X","type":"f_un_op_D"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111001","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D"],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_X            = X(rs1);\\n  let rd_val_D             = rs1_val_X [63..0];\\n  F(rd) = rd_val_D;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fclass.h","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FMV_H_X","type":"f_un_op_H"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111010","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh"],"function":"{\\n  let rs1_val_X            = X(rs1);\\n  let rd_val_H             = rs1_val_X [15..0];\\n  F(rd) = nan_box (rd_val_H);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fclass.s","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FMV_W_X","type":"f_un_op_S"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111000","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["F"],"function":"{\\n  let rs1_val_X            = X(rs1);\\n  let rd_val_S             = rs1_val_X [31..0];\\n  F(rd) = nan_box (rd_val_S);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fcvt.d.h","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_H_LU","type":"f_un_rm_op_H"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_H;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.d.l","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_D_LU","type":"f_un_rm_op_D"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_D;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.d.lu","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_D_LU","type":"f_un_rm_op_D"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_D;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.d.s","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_D_LU","type":"f_un_rm_op_D"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_D;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.d.w","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_D_LU","type":"f_un_rm_op_D"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_D;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.d.wu","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_D_LU","type":"f_un_rm_op_D"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_D;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.h.d","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_H_LU","type":"f_un_rm_op_H"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_H;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.h.l","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_H_LU","type":"f_un_rm_op_H"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_H;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.h.lu","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_H_LU","type":"f_un_rm_op_H"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_H;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.h.s","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_H_LU","type":"f_un_rm_op_H"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_H;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.h.w","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_H_LU","type":"f_un_rm_op_H"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_H;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.h.wu","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_H_LU","type":"f_un_rm_op_H"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_H;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.l.d","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_D_LU","type":"f_un_rm_op_D"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_D;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.l.h","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_H_LU","type":"f_un_rm_op_H"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_H;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.l.s","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_S_LU","type":"f_un_rm_op_S"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_S(rd) = rd_val_S;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.lu.d","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_D_LU","type":"f_un_rm_op_D"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_D;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.lu.h","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_H_LU","type":"f_un_rm_op_H"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_H;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.lu.s","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_S_LU","type":"f_un_rm_op_S"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_S(rd) = rd_val_S;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.s.d","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_D_LU","type":"f_un_rm_op_D"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_D;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.s.h","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_H_LU","type":"f_un_rm_op_H"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_H;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.s.l","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_S_LU","type":"f_un_rm_op_S"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_S(rd) = rd_val_S;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.s.lu","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_S_LU","type":"f_un_rm_op_S"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_S(rd) = rd_val_S;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.s.w","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_S_LU","type":"f_un_rm_op_S"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_S(rd) = rd_val_S;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.s.wu","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_S_LU","type":"f_un_rm_op_S"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_S(rd) = rd_val_S;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.w.d","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_D_LU","type":"f_un_rm_op_D"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_D;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.w.h","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_H_LU","type":"f_un_rm_op_H"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_H;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.w.s","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_S_LU","type":"f_un_rm_op_S"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_S(rd) = rd_val_S;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.wu.d","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_D_LU","type":"f_un_rm_op_D"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_D;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.wu.h","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_H_LU","type":"f_un_rm_op_H"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_H;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvt.wu.s","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_S_LU","type":"f_un_rm_op_S"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_S(rd) = rd_val_S;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fcvtmod.w.d","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1100001","size":7},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{\\n  let rs1_val_D = F_D(rs1);\\n  let (fflags, rd_val) = fcvtmod_helper(rs1_val_D);\\n  accrue_fflags(fflags);\\n  X(rd) = sign_extend(rd_val);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fdiv.d","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_bin_rm_op_D"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_64b = F_or_X_D(rs1);\\n  let rs2_val_64b = F_or_X_D(rs2);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op {\\n        FADD_D  => riscv_f64Add (rm_3b, rs1_val_64b, rs2_val_64b),\\n        FSUB_D  => riscv_f64Sub (rm_3b, rs1_val_64b, rs2_val_64b),\\n        FMUL_D  => riscv_f64Mul (rm_3b, rs1_val_64b, rs2_val_64b),\\n        FDIV_D  => riscv_f64Div (rm_3b, rs1_val_64b, rs2_val_64b)\\n      };\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_64b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fdiv.h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_bin_rm_op_H"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001110","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_16b = F_or_X_H(rs1);\\n  let rs2_val_16b = F_or_X_H(rs2);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op {\\n        FADD_H  => riscv_f16Add (rm_3b, rs1_val_16b, rs2_val_16b),\\n        FSUB_H  => riscv_f16Sub (rm_3b, rs1_val_16b, rs2_val_16b),\\n        FMUL_H  => riscv_f16Mul (rm_3b, rs1_val_16b, rs2_val_16b),\\n        FDIV_H  => riscv_f16Div (rm_3b, rs1_val_16b, rs2_val_16b)\\n      };\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_16b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fdiv.s","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_bin_rm_op_S"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_32b = F_or_X_S(rs1);\\n  let rs2_val_32b = F_or_X_S(rs2);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op {\\n        FADD_S  => riscv_f32Add (rm_3b, rs1_val_32b, rs2_val_32b),\\n        FSUB_S  => riscv_f32Sub (rm_3b, rs1_val_32b, rs2_val_32b),\\n        FMUL_S  => riscv_f32Mul (rm_3b, rs1_val_32b, rs2_val_32b),\\n        FDIV_S  => riscv_f32Div (rm_3b, rs1_val_32b, rs2_val_32b)\\n      };\\n      accrue_fflags(fflags);\\n      F_or_X_S(rd) = rd_val_32b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fence","name":"Fence (Memory)","operands":[{"name":"pred","type":"bits(4)"},{"name":"succ","type":"bits(4)"}],"syntax":"pred,succ","format":"I","fields":[{"field":"0b0000","size":4},{"field":"pred","size":4},{"field":"succ","size":4},{"field":"0b00000","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b0001111","size":7}],"extensions":[],"function":"{\\n  // If the FIOM bit in menvcfg/senvcfg is set then the I/O bits can imply R/W.\\n  let fiom = is_fiom_active();\\n  let pred = effective_fence_set(pred, fiom);\\n  let succ = effective_fence_set(succ, fiom);\\n\\n  match (pred, succ) {\\n    (_ : bits(2) @ 0b11, _ : bits(2) @ 0b11) => __barrier(Barrier_RISCV_rw_rw()),\\n    (_ : bits(2) @ 0b10, _ : bits(2) @ 0b11) => __barrier(Barrier_RISCV_r_rw()),\\n    (_ : bits(2) @ 0b10, _ : bits(2) @ 0b10) => __barrier(Barrier_RISCV_r_r()),\\n    (_ : bits(2) @ 0b11, _ : bits(2) @ 0b01) => __barrier(Barrier_RISCV_rw_w()),\\n    (_ : bits(2) @ 0b01, _ : bits(2) @ 0b01) => __barrier(Barrier_RISCV_w_w()),\\n    (_ : bits(2) @ 0b01, _ : bits(2) @ 0b11) => __barrier(Barrier_RISCV_w_rw()),\\n    (_ : bits(2) @ 0b11, _ : bits(2) @ 0b10) => __barrier(Barrier_RISCV_rw_r()),\\n    (_ : bits(2) @ 0b10, _ : bits(2) @ 0b01) => __barrier(Barrier_RISCV_r_w()),\\n    (_ : bits(2) @ 0b01, _ : bits(2) @ 0b10) => __barrier(Barrier_RISCV_w_r()),\\n\\n    (_ : bits(4)       , _ : bits(2) @ 0b00) => (),\\n    (_ : bits(2) @ 0b00, _ : bits(4)       ) => (),\\n\\n    _ => { print(\\"FIXME: unsupported fence\\");\\n           () }\\n  };\\n  RETIRE_SUCCESS\\n}","description":"\\nThe FENCE instruction is used to provide memory ordering guarantees.\\nIt specifies ordering constraints on memory operations that precede\\nand follow it in program order. The FENCE instruction includes two\\n4-bit fields, \'pred\' and \'succ\', which represent the memory ordering\\nrequirements before and after the FENCE instruction, respectively.\\n *\\nThe bits in \'pred\' and \'succ\' represent the following ordering constraints:\\n- \'i\': instruction stream order\\n- \'o\': outstanding loads\\n- \'r\': read operations\\n- \'w\': write operations\\n *\\nThe FENCE instruction is used to control the visibility of memory\\noperations, and its behavior is influenced by the \'pred\' and \'succ\'\\nfields. The precise semantics of the FENCE instruction depend on the\\nspecific bits set in these fields.\\n "},{"mnemonic":"fence.i","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b000000000000","size":12},{"field":"0b00000","size":5},{"field":"0b001","size":3},{"field":"0b00000","size":5},{"field":"0b0001111","size":7}],"extensions":[],"function":"{ /* __barrier(Barrier_RISCV_i); */ RETIRE_SUCCESS }","description":"TBD"},{"mnemonic":"fence.tso","name":"Fence (Total Store Order)","operands":[{"name":"pred","type":"bits(4)"},{"name":"succ","type":"bits(4)"}],"syntax":"pred,succ","format":"I","fields":[{"field":"0b1000","size":4},{"field":"pred","size":4},{"field":"succ","size":4},{"field":"0b00000","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b0001111","size":7}],"extensions":[],"function":"{\\n  match (pred, succ) {\\n    (_ : bits(2) @ 0b11, _ : bits(2) @ 0b11) => __barrier(Barrier_RISCV_tso()),\\n    (_ : bits(2) @ 0b00, _ : bits(2) @ 0b00) => (),\\n\\n    _ => { print(\\"FIXME: unsupported fence\\");\\n           () }\\n  };\\n  RETIRE_SUCCESS\\n}","description":"\\nThe FENCE_TSO instruction is a memory\\nordering instruction that provides a stronger memory consistency model\\ncompared to the standard FENCE instruction. It ensures that all memory\\noperations preceding and following the FENCE_TSO instruction are globally\\nordered. The FENCE_TSO instruction includes two 4-bit fields, \'pred\' and\\n\'succ\', which represent the memory ordering requirements before and after\\nthe FENCE_TSO instruction, respectively.\\n "},{"mnemonic":"feq.d","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_D","type":"f_bin_op_D"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_D = F_or_X_D(rs1);\\n  let rs2_val_D = F_or_X_D(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f64Le (rs1_val_D, rs2_val_D);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"feq.h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_H","type":"f_bin_op_H"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_H = F_or_X_H(rs1);\\n  let rs2_val_H = F_or_X_H(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f16Le (rs1_val_H, rs2_val_H);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"feq.s","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_S","type":"f_bin_op_S"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_S = F_or_X_S(rs1);\\n  let rs2_val_S = F_or_X_S(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f32Le (rs1_val_S, rs2_val_S);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"flb","name":"TBD","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"width","type":"word_width"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"rd","size":5},{"field":"0b0000111","size":7}],"extensions":["D"],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(addr, _) => {\\n          let (aq, rl, res) = (false, false, false);\\n          match (width) {\\n            BYTE => { handle_illegal(); RETIRE_FAIL },\\n            HALF =>\\n               process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)),\\n            WORD =>\\n               process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)),\\n            DOUBLE if sizeof(flen) >= 64 =>\\n               process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"floating point load\\"),\\n          }\\n        }\\n      }\\n  }\\n}","description":"TBD"},{"mnemonic":"fld","name":"TBD","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"width","type":"word_width"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"rd","size":5},{"field":"0b0000111","size":7}],"extensions":["D"],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(addr, _) => {\\n          let (aq, rl, res) = (false, false, false);\\n          match (width) {\\n            BYTE => { handle_illegal(); RETIRE_FAIL },\\n            HALF =>\\n               process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)),\\n            WORD =>\\n               process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)),\\n            DOUBLE if sizeof(flen) >= 64 =>\\n               process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"floating point load\\"),\\n          }\\n        }\\n      }\\n  }\\n}","description":"TBD"},{"mnemonic":"fle.d","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_D","type":"f_bin_op_D"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_D = F_or_X_D(rs1);\\n  let rs2_val_D = F_or_X_D(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f64Le (rs1_val_D, rs2_val_D);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fle.h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_H","type":"f_bin_op_H"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_H = F_or_X_H(rs1);\\n  let rs2_val_H = F_or_X_H(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f16Le (rs1_val_H, rs2_val_H);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fle.s","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_S","type":"f_bin_op_S"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_S = F_or_X_S(rs1);\\n  let rs2_val_S = F_or_X_S(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f32Le (rs1_val_S, rs2_val_S);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fleq.d","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{\\n  let rs1_val_D = F_D(rs1);\\n  let rs2_val_D = F_D(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f64Le_quiet   (rs1_val_D, rs2_val_D);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fleq.h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh","Zfa"],"function":"{\\n  let rs1_val_H = F_H(rs1);\\n  let rs2_val_H = F_H(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f16Le_quiet   (rs1_val_H, rs2_val_H);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fleq.s","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfa"],"function":"{\\n  let rs1_val_S = F_S(rs1);\\n  let rs2_val_S = F_S(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f32Le_quiet   (rs1_val_S, rs2_val_S);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"flh","name":"TBD","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"width","type":"word_width"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"rd","size":5},{"field":"0b0000111","size":7}],"extensions":["D"],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(addr, _) => {\\n          let (aq, rl, res) = (false, false, false);\\n          match (width) {\\n            BYTE => { handle_illegal(); RETIRE_FAIL },\\n            HALF =>\\n               process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)),\\n            WORD =>\\n               process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)),\\n            DOUBLE if sizeof(flen) >= 64 =>\\n               process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"floating point load\\"),\\n          }\\n        }\\n      }\\n  }\\n}","description":"TBD"},{"mnemonic":"fli.d","name":"TBD","operands":[{"name":"constantidx","type":"bits(5)"},{"name":"rd","type":"regidx"}],"syntax":"rd,constantidx","format":"TBD","fields":[{"field":"0b1111001","size":7},{"field":"0b00001","size":5},{"field":"rs1","size":3},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{\\n  let bits : bits(64) = match constantidx {\\n    0b00000 => { 0xbff0000000000000 },  /* -1.0 */\\n    0b00001 => { 0x0010000000000000 },  /* minimum positive normal */\\n    0b00010 => { 0x3Ef0000000000000 },  /* 1.0 * 2^-16 */\\n    0b00011 => { 0x3f00000000000000 },  /* 1.0 * 2^-15 */\\n    0b00100 => { 0x3f70000000000000 },  /* 1.0 * 2^-8  */\\n    0b00101 => { 0x3f80000000000000 },  /* 1.0 * 2^-7  */\\n    0b00110 => { 0x3fb0000000000000 },  /* 1.0 * 2^-4  */\\n    0b00111 => { 0x3fc0000000000000 },  /* 1.0 * 2^-3  */\\n    0b01000 => { 0x3fd0000000000000 },  /* 0.25 */\\n    0b01001 => { 0x3fd4000000000000 },  /* 0.3125 */\\n    0b01010 => { 0x3fd8000000000000 },  /* 0.375 */\\n    0b01011 => { 0x3fdc000000000000 },  /* 0.4375 */\\n    0b01100 => { 0x3fe0000000000000 },  /* 0.5 */\\n    0b01101 => { 0x3fe4000000000000 },  /* 0.625 */\\n    0b01110 => { 0x3fe8000000000000 },  /* 0.75 */\\n    0b01111 => { 0x3fec000000000000 },  /* 0.875 */\\n    0b10000 => { 0x3ff0000000000000 },  /* 1.0 */\\n    0b10001 => { 0x3ff4000000000000 },  /* 1.25 */\\n    0b10010 => { 0x3ff8000000000000 },  /* 1.5 */\\n    0b10011 => { 0x3ffc000000000000 },  /* 1.75 */\\n    0b10100 => { 0x4000000000000000 },  /* 2.0 */\\n    0b10101 => { 0x4004000000000000 },  /* 2.5 */\\n    0b10110 => { 0x4008000000000000 },  /* 3 */\\n    0b10111 => { 0x4010000000000000 },  /* 4 */\\n    0b11000 => { 0x4020000000000000 },  /* 8 */\\n    0b11001 => { 0x4030000000000000 },  /* 16 */\\n    0b11010 => { 0x4060000000000000 },  /* 2^7 */\\n    0b11011 => { 0x4070000000000000 },  /* 2^8 */\\n    0b11100 => { 0x40e0000000000000 },  /* 2^15 */\\n    0b11101 => { 0x40f0000000000000 },  /* 2^16 */\\n    0b11110 => { 0x7ff0000000000000 },  /* +inf */\\n    0b11111 => { canonical_NaN_D() },\\n  };\\n  F_D(rd) = bits;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fli.h","name":"TBD","operands":[{"name":"constantidx","type":"bits(5)"},{"name":"rd","type":"regidx"}],"syntax":"rd,constantidx","format":"TBD","fields":[{"field":"0b1111010","size":7},{"field":"0b00001","size":5},{"field":"rs1","size":3},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh","Zfa"],"function":"{\\n  let bits : bits(16) = match constantidx {\\n    0b00000 => { 0xbc00 },  /* -1.0 */\\n    0b00001 => { 0x0400 },  /* minimum positive normal */\\n    0b00010 => { 0x0100 },  /* 1.0 * 2^-16 */\\n    0b00011 => { 0x0200 },  /* 1.0 * 2^-15 */\\n    0b00100 => { 0x1c00 },  /* 1.0 * 2^-8  */\\n    0b00101 => { 0x2000 },  /* 1.0 * 2^-7  */\\n    0b00110 => { 0x2c00 },  /* 1.0 * 2^-4  */\\n    0b00111 => { 0x3000 },  /* 1.0 * 2^-3  */\\n    0b01000 => { 0x3400 },  /* 0.25 */\\n    0b01001 => { 0x3500 },  /* 0.3125 */\\n    0b01010 => { 0x3600 },  /* 0.375 */\\n    0b01011 => { 0x3700 },  /* 0.4375 */\\n    0b01100 => { 0x3800 },  /* 0.5 */\\n    0b01101 => { 0x3900 },  /* 0.625 */\\n    0b01110 => { 0x3a00 },  /* 0.75 */\\n    0b01111 => { 0x3b00 },  /* 0.875 */\\n    0b10000 => { 0x3c00 },  /* 1.0 */\\n    0b10001 => { 0x3d00 },  /* 1.25 */\\n    0b10010 => { 0x3e00 },  /* 1.5 */\\n    0b10011 => { 0x3f00 },  /* 1.75 */\\n    0b10100 => { 0x4000 },  /* 2.0 */\\n    0b10101 => { 0x4100 },  /* 2.5 */\\n    0b10110 => { 0x4200 },  /* 3 */\\n    0b10111 => { 0x4400 },  /* 4 */\\n    0b11000 => { 0x4800 },  /* 8 */\\n    0b11001 => { 0x4c00 },  /* 16 */\\n    0b11010 => { 0x5800 },  /* 2^7 */\\n    0b11011 => { 0x5c00 },  /* 2^8 */\\n    0b11100 => { 0x7800 },  /* 2^15 */\\n    0b11101 => { 0x7c00 },  /* 2^16 */\\n    0b11110 => { 0x7c00 },  /* +inf */\\n    0b11111 => { canonical_NaN_H() },\\n  };\\n  F_H(rd) = bits;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fli.s","name":"TBD","operands":[{"name":"constantidx","type":"bits(5)"},{"name":"rd","type":"regidx"}],"syntax":"rd,constantidx","format":"TBD","fields":[{"field":"0b1111000","size":7},{"field":"0b00001","size":5},{"field":"rs1","size":3},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfa"],"function":"{\\n  let bits : bits(32) = match constantidx {\\n    0b00000 => { 0xbf800000 },  /* -1.0 */\\n    0b00001 => { 0x00800000 },  /* minimum positive normal */\\n    0b00010 => { 0x37800000 },  /* 1.0 * 2^-16 */\\n    0b00011 => { 0x38000000 },  /* 1.0 * 2^-15 */\\n    0b00100 => { 0x3b800000 },  /* 1.0 * 2^-8  */\\n    0b00101 => { 0x3c000000 },  /* 1.0 * 2^-7  */\\n    0b00110 => { 0x3d800000 },  /* 1.0 * 2^-4  */\\n    0b00111 => { 0x3e000000 },  /* 1.0 * 2^-3  */\\n    0b01000 => { 0x3e800000 },  /* 0.25 */\\n    0b01001 => { 0x3ea00000 },  /* 0.3125 */\\n    0b01010 => { 0x3ec00000 },  /* 0.375 */\\n    0b01011 => { 0x3ee00000 },  /* 0.4375 */\\n    0b01100 => { 0x3f000000 },  /* 0.5 */\\n    0b01101 => { 0x3f200000 },  /* 0.625 */\\n    0b01110 => { 0x3f400000 },  /* 0.75 */\\n    0b01111 => { 0x3f600000 },  /* 0.875 */\\n    0b10000 => { 0x3f800000 },  /* 1.0 */\\n    0b10001 => { 0x3fa00000 },  /* 1.25 */\\n    0b10010 => { 0x3fc00000 },  /* 1.5 */\\n    0b10011 => { 0x3fe00000 },  /* 1.75 */\\n    0b10100 => { 0x40000000 },  /* 2.0 */\\n    0b10101 => { 0x40200000 },  /* 2.5 */\\n    0b10110 => { 0x40400000 },  /* 3 */\\n    0b10111 => { 0x40800000 },  /* 4 */\\n    0b11000 => { 0x41000000 },  /* 8 */\\n    0b11001 => { 0x41800000 },  /* 16 */\\n    0b11010 => { 0x43000000 },  /* 2^7 */\\n    0b11011 => { 0x43800000 },  /* 2^8 */\\n    0b11100 => { 0x47000000 },  /* 2^15 */\\n    0b11101 => { 0x47800000 },  /* 2^16 */\\n    0b11110 => { 0x7f800000 },  /* +inf */\\n    0b11111 => { canonical_NaN_S() },\\n  };\\n  F_S(rd) = bits;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"flt.d","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_D","type":"f_bin_op_D"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_D = F_or_X_D(rs1);\\n  let rs2_val_D = F_or_X_D(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f64Le (rs1_val_D, rs2_val_D);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"flt.h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_H","type":"f_bin_op_H"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_H = F_or_X_H(rs1);\\n  let rs2_val_H = F_or_X_H(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f16Le (rs1_val_H, rs2_val_H);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"flt.s","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_S","type":"f_bin_op_S"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_S = F_or_X_S(rs1);\\n  let rs2_val_S = F_or_X_S(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f32Le (rs1_val_S, rs2_val_S);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fltq.d","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{\\n  let rs1_val_D = F_D(rs1);\\n  let rs2_val_D = F_D(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f64Lt_quiet   (rs1_val_D, rs2_val_D);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fltq.h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh","Zfa"],"function":"{\\n  let rs1_val_H = F_H(rs1);\\n  let rs2_val_H = F_H(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f16Lt_quiet   (rs1_val_H, rs2_val_H);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fltq.s","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfa"],"function":"{\\n  let rs1_val_S = F_S(rs1);\\n  let rs2_val_S = F_S(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f32Lt_quiet   (rs1_val_S, rs2_val_S);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"flw","name":"TBD","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"width","type":"word_width"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"rd","size":5},{"field":"0b0000111","size":7}],"extensions":["D"],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(addr, _) => {\\n          let (aq, rl, res) = (false, false, false);\\n          match (width) {\\n            BYTE => { handle_illegal(); RETIRE_FAIL },\\n            HALF =>\\n               process_fload16(rd, vaddr, mem_read(Read(Data), addr, 2, aq, rl, res)),\\n            WORD =>\\n               process_fload32(rd, vaddr, mem_read(Read(Data), addr, 4, aq, rl, res)),\\n            DOUBLE if sizeof(flen) >= 64 =>\\n               process_fload64(rd, vaddr, mem_read(Read(Data), addr, 8, aq, rl, res)),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"floating point load\\"),\\n          }\\n        }\\n      }\\n  }\\n}","description":"TBD"},{"mnemonic":"fmadd.d","name":"TBD","operands":[{"name":"rs3","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_madd_op_D"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b01","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{\\n  let rs1_val_64b = F_or_X_D(rs1);\\n  let rs2_val_64b = F_or_X_D(rs2);\\n  let rs3_val_64b = F_or_X_D(rs3);\\n\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_64b) : (bits(5), bits(64)) =\\n        match op {\\n          FMADD_D  => riscv_f64MulAdd (rm_3b, rs1_val_64b, rs2_val_64b, rs3_val_64b),\\n          FMSUB_D  => riscv_f64MulAdd (rm_3b, rs1_val_64b, rs2_val_64b, negate_D (rs3_val_64b)),\\n          FNMSUB_D => riscv_f64MulAdd (rm_3b, negate_D (rs1_val_64b), rs2_val_64b, rs3_val_64b),\\n          FNMADD_D => riscv_f64MulAdd (rm_3b, negate_D (rs1_val_64b), rs2_val_64b, negate_D (rs3_val_64b))\\n        };\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_64b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fmadd.h","name":"TBD","operands":[{"name":"rs3","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_madd_op_H"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b10","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{\\n  let rs1_val_16b = F_or_X_H(rs1);\\n  let rs2_val_16b = F_or_X_H(rs2);\\n  let rs3_val_16b = F_or_X_H(rs3);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_16b) : (bits(5), bits(16)) =\\n        match op {\\n          FMADD_H  => riscv_f16MulAdd (rm_3b, rs1_val_16b, rs2_val_16b, rs3_val_16b),\\n          FMSUB_H  => riscv_f16MulAdd (rm_3b, rs1_val_16b, rs2_val_16b, negate_H (rs3_val_16b)),\\n          FNMSUB_H => riscv_f16MulAdd (rm_3b, negate_H (rs1_val_16b), rs2_val_16b, rs3_val_16b),\\n          FNMADD_H => riscv_f16MulAdd (rm_3b, negate_H (rs1_val_16b), rs2_val_16b, negate_H (rs3_val_16b))\\n        };\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_16b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fmadd.s","name":"TBD","operands":[{"name":"rs3","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_madd_op_S"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b00","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{\\n  let rs1_val_32b = F_or_X_S(rs1);\\n  let rs2_val_32b = F_or_X_S(rs2);\\n  let rs3_val_32b = F_or_X_S(rs3);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_32b) : (bits(5), bits(32)) =\\n        match op {\\n          FMADD_S  => riscv_f32MulAdd (rm_3b, rs1_val_32b, rs2_val_32b, rs3_val_32b),\\n          FMSUB_S  => riscv_f32MulAdd (rm_3b, rs1_val_32b, rs2_val_32b, negate_S (rs3_val_32b)),\\n          FNMSUB_S => riscv_f32MulAdd (rm_3b, negate_S (rs1_val_32b), rs2_val_32b, rs3_val_32b),\\n          FNMADD_S => riscv_f32MulAdd (rm_3b, negate_S (rs1_val_32b), rs2_val_32b, negate_S (rs3_val_32b))\\n        };\\n      accrue_fflags(fflags);\\n      F_or_X_S(rd) = rd_val_32b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fmax.d","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_D","type":"f_bin_op_D"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_D = F_or_X_D(rs1);\\n  let rs2_val_D = F_or_X_D(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f64Le (rs1_val_D, rs2_val_D);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fmax.h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_H","type":"f_bin_op_H"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_H = F_or_X_H(rs1);\\n  let rs2_val_H = F_or_X_H(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f16Le (rs1_val_H, rs2_val_H);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fmax.s","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_S","type":"f_bin_op_S"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_S = F_or_X_S(rs1);\\n  let rs2_val_S = F_or_X_S(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f32Le (rs1_val_S, rs2_val_S);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fmaxm.d","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{\\n  let rs1_val_D = F(rs1);\\n  let rs2_val_D = F(rs2);\\n\\n  let is_quiet  = true;\\n  let (rs2_lt_rs1, fflags) = fle_D (rs2_val_D, rs1_val_D, is_quiet);\\n\\n  let rd_val_D  = if      (f_is_NaN_D(rs1_val_D) | f_is_NaN_D(rs2_val_D))           then canonical_NaN_D()\\n                  else if (f_is_neg_zero_D(rs1_val_D) & f_is_pos_zero_D(rs2_val_D)) then rs2_val_D\\n                  else if (f_is_neg_zero_D(rs2_val_D) & f_is_pos_zero_D(rs1_val_D)) then rs1_val_D\\n                  else if rs2_lt_rs1                                                then rs1_val_D\\n                  else                                                              rs2_val_D;\\n\\n  accrue_fflags(fflags);\\n  F(rd) = rd_val_D;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fmaxm.h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010110","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh","Zfa"],"function":"{\\n  let rs1_val_H = F_H(rs1);\\n  let rs2_val_H = F_H(rs2);\\n\\n  let is_quiet  = true;\\n  let (rs2_lt_rs1, fflags) = fle_H (rs2_val_H, rs1_val_H, is_quiet);\\n\\n  let rd_val_H =  if      (f_is_NaN_H(rs1_val_H) | f_is_NaN_H(rs2_val_H))           then canonical_NaN_H()\\n                  else if (f_is_neg_zero_H(rs1_val_H) & f_is_pos_zero_H(rs2_val_H)) then rs2_val_H\\n                  else if (f_is_neg_zero_H(rs2_val_H) & f_is_pos_zero_H(rs1_val_H)) then rs1_val_H\\n                  else if rs2_lt_rs1                                                then rs1_val_H\\n                  else /* (not rs2_lt_rs1) */                                            rs2_val_H;\\n\\n  accrue_fflags(fflags);\\n  F_H(rd) = rd_val_H;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fmaxm.s","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfa"],"function":"{\\n  let rs1_val_S = F_S(rs1);\\n  let rs2_val_S = F_S(rs2);\\n\\n  let is_quiet  = true;\\n  let (rs2_lt_rs1, fflags) = fle_S (rs2_val_S, rs1_val_S, is_quiet);\\n\\n  let rd_val_S  = if      (f_is_NaN_S(rs1_val_S) | f_is_NaN_S(rs2_val_S))           then canonical_NaN_S()\\n                  else if (f_is_neg_zero_S(rs1_val_S) & f_is_pos_zero_S(rs2_val_S)) then rs2_val_S\\n                  else if (f_is_neg_zero_S(rs2_val_S) & f_is_pos_zero_S(rs1_val_S)) then rs1_val_S\\n                  else if rs2_lt_rs1                                                then rs1_val_S\\n                  else /* (not rs2_lt_rs1) */                                            rs2_val_S;\\n\\n  accrue_fflags(fflags);\\n  F_S(rd) = rd_val_S;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fmin.d","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_D","type":"f_bin_op_D"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_D = F_or_X_D(rs1);\\n  let rs2_val_D = F_or_X_D(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f64Le (rs1_val_D, rs2_val_D);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fmin.h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_H","type":"f_bin_op_H"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_H = F_or_X_H(rs1);\\n  let rs2_val_H = F_or_X_H(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f16Le (rs1_val_H, rs2_val_H);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fmin.s","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_S","type":"f_bin_op_S"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_S = F_or_X_S(rs1);\\n  let rs2_val_S = F_or_X_S(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f32Le (rs1_val_S, rs2_val_S);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fminm.d","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b010","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{\\n  let rs1_val_D = F(rs1);\\n  let rs2_val_D = F(rs2);\\n\\n  let is_quiet  = true;\\n  let (rs1_lt_rs2, fflags) = fle_D (rs1_val_D, rs2_val_D, is_quiet);\\n\\n  let rd_val_D  = if      (f_is_NaN_D(rs1_val_D) | f_is_NaN_D(rs2_val_D))           then canonical_NaN_D()\\n                  else if (f_is_neg_zero_D(rs1_val_D) & f_is_pos_zero_D(rs2_val_D)) then rs1_val_D\\n                  else if (f_is_neg_zero_D(rs2_val_D) & f_is_pos_zero_D(rs1_val_D)) then rs2_val_D\\n                  else if rs1_lt_rs2                                                then rs1_val_D\\n                  else                                                              rs2_val_D;\\n\\n  accrue_fflags(fflags);\\n  F(rd) = rd_val_D;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fminm.h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010110","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b010","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh","Zfa"],"function":"{\\n  let rs1_val_H = F_H(rs1);\\n  let rs2_val_H = F_H(rs2);\\n\\n  let is_quiet  = true;\\n  let (rs1_lt_rs2, fflags) = fle_H (rs1_val_H, rs2_val_H, is_quiet);\\n\\n  let rd_val_H  = if      (f_is_NaN_H(rs1_val_H) | f_is_NaN_H(rs2_val_H))           then canonical_NaN_H()\\n                  else if (f_is_neg_zero_H(rs1_val_H) & f_is_pos_zero_H(rs2_val_H)) then rs1_val_H\\n                  else if (f_is_neg_zero_H(rs2_val_H) & f_is_pos_zero_H(rs1_val_H)) then rs2_val_H\\n                  else if rs1_lt_rs2                                                then rs1_val_H\\n                  else /* (not rs1_lt_rs2) */                                            rs2_val_H;\\n\\n  accrue_fflags(fflags);\\n  F_H(rd) = rd_val_H;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fminm.s","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b010","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfa"],"function":"{\\n  let rs1_val_S = F_S(rs1);\\n  let rs2_val_S = F_S(rs2);\\n\\n  let is_quiet  = true;\\n  let (rs1_lt_rs2, fflags) = fle_S (rs1_val_S, rs2_val_S, is_quiet);\\n\\n  let rd_val_S  = if      (f_is_NaN_S(rs1_val_S) | f_is_NaN_S(rs2_val_S))           then canonical_NaN_S()\\n                  else if (f_is_neg_zero_S(rs1_val_S) & f_is_pos_zero_S(rs2_val_S)) then rs1_val_S\\n                  else if (f_is_neg_zero_S(rs2_val_S) & f_is_pos_zero_S(rs1_val_S)) then rs2_val_S\\n                  else if rs1_lt_rs2                                                then rs1_val_S\\n                  else /* (not rs1_lt_rs2) */                                            rs2_val_S;\\n\\n  accrue_fflags(fflags);\\n  F_S(rd) = rd_val_S;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fmsub.d","name":"TBD","operands":[{"name":"rs3","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_madd_op_D"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b01","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{\\n  let rs1_val_64b = F_or_X_D(rs1);\\n  let rs2_val_64b = F_or_X_D(rs2);\\n  let rs3_val_64b = F_or_X_D(rs3);\\n\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_64b) : (bits(5), bits(64)) =\\n        match op {\\n          FMADD_D  => riscv_f64MulAdd (rm_3b, rs1_val_64b, rs2_val_64b, rs3_val_64b),\\n          FMSUB_D  => riscv_f64MulAdd (rm_3b, rs1_val_64b, rs2_val_64b, negate_D (rs3_val_64b)),\\n          FNMSUB_D => riscv_f64MulAdd (rm_3b, negate_D (rs1_val_64b), rs2_val_64b, rs3_val_64b),\\n          FNMADD_D => riscv_f64MulAdd (rm_3b, negate_D (rs1_val_64b), rs2_val_64b, negate_D (rs3_val_64b))\\n        };\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_64b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fmsub.h","name":"TBD","operands":[{"name":"rs3","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_madd_op_H"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b10","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{\\n  let rs1_val_16b = F_or_X_H(rs1);\\n  let rs2_val_16b = F_or_X_H(rs2);\\n  let rs3_val_16b = F_or_X_H(rs3);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_16b) : (bits(5), bits(16)) =\\n        match op {\\n          FMADD_H  => riscv_f16MulAdd (rm_3b, rs1_val_16b, rs2_val_16b, rs3_val_16b),\\n          FMSUB_H  => riscv_f16MulAdd (rm_3b, rs1_val_16b, rs2_val_16b, negate_H (rs3_val_16b)),\\n          FNMSUB_H => riscv_f16MulAdd (rm_3b, negate_H (rs1_val_16b), rs2_val_16b, rs3_val_16b),\\n          FNMADD_H => riscv_f16MulAdd (rm_3b, negate_H (rs1_val_16b), rs2_val_16b, negate_H (rs3_val_16b))\\n        };\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_16b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fmsub.s","name":"TBD","operands":[{"name":"rs3","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_madd_op_S"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b00","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{\\n  let rs1_val_32b = F_or_X_S(rs1);\\n  let rs2_val_32b = F_or_X_S(rs2);\\n  let rs3_val_32b = F_or_X_S(rs3);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_32b) : (bits(5), bits(32)) =\\n        match op {\\n          FMADD_S  => riscv_f32MulAdd (rm_3b, rs1_val_32b, rs2_val_32b, rs3_val_32b),\\n          FMSUB_S  => riscv_f32MulAdd (rm_3b, rs1_val_32b, rs2_val_32b, negate_S (rs3_val_32b)),\\n          FNMSUB_S => riscv_f32MulAdd (rm_3b, negate_S (rs1_val_32b), rs2_val_32b, rs3_val_32b),\\n          FNMADD_S => riscv_f32MulAdd (rm_3b, negate_S (rs1_val_32b), rs2_val_32b, negate_S (rs3_val_32b))\\n        };\\n      accrue_fflags(fflags);\\n      F_or_X_S(rd) = rd_val_32b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fmul.d","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_bin_rm_op_D"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_64b = F_or_X_D(rs1);\\n  let rs2_val_64b = F_or_X_D(rs2);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op {\\n        FADD_D  => riscv_f64Add (rm_3b, rs1_val_64b, rs2_val_64b),\\n        FSUB_D  => riscv_f64Sub (rm_3b, rs1_val_64b, rs2_val_64b),\\n        FMUL_D  => riscv_f64Mul (rm_3b, rs1_val_64b, rs2_val_64b),\\n        FDIV_D  => riscv_f64Div (rm_3b, rs1_val_64b, rs2_val_64b)\\n      };\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_64b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fmul.h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_bin_rm_op_H"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001110","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_16b = F_or_X_H(rs1);\\n  let rs2_val_16b = F_or_X_H(rs2);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op {\\n        FADD_H  => riscv_f16Add (rm_3b, rs1_val_16b, rs2_val_16b),\\n        FSUB_H  => riscv_f16Sub (rm_3b, rs1_val_16b, rs2_val_16b),\\n        FMUL_H  => riscv_f16Mul (rm_3b, rs1_val_16b, rs2_val_16b),\\n        FDIV_H  => riscv_f16Div (rm_3b, rs1_val_16b, rs2_val_16b)\\n      };\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_16b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fmul.s","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_bin_rm_op_S"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_32b = F_or_X_S(rs1);\\n  let rs2_val_32b = F_or_X_S(rs2);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op {\\n        FADD_S  => riscv_f32Add (rm_3b, rs1_val_32b, rs2_val_32b),\\n        FSUB_S  => riscv_f32Sub (rm_3b, rs1_val_32b, rs2_val_32b),\\n        FMUL_S  => riscv_f32Mul (rm_3b, rs1_val_32b, rs2_val_32b),\\n        FDIV_S  => riscv_f32Div (rm_3b, rs1_val_32b, rs2_val_32b)\\n      };\\n      accrue_fflags(fflags);\\n      F_or_X_S(rd) = rd_val_32b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fmv.d.x","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FMV_D_X","type":"f_un_op_D"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111001","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D"],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_X            = X(rs1);\\n  let rd_val_D             = rs1_val_X [63..0];\\n  F(rd) = rd_val_D;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fmv.h.x","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FMV_H_X","type":"f_un_op_H"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111010","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh"],"function":"{\\n  let rs1_val_X            = X(rs1);\\n  let rd_val_H             = rs1_val_X [15..0];\\n  F(rd) = nan_box (rd_val_H);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fmv.w.x","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FMV_W_X","type":"f_un_op_S"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111000","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["F"],"function":"{\\n  let rs1_val_X            = X(rs1);\\n  let rd_val_S             = rs1_val_X [31..0];\\n  F(rd) = nan_box (rd_val_S);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fmv.x.d","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FMV_D_X","type":"f_un_op_D"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111001","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D"],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_X            = X(rs1);\\n  let rd_val_D             = rs1_val_X [63..0];\\n  F(rd) = rd_val_D;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fmv.x.h","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FMV_H_X","type":"f_un_op_H"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111010","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh"],"function":"{\\n  let rs1_val_X            = X(rs1);\\n  let rd_val_H             = rs1_val_X [15..0];\\n  F(rd) = nan_box (rd_val_H);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fmv.x.w","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FMV_W_X","type":"f_un_op_S"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1111000","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["F"],"function":"{\\n  let rs1_val_X            = X(rs1);\\n  let rd_val_S             = rs1_val_X [31..0];\\n  F(rd) = nan_box (rd_val_S);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fmvh.x.d","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b1110001","size":7},{"field":"0b00001","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{\\n  let rs1_val_D           = F_D(rs1)[63..32];\\n  let rd_val_X : xlenbits = sign_extend(rs1_val_D);\\n  X(rd)                   = rd_val_X;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fmvp.d.x","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1011001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{\\n  let rs1_val_X     = X(rs1)[31..0];\\n  let rs2_val_X     = X(rs2)[31..0];\\n\\n  /* Concatenate the two values using \'@\' operator */\\n  /* e.g. */\\n  /*   rs1 = 0x01234567 */\\n  /*   rs2 = 0x89abcdef */\\n  /*   rd  = rs1 @ rs2 => 0x89abcdef01234567 */\\n  let rd_val_D      = rs2_val_X @ rs1_val_X;\\n\\n  F_D(rd)           = rd_val_D;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fnmadd.d","name":"TBD","operands":[{"name":"rs3","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_madd_op_D"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b01","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{\\n  let rs1_val_64b = F_or_X_D(rs1);\\n  let rs2_val_64b = F_or_X_D(rs2);\\n  let rs3_val_64b = F_or_X_D(rs3);\\n\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_64b) : (bits(5), bits(64)) =\\n        match op {\\n          FMADD_D  => riscv_f64MulAdd (rm_3b, rs1_val_64b, rs2_val_64b, rs3_val_64b),\\n          FMSUB_D  => riscv_f64MulAdd (rm_3b, rs1_val_64b, rs2_val_64b, negate_D (rs3_val_64b)),\\n          FNMSUB_D => riscv_f64MulAdd (rm_3b, negate_D (rs1_val_64b), rs2_val_64b, rs3_val_64b),\\n          FNMADD_D => riscv_f64MulAdd (rm_3b, negate_D (rs1_val_64b), rs2_val_64b, negate_D (rs3_val_64b))\\n        };\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_64b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fnmadd.h","name":"TBD","operands":[{"name":"rs3","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_madd_op_H"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b10","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{\\n  let rs1_val_16b = F_or_X_H(rs1);\\n  let rs2_val_16b = F_or_X_H(rs2);\\n  let rs3_val_16b = F_or_X_H(rs3);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_16b) : (bits(5), bits(16)) =\\n        match op {\\n          FMADD_H  => riscv_f16MulAdd (rm_3b, rs1_val_16b, rs2_val_16b, rs3_val_16b),\\n          FMSUB_H  => riscv_f16MulAdd (rm_3b, rs1_val_16b, rs2_val_16b, negate_H (rs3_val_16b)),\\n          FNMSUB_H => riscv_f16MulAdd (rm_3b, negate_H (rs1_val_16b), rs2_val_16b, rs3_val_16b),\\n          FNMADD_H => riscv_f16MulAdd (rm_3b, negate_H (rs1_val_16b), rs2_val_16b, negate_H (rs3_val_16b))\\n        };\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_16b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fnmadd.s","name":"TBD","operands":[{"name":"rs3","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_madd_op_S"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b00","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{\\n  let rs1_val_32b = F_or_X_S(rs1);\\n  let rs2_val_32b = F_or_X_S(rs2);\\n  let rs3_val_32b = F_or_X_S(rs3);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_32b) : (bits(5), bits(32)) =\\n        match op {\\n          FMADD_S  => riscv_f32MulAdd (rm_3b, rs1_val_32b, rs2_val_32b, rs3_val_32b),\\n          FMSUB_S  => riscv_f32MulAdd (rm_3b, rs1_val_32b, rs2_val_32b, negate_S (rs3_val_32b)),\\n          FNMSUB_S => riscv_f32MulAdd (rm_3b, negate_S (rs1_val_32b), rs2_val_32b, rs3_val_32b),\\n          FNMADD_S => riscv_f32MulAdd (rm_3b, negate_S (rs1_val_32b), rs2_val_32b, negate_S (rs3_val_32b))\\n        };\\n      accrue_fflags(fflags);\\n      F_or_X_S(rd) = rd_val_32b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fnmsub.d","name":"TBD","operands":[{"name":"rs3","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_madd_op_D"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b01","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{\\n  let rs1_val_64b = F_or_X_D(rs1);\\n  let rs2_val_64b = F_or_X_D(rs2);\\n  let rs3_val_64b = F_or_X_D(rs3);\\n\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_64b) : (bits(5), bits(64)) =\\n        match op {\\n          FMADD_D  => riscv_f64MulAdd (rm_3b, rs1_val_64b, rs2_val_64b, rs3_val_64b),\\n          FMSUB_D  => riscv_f64MulAdd (rm_3b, rs1_val_64b, rs2_val_64b, negate_D (rs3_val_64b)),\\n          FNMSUB_D => riscv_f64MulAdd (rm_3b, negate_D (rs1_val_64b), rs2_val_64b, rs3_val_64b),\\n          FNMADD_D => riscv_f64MulAdd (rm_3b, negate_D (rs1_val_64b), rs2_val_64b, negate_D (rs3_val_64b))\\n        };\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_64b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fnmsub.h","name":"TBD","operands":[{"name":"rs3","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_madd_op_H"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b10","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{\\n  let rs1_val_16b = F_or_X_H(rs1);\\n  let rs2_val_16b = F_or_X_H(rs2);\\n  let rs3_val_16b = F_or_X_H(rs3);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_16b) : (bits(5), bits(16)) =\\n        match op {\\n          FMADD_H  => riscv_f16MulAdd (rm_3b, rs1_val_16b, rs2_val_16b, rs3_val_16b),\\n          FMSUB_H  => riscv_f16MulAdd (rm_3b, rs1_val_16b, rs2_val_16b, negate_H (rs3_val_16b)),\\n          FNMSUB_H => riscv_f16MulAdd (rm_3b, negate_H (rs1_val_16b), rs2_val_16b, rs3_val_16b),\\n          FNMADD_H => riscv_f16MulAdd (rm_3b, negate_H (rs1_val_16b), rs2_val_16b, negate_H (rs3_val_16b))\\n        };\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_16b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fnmsub.s","name":"TBD","operands":[{"name":"rs3","type":"regidx"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_madd_op_S"}],"syntax":"rd,rs1,rs2,rs3,rm","format":"TBD","fields":[{"field":"rs3","size":5},{"field":"0b00","size":2},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1001111","size":7}],"extensions":[],"function":"{\\n  let rs1_val_32b = F_or_X_S(rs1);\\n  let rs2_val_32b = F_or_X_S(rs2);\\n  let rs3_val_32b = F_or_X_S(rs3);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_32b) : (bits(5), bits(32)) =\\n        match op {\\n          FMADD_S  => riscv_f32MulAdd (rm_3b, rs1_val_32b, rs2_val_32b, rs3_val_32b),\\n          FMSUB_S  => riscv_f32MulAdd (rm_3b, rs1_val_32b, rs2_val_32b, negate_S (rs3_val_32b)),\\n          FNMSUB_S => riscv_f32MulAdd (rm_3b, negate_S (rs1_val_32b), rs2_val_32b, rs3_val_32b),\\n          FNMADD_S => riscv_f32MulAdd (rm_3b, negate_S (rs1_val_32b), rs2_val_32b, negate_S (rs3_val_32b))\\n        };\\n      accrue_fflags(fflags);\\n      F_or_X_S(rd) = rd_val_32b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fround.d","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b0100001","size":7},{"field":"0b00100","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{\\n  let rs1_val_D = F(rs1);\\n\\n  match (select_instr_or_fcsr_rm(rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b =  encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_D) = riscv_f64roundToInt(rm_3b, rs1_val_D, false);\\n\\n      accrue_fflags(fflags);\\n      F(rd) = rd_val_D;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fround.h","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b0100010","size":7},{"field":"0b00100","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh","Zfa"],"function":"{\\n  let rs1_val_H = F_H(rs1);\\n\\n  match (select_instr_or_fcsr_rm(rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b =  encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_H) = riscv_f16roundToInt(rm_3b, rs1_val_H, false);\\n\\n      accrue_fflags(fflags);\\n      F_H(rd) = rd_val_H;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fround.s","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"0b00100","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfa"],"function":"{\\n  let rs1_val_S = F_S(rs1);\\n\\n  match (select_instr_or_fcsr_rm(rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b =  encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_S) = riscv_f32roundToInt(rm_3b, rs1_val_S, false);\\n\\n      accrue_fflags(fflags);\\n      F_S(rd) = rd_val_S;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"froundnx.d","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b0100001","size":7},{"field":"0b00101","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["D","Zfa"],"function":"{\\n  let rs1_val_D = F_D(rs1);\\n\\n  match (select_instr_or_fcsr_rm(rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b =  encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_D) = riscv_f64roundToInt(rm_3b, rs1_val_D, true);\\n\\n      accrue_fflags(fflags);\\n      F_D(rd) = rd_val_D;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"froundnx.h","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b0100010","size":7},{"field":"0b00101","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfh","Zfa"],"function":"{\\n  let rs1_val_H = F_H(rs1);\\n\\n  match (select_instr_or_fcsr_rm(rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b =  encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_H) = riscv_f16roundToInt(rm_3b, rs1_val_H, true);\\n\\n      accrue_fflags(fflags);\\n      F_H(rd) = rd_val_H;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"froundnx.s","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"0b00101","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":["Zfa"],"function":"{\\n  let rs1_val_S = F_S(rs1);\\n\\n  match (select_instr_or_fcsr_rm(rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b =  encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_S) = riscv_f32roundToInt(rm_3b, rs1_val_S, true);\\n\\n      accrue_fflags(fflags);\\n      F_S(rd) = rd_val_S;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fsb","name":"TBD","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"imm5","size":1},{"field":"0b0100111","size":7}],"extensions":["D"],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  let (aq, rl, con) = (false, false, false);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(addr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => MemValue () /* bogus placeholder for illegal size */,\\n            HALF   => mem_write_ea(addr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(addr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(addr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = F(rs2);\\n              match (width) {\\n                BYTE => { handle_illegal(); RETIRE_FAIL },\\n                HALF => process_fstore (vaddr, mem_write_value(addr, 2, rs2_val[15..0], aq, rl, con)),\\n                WORD => process_fstore (vaddr, mem_write_value(addr, 4, rs2_val[31..0], aq, rl, con)),\\n                DOUBLE if sizeof(flen) >= 64 =>\\n                  process_fstore (vaddr, mem_write_value(addr, 8, rs2_val, aq, rl, con)),\\n                _ => report_invalid_width(__FILE__, __LINE__, width, \\"floating point store\\"),\\n              };\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"TBD"},{"mnemonic":"fsd","name":"TBD","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"imm5","size":1},{"field":"0b0100111","size":7}],"extensions":["D"],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  let (aq, rl, con) = (false, false, false);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(addr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => MemValue () /* bogus placeholder for illegal size */,\\n            HALF   => mem_write_ea(addr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(addr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(addr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = F(rs2);\\n              match (width) {\\n                BYTE => { handle_illegal(); RETIRE_FAIL },\\n                HALF => process_fstore (vaddr, mem_write_value(addr, 2, rs2_val[15..0], aq, rl, con)),\\n                WORD => process_fstore (vaddr, mem_write_value(addr, 4, rs2_val[31..0], aq, rl, con)),\\n                DOUBLE if sizeof(flen) >= 64 =>\\n                  process_fstore (vaddr, mem_write_value(addr, 8, rs2_val, aq, rl, con)),\\n                _ => report_invalid_width(__FILE__, __LINE__, width, \\"floating point store\\"),\\n              };\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"TBD"},{"mnemonic":"fsgnj.d","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_D","type":"f_bin_op_D"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_D = F_or_X_D(rs1);\\n  let rs2_val_D = F_or_X_D(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f64Le (rs1_val_D, rs2_val_D);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fsgnj.h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_H","type":"f_bin_op_H"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_H = F_or_X_H(rs1);\\n  let rs2_val_H = F_or_X_H(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f16Le (rs1_val_H, rs2_val_H);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fsgnj.s","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_S","type":"f_bin_op_S"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_S = F_or_X_S(rs1);\\n  let rs2_val_S = F_or_X_S(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f32Le (rs1_val_S, rs2_val_S);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fsgnjn.d","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_D","type":"f_bin_op_D"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_D = F_or_X_D(rs1);\\n  let rs2_val_D = F_or_X_D(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f64Le (rs1_val_D, rs2_val_D);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fsgnjn.h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_H","type":"f_bin_op_H"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_H = F_or_X_H(rs1);\\n  let rs2_val_H = F_or_X_H(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f16Le (rs1_val_H, rs2_val_H);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fsgnjn.s","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_S","type":"f_bin_op_S"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_S = F_or_X_S(rs1);\\n  let rs2_val_S = F_or_X_S(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f32Le (rs1_val_S, rs2_val_S);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fsgnjx.d","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_D","type":"f_bin_op_D"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_D = F_or_X_D(rs1);\\n  let rs2_val_D = F_or_X_D(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f64Le (rs1_val_D, rs2_val_D);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fsgnjx.h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_H","type":"f_bin_op_H"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010010","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_H = F_or_X_H(rs1);\\n  let rs2_val_H = F_or_X_H(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f16Le (rs1_val_H, rs2_val_H);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fsgnjx.s","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"FLE_S","type":"f_bin_op_S"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b1010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_S = F_or_X_S(rs1);\\n  let rs2_val_S = F_or_X_S(rs2);\\n\\n  let (fflags, rd_val) : (bits_fflags, bool) =\\n      riscv_f32Le (rs1_val_S, rs2_val_S);\\n\\n  accrue_fflags(fflags);\\n  X(rd) = zero_extend(bool_to_bits(rd_val));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"fsh","name":"TBD","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"imm5","size":1},{"field":"0b0100111","size":7}],"extensions":["D"],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  let (aq, rl, con) = (false, false, false);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(addr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => MemValue () /* bogus placeholder for illegal size */,\\n            HALF   => mem_write_ea(addr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(addr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(addr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = F(rs2);\\n              match (width) {\\n                BYTE => { handle_illegal(); RETIRE_FAIL },\\n                HALF => process_fstore (vaddr, mem_write_value(addr, 2, rs2_val[15..0], aq, rl, con)),\\n                WORD => process_fstore (vaddr, mem_write_value(addr, 4, rs2_val[31..0], aq, rl, con)),\\n                DOUBLE if sizeof(flen) >= 64 =>\\n                  process_fstore (vaddr, mem_write_value(addr, 8, rs2_val, aq, rl, con)),\\n                _ => report_invalid_width(__FILE__, __LINE__, width, \\"floating point store\\"),\\n              };\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"TBD"},{"mnemonic":"fsqrt.d","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_D_LU","type":"f_un_rm_op_D"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101001","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_D) = riscv_ui64ToF64 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_D;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fsqrt.h","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_H_LU","type":"f_un_rm_op_H"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101010","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_H) = riscv_ui64ToF16 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_H;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fsqrt.s","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"FCVT_S_LU","type":"f_un_rm_op_S"}],"syntax":"rd,rs1,rm","format":"TBD","fields":[{"field":"0b1101000","size":7},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  assert(sizeof(xlen) >= 64);\\n  let rs1_val_LU = X(rs1)[63..0];\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_S) = riscv_ui64ToF32 (rm_3b, rs1_val_LU);\\n\\n      accrue_fflags(fflags);\\n      F_or_X_S(rd) = rd_val_S;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fsub.d","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_bin_rm_op_D"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001101","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_64b = F_or_X_D(rs1);\\n  let rs2_val_64b = F_or_X_D(rs2);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_64b) : (bits(5), bits(64)) = match op {\\n        FADD_D  => riscv_f64Add (rm_3b, rs1_val_64b, rs2_val_64b),\\n        FSUB_D  => riscv_f64Sub (rm_3b, rs1_val_64b, rs2_val_64b),\\n        FMUL_D  => riscv_f64Mul (rm_3b, rs1_val_64b, rs2_val_64b),\\n        FDIV_D  => riscv_f64Div (rm_3b, rs1_val_64b, rs2_val_64b)\\n      };\\n      accrue_fflags(fflags);\\n      F_or_X_D(rd) = rd_val_64b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fsub.h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_bin_rm_op_H"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001110","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_16b = F_or_X_H(rs1);\\n  let rs2_val_16b = F_or_X_H(rs2);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_16b) : (bits(5), bits(16)) = match op {\\n        FADD_H  => riscv_f16Add (rm_3b, rs1_val_16b, rs2_val_16b),\\n        FSUB_H  => riscv_f16Sub (rm_3b, rs1_val_16b, rs2_val_16b),\\n        FMUL_H  => riscv_f16Mul (rm_3b, rs1_val_16b, rs2_val_16b),\\n        FDIV_H  => riscv_f16Div (rm_3b, rs1_val_16b, rs2_val_16b)\\n      };\\n      accrue_fflags(fflags);\\n      F_or_X_H(rd) = rd_val_16b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fsub.s","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rm","type":"rounding_mode"},{"name":"rd","type":"regidx"},{"name":"op","type":"f_bin_rm_op_S"}],"syntax":"rd,rs1,rs2,rm","format":"TBD","fields":[{"field":"0b0001100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_rounding_mode(rm)","size":3},{"field":"rd","size":5},{"field":"0b1010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val_32b = F_or_X_S(rs1);\\n  let rs2_val_32b = F_or_X_S(rs2);\\n  match (select_instr_or_fcsr_rm (rm)) {\\n    None() => { handle_illegal(); RETIRE_FAIL },\\n    Some(rm\') => {\\n      let rm_3b = encdec_rounding_mode(rm\');\\n      let (fflags, rd_val_32b) : (bits(5), bits(32)) = match op {\\n        FADD_S  => riscv_f32Add (rm_3b, rs1_val_32b, rs2_val_32b),\\n        FSUB_S  => riscv_f32Sub (rm_3b, rs1_val_32b, rs2_val_32b),\\n        FMUL_S  => riscv_f32Mul (rm_3b, rs1_val_32b, rs2_val_32b),\\n        FDIV_S  => riscv_f32Div (rm_3b, rs1_val_32b, rs2_val_32b)\\n      };\\n      accrue_fflags(fflags);\\n      F_or_X_S(rd) = rd_val_32b;\\n      RETIRE_SUCCESS\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"fsw","name":"TBD","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b011","size":3},{"field":"imm5","size":1},{"field":"0b0100111","size":7}],"extensions":["D"],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  let (aq, rl, con) = (false, false, false);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(addr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => MemValue () /* bogus placeholder for illegal size */,\\n            HALF   => mem_write_ea(addr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(addr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(addr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = F(rs2);\\n              match (width) {\\n                BYTE => { handle_illegal(); RETIRE_FAIL },\\n                HALF => process_fstore (vaddr, mem_write_value(addr, 2, rs2_val[15..0], aq, rl, con)),\\n                WORD => process_fstore (vaddr, mem_write_value(addr, 4, rs2_val[31..0], aq, rl, con)),\\n                DOUBLE if sizeof(flen) >= 64 =>\\n                  process_fstore (vaddr, mem_write_value(addr, 8, rs2_val, aq, rl, con)),\\n                _ => report_invalid_width(__FILE__, __LINE__, width, \\"floating point store\\"),\\n              };\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"TBD"},{"mnemonic":"illegal","name":"TBD","operands":[{"name":"s","type":"word"}],"syntax":"s","format":"TBD","fields":[{"field":"s","size":32}],"extensions":[],"function":"{ handle_illegal(); RETIRE_FAIL }","description":"TBD"},{"mnemonic":"jal","name":"TBD","operands":[{"name":"imm","type":"bits(21)"},{"name":"rd","type":"regidx"}],"syntax":"rd,imm","format":"TBD","fields":[{"field":"imm_19","size":1},{"field":"imm_18_13","size":6},{"field":"imm_12_9","size":4},{"field":"imm_8","size":1},{"field":"imm_7_0","size":8},{"field":"rd","size":5},{"field":"0b1101111","size":7}],"extensions":[],"function":"{\\n  let t : xlenbits = PC + sign_extend(imm);\\n  /* Extensions get the first checks on the prospective target address. */\\n  match ext_control_check_pc(t) {\\n    Ext_ControlAddr_Error(e) => {\\n      ext_handle_control_check_error(e);\\n      RETIRE_FAIL\\n    },\\n    Ext_ControlAddr_OK(target) => {\\n      /* Perform standard alignment check */\\n      if bit_to_bool(target[1]) & not(extension(\\"C\\"))\\n      then {\\n        handle_mem_exception(target, E_Fetch_Addr_Align());\\n        RETIRE_FAIL\\n      } else {\\n        X(rd) = get_next_pc();\\n        set_next_pc(target);\\n        RETIRE_SUCCESS\\n      }\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"jalr","name":"Jump And Link Register","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,imm","format":"I","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b1100111","size":7}],"extensions":[],"function":"{\\n/* For the sequential model, the memory-model definition doesn\'t work directly\\n * if rs1 = rd.  We would effectively have to keep a regfile for reads and another for\\n * writes, and swap on instruction completion.  This could perhaps be optimized in\\n * some manner, but for now, we just keep a reordered definition to improve simulator\\n * performance.\\n */\\n  let t : xlenbits = X(rs1) + sign_extend(imm);\\n  /* Extensions get the first checks on the prospective target address. */\\n  match ext_control_check_addr(t) {\\n    Ext_ControlAddr_Error(e) => {\\n      ext_handle_control_check_error(e);\\n      RETIRE_FAIL\\n    },\\n    Ext_ControlAddr_OK(addr) => {\\n      let target = [addr with 0 = bitzero];  /* clear addr[0] */\\n      if bit_to_bool(target[1]) & not(extension(\\"C\\")) then {\\n        handle_mem_exception(target, E_Fetch_Addr_Align());\\n        RETIRE_FAIL\\n      } else {\\n        X(rd) = get_next_pc();\\n        set_next_pc(target);\\n        RETIRE_SUCCESS\\n      }\\n    }\\n  }\\n}","description":"\\nThe target address is obtained by adding the sign-extended 12-bit\\nI-immediate to the register rs1, then setting the\\nleast-significant bit of the result to zero. The address of the\\ninstruction following the jump (pc+4) is written to register rd.\\nRegister x0 can be used as the destination if the result is not\\nrequired.\\n "},{"mnemonic":"lb","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lb.aq","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lb.aq.rl","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lb.rl","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lbu","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lbu.aq","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lbu.aq.rl","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lbu.rl","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"ld","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"ld.aq","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"ld.aq.rl","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"ld.rl","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"ldu","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"ldu.aq","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"ldu.aq.rl","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"ldu.rl","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lh","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lh.aq","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lh.aq.rl","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lh.rl","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lhu","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lhu.aq","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lhu.aq.rl","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lhu.rl","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lr.b","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Extensions might perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), Read(Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        let aligned : bool =\\n           /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n            * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n            */\\n           match width {\\n             BYTE   => true,\\n             HALF   => vaddr[0..0] == 0b0,\\n             WORD   => vaddr[1..0] == 0b00,\\n             DOUBLE => vaddr[2..0] == 0b000\\n           };\\n        /* \\"LR faults like a normal load, even though it\'s in the AMO major opcode space.\\"\\n         * - Andrew Waterman, isa-dev, 10 Jul 2018.\\n         */\\n        if not(aligned)\\n        then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n        else match translateAddr(vaddr, Read(Data)) {\\n               TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n               TR_Address(addr, _) =>\\n                 match (width, sizeof(xlen)) {\\n                   (BYTE, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, aq & rl, true), false),\\n                   (HALF, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, aq & rl, true), false),\\n                   (WORD, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, aq & rl, true), false),\\n                   (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, aq & rl, true), false),\\n                   _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                 }\\n             }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"lr.b.aq","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Extensions might perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), Read(Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        let aligned : bool =\\n           /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n            * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n            */\\n           match width {\\n             BYTE   => true,\\n             HALF   => vaddr[0..0] == 0b0,\\n             WORD   => vaddr[1..0] == 0b00,\\n             DOUBLE => vaddr[2..0] == 0b000\\n           };\\n        /* \\"LR faults like a normal load, even though it\'s in the AMO major opcode space.\\"\\n         * - Andrew Waterman, isa-dev, 10 Jul 2018.\\n         */\\n        if not(aligned)\\n        then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n        else match translateAddr(vaddr, Read(Data)) {\\n               TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n               TR_Address(addr, _) =>\\n                 match (width, sizeof(xlen)) {\\n                   (BYTE, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, aq & rl, true), false),\\n                   (HALF, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, aq & rl, true), false),\\n                   (WORD, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, aq & rl, true), false),\\n                   (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, aq & rl, true), false),\\n                   _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                 }\\n             }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"lr.b.aq.rl","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Extensions might perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), Read(Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        let aligned : bool =\\n           /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n            * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n            */\\n           match width {\\n             BYTE   => true,\\n             HALF   => vaddr[0..0] == 0b0,\\n             WORD   => vaddr[1..0] == 0b00,\\n             DOUBLE => vaddr[2..0] == 0b000\\n           };\\n        /* \\"LR faults like a normal load, even though it\'s in the AMO major opcode space.\\"\\n         * - Andrew Waterman, isa-dev, 10 Jul 2018.\\n         */\\n        if not(aligned)\\n        then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n        else match translateAddr(vaddr, Read(Data)) {\\n               TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n               TR_Address(addr, _) =>\\n                 match (width, sizeof(xlen)) {\\n                   (BYTE, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, aq & rl, true), false),\\n                   (HALF, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, aq & rl, true), false),\\n                   (WORD, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, aq & rl, true), false),\\n                   (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, aq & rl, true), false),\\n                   _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                 }\\n             }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"lr.b.rl","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Extensions might perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), Read(Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        let aligned : bool =\\n           /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n            * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n            */\\n           match width {\\n             BYTE   => true,\\n             HALF   => vaddr[0..0] == 0b0,\\n             WORD   => vaddr[1..0] == 0b00,\\n             DOUBLE => vaddr[2..0] == 0b000\\n           };\\n        /* \\"LR faults like a normal load, even though it\'s in the AMO major opcode space.\\"\\n         * - Andrew Waterman, isa-dev, 10 Jul 2018.\\n         */\\n        if not(aligned)\\n        then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n        else match translateAddr(vaddr, Read(Data)) {\\n               TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n               TR_Address(addr, _) =>\\n                 match (width, sizeof(xlen)) {\\n                   (BYTE, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, aq & rl, true), false),\\n                   (HALF, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, aq & rl, true), false),\\n                   (WORD, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, aq & rl, true), false),\\n                   (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, aq & rl, true), false),\\n                   _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                 }\\n             }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"lr.d","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Extensions might perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), Read(Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        let aligned : bool =\\n           /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n            * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n            */\\n           match width {\\n             BYTE   => true,\\n             HALF   => vaddr[0..0] == 0b0,\\n             WORD   => vaddr[1..0] == 0b00,\\n             DOUBLE => vaddr[2..0] == 0b000\\n           };\\n        /* \\"LR faults like a normal load, even though it\'s in the AMO major opcode space.\\"\\n         * - Andrew Waterman, isa-dev, 10 Jul 2018.\\n         */\\n        if not(aligned)\\n        then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n        else match translateAddr(vaddr, Read(Data)) {\\n               TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n               TR_Address(addr, _) =>\\n                 match (width, sizeof(xlen)) {\\n                   (BYTE, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, aq & rl, true), false),\\n                   (HALF, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, aq & rl, true), false),\\n                   (WORD, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, aq & rl, true), false),\\n                   (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, aq & rl, true), false),\\n                   _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                 }\\n             }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"lr.d.aq","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Extensions might perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), Read(Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        let aligned : bool =\\n           /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n            * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n            */\\n           match width {\\n             BYTE   => true,\\n             HALF   => vaddr[0..0] == 0b0,\\n             WORD   => vaddr[1..0] == 0b00,\\n             DOUBLE => vaddr[2..0] == 0b000\\n           };\\n        /* \\"LR faults like a normal load, even though it\'s in the AMO major opcode space.\\"\\n         * - Andrew Waterman, isa-dev, 10 Jul 2018.\\n         */\\n        if not(aligned)\\n        then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n        else match translateAddr(vaddr, Read(Data)) {\\n               TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n               TR_Address(addr, _) =>\\n                 match (width, sizeof(xlen)) {\\n                   (BYTE, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, aq & rl, true), false),\\n                   (HALF, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, aq & rl, true), false),\\n                   (WORD, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, aq & rl, true), false),\\n                   (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, aq & rl, true), false),\\n                   _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                 }\\n             }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"lr.d.aq.rl","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Extensions might perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), Read(Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        let aligned : bool =\\n           /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n            * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n            */\\n           match width {\\n             BYTE   => true,\\n             HALF   => vaddr[0..0] == 0b0,\\n             WORD   => vaddr[1..0] == 0b00,\\n             DOUBLE => vaddr[2..0] == 0b000\\n           };\\n        /* \\"LR faults like a normal load, even though it\'s in the AMO major opcode space.\\"\\n         * - Andrew Waterman, isa-dev, 10 Jul 2018.\\n         */\\n        if not(aligned)\\n        then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n        else match translateAddr(vaddr, Read(Data)) {\\n               TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n               TR_Address(addr, _) =>\\n                 match (width, sizeof(xlen)) {\\n                   (BYTE, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, aq & rl, true), false),\\n                   (HALF, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, aq & rl, true), false),\\n                   (WORD, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, aq & rl, true), false),\\n                   (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, aq & rl, true), false),\\n                   _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                 }\\n             }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"lr.d.rl","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Extensions might perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), Read(Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        let aligned : bool =\\n           /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n            * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n            */\\n           match width {\\n             BYTE   => true,\\n             HALF   => vaddr[0..0] == 0b0,\\n             WORD   => vaddr[1..0] == 0b00,\\n             DOUBLE => vaddr[2..0] == 0b000\\n           };\\n        /* \\"LR faults like a normal load, even though it\'s in the AMO major opcode space.\\"\\n         * - Andrew Waterman, isa-dev, 10 Jul 2018.\\n         */\\n        if not(aligned)\\n        then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n        else match translateAddr(vaddr, Read(Data)) {\\n               TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n               TR_Address(addr, _) =>\\n                 match (width, sizeof(xlen)) {\\n                   (BYTE, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, aq & rl, true), false),\\n                   (HALF, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, aq & rl, true), false),\\n                   (WORD, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, aq & rl, true), false),\\n                   (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, aq & rl, true), false),\\n                   _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                 }\\n             }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"lr.h","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Extensions might perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), Read(Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        let aligned : bool =\\n           /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n            * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n            */\\n           match width {\\n             BYTE   => true,\\n             HALF   => vaddr[0..0] == 0b0,\\n             WORD   => vaddr[1..0] == 0b00,\\n             DOUBLE => vaddr[2..0] == 0b000\\n           };\\n        /* \\"LR faults like a normal load, even though it\'s in the AMO major opcode space.\\"\\n         * - Andrew Waterman, isa-dev, 10 Jul 2018.\\n         */\\n        if not(aligned)\\n        then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n        else match translateAddr(vaddr, Read(Data)) {\\n               TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n               TR_Address(addr, _) =>\\n                 match (width, sizeof(xlen)) {\\n                   (BYTE, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, aq & rl, true), false),\\n                   (HALF, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, aq & rl, true), false),\\n                   (WORD, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, aq & rl, true), false),\\n                   (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, aq & rl, true), false),\\n                   _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                 }\\n             }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"lr.h.aq","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Extensions might perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), Read(Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        let aligned : bool =\\n           /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n            * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n            */\\n           match width {\\n             BYTE   => true,\\n             HALF   => vaddr[0..0] == 0b0,\\n             WORD   => vaddr[1..0] == 0b00,\\n             DOUBLE => vaddr[2..0] == 0b000\\n           };\\n        /* \\"LR faults like a normal load, even though it\'s in the AMO major opcode space.\\"\\n         * - Andrew Waterman, isa-dev, 10 Jul 2018.\\n         */\\n        if not(aligned)\\n        then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n        else match translateAddr(vaddr, Read(Data)) {\\n               TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n               TR_Address(addr, _) =>\\n                 match (width, sizeof(xlen)) {\\n                   (BYTE, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, aq & rl, true), false),\\n                   (HALF, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, aq & rl, true), false),\\n                   (WORD, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, aq & rl, true), false),\\n                   (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, aq & rl, true), false),\\n                   _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                 }\\n             }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"lr.h.aq.rl","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Extensions might perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), Read(Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        let aligned : bool =\\n           /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n            * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n            */\\n           match width {\\n             BYTE   => true,\\n             HALF   => vaddr[0..0] == 0b0,\\n             WORD   => vaddr[1..0] == 0b00,\\n             DOUBLE => vaddr[2..0] == 0b000\\n           };\\n        /* \\"LR faults like a normal load, even though it\'s in the AMO major opcode space.\\"\\n         * - Andrew Waterman, isa-dev, 10 Jul 2018.\\n         */\\n        if not(aligned)\\n        then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n        else match translateAddr(vaddr, Read(Data)) {\\n               TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n               TR_Address(addr, _) =>\\n                 match (width, sizeof(xlen)) {\\n                   (BYTE, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, aq & rl, true), false),\\n                   (HALF, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, aq & rl, true), false),\\n                   (WORD, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, aq & rl, true), false),\\n                   (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, aq & rl, true), false),\\n                   _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                 }\\n             }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"lr.h.rl","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Extensions might perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), Read(Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        let aligned : bool =\\n           /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n            * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n            */\\n           match width {\\n             BYTE   => true,\\n             HALF   => vaddr[0..0] == 0b0,\\n             WORD   => vaddr[1..0] == 0b00,\\n             DOUBLE => vaddr[2..0] == 0b000\\n           };\\n        /* \\"LR faults like a normal load, even though it\'s in the AMO major opcode space.\\"\\n         * - Andrew Waterman, isa-dev, 10 Jul 2018.\\n         */\\n        if not(aligned)\\n        then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n        else match translateAddr(vaddr, Read(Data)) {\\n               TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n               TR_Address(addr, _) =>\\n                 match (width, sizeof(xlen)) {\\n                   (BYTE, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, aq & rl, true), false),\\n                   (HALF, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, aq & rl, true), false),\\n                   (WORD, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, aq & rl, true), false),\\n                   (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, aq & rl, true), false),\\n                   _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                 }\\n             }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"lr.w","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Extensions might perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), Read(Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        let aligned : bool =\\n           /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n            * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n            */\\n           match width {\\n             BYTE   => true,\\n             HALF   => vaddr[0..0] == 0b0,\\n             WORD   => vaddr[1..0] == 0b00,\\n             DOUBLE => vaddr[2..0] == 0b000\\n           };\\n        /* \\"LR faults like a normal load, even though it\'s in the AMO major opcode space.\\"\\n         * - Andrew Waterman, isa-dev, 10 Jul 2018.\\n         */\\n        if not(aligned)\\n        then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n        else match translateAddr(vaddr, Read(Data)) {\\n               TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n               TR_Address(addr, _) =>\\n                 match (width, sizeof(xlen)) {\\n                   (BYTE, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, aq & rl, true), false),\\n                   (HALF, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, aq & rl, true), false),\\n                   (WORD, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, aq & rl, true), false),\\n                   (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, aq & rl, true), false),\\n                   _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                 }\\n             }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"lr.w.aq","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Extensions might perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), Read(Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        let aligned : bool =\\n           /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n            * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n            */\\n           match width {\\n             BYTE   => true,\\n             HALF   => vaddr[0..0] == 0b0,\\n             WORD   => vaddr[1..0] == 0b00,\\n             DOUBLE => vaddr[2..0] == 0b000\\n           };\\n        /* \\"LR faults like a normal load, even though it\'s in the AMO major opcode space.\\"\\n         * - Andrew Waterman, isa-dev, 10 Jul 2018.\\n         */\\n        if not(aligned)\\n        then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n        else match translateAddr(vaddr, Read(Data)) {\\n               TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n               TR_Address(addr, _) =>\\n                 match (width, sizeof(xlen)) {\\n                   (BYTE, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, aq & rl, true), false),\\n                   (HALF, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, aq & rl, true), false),\\n                   (WORD, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, aq & rl, true), false),\\n                   (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, aq & rl, true), false),\\n                   _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                 }\\n             }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"lr.w.aq.rl","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Extensions might perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), Read(Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        let aligned : bool =\\n           /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n            * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n            */\\n           match width {\\n             BYTE   => true,\\n             HALF   => vaddr[0..0] == 0b0,\\n             WORD   => vaddr[1..0] == 0b00,\\n             DOUBLE => vaddr[2..0] == 0b000\\n           };\\n        /* \\"LR faults like a normal load, even though it\'s in the AMO major opcode space.\\"\\n         * - Andrew Waterman, isa-dev, 10 Jul 2018.\\n         */\\n        if not(aligned)\\n        then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n        else match translateAddr(vaddr, Read(Data)) {\\n               TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n               TR_Address(addr, _) =>\\n                 match (width, sizeof(xlen)) {\\n                   (BYTE, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, aq & rl, true), false),\\n                   (HALF, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, aq & rl, true), false),\\n                   (WORD, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, aq & rl, true), false),\\n                   (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, aq & rl, true), false),\\n                   _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                 }\\n             }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"lr.w.rl","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00010","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if extension(\\"A\\") then {\\n    /* Get the address, X(rs1) (no offset).\\n     * Extensions might perform additional checks on address validity.\\n     */\\n    match ext_data_get_addr(rs1, zeros(), Read(Data), width) {\\n      Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n      Ext_DataAddr_OK(vaddr) => {\\n        let aligned : bool =\\n           /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n            * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n            */\\n           match width {\\n             BYTE   => true,\\n             HALF   => vaddr[0..0] == 0b0,\\n             WORD   => vaddr[1..0] == 0b00,\\n             DOUBLE => vaddr[2..0] == 0b000\\n           };\\n        /* \\"LR faults like a normal load, even though it\'s in the AMO major opcode space.\\"\\n         * - Andrew Waterman, isa-dev, 10 Jul 2018.\\n         */\\n        if not(aligned)\\n        then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n        else match translateAddr(vaddr, Read(Data)) {\\n               TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n               TR_Address(addr, _) =>\\n                 match (width, sizeof(xlen)) {\\n                   (BYTE, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 1, aq, aq & rl, true), false),\\n                   (HALF, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 2, aq, aq & rl, true), false),\\n                   (WORD, _)    => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 4, aq, aq & rl, true), false),\\n                   (DOUBLE, 64) => process_loadres(rd, vaddr, mem_read(Read(Data), addr, 8, aq, aq & rl, true), false),\\n                   _            => internal_error(__FILE__, __LINE__, \\"Unexpected AMO width\\")\\n                 }\\n             }\\n      }\\n    }\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"lui","name":"TBD","operands":[{"name":"imm","type":"bits(20)"},{"name":"rd","type":"regidx"},{"name":"op","type":"uop"}],"syntax":"rd,imm","format":"TBD","fields":[{"field":"imm","size":20},{"field":"rd","size":5},{"field":"encdec_uop(op)","size":7}],"extensions":[],"function":"{\\n  let off : xlenbits = sign_extend(imm @ 0x000);\\n  let ret : xlenbits = match op {\\n    RISCV_LUI   => off,\\n    RISCV_AUIPC => get_arch_pc() + off\\n  };\\n  X(rd) = ret;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"lw","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lw.aq","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lw.aq.rl","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lw.rl","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lwu","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lwu.aq","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lwu.aq.rl","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"lwu.rl","name":"Load","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"is_unsigned","type":"bool"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rd,imm(rs1)","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"bool_bits(is_unsigned)","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0000011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Read(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_Load_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Read(Data)) {\\n        TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) =>\\n          match (width) {\\n            BYTE =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 1, aq, rl, false), is_unsigned),\\n            HALF =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 2, aq, rl, false), is_unsigned),\\n            WORD =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 4, aq, rl, false), is_unsigned),\\n            DOUBLE if sizeof(xlen) >= 64 =>\\n              process_load(rd, vaddr, mem_read(Read(Data), paddr, 8, aq, rl, false), is_unsigned),\\n            _ => report_invalid_width(__FILE__, __LINE__, width, \\"load\\")\\n          }\\n      }\\n  }\\n}","description":"\\nThe LOAD instruction format is used for loading data from memory into a\\nregister. The specific operation is determined by the word width (size),\\nwhether the load is signed or unsigned (is_unsigned), and memory ordering\\nsemantics (acquire, release). The result is written to the destination\\nregister (rd), and the memory address is computed by adding the immediate\\noffset (imm) to the value in register rs1.\\n "},{"mnemonic":"max","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zbb"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ANDN => rs1_val & ~(rs2_val),\\n    RISCV_ORN  => rs1_val | ~(rs2_val),\\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_ROL  => if sizeof(xlen) == 32\\n                  then rs1_val <<< rs2_val[4..0]\\n                  else rs1_val <<< rs2_val[5..0],\\n    RISCV_ROR  => if sizeof(xlen) == 32\\n                  then rs1_val >>> rs2_val[4..0]\\n                  else rs1_val >>> rs2_val[5..0]\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"maxu","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zbb"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ANDN => rs1_val & ~(rs2_val),\\n    RISCV_ORN  => rs1_val | ~(rs2_val),\\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_ROL  => if sizeof(xlen) == 32\\n                  then rs1_val <<< rs2_val[4..0]\\n                  else rs1_val <<< rs2_val[5..0],\\n    RISCV_ROR  => if sizeof(xlen) == 32\\n                  then rs1_val >>> rs2_val[4..0]\\n                  else rs1_val >>> rs2_val[5..0]\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"min","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zbb"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ANDN => rs1_val & ~(rs2_val),\\n    RISCV_ORN  => rs1_val | ~(rs2_val),\\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_ROL  => if sizeof(xlen) == 32\\n                  then rs1_val <<< rs2_val[4..0]\\n                  else rs1_val <<< rs2_val[5..0],\\n    RISCV_ROR  => if sizeof(xlen) == 32\\n                  then rs1_val >>> rs2_val[4..0]\\n                  else rs1_val >>> rs2_val[5..0]\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"minu","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zbb"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ANDN => rs1_val & ~(rs2_val),\\n    RISCV_ORN  => rs1_val | ~(rs2_val),\\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_ROL  => if sizeof(xlen) == 32\\n                  then rs1_val <<< rs2_val[4..0]\\n                  else rs1_val <<< rs2_val[5..0],\\n    RISCV_ROR  => if sizeof(xlen) == 32\\n                  then rs1_val >>> rs2_val[4..0]\\n                  else rs1_val >>> rs2_val[5..0]\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"mret","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b0011000","size":7},{"field":"0b00010","size":5},{"field":"0b00000","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{\\n  if   cur_privilege != Machine\\n  then { handle_illegal(); RETIRE_FAIL }\\n  else if not(ext_check_xret_priv (Machine))\\n  then { ext_fail_xret_priv(); RETIRE_FAIL }\\n  else {\\n    set_next_pc(exception_handler(cur_privilege, CTL_MRET(), PC));\\n    RETIRE_SUCCESS\\n  }\\n}","description":"TBD"},{"mnemonic":"mul","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"high","type":"bool"},{"name":"signed1","type":"bool"},{"name":"signed2","type":"bool"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_mul_op(high,signed1,signed2)","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["M"],"function":"{\\n  if extension(\\"M\\") | haveZmmul() then {\\n    let rs1_val = X(rs1);\\n    let rs2_val = X(rs2);\\n    let rs1_int : int = if signed1 then signed(rs1_val) else unsigned(rs1_val);\\n    let rs2_int : int = if signed2 then signed(rs2_val) else unsigned(rs2_val);\\n    let result_wide = to_bits(2 * sizeof(xlen), rs1_int * rs2_int);\\n    let result = if   high\\n                 then result_wide[(2 * sizeof(xlen) - 1) .. sizeof(xlen)]\\n                 else result_wide[(sizeof(xlen) - 1) .. 0];\\n    X(rd) = result;\\n    RETIRE_SUCCESS\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"mulh","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"high","type":"bool"},{"name":"signed1","type":"bool"},{"name":"signed2","type":"bool"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_mul_op(high,signed1,signed2)","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["M"],"function":"{\\n  if extension(\\"M\\") | haveZmmul() then {\\n    let rs1_val = X(rs1);\\n    let rs2_val = X(rs2);\\n    let rs1_int : int = if signed1 then signed(rs1_val) else unsigned(rs1_val);\\n    let rs2_int : int = if signed2 then signed(rs2_val) else unsigned(rs2_val);\\n    let result_wide = to_bits(2 * sizeof(xlen), rs1_int * rs2_int);\\n    let result = if   high\\n                 then result_wide[(2 * sizeof(xlen) - 1) .. sizeof(xlen)]\\n                 else result_wide[(sizeof(xlen) - 1) .. 0];\\n    X(rd) = result;\\n    RETIRE_SUCCESS\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"mulhsu","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"high","type":"bool"},{"name":"signed1","type":"bool"},{"name":"signed2","type":"bool"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_mul_op(high,signed1,signed2)","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["M"],"function":"{\\n  if extension(\\"M\\") | haveZmmul() then {\\n    let rs1_val = X(rs1);\\n    let rs2_val = X(rs2);\\n    let rs1_int : int = if signed1 then signed(rs1_val) else unsigned(rs1_val);\\n    let rs2_int : int = if signed2 then signed(rs2_val) else unsigned(rs2_val);\\n    let result_wide = to_bits(2 * sizeof(xlen), rs1_int * rs2_int);\\n    let result = if   high\\n                 then result_wide[(2 * sizeof(xlen) - 1) .. sizeof(xlen)]\\n                 else result_wide[(sizeof(xlen) - 1) .. 0];\\n    X(rd) = result;\\n    RETIRE_SUCCESS\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"mulhu","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"high","type":"bool"},{"name":"signed1","type":"bool"},{"name":"signed2","type":"bool"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_mul_op(high,signed1,signed2)","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["M"],"function":"{\\n  if extension(\\"M\\") | haveZmmul() then {\\n    let rs1_val = X(rs1);\\n    let rs2_val = X(rs2);\\n    let rs1_int : int = if signed1 then signed(rs1_val) else unsigned(rs1_val);\\n    let rs2_int : int = if signed2 then signed(rs2_val) else unsigned(rs2_val);\\n    let result_wide = to_bits(2 * sizeof(xlen), rs1_int * rs2_int);\\n    let result = if   high\\n                 then result_wide[(2 * sizeof(xlen) - 1) .. sizeof(xlen)]\\n                 else result_wide[(sizeof(xlen) - 1) .. 0];\\n    X(rd) = result;\\n    RETIRE_SUCCESS\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"mulw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["M"],"function":"{\\n  if extension(\\"M\\") | haveZmmul() then {\\n    let rs1_val = X(rs1)[31..0];\\n    let rs2_val = X(rs2)[31..0];\\n    let rs1_int : int = signed(rs1_val);\\n    let rs2_int : int = signed(rs2_val);\\n    /* to_bits requires expansion to 64 bits followed by truncation */\\n    let result32 = to_bits(64, rs1_int * rs2_int)[31..0];\\n    let result : xlenbits = sign_extend(result32);\\n    X(rd) = result;\\n    RETIRE_SUCCESS\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"or","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"rop"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ADD  => rs1_val + rs2_val,\\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\\n    RISCV_AND  => rs1_val & rs2_val,\\n    RISCV_OR   => rs1_val | rs2_val,\\n    RISCV_XOR  => rs1_val ^ rs2_val,\\n    RISCV_SLL  => if   sizeof(xlen) == 32\\n                  then rs1_val << (rs2_val[4..0])\\n                  else rs1_val << (rs2_val[5..0]),\\n    RISCV_SRL  => if   sizeof(xlen) == 32\\n                  then rs1_val >> (rs2_val[4..0])\\n                  else rs1_val >> (rs2_val[5..0]),\\n    RISCV_SUB  => rs1_val - rs2_val,\\n    RISCV_SRA  => if   sizeof(xlen) == 32\\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe R-type (Register-type) instruction format is used for operations\\nthat involve three registers. The specific operation is determined\\nby the opcode and funct7 fields. The result is written to the\\ndestination register (rd), and the source operands are specified\\nby the source registers (rs1 and rs2). The format is common for\\narithmetic, logical, and shift operations.\\n "},{"mnemonic":"orc.b","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b001010000111","size":12},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbb"],"function":"{\\n  let rs1_val = X(rs1);\\n  result : xlenbits = zeros();\\n  foreach (i from 0 to (sizeof(xlen) - 8) by 8)\\n    result[(i + 7) .. i] = if rs1_val[(i + 7) .. i] == zeros()\\n                           then 0x00\\n                           else 0xFF;\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"ori","name":"TBD","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"iop"}],"syntax":"rd,rs1,imm","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"encdec_iop(op)","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let immext : xlenbits = sign_extend(imm);\\n  let result : xlenbits = match op {\\n    RISCV_ADDI  => rs1_val + immext,\\n    RISCV_SLTI  => zero_extend(bool_to_bits(rs1_val <_s immext)),\\n    RISCV_SLTIU => zero_extend(bool_to_bits(rs1_val <_u immext)),\\n    RISCV_ANDI  => rs1_val & immext,\\n    RISCV_ORI   => rs1_val | immext,\\n    RISCV_XORI  => rs1_val ^ immext\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe ITYPE instruction operates on an immediate value, adding, comparing, or\\nperforming bitwise operations with the contents of register rs1.\\nThe immediate value, rs1, and the operation code (iop) determine the operation.\\nThe result is stored in register rd.\\nThe supported immediate operations (iop) include:\\n  - \\"addi\\"  : Add immediate\\n  - \\"slti\\"  : Set less than immediate (signed)\\n  - \\"sltiu\\" : Set less than immediate (unsigned)\\n  - \\"andi\\"  : AND immediate\\n  - \\"ori\\"   : OR immediate\\n  - \\"xori\\"  : XOR immediate\\n *\\nNote: The immediate value is sign-extended before performing the operation.\\n "},{"mnemonic":"orn","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zbb"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ANDN => rs1_val & ~(rs2_val),\\n    RISCV_ORN  => rs1_val | ~(rs2_val),\\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_ROL  => if sizeof(xlen) == 32\\n                  then rs1_val <<< rs2_val[4..0]\\n                  else rs1_val <<< rs2_val[5..0],\\n    RISCV_ROR  => if sizeof(xlen) == 32\\n                  then rs1_val >>> rs2_val[4..0]\\n                  else rs1_val >>> rs2_val[5..0]\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"pack","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zbkb"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b111","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbkb"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_PACK  => rs2_val[(sizeof(xlen_bytes)*4 - 1)..0] @ rs1_val[(sizeof(xlen_bytes)*4 - 1)..0],\\n    RISCV_PACKH => zero_extend(rs2_val[7..0] @ rs1_val[7..0])\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"packh","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zbkb"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b111","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbkb"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_PACK  => rs2_val[(sizeof(xlen_bytes)*4 - 1)..0] @ rs1_val[(sizeof(xlen_bytes)*4 - 1)..0],\\n    RISCV_PACKH => zero_extend(rs2_val[7..0] @ rs1_val[7..0])\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"packw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zbkb"],"function":"{\\n  assert(sizeof(xlen) == 64);\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : bits(32) = rs2_val[15..0] @ rs1_val[15..0];\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"rem","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"s","type":"bool"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b11","size":2},{"field":"bool_not_bits(s)","size":1},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["M"],"function":"{\\n  if extension(\\"M\\") then {\\n    let rs1_val = X(rs1);\\n    let rs2_val = X(rs2);\\n    let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val);\\n    let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val);\\n    let r : int = if rs2_int == 0 then rs1_int else rem_round_zero(rs1_int, rs2_int);\\n    /* signed overflow case returns zero naturally as required due to -1 divisor */\\n    X(rd) = to_bits(sizeof(xlen), r);\\n    RETIRE_SUCCESS\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"remu","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"s","type":"bool"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b11","size":2},{"field":"bool_not_bits(s)","size":1},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["M"],"function":"{\\n  if extension(\\"M\\") then {\\n    let rs1_val = X(rs1);\\n    let rs2_val = X(rs2);\\n    let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val);\\n    let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val);\\n    let r : int = if rs2_int == 0 then rs1_int else rem_round_zero(rs1_int, rs2_int);\\n    /* signed overflow case returns zero naturally as required due to -1 divisor */\\n    X(rd) = to_bits(sizeof(xlen), r);\\n    RETIRE_SUCCESS\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"remuw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"s","type":"bool"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b11","size":2},{"field":"bool_not_bits(s)","size":1},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["M"],"function":"{\\n  if extension(\\"M\\") then {\\n    let rs1_val = X(rs1)[31..0];\\n    let rs2_val = X(rs2)[31..0];\\n    let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val);\\n    let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val);\\n    let r : int = if rs2_int == 0 then rs1_int else rem_round_zero(rs1_int, rs2_int);\\n    /* signed overflow case returns zero naturally as required due to -1 divisor */\\n    X(rd) = sign_extend(to_bits(32, r));\\n    RETIRE_SUCCESS\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"remw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"s","type":"bool"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0000001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b11","size":2},{"field":"bool_not_bits(s)","size":1},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["M"],"function":"{\\n  if extension(\\"M\\") then {\\n    let rs1_val = X(rs1)[31..0];\\n    let rs2_val = X(rs2)[31..0];\\n    let rs1_int : int = if s then signed(rs1_val) else unsigned(rs1_val);\\n    let rs2_int : int = if s then signed(rs2_val) else unsigned(rs2_val);\\n    let r : int = if rs2_int == 0 then rs1_int else rem_round_zero(rs1_int, rs2_int);\\n    /* signed overflow case returns zero naturally as required due to -1 divisor */\\n    X(rd) = sign_extend(to_bits(32, r));\\n    RETIRE_SUCCESS\\n  } else {\\n    handle_illegal();\\n    RETIRE_FAIL\\n  }\\n}","description":"TBD"},{"mnemonic":"rev8","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b011010111000","size":12},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{\\n  let rs1_val = X(rs1);\\n  result : xlenbits = zeros();\\n  foreach (i from 0 to (sizeof(xlen) - 8) by 8)\\n    result[(i + 7) .. i] = rs1_val[(sizeof(xlen) - i - 1) .. (sizeof(xlen) - i - 8)];\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"rol","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zbb"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ANDN => rs1_val & ~(rs2_val),\\n    RISCV_ORN  => rs1_val | ~(rs2_val),\\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_ROL  => if sizeof(xlen) == 32\\n                  then rs1_val <<< rs2_val[4..0]\\n                  else rs1_val <<< rs2_val[5..0],\\n    RISCV_ROR  => if sizeof(xlen) == 32\\n                  then rs1_val >>> rs2_val[4..0]\\n                  else rs1_val >>> rs2_val[5..0]\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"rolw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"bropw_zbb"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{\\n  let rs1_val = (X(rs1))[31..0];\\n  let shamt = (X(rs2))[4..0];\\n  let result : bits(32) = match op {\\n    RISCV_ROLW => rs1_val <<< shamt,\\n    RISCV_RORW => rs1_val >>> shamt\\n  };\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"ror","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zbb"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ANDN => rs1_val & ~(rs2_val),\\n    RISCV_ORN  => rs1_val | ~(rs2_val),\\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_ROL  => if sizeof(xlen) == 32\\n                  then rs1_val <<< rs2_val[4..0]\\n                  else rs1_val <<< rs2_val[5..0],\\n    RISCV_ROR  => if sizeof(xlen) == 32\\n                  then rs1_val >>> rs2_val[4..0]\\n                  else rs1_val >>> rs2_val[5..0]\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"rori","name":"TBD","operands":[{"name":"shamt","type":"bits(6)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b011000","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{\\n  let rs1_val = X(rs1);\\n  let result : xlenbits = if sizeof(xlen) == 32\\n                          then rs1_val >>> shamt[4..0]\\n                          else rs1_val >>> shamt;\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"roriw","name":"TBD","operands":[{"name":"shamt","type":"bits(5)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"shamt","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{\\n  let rs1_val = (X(rs1))[31..0];\\n  let result : xlenbits = sign_extend(rs1_val >>> shamt);\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"rorw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"bropw_zbb"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{\\n  let rs1_val = (X(rs1))[31..0];\\n  let shamt = (X(rs2))[4..0];\\n  let result : bits(32) = match op {\\n    RISCV_ROLW => rs1_val <<< shamt,\\n    RISCV_RORW => rs1_val >>> shamt\\n  };\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sb","name":"Store","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => mem_write_ea(paddr, 1, aq, rl, false),\\n            HALF   => mem_write_ea(paddr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(paddr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(paddr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = X(rs2);\\n              let res : MemoryOpResult(bool) = match (width) {\\n                BYTE => mem_write_value(paddr, 1, rs2_val[7..0],  aq, rl, false),\\n                HALF => mem_write_value(paddr, 2, rs2_val[15..0], aq, rl, false),\\n                WORD => mem_write_value(paddr, 4, rs2_val[31..0], aq, rl, false),\\n                DOUBLE if sizeof(xlen) >= 64\\n                     => mem_write_value(paddr, 8, rs2_val,        aq, rl, false),\\n                _    => report_invalid_width(__FILE__, __LINE__, width, \\"store\\"),\\n              };\\n              match (res) {\\n                MemValue(true)  => RETIRE_SUCCESS,\\n                MemValue(false) => internal_error(__FILE__, __LINE__, \\"store got false from mem_write_value\\"),\\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n              }\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"\\nThe STORE instruction format is used for storing data from a register into\\nmemory. The specific operation is determined by the word width (size) and\\nmemory ordering semantics (acquire, release). The memory address is computed\\nby adding the immediate offset (imm) to the value in register rs1, and the\\ndata is taken from register rs2.\\n "},{"mnemonic":"sb.aq","name":"Store","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => mem_write_ea(paddr, 1, aq, rl, false),\\n            HALF   => mem_write_ea(paddr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(paddr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(paddr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = X(rs2);\\n              let res : MemoryOpResult(bool) = match (width) {\\n                BYTE => mem_write_value(paddr, 1, rs2_val[7..0],  aq, rl, false),\\n                HALF => mem_write_value(paddr, 2, rs2_val[15..0], aq, rl, false),\\n                WORD => mem_write_value(paddr, 4, rs2_val[31..0], aq, rl, false),\\n                DOUBLE if sizeof(xlen) >= 64\\n                     => mem_write_value(paddr, 8, rs2_val,        aq, rl, false),\\n                _    => report_invalid_width(__FILE__, __LINE__, width, \\"store\\"),\\n              };\\n              match (res) {\\n                MemValue(true)  => RETIRE_SUCCESS,\\n                MemValue(false) => internal_error(__FILE__, __LINE__, \\"store got false from mem_write_value\\"),\\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n              }\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"\\nThe STORE instruction format is used for storing data from a register into\\nmemory. The specific operation is determined by the word width (size) and\\nmemory ordering semantics (acquire, release). The memory address is computed\\nby adding the immediate offset (imm) to the value in register rs1, and the\\ndata is taken from register rs2.\\n "},{"mnemonic":"sb.aq.rl","name":"Store","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => mem_write_ea(paddr, 1, aq, rl, false),\\n            HALF   => mem_write_ea(paddr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(paddr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(paddr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = X(rs2);\\n              let res : MemoryOpResult(bool) = match (width) {\\n                BYTE => mem_write_value(paddr, 1, rs2_val[7..0],  aq, rl, false),\\n                HALF => mem_write_value(paddr, 2, rs2_val[15..0], aq, rl, false),\\n                WORD => mem_write_value(paddr, 4, rs2_val[31..0], aq, rl, false),\\n                DOUBLE if sizeof(xlen) >= 64\\n                     => mem_write_value(paddr, 8, rs2_val,        aq, rl, false),\\n                _    => report_invalid_width(__FILE__, __LINE__, width, \\"store\\"),\\n              };\\n              match (res) {\\n                MemValue(true)  => RETIRE_SUCCESS,\\n                MemValue(false) => internal_error(__FILE__, __LINE__, \\"store got false from mem_write_value\\"),\\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n              }\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"\\nThe STORE instruction format is used for storing data from a register into\\nmemory. The specific operation is determined by the word width (size) and\\nmemory ordering semantics (acquire, release). The memory address is computed\\nby adding the immediate offset (imm) to the value in register rs1, and the\\ndata is taken from register rs2.\\n "},{"mnemonic":"sb.rl","name":"Store","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => mem_write_ea(paddr, 1, aq, rl, false),\\n            HALF   => mem_write_ea(paddr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(paddr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(paddr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = X(rs2);\\n              let res : MemoryOpResult(bool) = match (width) {\\n                BYTE => mem_write_value(paddr, 1, rs2_val[7..0],  aq, rl, false),\\n                HALF => mem_write_value(paddr, 2, rs2_val[15..0], aq, rl, false),\\n                WORD => mem_write_value(paddr, 4, rs2_val[31..0], aq, rl, false),\\n                DOUBLE if sizeof(xlen) >= 64\\n                     => mem_write_value(paddr, 8, rs2_val,        aq, rl, false),\\n                _    => report_invalid_width(__FILE__, __LINE__, width, \\"store\\"),\\n              };\\n              match (res) {\\n                MemValue(true)  => RETIRE_SUCCESS,\\n                MemValue(false) => internal_error(__FILE__, __LINE__, \\"store got false from mem_write_value\\"),\\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n              }\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"\\nThe STORE instruction format is used for storing data from a register into\\nmemory. The specific operation is determined by the word width (size) and\\nmemory ordering semantics (acquire, release). The memory address is computed\\nby adding the immediate offset (imm) to the value in register rs1, and the\\ndata is taken from register rs2.\\n "},{"mnemonic":"sc.b","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if speculate_conditional () == false then {\\n    /* should only happen in rmem\\n     * rmem: allow SC to fail very early\\n     */\\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\\n  } else {\\n    if extension(\\"A\\") then {\\n      /* normal non-rmem case\\n       * rmem: SC is allowed to succeed (but might fail later)\\n       */\\n      /* Get the address, X(rs1) (no offset).\\n       * Extensions might perform additional checks on address validity.\\n       */\\n      match ext_data_get_addr(rs1, zeros(), Write(Data), width) {\\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n        Ext_DataAddr_OK(vaddr) => {\\n          let aligned : bool =\\n            /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n             * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n             */\\n            match width {\\n              BYTE   => true,\\n              HALF   => vaddr[0..0] == 0b0,\\n              WORD   => vaddr[1..0] == 0b00,\\n              DOUBLE => vaddr[2..0] == 0b000\\n            };\\n          if not(aligned)\\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n          else {\\n            if match_reservation(vaddr) == false then {\\n              /* cannot happen in rmem */\\n              X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\\n            } else {\\n              match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\\n                                                          * both result in a SAMO exception */\\n                TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                TR_Address(addr, _) => {\\n                  let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n                    (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n                    (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n                    (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n                    (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n                    _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                  };\\n                  match (eares) {\\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                    MemValue(_) => {\\n                      rs2_val = X(rs2);\\n                      let res : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                        (BYTE, _)    => mem_write_value(addr, 1, rs2_val[7..0], aq & rl, rl, true),\\n                        (HALF, _)    => mem_write_value(addr, 2, rs2_val[15..0], aq & rl, rl, true),\\n                        (WORD, _)    => mem_write_value(addr, 4, rs2_val[31..0], aq & rl, rl, true),\\n                        (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val,        aq & rl, rl, true),\\n                        _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                      };\\n                      match (res) {\\n                        MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    } else {\\n      handle_illegal();\\n      RETIRE_FAIL\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"sc.b.aq","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if speculate_conditional () == false then {\\n    /* should only happen in rmem\\n     * rmem: allow SC to fail very early\\n     */\\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\\n  } else {\\n    if extension(\\"A\\") then {\\n      /* normal non-rmem case\\n       * rmem: SC is allowed to succeed (but might fail later)\\n       */\\n      /* Get the address, X(rs1) (no offset).\\n       * Extensions might perform additional checks on address validity.\\n       */\\n      match ext_data_get_addr(rs1, zeros(), Write(Data), width) {\\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n        Ext_DataAddr_OK(vaddr) => {\\n          let aligned : bool =\\n            /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n             * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n             */\\n            match width {\\n              BYTE   => true,\\n              HALF   => vaddr[0..0] == 0b0,\\n              WORD   => vaddr[1..0] == 0b00,\\n              DOUBLE => vaddr[2..0] == 0b000\\n            };\\n          if not(aligned)\\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n          else {\\n            if match_reservation(vaddr) == false then {\\n              /* cannot happen in rmem */\\n              X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\\n            } else {\\n              match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\\n                                                          * both result in a SAMO exception */\\n                TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                TR_Address(addr, _) => {\\n                  let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n                    (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n                    (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n                    (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n                    (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n                    _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                  };\\n                  match (eares) {\\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                    MemValue(_) => {\\n                      rs2_val = X(rs2);\\n                      let res : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                        (BYTE, _)    => mem_write_value(addr, 1, rs2_val[7..0], aq & rl, rl, true),\\n                        (HALF, _)    => mem_write_value(addr, 2, rs2_val[15..0], aq & rl, rl, true),\\n                        (WORD, _)    => mem_write_value(addr, 4, rs2_val[31..0], aq & rl, rl, true),\\n                        (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val,        aq & rl, rl, true),\\n                        _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                      };\\n                      match (res) {\\n                        MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    } else {\\n      handle_illegal();\\n      RETIRE_FAIL\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"sc.b.aq.rl","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if speculate_conditional () == false then {\\n    /* should only happen in rmem\\n     * rmem: allow SC to fail very early\\n     */\\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\\n  } else {\\n    if extension(\\"A\\") then {\\n      /* normal non-rmem case\\n       * rmem: SC is allowed to succeed (but might fail later)\\n       */\\n      /* Get the address, X(rs1) (no offset).\\n       * Extensions might perform additional checks on address validity.\\n       */\\n      match ext_data_get_addr(rs1, zeros(), Write(Data), width) {\\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n        Ext_DataAddr_OK(vaddr) => {\\n          let aligned : bool =\\n            /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n             * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n             */\\n            match width {\\n              BYTE   => true,\\n              HALF   => vaddr[0..0] == 0b0,\\n              WORD   => vaddr[1..0] == 0b00,\\n              DOUBLE => vaddr[2..0] == 0b000\\n            };\\n          if not(aligned)\\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n          else {\\n            if match_reservation(vaddr) == false then {\\n              /* cannot happen in rmem */\\n              X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\\n            } else {\\n              match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\\n                                                          * both result in a SAMO exception */\\n                TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                TR_Address(addr, _) => {\\n                  let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n                    (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n                    (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n                    (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n                    (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n                    _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                  };\\n                  match (eares) {\\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                    MemValue(_) => {\\n                      rs2_val = X(rs2);\\n                      let res : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                        (BYTE, _)    => mem_write_value(addr, 1, rs2_val[7..0], aq & rl, rl, true),\\n                        (HALF, _)    => mem_write_value(addr, 2, rs2_val[15..0], aq & rl, rl, true),\\n                        (WORD, _)    => mem_write_value(addr, 4, rs2_val[31..0], aq & rl, rl, true),\\n                        (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val,        aq & rl, rl, true),\\n                        _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                      };\\n                      match (res) {\\n                        MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    } else {\\n      handle_illegal();\\n      RETIRE_FAIL\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"sc.b.rl","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if speculate_conditional () == false then {\\n    /* should only happen in rmem\\n     * rmem: allow SC to fail very early\\n     */\\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\\n  } else {\\n    if extension(\\"A\\") then {\\n      /* normal non-rmem case\\n       * rmem: SC is allowed to succeed (but might fail later)\\n       */\\n      /* Get the address, X(rs1) (no offset).\\n       * Extensions might perform additional checks on address validity.\\n       */\\n      match ext_data_get_addr(rs1, zeros(), Write(Data), width) {\\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n        Ext_DataAddr_OK(vaddr) => {\\n          let aligned : bool =\\n            /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n             * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n             */\\n            match width {\\n              BYTE   => true,\\n              HALF   => vaddr[0..0] == 0b0,\\n              WORD   => vaddr[1..0] == 0b00,\\n              DOUBLE => vaddr[2..0] == 0b000\\n            };\\n          if not(aligned)\\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n          else {\\n            if match_reservation(vaddr) == false then {\\n              /* cannot happen in rmem */\\n              X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\\n            } else {\\n              match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\\n                                                          * both result in a SAMO exception */\\n                TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                TR_Address(addr, _) => {\\n                  let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n                    (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n                    (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n                    (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n                    (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n                    _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                  };\\n                  match (eares) {\\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                    MemValue(_) => {\\n                      rs2_val = X(rs2);\\n                      let res : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                        (BYTE, _)    => mem_write_value(addr, 1, rs2_val[7..0], aq & rl, rl, true),\\n                        (HALF, _)    => mem_write_value(addr, 2, rs2_val[15..0], aq & rl, rl, true),\\n                        (WORD, _)    => mem_write_value(addr, 4, rs2_val[31..0], aq & rl, rl, true),\\n                        (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val,        aq & rl, rl, true),\\n                        _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                      };\\n                      match (res) {\\n                        MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    } else {\\n      handle_illegal();\\n      RETIRE_FAIL\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"sc.d","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if speculate_conditional () == false then {\\n    /* should only happen in rmem\\n     * rmem: allow SC to fail very early\\n     */\\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\\n  } else {\\n    if extension(\\"A\\") then {\\n      /* normal non-rmem case\\n       * rmem: SC is allowed to succeed (but might fail later)\\n       */\\n      /* Get the address, X(rs1) (no offset).\\n       * Extensions might perform additional checks on address validity.\\n       */\\n      match ext_data_get_addr(rs1, zeros(), Write(Data), width) {\\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n        Ext_DataAddr_OK(vaddr) => {\\n          let aligned : bool =\\n            /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n             * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n             */\\n            match width {\\n              BYTE   => true,\\n              HALF   => vaddr[0..0] == 0b0,\\n              WORD   => vaddr[1..0] == 0b00,\\n              DOUBLE => vaddr[2..0] == 0b000\\n            };\\n          if not(aligned)\\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n          else {\\n            if match_reservation(vaddr) == false then {\\n              /* cannot happen in rmem */\\n              X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\\n            } else {\\n              match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\\n                                                          * both result in a SAMO exception */\\n                TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                TR_Address(addr, _) => {\\n                  let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n                    (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n                    (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n                    (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n                    (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n                    _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                  };\\n                  match (eares) {\\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                    MemValue(_) => {\\n                      rs2_val = X(rs2);\\n                      let res : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                        (BYTE, _)    => mem_write_value(addr, 1, rs2_val[7..0], aq & rl, rl, true),\\n                        (HALF, _)    => mem_write_value(addr, 2, rs2_val[15..0], aq & rl, rl, true),\\n                        (WORD, _)    => mem_write_value(addr, 4, rs2_val[31..0], aq & rl, rl, true),\\n                        (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val,        aq & rl, rl, true),\\n                        _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                      };\\n                      match (res) {\\n                        MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    } else {\\n      handle_illegal();\\n      RETIRE_FAIL\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"sc.d.aq","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if speculate_conditional () == false then {\\n    /* should only happen in rmem\\n     * rmem: allow SC to fail very early\\n     */\\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\\n  } else {\\n    if extension(\\"A\\") then {\\n      /* normal non-rmem case\\n       * rmem: SC is allowed to succeed (but might fail later)\\n       */\\n      /* Get the address, X(rs1) (no offset).\\n       * Extensions might perform additional checks on address validity.\\n       */\\n      match ext_data_get_addr(rs1, zeros(), Write(Data), width) {\\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n        Ext_DataAddr_OK(vaddr) => {\\n          let aligned : bool =\\n            /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n             * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n             */\\n            match width {\\n              BYTE   => true,\\n              HALF   => vaddr[0..0] == 0b0,\\n              WORD   => vaddr[1..0] == 0b00,\\n              DOUBLE => vaddr[2..0] == 0b000\\n            };\\n          if not(aligned)\\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n          else {\\n            if match_reservation(vaddr) == false then {\\n              /* cannot happen in rmem */\\n              X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\\n            } else {\\n              match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\\n                                                          * both result in a SAMO exception */\\n                TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                TR_Address(addr, _) => {\\n                  let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n                    (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n                    (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n                    (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n                    (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n                    _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                  };\\n                  match (eares) {\\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                    MemValue(_) => {\\n                      rs2_val = X(rs2);\\n                      let res : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                        (BYTE, _)    => mem_write_value(addr, 1, rs2_val[7..0], aq & rl, rl, true),\\n                        (HALF, _)    => mem_write_value(addr, 2, rs2_val[15..0], aq & rl, rl, true),\\n                        (WORD, _)    => mem_write_value(addr, 4, rs2_val[31..0], aq & rl, rl, true),\\n                        (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val,        aq & rl, rl, true),\\n                        _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                      };\\n                      match (res) {\\n                        MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    } else {\\n      handle_illegal();\\n      RETIRE_FAIL\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"sc.d.aq.rl","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if speculate_conditional () == false then {\\n    /* should only happen in rmem\\n     * rmem: allow SC to fail very early\\n     */\\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\\n  } else {\\n    if extension(\\"A\\") then {\\n      /* normal non-rmem case\\n       * rmem: SC is allowed to succeed (but might fail later)\\n       */\\n      /* Get the address, X(rs1) (no offset).\\n       * Extensions might perform additional checks on address validity.\\n       */\\n      match ext_data_get_addr(rs1, zeros(), Write(Data), width) {\\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n        Ext_DataAddr_OK(vaddr) => {\\n          let aligned : bool =\\n            /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n             * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n             */\\n            match width {\\n              BYTE   => true,\\n              HALF   => vaddr[0..0] == 0b0,\\n              WORD   => vaddr[1..0] == 0b00,\\n              DOUBLE => vaddr[2..0] == 0b000\\n            };\\n          if not(aligned)\\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n          else {\\n            if match_reservation(vaddr) == false then {\\n              /* cannot happen in rmem */\\n              X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\\n            } else {\\n              match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\\n                                                          * both result in a SAMO exception */\\n                TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                TR_Address(addr, _) => {\\n                  let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n                    (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n                    (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n                    (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n                    (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n                    _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                  };\\n                  match (eares) {\\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                    MemValue(_) => {\\n                      rs2_val = X(rs2);\\n                      let res : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                        (BYTE, _)    => mem_write_value(addr, 1, rs2_val[7..0], aq & rl, rl, true),\\n                        (HALF, _)    => mem_write_value(addr, 2, rs2_val[15..0], aq & rl, rl, true),\\n                        (WORD, _)    => mem_write_value(addr, 4, rs2_val[31..0], aq & rl, rl, true),\\n                        (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val,        aq & rl, rl, true),\\n                        _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                      };\\n                      match (res) {\\n                        MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    } else {\\n      handle_illegal();\\n      RETIRE_FAIL\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"sc.d.rl","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if speculate_conditional () == false then {\\n    /* should only happen in rmem\\n     * rmem: allow SC to fail very early\\n     */\\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\\n  } else {\\n    if extension(\\"A\\") then {\\n      /* normal non-rmem case\\n       * rmem: SC is allowed to succeed (but might fail later)\\n       */\\n      /* Get the address, X(rs1) (no offset).\\n       * Extensions might perform additional checks on address validity.\\n       */\\n      match ext_data_get_addr(rs1, zeros(), Write(Data), width) {\\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n        Ext_DataAddr_OK(vaddr) => {\\n          let aligned : bool =\\n            /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n             * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n             */\\n            match width {\\n              BYTE   => true,\\n              HALF   => vaddr[0..0] == 0b0,\\n              WORD   => vaddr[1..0] == 0b00,\\n              DOUBLE => vaddr[2..0] == 0b000\\n            };\\n          if not(aligned)\\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n          else {\\n            if match_reservation(vaddr) == false then {\\n              /* cannot happen in rmem */\\n              X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\\n            } else {\\n              match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\\n                                                          * both result in a SAMO exception */\\n                TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                TR_Address(addr, _) => {\\n                  let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n                    (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n                    (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n                    (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n                    (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n                    _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                  };\\n                  match (eares) {\\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                    MemValue(_) => {\\n                      rs2_val = X(rs2);\\n                      let res : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                        (BYTE, _)    => mem_write_value(addr, 1, rs2_val[7..0], aq & rl, rl, true),\\n                        (HALF, _)    => mem_write_value(addr, 2, rs2_val[15..0], aq & rl, rl, true),\\n                        (WORD, _)    => mem_write_value(addr, 4, rs2_val[31..0], aq & rl, rl, true),\\n                        (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val,        aq & rl, rl, true),\\n                        _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                      };\\n                      match (res) {\\n                        MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    } else {\\n      handle_illegal();\\n      RETIRE_FAIL\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"sc.h","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if speculate_conditional () == false then {\\n    /* should only happen in rmem\\n     * rmem: allow SC to fail very early\\n     */\\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\\n  } else {\\n    if extension(\\"A\\") then {\\n      /* normal non-rmem case\\n       * rmem: SC is allowed to succeed (but might fail later)\\n       */\\n      /* Get the address, X(rs1) (no offset).\\n       * Extensions might perform additional checks on address validity.\\n       */\\n      match ext_data_get_addr(rs1, zeros(), Write(Data), width) {\\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n        Ext_DataAddr_OK(vaddr) => {\\n          let aligned : bool =\\n            /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n             * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n             */\\n            match width {\\n              BYTE   => true,\\n              HALF   => vaddr[0..0] == 0b0,\\n              WORD   => vaddr[1..0] == 0b00,\\n              DOUBLE => vaddr[2..0] == 0b000\\n            };\\n          if not(aligned)\\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n          else {\\n            if match_reservation(vaddr) == false then {\\n              /* cannot happen in rmem */\\n              X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\\n            } else {\\n              match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\\n                                                          * both result in a SAMO exception */\\n                TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                TR_Address(addr, _) => {\\n                  let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n                    (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n                    (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n                    (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n                    (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n                    _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                  };\\n                  match (eares) {\\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                    MemValue(_) => {\\n                      rs2_val = X(rs2);\\n                      let res : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                        (BYTE, _)    => mem_write_value(addr, 1, rs2_val[7..0], aq & rl, rl, true),\\n                        (HALF, _)    => mem_write_value(addr, 2, rs2_val[15..0], aq & rl, rl, true),\\n                        (WORD, _)    => mem_write_value(addr, 4, rs2_val[31..0], aq & rl, rl, true),\\n                        (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val,        aq & rl, rl, true),\\n                        _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                      };\\n                      match (res) {\\n                        MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    } else {\\n      handle_illegal();\\n      RETIRE_FAIL\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"sc.h.aq","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if speculate_conditional () == false then {\\n    /* should only happen in rmem\\n     * rmem: allow SC to fail very early\\n     */\\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\\n  } else {\\n    if extension(\\"A\\") then {\\n      /* normal non-rmem case\\n       * rmem: SC is allowed to succeed (but might fail later)\\n       */\\n      /* Get the address, X(rs1) (no offset).\\n       * Extensions might perform additional checks on address validity.\\n       */\\n      match ext_data_get_addr(rs1, zeros(), Write(Data), width) {\\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n        Ext_DataAddr_OK(vaddr) => {\\n          let aligned : bool =\\n            /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n             * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n             */\\n            match width {\\n              BYTE   => true,\\n              HALF   => vaddr[0..0] == 0b0,\\n              WORD   => vaddr[1..0] == 0b00,\\n              DOUBLE => vaddr[2..0] == 0b000\\n            };\\n          if not(aligned)\\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n          else {\\n            if match_reservation(vaddr) == false then {\\n              /* cannot happen in rmem */\\n              X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\\n            } else {\\n              match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\\n                                                          * both result in a SAMO exception */\\n                TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                TR_Address(addr, _) => {\\n                  let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n                    (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n                    (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n                    (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n                    (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n                    _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                  };\\n                  match (eares) {\\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                    MemValue(_) => {\\n                      rs2_val = X(rs2);\\n                      let res : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                        (BYTE, _)    => mem_write_value(addr, 1, rs2_val[7..0], aq & rl, rl, true),\\n                        (HALF, _)    => mem_write_value(addr, 2, rs2_val[15..0], aq & rl, rl, true),\\n                        (WORD, _)    => mem_write_value(addr, 4, rs2_val[31..0], aq & rl, rl, true),\\n                        (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val,        aq & rl, rl, true),\\n                        _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                      };\\n                      match (res) {\\n                        MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    } else {\\n      handle_illegal();\\n      RETIRE_FAIL\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"sc.h.aq.rl","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if speculate_conditional () == false then {\\n    /* should only happen in rmem\\n     * rmem: allow SC to fail very early\\n     */\\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\\n  } else {\\n    if extension(\\"A\\") then {\\n      /* normal non-rmem case\\n       * rmem: SC is allowed to succeed (but might fail later)\\n       */\\n      /* Get the address, X(rs1) (no offset).\\n       * Extensions might perform additional checks on address validity.\\n       */\\n      match ext_data_get_addr(rs1, zeros(), Write(Data), width) {\\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n        Ext_DataAddr_OK(vaddr) => {\\n          let aligned : bool =\\n            /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n             * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n             */\\n            match width {\\n              BYTE   => true,\\n              HALF   => vaddr[0..0] == 0b0,\\n              WORD   => vaddr[1..0] == 0b00,\\n              DOUBLE => vaddr[2..0] == 0b000\\n            };\\n          if not(aligned)\\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n          else {\\n            if match_reservation(vaddr) == false then {\\n              /* cannot happen in rmem */\\n              X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\\n            } else {\\n              match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\\n                                                          * both result in a SAMO exception */\\n                TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                TR_Address(addr, _) => {\\n                  let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n                    (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n                    (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n                    (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n                    (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n                    _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                  };\\n                  match (eares) {\\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                    MemValue(_) => {\\n                      rs2_val = X(rs2);\\n                      let res : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                        (BYTE, _)    => mem_write_value(addr, 1, rs2_val[7..0], aq & rl, rl, true),\\n                        (HALF, _)    => mem_write_value(addr, 2, rs2_val[15..0], aq & rl, rl, true),\\n                        (WORD, _)    => mem_write_value(addr, 4, rs2_val[31..0], aq & rl, rl, true),\\n                        (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val,        aq & rl, rl, true),\\n                        _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                      };\\n                      match (res) {\\n                        MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    } else {\\n      handle_illegal();\\n      RETIRE_FAIL\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"sc.h.rl","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if speculate_conditional () == false then {\\n    /* should only happen in rmem\\n     * rmem: allow SC to fail very early\\n     */\\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\\n  } else {\\n    if extension(\\"A\\") then {\\n      /* normal non-rmem case\\n       * rmem: SC is allowed to succeed (but might fail later)\\n       */\\n      /* Get the address, X(rs1) (no offset).\\n       * Extensions might perform additional checks on address validity.\\n       */\\n      match ext_data_get_addr(rs1, zeros(), Write(Data), width) {\\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n        Ext_DataAddr_OK(vaddr) => {\\n          let aligned : bool =\\n            /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n             * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n             */\\n            match width {\\n              BYTE   => true,\\n              HALF   => vaddr[0..0] == 0b0,\\n              WORD   => vaddr[1..0] == 0b00,\\n              DOUBLE => vaddr[2..0] == 0b000\\n            };\\n          if not(aligned)\\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n          else {\\n            if match_reservation(vaddr) == false then {\\n              /* cannot happen in rmem */\\n              X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\\n            } else {\\n              match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\\n                                                          * both result in a SAMO exception */\\n                TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                TR_Address(addr, _) => {\\n                  let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n                    (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n                    (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n                    (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n                    (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n                    _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                  };\\n                  match (eares) {\\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                    MemValue(_) => {\\n                      rs2_val = X(rs2);\\n                      let res : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                        (BYTE, _)    => mem_write_value(addr, 1, rs2_val[7..0], aq & rl, rl, true),\\n                        (HALF, _)    => mem_write_value(addr, 2, rs2_val[15..0], aq & rl, rl, true),\\n                        (WORD, _)    => mem_write_value(addr, 4, rs2_val[31..0], aq & rl, rl, true),\\n                        (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val,        aq & rl, rl, true),\\n                        _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                      };\\n                      match (res) {\\n                        MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    } else {\\n      handle_illegal();\\n      RETIRE_FAIL\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"sc.w","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if speculate_conditional () == false then {\\n    /* should only happen in rmem\\n     * rmem: allow SC to fail very early\\n     */\\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\\n  } else {\\n    if extension(\\"A\\") then {\\n      /* normal non-rmem case\\n       * rmem: SC is allowed to succeed (but might fail later)\\n       */\\n      /* Get the address, X(rs1) (no offset).\\n       * Extensions might perform additional checks on address validity.\\n       */\\n      match ext_data_get_addr(rs1, zeros(), Write(Data), width) {\\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n        Ext_DataAddr_OK(vaddr) => {\\n          let aligned : bool =\\n            /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n             * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n             */\\n            match width {\\n              BYTE   => true,\\n              HALF   => vaddr[0..0] == 0b0,\\n              WORD   => vaddr[1..0] == 0b00,\\n              DOUBLE => vaddr[2..0] == 0b000\\n            };\\n          if not(aligned)\\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n          else {\\n            if match_reservation(vaddr) == false then {\\n              /* cannot happen in rmem */\\n              X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\\n            } else {\\n              match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\\n                                                          * both result in a SAMO exception */\\n                TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                TR_Address(addr, _) => {\\n                  let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n                    (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n                    (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n                    (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n                    (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n                    _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                  };\\n                  match (eares) {\\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                    MemValue(_) => {\\n                      rs2_val = X(rs2);\\n                      let res : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                        (BYTE, _)    => mem_write_value(addr, 1, rs2_val[7..0], aq & rl, rl, true),\\n                        (HALF, _)    => mem_write_value(addr, 2, rs2_val[15..0], aq & rl, rl, true),\\n                        (WORD, _)    => mem_write_value(addr, 4, rs2_val[31..0], aq & rl, rl, true),\\n                        (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val,        aq & rl, rl, true),\\n                        _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                      };\\n                      match (res) {\\n                        MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    } else {\\n      handle_illegal();\\n      RETIRE_FAIL\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"sc.w.aq","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if speculate_conditional () == false then {\\n    /* should only happen in rmem\\n     * rmem: allow SC to fail very early\\n     */\\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\\n  } else {\\n    if extension(\\"A\\") then {\\n      /* normal non-rmem case\\n       * rmem: SC is allowed to succeed (but might fail later)\\n       */\\n      /* Get the address, X(rs1) (no offset).\\n       * Extensions might perform additional checks on address validity.\\n       */\\n      match ext_data_get_addr(rs1, zeros(), Write(Data), width) {\\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n        Ext_DataAddr_OK(vaddr) => {\\n          let aligned : bool =\\n            /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n             * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n             */\\n            match width {\\n              BYTE   => true,\\n              HALF   => vaddr[0..0] == 0b0,\\n              WORD   => vaddr[1..0] == 0b00,\\n              DOUBLE => vaddr[2..0] == 0b000\\n            };\\n          if not(aligned)\\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n          else {\\n            if match_reservation(vaddr) == false then {\\n              /* cannot happen in rmem */\\n              X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\\n            } else {\\n              match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\\n                                                          * both result in a SAMO exception */\\n                TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                TR_Address(addr, _) => {\\n                  let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n                    (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n                    (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n                    (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n                    (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n                    _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                  };\\n                  match (eares) {\\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                    MemValue(_) => {\\n                      rs2_val = X(rs2);\\n                      let res : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                        (BYTE, _)    => mem_write_value(addr, 1, rs2_val[7..0], aq & rl, rl, true),\\n                        (HALF, _)    => mem_write_value(addr, 2, rs2_val[15..0], aq & rl, rl, true),\\n                        (WORD, _)    => mem_write_value(addr, 4, rs2_val[31..0], aq & rl, rl, true),\\n                        (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val,        aq & rl, rl, true),\\n                        _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                      };\\n                      match (res) {\\n                        MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    } else {\\n      handle_illegal();\\n      RETIRE_FAIL\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"sc.w.aq.rl","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if speculate_conditional () == false then {\\n    /* should only happen in rmem\\n     * rmem: allow SC to fail very early\\n     */\\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\\n  } else {\\n    if extension(\\"A\\") then {\\n      /* normal non-rmem case\\n       * rmem: SC is allowed to succeed (but might fail later)\\n       */\\n      /* Get the address, X(rs1) (no offset).\\n       * Extensions might perform additional checks on address validity.\\n       */\\n      match ext_data_get_addr(rs1, zeros(), Write(Data), width) {\\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n        Ext_DataAddr_OK(vaddr) => {\\n          let aligned : bool =\\n            /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n             * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n             */\\n            match width {\\n              BYTE   => true,\\n              HALF   => vaddr[0..0] == 0b0,\\n              WORD   => vaddr[1..0] == 0b00,\\n              DOUBLE => vaddr[2..0] == 0b000\\n            };\\n          if not(aligned)\\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n          else {\\n            if match_reservation(vaddr) == false then {\\n              /* cannot happen in rmem */\\n              X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\\n            } else {\\n              match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\\n                                                          * both result in a SAMO exception */\\n                TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                TR_Address(addr, _) => {\\n                  let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n                    (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n                    (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n                    (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n                    (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n                    _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                  };\\n                  match (eares) {\\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                    MemValue(_) => {\\n                      rs2_val = X(rs2);\\n                      let res : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                        (BYTE, _)    => mem_write_value(addr, 1, rs2_val[7..0], aq & rl, rl, true),\\n                        (HALF, _)    => mem_write_value(addr, 2, rs2_val[15..0], aq & rl, rl, true),\\n                        (WORD, _)    => mem_write_value(addr, 4, rs2_val[31..0], aq & rl, rl, true),\\n                        (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val,        aq & rl, rl, true),\\n                        _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                      };\\n                      match (res) {\\n                        MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    } else {\\n      handle_illegal();\\n      RETIRE_FAIL\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"sc.w.rl","name":"TBD","operands":[{"name":"aq","type":"bool"},{"name":"rl","type":"bool"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b00011","size":5},{"field":"bool_bits(aq)","size":1},{"field":"bool_bits(rl)","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"rd","size":5},{"field":"0b0101111","size":7}],"extensions":["A"],"function":"{\\n  if speculate_conditional () == false then {\\n    /* should only happen in rmem\\n     * rmem: allow SC to fail very early\\n     */\\n    X(rd) = zero_extend(0b1); RETIRE_SUCCESS\\n  } else {\\n    if extension(\\"A\\") then {\\n      /* normal non-rmem case\\n       * rmem: SC is allowed to succeed (but might fail later)\\n       */\\n      /* Get the address, X(rs1) (no offset).\\n       * Extensions might perform additional checks on address validity.\\n       */\\n      match ext_data_get_addr(rs1, zeros(), Write(Data), width) {\\n        Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n        Ext_DataAddr_OK(vaddr) => {\\n          let aligned : bool =\\n            /* BYTE and HALF would only occur due to invalid decodes, but it doesn\'t hurt\\n             * to treat them as valid here; otherwise we\'d need to throw an internal_error.\\n             */\\n            match width {\\n              BYTE   => true,\\n              HALF   => vaddr[0..0] == 0b0,\\n              WORD   => vaddr[1..0] == 0b00,\\n              DOUBLE => vaddr[2..0] == 0b000\\n            };\\n          if not(aligned)\\n          then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n          else {\\n            if match_reservation(vaddr) == false then {\\n              /* cannot happen in rmem */\\n              X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS\\n            } else {\\n              match translateAddr(vaddr, Write(Data)) {  /* Write and ReadWrite are equivalent here:\\n                                                          * both result in a SAMO exception */\\n                TR_Failure(e, _) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                TR_Address(addr, _) => {\\n                  let eares : MemoryOpResult(unit) = match (width, sizeof(xlen)) {\\n                    (BYTE, _)    => mem_write_ea(addr, 1, aq & rl, rl, true),\\n                    (HALF, _)    => mem_write_ea(addr, 2, aq & rl, rl, true),\\n                    (WORD, _)    => mem_write_ea(addr, 4, aq & rl, rl, true),\\n                    (DOUBLE, 64) => mem_write_ea(addr, 8, aq & rl, rl, true),\\n                    _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                  };\\n                  match (eares) {\\n                    MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n                    MemValue(_) => {\\n                      rs2_val = X(rs2);\\n                      let res : MemoryOpResult(bool) = match (width, sizeof(xlen)) {\\n                        (BYTE, _)    => mem_write_value(addr, 1, rs2_val[7..0], aq & rl, rl, true),\\n                        (HALF, _)    => mem_write_value(addr, 2, rs2_val[15..0], aq & rl, rl, true),\\n                        (WORD, _)    => mem_write_value(addr, 4, rs2_val[31..0], aq & rl, rl, true),\\n                        (DOUBLE, 64) => mem_write_value(addr, 8, rs2_val,        aq & rl, rl, true),\\n                        _            => internal_error(__FILE__, __LINE__, \\"STORECON expected word or double\\")\\n                      };\\n                      match (res) {\\n                        MemValue(true)  => { X(rd) = zero_extend(0b0); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemValue(false) => { X(rd) = zero_extend(0b1); cancel_reservation(); RETIRE_SUCCESS },\\n                        MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n                      }\\n                    }\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      }\\n    } else {\\n      handle_illegal();\\n      RETIRE_FAIL\\n    }\\n  }\\n}","description":"TBD"},{"mnemonic":"sd","name":"Store","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => mem_write_ea(paddr, 1, aq, rl, false),\\n            HALF   => mem_write_ea(paddr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(paddr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(paddr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = X(rs2);\\n              let res : MemoryOpResult(bool) = match (width) {\\n                BYTE => mem_write_value(paddr, 1, rs2_val[7..0],  aq, rl, false),\\n                HALF => mem_write_value(paddr, 2, rs2_val[15..0], aq, rl, false),\\n                WORD => mem_write_value(paddr, 4, rs2_val[31..0], aq, rl, false),\\n                DOUBLE if sizeof(xlen) >= 64\\n                     => mem_write_value(paddr, 8, rs2_val,        aq, rl, false),\\n                _    => report_invalid_width(__FILE__, __LINE__, width, \\"store\\"),\\n              };\\n              match (res) {\\n                MemValue(true)  => RETIRE_SUCCESS,\\n                MemValue(false) => internal_error(__FILE__, __LINE__, \\"store got false from mem_write_value\\"),\\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n              }\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"\\nThe STORE instruction format is used for storing data from a register into\\nmemory. The specific operation is determined by the word width (size) and\\nmemory ordering semantics (acquire, release). The memory address is computed\\nby adding the immediate offset (imm) to the value in register rs1, and the\\ndata is taken from register rs2.\\n "},{"mnemonic":"sd.aq","name":"Store","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => mem_write_ea(paddr, 1, aq, rl, false),\\n            HALF   => mem_write_ea(paddr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(paddr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(paddr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = X(rs2);\\n              let res : MemoryOpResult(bool) = match (width) {\\n                BYTE => mem_write_value(paddr, 1, rs2_val[7..0],  aq, rl, false),\\n                HALF => mem_write_value(paddr, 2, rs2_val[15..0], aq, rl, false),\\n                WORD => mem_write_value(paddr, 4, rs2_val[31..0], aq, rl, false),\\n                DOUBLE if sizeof(xlen) >= 64\\n                     => mem_write_value(paddr, 8, rs2_val,        aq, rl, false),\\n                _    => report_invalid_width(__FILE__, __LINE__, width, \\"store\\"),\\n              };\\n              match (res) {\\n                MemValue(true)  => RETIRE_SUCCESS,\\n                MemValue(false) => internal_error(__FILE__, __LINE__, \\"store got false from mem_write_value\\"),\\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n              }\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"\\nThe STORE instruction format is used for storing data from a register into\\nmemory. The specific operation is determined by the word width (size) and\\nmemory ordering semantics (acquire, release). The memory address is computed\\nby adding the immediate offset (imm) to the value in register rs1, and the\\ndata is taken from register rs2.\\n "},{"mnemonic":"sd.aq.rl","name":"Store","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => mem_write_ea(paddr, 1, aq, rl, false),\\n            HALF   => mem_write_ea(paddr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(paddr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(paddr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = X(rs2);\\n              let res : MemoryOpResult(bool) = match (width) {\\n                BYTE => mem_write_value(paddr, 1, rs2_val[7..0],  aq, rl, false),\\n                HALF => mem_write_value(paddr, 2, rs2_val[15..0], aq, rl, false),\\n                WORD => mem_write_value(paddr, 4, rs2_val[31..0], aq, rl, false),\\n                DOUBLE if sizeof(xlen) >= 64\\n                     => mem_write_value(paddr, 8, rs2_val,        aq, rl, false),\\n                _    => report_invalid_width(__FILE__, __LINE__, width, \\"store\\"),\\n              };\\n              match (res) {\\n                MemValue(true)  => RETIRE_SUCCESS,\\n                MemValue(false) => internal_error(__FILE__, __LINE__, \\"store got false from mem_write_value\\"),\\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n              }\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"\\nThe STORE instruction format is used for storing data from a register into\\nmemory. The specific operation is determined by the word width (size) and\\nmemory ordering semantics (acquire, release). The memory address is computed\\nby adding the immediate offset (imm) to the value in register rs1, and the\\ndata is taken from register rs2.\\n "},{"mnemonic":"sd.rl","name":"Store","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => mem_write_ea(paddr, 1, aq, rl, false),\\n            HALF   => mem_write_ea(paddr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(paddr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(paddr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = X(rs2);\\n              let res : MemoryOpResult(bool) = match (width) {\\n                BYTE => mem_write_value(paddr, 1, rs2_val[7..0],  aq, rl, false),\\n                HALF => mem_write_value(paddr, 2, rs2_val[15..0], aq, rl, false),\\n                WORD => mem_write_value(paddr, 4, rs2_val[31..0], aq, rl, false),\\n                DOUBLE if sizeof(xlen) >= 64\\n                     => mem_write_value(paddr, 8, rs2_val,        aq, rl, false),\\n                _    => report_invalid_width(__FILE__, __LINE__, width, \\"store\\"),\\n              };\\n              match (res) {\\n                MemValue(true)  => RETIRE_SUCCESS,\\n                MemValue(false) => internal_error(__FILE__, __LINE__, \\"store got false from mem_write_value\\"),\\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n              }\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"\\nThe STORE instruction format is used for storing data from a register into\\nmemory. The specific operation is determined by the word width (size) and\\nmemory ordering semantics (acquire, release). The memory address is computed\\nby adding the immediate offset (imm) to the value in register rs1, and the\\ndata is taken from register rs2.\\n "},{"mnemonic":"sext.b","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"extop_zbb"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b0000100","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zbb"],"function":"{\\n  let rs1_val = X(rs1);\\n  let result : xlenbits = match op {\\n    RISCV_SEXTB => sign_extend(rs1_val[7..0]),\\n    RISCV_SEXTH => sign_extend(rs1_val[15..0]),\\n    RISCV_ZEXTH => zero_extend(rs1_val[15..0])\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sext.h","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"extop_zbb"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b0000100","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zbb"],"function":"{\\n  let rs1_val = X(rs1);\\n  let result : xlenbits = match op {\\n    RISCV_SEXTB => sign_extend(rs1_val[7..0]),\\n    RISCV_SEXTH => sign_extend(rs1_val[15..0]),\\n    RISCV_ZEXTH => zero_extend(rs1_val[15..0])\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sfence.vma","name":"Store Fence (Virtual Memory Address)","operands":[{"name":"rs1","type":"regidx"},{"name":"rs2","type":"regidx"}],"syntax":"rs1,rs2","format":"R","fields":[{"field":"0b0001001","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{\\n  let addr : option(xlenbits) = if rs1 == 0b00000 then None() else Some(X(rs1));\\n  let asid : option(xlenbits) = if rs2 == 0b00000 then None() else Some(X(rs2));\\n  match cur_privilege {\\n    User       => { handle_illegal(); RETIRE_FAIL },\\n    Supervisor => match (architecture(get_mstatus_SXL(mstatus)), mstatus.TVM()) {\\n                    (Some(_), 0b1)  => { handle_illegal(); RETIRE_FAIL },\\n                    (Some(_), 0b0) => { flush_TLB(asid, addr); RETIRE_SUCCESS },\\n                    (_, _)           => internal_error(__FILE__, __LINE__, \\"unimplemented sfence architecture\\")\\n                  },\\n    Machine    => { flush_TLB(asid, addr); RETIRE_SUCCESS }\\n  }\\n}","description":"\\nThe SFENCE.VMA instruction is used to synchronize the store queue and flush\\nTLB entries based on virtual memory address and optional ASID values.\\nIts behavior depends on the current privilege level:\\n- In User mode, it handles the illegal instruction and returns with RETIRE_FAIL.\\n- In Supervisor mode, it checks for illegal instructions and performs TLB\\n  flushing based on the provided virtual memory address and ASID values.\\n- In Machine mode, it performs TLB flushing based on the provided virtual\\n  memory address and ASID values.\\n "},{"mnemonic":"sh","name":"Store","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => mem_write_ea(paddr, 1, aq, rl, false),\\n            HALF   => mem_write_ea(paddr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(paddr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(paddr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = X(rs2);\\n              let res : MemoryOpResult(bool) = match (width) {\\n                BYTE => mem_write_value(paddr, 1, rs2_val[7..0],  aq, rl, false),\\n                HALF => mem_write_value(paddr, 2, rs2_val[15..0], aq, rl, false),\\n                WORD => mem_write_value(paddr, 4, rs2_val[31..0], aq, rl, false),\\n                DOUBLE if sizeof(xlen) >= 64\\n                     => mem_write_value(paddr, 8, rs2_val,        aq, rl, false),\\n                _    => report_invalid_width(__FILE__, __LINE__, width, \\"store\\"),\\n              };\\n              match (res) {\\n                MemValue(true)  => RETIRE_SUCCESS,\\n                MemValue(false) => internal_error(__FILE__, __LINE__, \\"store got false from mem_write_value\\"),\\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n              }\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"\\nThe STORE instruction format is used for storing data from a register into\\nmemory. The specific operation is determined by the word width (size) and\\nmemory ordering semantics (acquire, release). The memory address is computed\\nby adding the immediate offset (imm) to the value in register rs1, and the\\ndata is taken from register rs2.\\n "},{"mnemonic":"sh.aq","name":"Store","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => mem_write_ea(paddr, 1, aq, rl, false),\\n            HALF   => mem_write_ea(paddr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(paddr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(paddr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = X(rs2);\\n              let res : MemoryOpResult(bool) = match (width) {\\n                BYTE => mem_write_value(paddr, 1, rs2_val[7..0],  aq, rl, false),\\n                HALF => mem_write_value(paddr, 2, rs2_val[15..0], aq, rl, false),\\n                WORD => mem_write_value(paddr, 4, rs2_val[31..0], aq, rl, false),\\n                DOUBLE if sizeof(xlen) >= 64\\n                     => mem_write_value(paddr, 8, rs2_val,        aq, rl, false),\\n                _    => report_invalid_width(__FILE__, __LINE__, width, \\"store\\"),\\n              };\\n              match (res) {\\n                MemValue(true)  => RETIRE_SUCCESS,\\n                MemValue(false) => internal_error(__FILE__, __LINE__, \\"store got false from mem_write_value\\"),\\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n              }\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"\\nThe STORE instruction format is used for storing data from a register into\\nmemory. The specific operation is determined by the word width (size) and\\nmemory ordering semantics (acquire, release). The memory address is computed\\nby adding the immediate offset (imm) to the value in register rs1, and the\\ndata is taken from register rs2.\\n "},{"mnemonic":"sh.aq.rl","name":"Store","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => mem_write_ea(paddr, 1, aq, rl, false),\\n            HALF   => mem_write_ea(paddr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(paddr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(paddr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = X(rs2);\\n              let res : MemoryOpResult(bool) = match (width) {\\n                BYTE => mem_write_value(paddr, 1, rs2_val[7..0],  aq, rl, false),\\n                HALF => mem_write_value(paddr, 2, rs2_val[15..0], aq, rl, false),\\n                WORD => mem_write_value(paddr, 4, rs2_val[31..0], aq, rl, false),\\n                DOUBLE if sizeof(xlen) >= 64\\n                     => mem_write_value(paddr, 8, rs2_val,        aq, rl, false),\\n                _    => report_invalid_width(__FILE__, __LINE__, width, \\"store\\"),\\n              };\\n              match (res) {\\n                MemValue(true)  => RETIRE_SUCCESS,\\n                MemValue(false) => internal_error(__FILE__, __LINE__, \\"store got false from mem_write_value\\"),\\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n              }\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"\\nThe STORE instruction format is used for storing data from a register into\\nmemory. The specific operation is determined by the word width (size) and\\nmemory ordering semantics (acquire, release). The memory address is computed\\nby adding the immediate offset (imm) to the value in register rs1, and the\\ndata is taken from register rs2.\\n "},{"mnemonic":"sh.rl","name":"Store","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => mem_write_ea(paddr, 1, aq, rl, false),\\n            HALF   => mem_write_ea(paddr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(paddr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(paddr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = X(rs2);\\n              let res : MemoryOpResult(bool) = match (width) {\\n                BYTE => mem_write_value(paddr, 1, rs2_val[7..0],  aq, rl, false),\\n                HALF => mem_write_value(paddr, 2, rs2_val[15..0], aq, rl, false),\\n                WORD => mem_write_value(paddr, 4, rs2_val[31..0], aq, rl, false),\\n                DOUBLE if sizeof(xlen) >= 64\\n                     => mem_write_value(paddr, 8, rs2_val,        aq, rl, false),\\n                _    => report_invalid_width(__FILE__, __LINE__, width, \\"store\\"),\\n              };\\n              match (res) {\\n                MemValue(true)  => RETIRE_SUCCESS,\\n                MemValue(false) => internal_error(__FILE__, __LINE__, \\"store got false from mem_write_value\\"),\\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n              }\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"\\nThe STORE instruction format is used for storing data from a register into\\nmemory. The specific operation is determined by the word width (size) and\\nmemory ordering semantics (acquire, release). The memory address is computed\\nby adding the immediate offset (imm) to the value in register rs1, and the\\ndata is taken from register rs2.\\n "},{"mnemonic":"sh1add","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zba"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zba"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let shamt : bits(2) = match op {\\n    RISCV_SH1ADD => 0b01,\\n    RISCV_SH2ADD => 0b10,\\n    RISCV_SH3ADD => 0b11\\n  };\\n  let result : xlenbits = (rs1_val << shamt) + rs2_val;\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sh1add.uw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"bropw_zba"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zba"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let shamt : bits(2) = match op {\\n    RISCV_ADDUW    => 0b00,\\n    RISCV_SH1ADDUW => 0b01,\\n    RISCV_SH2ADDUW => 0b10,\\n    RISCV_SH3ADDUW => 0b11\\n  };\\n  let result : xlenbits = (zero_extend(rs1_val[31..0]) << shamt) + rs2_val;\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sh2add","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zba"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zba"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let shamt : bits(2) = match op {\\n    RISCV_SH1ADD => 0b01,\\n    RISCV_SH2ADD => 0b10,\\n    RISCV_SH3ADD => 0b11\\n  };\\n  let result : xlenbits = (rs1_val << shamt) + rs2_val;\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sh2add.uw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"bropw_zba"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zba"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let shamt : bits(2) = match op {\\n    RISCV_ADDUW    => 0b00,\\n    RISCV_SH1ADDUW => 0b01,\\n    RISCV_SH2ADDUW => 0b10,\\n    RISCV_SH3ADDUW => 0b11\\n  };\\n  let result : xlenbits = (zero_extend(rs1_val[31..0]) << shamt) + rs2_val;\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sh3add","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zba"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zba"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let shamt : bits(2) = match op {\\n    RISCV_SH1ADD => 0b01,\\n    RISCV_SH2ADD => 0b10,\\n    RISCV_SH3ADD => 0b11\\n  };\\n  let result : xlenbits = (rs1_val << shamt) + rs2_val;\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sh3add.uw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"bropw_zba"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zba"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let shamt : bits(2) = match op {\\n    RISCV_ADDUW    => 0b00,\\n    RISCV_SH1ADDUW => 0b01,\\n    RISCV_SH2ADDUW => 0b10,\\n    RISCV_SH3ADDUW => 0b11\\n  };\\n  let result : xlenbits = (zero_extend(rs1_val[31..0]) << shamt) + rs2_val;\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sha256sig0","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b00010","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknh"],"function":"{\\n  let inb    : bits(32) = X(rs1)[31..0];\\n  let result : bits(32) = (inb >>> 7) ^ (inb >>> 18) ^ (inb >>  3);\\n  X(rd)      = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sha256sig1","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b00011","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknh"],"function":"{\\n  let inb    : bits(32) = X(rs1)[31..0];\\n  let result : bits(32) = (inb >>> 17) ^ (inb >>> 19) ^ (inb >> 10);\\n  X(rd)      = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sha256sum0","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknh"],"function":"{\\n  let inb    : bits(32) = X(rs1)[31..0];\\n  let result : bits(32) = (inb >>> 2) ^ (inb >>> 13) ^ (inb >>> 22);\\n  X(rd)      = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sha256sum1","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b00001","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknh"],"function":"{\\n  let inb    : bits(32) = X(rs1)[31..0];\\n  let result : bits(32) = (inb >>> 6) ^ (inb >>> 11) ^ (inb >>> 25);\\n  X(rd)      = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sha512sig0","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b00110","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknh"],"function":"{\\n  assert(sizeof(xlen) == 64);\\n  let input  : bits(64) = X(rs1);\\n  let result : bits(64) = (input >>>  1) ^ (input >>>  8) ^ (input >> 7);\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sha512sig0h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b01","size":2},{"field":"0b01110","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknh"],"function":"{\\n  X(rd) = sign_extend((X(rs1) >>  1) ^ (X(rs1) >>  7) ^ (X(rs1) >>  8) ^\\n               (X(rs2) << 31)                  ^ (X(rs2) << 24));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sha512sig0l","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b01","size":2},{"field":"0b01010","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknh"],"function":"{\\n  X(rd) = sign_extend((X(rs1) >>  1) ^ (X(rs1) >>  7) ^ (X(rs1) >>  8) ^\\n               (X(rs2) << 31) ^ (X(rs2) << 25) ^ (X(rs2) << 24));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sha512sig1","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b00111","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknh"],"function":"{\\n  assert(sizeof(xlen) == 64);\\n  let input  : bits(64) = X(rs1);\\n  let result : bits(64) = (input >>> 19) ^ (input >>> 61) ^ (input >> 6);\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sha512sig1h","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b01","size":2},{"field":"0b01111","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknh"],"function":"{\\n  X(rd) = sign_extend((X(rs1) <<  3) ^ (X(rs1) >>  6) ^ (X(rs1) >> 19) ^\\n               (X(rs2) >> 29)                  ^ (X(rs2) << 13));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sha512sig1l","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b01","size":2},{"field":"0b01011","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknh"],"function":"{\\n  X(rd) = sign_extend((X(rs1) <<  3) ^ (X(rs1) >>  6) ^ (X(rs1) >> 19) ^\\n               (X(rs2) >> 29) ^ (X(rs2) << 26) ^ (X(rs2) << 13));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sha512sum0","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b00100","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknh"],"function":"{\\n  assert(sizeof(xlen) == 64);\\n  let input  : bits(64) = X(rs1);\\n  let result : bits(64) = (input >>> 28) ^ (input >>> 34) ^ (input >>> 39);\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sha512sum0r","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b01","size":2},{"field":"0b01000","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknh"],"function":"{\\n  X(rd) = sign_extend((X(rs1) << 25) ^ (X(rs1) << 30) ^ (X(rs1) >> 28) ^\\n               (X(rs2) >>  7) ^ (X(rs2) >>  2) ^ (X(rs2) <<  4));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sha512sum1","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b00101","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zknh"],"function":"{\\n  assert(sizeof(xlen) == 64);\\n  let input  : bits(64) = X(rs1);\\n  let result : bits(64) = (input >>> 14) ^ (input >>> 18) ^ (input >>> 41);\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sha512sum1r","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b01","size":2},{"field":"0b01001","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zknh"],"function":"{\\n  X(rd) = sign_extend((X(rs1) << 23) ^ (X(rs1) >> 14) ^ (X(rs1) >> 18) ^\\n               (X(rs2) >>  9) ^ (X(rs2) << 18) ^ (X(rs2) << 14));\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sll","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"rop"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ADD  => rs1_val + rs2_val,\\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\\n    RISCV_AND  => rs1_val & rs2_val,\\n    RISCV_OR   => rs1_val | rs2_val,\\n    RISCV_XOR  => rs1_val ^ rs2_val,\\n    RISCV_SLL  => if   sizeof(xlen) == 32\\n                  then rs1_val << (rs2_val[4..0])\\n                  else rs1_val << (rs2_val[5..0]),\\n    RISCV_SRL  => if   sizeof(xlen) == 32\\n                  then rs1_val >> (rs2_val[4..0])\\n                  else rs1_val >> (rs2_val[5..0]),\\n    RISCV_SUB  => rs1_val - rs2_val,\\n    RISCV_SRA  => if   sizeof(xlen) == 32\\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe R-type (Register-type) instruction format is used for operations\\nthat involve three registers. The specific operation is determined\\nby the opcode and funct7 fields. The result is written to the\\ndestination register (rd), and the source operands are specified\\nby the source registers (rs1 and rs2). The format is common for\\narithmetic, logical, and shift operations.\\n "},{"mnemonic":"slli","name":"Shift Immediate","operands":[{"name":"shamt","type":"bits(6)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"sop"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  /* the decoder guard should ensure that shamt[5] = 0 for RV32 */\\n  let result : xlenbits = match op {\\n    RISCV_SLLI => if   sizeof(xlen) == 32\\n                  then rs1_val << shamt[4..0]\\n                  else rs1_val << shamt,\\n    RISCV_SRLI => if   sizeof(xlen) == 32\\n                  then rs1_val >> shamt[4..0]\\n                  else rs1_val >> shamt,\\n    RISCV_SRAI => if   sizeof(xlen) == 32\\n                  then shift_right_arith32(rs1_val, shamt[4..0])\\n                  else shift_right_arith64(rs1_val, shamt)\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe SHIFTIOP (Shift Immediate Operation) instruction format is used for\\noperations that involve shifting the bits of a register by an immediate\\nvalue. The specific operation is determined by the opcode field, and the\\nshift amount is specified by the immediate value (shamt). The result is\\nwritten to the destination register (rd), and the source operand is the\\nregister specified by rs1. The format is common for shift-left logical\\nimmediate (SLLI), shift-right logical immediate (SRLI), and shift-right\\narithmetic immediate (SRAI) operations.\\n *\\nNote: For RV32, the decoder ensures that shamt[5] = 0.\\n "},{"mnemonic":"slli.uw","name":"TBD","operands":[{"name":"shamt","type":"bits(6)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b000010","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":["Zba"],"function":"{\\n  let rs1_val = X(rs1);\\n  let result : xlenbits = zero_extend(rs1_val[31..0]) << shamt;\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"slliw","name":"Shift Immediate Word","operands":[{"name":"shamt","type":"bits(5)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"sopw"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"shamt","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = (X(rs1))[31..0];\\n  let result : bits(32) = match op {\\n    RISCV_SLLIW => rs1_val << shamt,\\n    RISCV_SRLIW => rs1_val >> shamt,\\n    RISCV_SRAIW => shift_right_arith32(rs1_val, shamt)\\n  };\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"\\nThe SHIFTIWOP instruction set deals with\\nimmediate shift operations on 32-bit values, with the result sign-extended\\nto 64 bits. The available operations include SLLIW (left shift logical\\nimmediate word), SRLIW (right shift logical immediate word), and SRAIW\\n(right shift arithmetic immediate word). These operations are applicable\\nwhen the target architecture has a width of 64 bits.\\n "},{"mnemonic":"sllw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"ropw"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = (X(rs1))[31..0];\\n  let rs2_val = (X(rs2))[31..0];\\n  let result : bits(32) = match op {\\n    RISCV_ADDW => rs1_val + rs2_val,\\n    RISCV_SUBW => rs1_val - rs2_val,\\n    RISCV_SLLW => rs1_val << (rs2_val[4..0]),\\n    RISCV_SRLW => rs1_val >> (rs2_val[4..0]),\\n    RISCV_SRAW => shift_right_arith32(rs1_val, rs2_val[4..0])\\n  };\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"\\nThe RTYPEW instruction set operates on 32-bit values,\\nand the result is sign-extended to 64 bits. The available operations are\\nADDW (addition), SUBW (subtraction), SLLW (logical left shift),\\nSRLW (logical right shift), and SRAW (arithmetic right shift).\\nThese operations are only applicable when the width of the target\\narchitecture is 64 bits.\\n "},{"mnemonic":"slt","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"rop"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ADD  => rs1_val + rs2_val,\\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\\n    RISCV_AND  => rs1_val & rs2_val,\\n    RISCV_OR   => rs1_val | rs2_val,\\n    RISCV_XOR  => rs1_val ^ rs2_val,\\n    RISCV_SLL  => if   sizeof(xlen) == 32\\n                  then rs1_val << (rs2_val[4..0])\\n                  else rs1_val << (rs2_val[5..0]),\\n    RISCV_SRL  => if   sizeof(xlen) == 32\\n                  then rs1_val >> (rs2_val[4..0])\\n                  else rs1_val >> (rs2_val[5..0]),\\n    RISCV_SUB  => rs1_val - rs2_val,\\n    RISCV_SRA  => if   sizeof(xlen) == 32\\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe R-type (Register-type) instruction format is used for operations\\nthat involve three registers. The specific operation is determined\\nby the opcode and funct7 fields. The result is written to the\\ndestination register (rd), and the source operands are specified\\nby the source registers (rs1 and rs2). The format is common for\\narithmetic, logical, and shift operations.\\n "},{"mnemonic":"slti","name":"TBD","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"iop"}],"syntax":"rd,rs1,imm","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"encdec_iop(op)","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let immext : xlenbits = sign_extend(imm);\\n  let result : xlenbits = match op {\\n    RISCV_ADDI  => rs1_val + immext,\\n    RISCV_SLTI  => zero_extend(bool_to_bits(rs1_val <_s immext)),\\n    RISCV_SLTIU => zero_extend(bool_to_bits(rs1_val <_u immext)),\\n    RISCV_ANDI  => rs1_val & immext,\\n    RISCV_ORI   => rs1_val | immext,\\n    RISCV_XORI  => rs1_val ^ immext\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe ITYPE instruction operates on an immediate value, adding, comparing, or\\nperforming bitwise operations with the contents of register rs1.\\nThe immediate value, rs1, and the operation code (iop) determine the operation.\\nThe result is stored in register rd.\\nThe supported immediate operations (iop) include:\\n  - \\"addi\\"  : Add immediate\\n  - \\"slti\\"  : Set less than immediate (signed)\\n  - \\"sltiu\\" : Set less than immediate (unsigned)\\n  - \\"andi\\"  : AND immediate\\n  - \\"ori\\"   : OR immediate\\n  - \\"xori\\"  : XOR immediate\\n *\\nNote: The immediate value is sign-extended before performing the operation.\\n "},{"mnemonic":"sltiu","name":"TBD","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"iop"}],"syntax":"rd,rs1,imm","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"encdec_iop(op)","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let immext : xlenbits = sign_extend(imm);\\n  let result : xlenbits = match op {\\n    RISCV_ADDI  => rs1_val + immext,\\n    RISCV_SLTI  => zero_extend(bool_to_bits(rs1_val <_s immext)),\\n    RISCV_SLTIU => zero_extend(bool_to_bits(rs1_val <_u immext)),\\n    RISCV_ANDI  => rs1_val & immext,\\n    RISCV_ORI   => rs1_val | immext,\\n    RISCV_XORI  => rs1_val ^ immext\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe ITYPE instruction operates on an immediate value, adding, comparing, or\\nperforming bitwise operations with the contents of register rs1.\\nThe immediate value, rs1, and the operation code (iop) determine the operation.\\nThe result is stored in register rd.\\nThe supported immediate operations (iop) include:\\n  - \\"addi\\"  : Add immediate\\n  - \\"slti\\"  : Set less than immediate (signed)\\n  - \\"sltiu\\" : Set less than immediate (unsigned)\\n  - \\"andi\\"  : AND immediate\\n  - \\"ori\\"   : OR immediate\\n  - \\"xori\\"  : XOR immediate\\n *\\nNote: The immediate value is sign-extended before performing the operation.\\n "},{"mnemonic":"sltu","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"rop"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ADD  => rs1_val + rs2_val,\\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\\n    RISCV_AND  => rs1_val & rs2_val,\\n    RISCV_OR   => rs1_val | rs2_val,\\n    RISCV_XOR  => rs1_val ^ rs2_val,\\n    RISCV_SLL  => if   sizeof(xlen) == 32\\n                  then rs1_val << (rs2_val[4..0])\\n                  else rs1_val << (rs2_val[5..0]),\\n    RISCV_SRL  => if   sizeof(xlen) == 32\\n                  then rs1_val >> (rs2_val[4..0])\\n                  else rs1_val >> (rs2_val[5..0]),\\n    RISCV_SUB  => rs1_val - rs2_val,\\n    RISCV_SRA  => if   sizeof(xlen) == 32\\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe R-type (Register-type) instruction format is used for operations\\nthat involve three registers. The specific operation is determined\\nby the opcode and funct7 fields. The result is written to the\\ndestination register (rd), and the source operands are specified\\nby the source registers (rs1 and rs2). The format is common for\\narithmetic, logical, and shift operations.\\n "},{"mnemonic":"sm3p0","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zksh"],"function":"{\\n  let r1     : bits(32) = X(rs1)[31..0];\\n  let result : bits(32) =  r1 ^ (r1 <<< 9) ^ (r1 <<< 17);\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sm3p1","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b00","size":2},{"field":"0b01000","size":5},{"field":"0b01001","size":5},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zksh"],"function":"{\\n  let r1     : bits(32) = X(rs1)[31..0];\\n  let result : bits(32) =  r1 ^ (r1 <<< 15) ^ (r1 <<< 23);\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sm4ed","name":"TBD","operands":[{"name":"bs","type":"bits(2)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2,bs","format":"TBD","fields":[{"field":"bs","size":2},{"field":"0b11000","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zksed"],"function":"{\\n  let shamt : bits(5)  = bs @ 0b000; /* shamt = bs*8 */\\n  let sb_in : bits(8)  = (X(rs2)[31..0] >> shamt)[7..0];\\n  let x     : bits(32) = 0x000000 @ sm4_sbox(sb_in);\\n  let y     : bits(32) = x ^ (x               <<  8) ^ ( x               <<  2) ^\\n                             (x               << 18) ^ ((x & 0x0000003F) << 26) ^\\n                             ((x & 0x000000C0) << 10);\\n  let z     : bits(32) = (y <<< shamt);\\n  let result : bits(32) = z ^ X(rs1)[31..0];\\n  X(rd)                = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sm4ks","name":"TBD","operands":[{"name":"bs","type":"bits(2)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2,bs","format":"TBD","fields":[{"field":"bs","size":2},{"field":"0b11010","size":5},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zksed"],"function":"{\\n  let shamt : bits(5)  = (bs @ 0b000); /* shamt = bs*8 */\\n  let sb_in : bits(8)  = (X(rs2)[31..0] >> shamt)[7..0];\\n  let x     : bits(32) = 0x000000 @ sm4_sbox(sb_in);\\n  let y     : bits(32) = x ^ ((x & 0x00000007) << 29) ^ ((x & 0x000000FE) <<  7) ^\\n                             ((x & 0x00000001) << 23) ^ ((x & 0x000000F8) << 13) ;\\n  let z     : bits(32) = (y <<< shamt);\\n  let result : bits(32) = z ^ X(rs1)[31..0];\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"sra","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"rop"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ADD  => rs1_val + rs2_val,\\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\\n    RISCV_AND  => rs1_val & rs2_val,\\n    RISCV_OR   => rs1_val | rs2_val,\\n    RISCV_XOR  => rs1_val ^ rs2_val,\\n    RISCV_SLL  => if   sizeof(xlen) == 32\\n                  then rs1_val << (rs2_val[4..0])\\n                  else rs1_val << (rs2_val[5..0]),\\n    RISCV_SRL  => if   sizeof(xlen) == 32\\n                  then rs1_val >> (rs2_val[4..0])\\n                  else rs1_val >> (rs2_val[5..0]),\\n    RISCV_SUB  => rs1_val - rs2_val,\\n    RISCV_SRA  => if   sizeof(xlen) == 32\\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe R-type (Register-type) instruction format is used for operations\\nthat involve three registers. The specific operation is determined\\nby the opcode and funct7 fields. The result is written to the\\ndestination register (rd), and the source operands are specified\\nby the source registers (rs1 and rs2). The format is common for\\narithmetic, logical, and shift operations.\\n "},{"mnemonic":"srai","name":"Shift Immediate","operands":[{"name":"shamt","type":"bits(6)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"sop"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  /* the decoder guard should ensure that shamt[5] = 0 for RV32 */\\n  let result : xlenbits = match op {\\n    RISCV_SLLI => if   sizeof(xlen) == 32\\n                  then rs1_val << shamt[4..0]\\n                  else rs1_val << shamt,\\n    RISCV_SRLI => if   sizeof(xlen) == 32\\n                  then rs1_val >> shamt[4..0]\\n                  else rs1_val >> shamt,\\n    RISCV_SRAI => if   sizeof(xlen) == 32\\n                  then shift_right_arith32(rs1_val, shamt[4..0])\\n                  else shift_right_arith64(rs1_val, shamt)\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe SHIFTIOP (Shift Immediate Operation) instruction format is used for\\noperations that involve shifting the bits of a register by an immediate\\nvalue. The specific operation is determined by the opcode field, and the\\nshift amount is specified by the immediate value (shamt). The result is\\nwritten to the destination register (rd), and the source operand is the\\nregister specified by rs1. The format is common for shift-left logical\\nimmediate (SLLI), shift-right logical immediate (SRLI), and shift-right\\narithmetic immediate (SRAI) operations.\\n *\\nNote: For RV32, the decoder ensures that shamt[5] = 0.\\n "},{"mnemonic":"sraiw","name":"Shift Immediate Word","operands":[{"name":"shamt","type":"bits(5)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"sopw"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"shamt","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = (X(rs1))[31..0];\\n  let result : bits(32) = match op {\\n    RISCV_SLLIW => rs1_val << shamt,\\n    RISCV_SRLIW => rs1_val >> shamt,\\n    RISCV_SRAIW => shift_right_arith32(rs1_val, shamt)\\n  };\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"\\nThe SHIFTIWOP instruction set deals with\\nimmediate shift operations on 32-bit values, with the result sign-extended\\nto 64 bits. The available operations include SLLIW (left shift logical\\nimmediate word), SRLIW (right shift logical immediate word), and SRAIW\\n(right shift arithmetic immediate word). These operations are applicable\\nwhen the target architecture has a width of 64 bits.\\n "},{"mnemonic":"sraw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"ropw"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = (X(rs1))[31..0];\\n  let rs2_val = (X(rs2))[31..0];\\n  let result : bits(32) = match op {\\n    RISCV_ADDW => rs1_val + rs2_val,\\n    RISCV_SUBW => rs1_val - rs2_val,\\n    RISCV_SLLW => rs1_val << (rs2_val[4..0]),\\n    RISCV_SRLW => rs1_val >> (rs2_val[4..0]),\\n    RISCV_SRAW => shift_right_arith32(rs1_val, rs2_val[4..0])\\n  };\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"\\nThe RTYPEW instruction set operates on 32-bit values,\\nand the result is sign-extended to 64 bits. The available operations are\\nADDW (addition), SUBW (subtraction), SLLW (logical left shift),\\nSRLW (logical right shift), and SRAW (arithmetic right shift).\\nThese operations are only applicable when the width of the target\\narchitecture is 64 bits.\\n "},{"mnemonic":"sret","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b0001000","size":7},{"field":"0b00010","size":5},{"field":"0b00000","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{\\n  let sret_illegal : bool = match cur_privilege {\\n    User       => true,\\n    Supervisor => not(haveSupMode ()) | mstatus.TSR() == 0b1,\\n    Machine    => not(haveSupMode ())\\n  };\\n  if   sret_illegal\\n  then { handle_illegal(); RETIRE_FAIL }\\n  else if not(ext_check_xret_priv (Supervisor))\\n  then { ext_fail_xret_priv(); RETIRE_FAIL }\\n  else {\\n    set_next_pc(exception_handler(cur_privilege, CTL_SRET(), PC));\\n    RETIRE_SUCCESS\\n  }\\n}","description":"TBD"},{"mnemonic":"srl","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"rop"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ADD  => rs1_val + rs2_val,\\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\\n    RISCV_AND  => rs1_val & rs2_val,\\n    RISCV_OR   => rs1_val | rs2_val,\\n    RISCV_XOR  => rs1_val ^ rs2_val,\\n    RISCV_SLL  => if   sizeof(xlen) == 32\\n                  then rs1_val << (rs2_val[4..0])\\n                  else rs1_val << (rs2_val[5..0]),\\n    RISCV_SRL  => if   sizeof(xlen) == 32\\n                  then rs1_val >> (rs2_val[4..0])\\n                  else rs1_val >> (rs2_val[5..0]),\\n    RISCV_SUB  => rs1_val - rs2_val,\\n    RISCV_SRA  => if   sizeof(xlen) == 32\\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe R-type (Register-type) instruction format is used for operations\\nthat involve three registers. The specific operation is determined\\nby the opcode and funct7 fields. The result is written to the\\ndestination register (rd), and the source operands are specified\\nby the source registers (rs1 and rs2). The format is common for\\narithmetic, logical, and shift operations.\\n "},{"mnemonic":"srli","name":"Shift Immediate","operands":[{"name":"shamt","type":"bits(6)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"sop"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"shamt","size":6},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  /* the decoder guard should ensure that shamt[5] = 0 for RV32 */\\n  let result : xlenbits = match op {\\n    RISCV_SLLI => if   sizeof(xlen) == 32\\n                  then rs1_val << shamt[4..0]\\n                  else rs1_val << shamt,\\n    RISCV_SRLI => if   sizeof(xlen) == 32\\n                  then rs1_val >> shamt[4..0]\\n                  else rs1_val >> shamt,\\n    RISCV_SRAI => if   sizeof(xlen) == 32\\n                  then shift_right_arith32(rs1_val, shamt[4..0])\\n                  else shift_right_arith64(rs1_val, shamt)\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe SHIFTIOP (Shift Immediate Operation) instruction format is used for\\noperations that involve shifting the bits of a register by an immediate\\nvalue. The specific operation is determined by the opcode field, and the\\nshift amount is specified by the immediate value (shamt). The result is\\nwritten to the destination register (rd), and the source operand is the\\nregister specified by rs1. The format is common for shift-left logical\\nimmediate (SLLI), shift-right logical immediate (SRLI), and shift-right\\narithmetic immediate (SRAI) operations.\\n *\\nNote: For RV32, the decoder ensures that shamt[5] = 0.\\n "},{"mnemonic":"srliw","name":"Shift Immediate Word","operands":[{"name":"shamt","type":"bits(5)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"sopw"}],"syntax":"rd,rs1,shamt","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"shamt","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0011011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = (X(rs1))[31..0];\\n  let result : bits(32) = match op {\\n    RISCV_SLLIW => rs1_val << shamt,\\n    RISCV_SRLIW => rs1_val >> shamt,\\n    RISCV_SRAIW => shift_right_arith32(rs1_val, shamt)\\n  };\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"\\nThe SHIFTIWOP instruction set deals with\\nimmediate shift operations on 32-bit values, with the result sign-extended\\nto 64 bits. The available operations include SLLIW (left shift logical\\nimmediate word), SRLIW (right shift logical immediate word), and SRAIW\\n(right shift arithmetic immediate word). These operations are applicable\\nwhen the target architecture has a width of 64 bits.\\n "},{"mnemonic":"srlw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"ropw"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = (X(rs1))[31..0];\\n  let rs2_val = (X(rs2))[31..0];\\n  let result : bits(32) = match op {\\n    RISCV_ADDW => rs1_val + rs2_val,\\n    RISCV_SUBW => rs1_val - rs2_val,\\n    RISCV_SLLW => rs1_val << (rs2_val[4..0]),\\n    RISCV_SRLW => rs1_val >> (rs2_val[4..0]),\\n    RISCV_SRAW => shift_right_arith32(rs1_val, rs2_val[4..0])\\n  };\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"\\nThe RTYPEW instruction set operates on 32-bit values,\\nand the result is sign-extended to 64 bits. The available operations are\\nADDW (addition), SUBW (subtraction), SLLW (logical left shift),\\nSRLW (logical right shift), and SRAW (arithmetic right shift).\\nThese operations are only applicable when the width of the target\\narchitecture is 64 bits.\\n "},{"mnemonic":"sub","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"rop"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ADD  => rs1_val + rs2_val,\\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\\n    RISCV_AND  => rs1_val & rs2_val,\\n    RISCV_OR   => rs1_val | rs2_val,\\n    RISCV_XOR  => rs1_val ^ rs2_val,\\n    RISCV_SLL  => if   sizeof(xlen) == 32\\n                  then rs1_val << (rs2_val[4..0])\\n                  else rs1_val << (rs2_val[5..0]),\\n    RISCV_SRL  => if   sizeof(xlen) == 32\\n                  then rs1_val >> (rs2_val[4..0])\\n                  else rs1_val >> (rs2_val[5..0]),\\n    RISCV_SUB  => rs1_val - rs2_val,\\n    RISCV_SRA  => if   sizeof(xlen) == 32\\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe R-type (Register-type) instruction format is used for operations\\nthat involve three registers. The specific operation is determined\\nby the opcode and funct7 fields. The result is written to the\\ndestination register (rd), and the source operands are specified\\nby the source registers (rs1 and rs2). The format is common for\\narithmetic, logical, and shift operations.\\n "},{"mnemonic":"subw","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"ropw"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = (X(rs1))[31..0];\\n  let rs2_val = (X(rs2))[31..0];\\n  let result : bits(32) = match op {\\n    RISCV_ADDW => rs1_val + rs2_val,\\n    RISCV_SUBW => rs1_val - rs2_val,\\n    RISCV_SLLW => rs1_val << (rs2_val[4..0]),\\n    RISCV_SRLW => rs1_val >> (rs2_val[4..0]),\\n    RISCV_SRAW => shift_right_arith32(rs1_val, rs2_val[4..0])\\n  };\\n  X(rd) = sign_extend(result);\\n  RETIRE_SUCCESS\\n}","description":"\\nThe RTYPEW instruction set operates on 32-bit values,\\nand the result is sign-extended to 64 bits. The available operations are\\nADDW (addition), SUBW (subtraction), SLLW (logical left shift),\\nSRLW (logical right shift), and SRAW (arithmetic right shift).\\nThese operations are only applicable when the width of the target\\narchitecture is 64 bits.\\n "},{"mnemonic":"sw","name":"Store","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => mem_write_ea(paddr, 1, aq, rl, false),\\n            HALF   => mem_write_ea(paddr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(paddr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(paddr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = X(rs2);\\n              let res : MemoryOpResult(bool) = match (width) {\\n                BYTE => mem_write_value(paddr, 1, rs2_val[7..0],  aq, rl, false),\\n                HALF => mem_write_value(paddr, 2, rs2_val[15..0], aq, rl, false),\\n                WORD => mem_write_value(paddr, 4, rs2_val[31..0], aq, rl, false),\\n                DOUBLE if sizeof(xlen) >= 64\\n                     => mem_write_value(paddr, 8, rs2_val,        aq, rl, false),\\n                _    => report_invalid_width(__FILE__, __LINE__, width, \\"store\\"),\\n              };\\n              match (res) {\\n                MemValue(true)  => RETIRE_SUCCESS,\\n                MemValue(false) => internal_error(__FILE__, __LINE__, \\"store got false from mem_write_value\\"),\\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n              }\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"\\nThe STORE instruction format is used for storing data from a register into\\nmemory. The specific operation is determined by the word width (size) and\\nmemory ordering semantics (acquire, release). The memory address is computed\\nby adding the immediate offset (imm) to the value in register rs1, and the\\ndata is taken from register rs2.\\n "},{"mnemonic":"sw.aq","name":"Store","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => mem_write_ea(paddr, 1, aq, rl, false),\\n            HALF   => mem_write_ea(paddr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(paddr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(paddr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = X(rs2);\\n              let res : MemoryOpResult(bool) = match (width) {\\n                BYTE => mem_write_value(paddr, 1, rs2_val[7..0],  aq, rl, false),\\n                HALF => mem_write_value(paddr, 2, rs2_val[15..0], aq, rl, false),\\n                WORD => mem_write_value(paddr, 4, rs2_val[31..0], aq, rl, false),\\n                DOUBLE if sizeof(xlen) >= 64\\n                     => mem_write_value(paddr, 8, rs2_val,        aq, rl, false),\\n                _    => report_invalid_width(__FILE__, __LINE__, width, \\"store\\"),\\n              };\\n              match (res) {\\n                MemValue(true)  => RETIRE_SUCCESS,\\n                MemValue(false) => internal_error(__FILE__, __LINE__, \\"store got false from mem_write_value\\"),\\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n              }\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"\\nThe STORE instruction format is used for storing data from a register into\\nmemory. The specific operation is determined by the word width (size) and\\nmemory ordering semantics (acquire, release). The memory address is computed\\nby adding the immediate offset (imm) to the value in register rs1, and the\\ndata is taken from register rs2.\\n "},{"mnemonic":"sw.aq.rl","name":"Store","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => mem_write_ea(paddr, 1, aq, rl, false),\\n            HALF   => mem_write_ea(paddr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(paddr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(paddr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = X(rs2);\\n              let res : MemoryOpResult(bool) = match (width) {\\n                BYTE => mem_write_value(paddr, 1, rs2_val[7..0],  aq, rl, false),\\n                HALF => mem_write_value(paddr, 2, rs2_val[15..0], aq, rl, false),\\n                WORD => mem_write_value(paddr, 4, rs2_val[31..0], aq, rl, false),\\n                DOUBLE if sizeof(xlen) >= 64\\n                     => mem_write_value(paddr, 8, rs2_val,        aq, rl, false),\\n                _    => report_invalid_width(__FILE__, __LINE__, width, \\"store\\"),\\n              };\\n              match (res) {\\n                MemValue(true)  => RETIRE_SUCCESS,\\n                MemValue(false) => internal_error(__FILE__, __LINE__, \\"store got false from mem_write_value\\"),\\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n              }\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"\\nThe STORE instruction format is used for storing data from a register into\\nmemory. The specific operation is determined by the word width (size) and\\nmemory ordering semantics (acquire, release). The memory address is computed\\nby adding the immediate offset (imm) to the value in register rs1, and the\\ndata is taken from register rs2.\\n "},{"mnemonic":"sw.rl","name":"Store","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"word_width"},{"name":"aq","type":"bool"},{"name":"rl","type":"bool"}],"syntax":"rs2,imm(rs1)","format":"TBD","fields":[{"field":"imm7","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b0","size":1},{"field":"size_bits(size)","size":2},{"field":"imm5","size":1},{"field":"0b0100011","size":7}],"extensions":[],"function":"{\\n  let offset : xlenbits = sign_extend(imm);\\n  /* Get the address, X(rs1) + offset.\\n     Some extensions perform additional checks on address validity. */\\n  match ext_data_get_addr(rs1, offset, Write(Data), width) {\\n    Ext_DataAddr_Error(e)  => { ext_handle_data_check_error(e); RETIRE_FAIL },\\n    Ext_DataAddr_OK(vaddr) =>\\n      if   check_misaligned(vaddr, width)\\n      then { handle_mem_exception(vaddr, E_SAMO_Addr_Align()); RETIRE_FAIL }\\n      else match translateAddr(vaddr, Write(Data)) {\\n        TR_Failure(e, _)    => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n        TR_Address(paddr, _) => {\\n          let eares : MemoryOpResult(unit) = match width {\\n            BYTE   => mem_write_ea(paddr, 1, aq, rl, false),\\n            HALF   => mem_write_ea(paddr, 2, aq, rl, false),\\n            WORD   => mem_write_ea(paddr, 4, aq, rl, false),\\n            DOUBLE => mem_write_ea(paddr, 8, aq, rl, false)\\n          };\\n          match (eares) {\\n            MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL },\\n            MemValue(_) => {\\n              let rs2_val = X(rs2);\\n              let res : MemoryOpResult(bool) = match (width) {\\n                BYTE => mem_write_value(paddr, 1, rs2_val[7..0],  aq, rl, false),\\n                HALF => mem_write_value(paddr, 2, rs2_val[15..0], aq, rl, false),\\n                WORD => mem_write_value(paddr, 4, rs2_val[31..0], aq, rl, false),\\n                DOUBLE if sizeof(xlen) >= 64\\n                     => mem_write_value(paddr, 8, rs2_val,        aq, rl, false),\\n                _    => report_invalid_width(__FILE__, __LINE__, width, \\"store\\"),\\n              };\\n              match (res) {\\n                MemValue(true)  => RETIRE_SUCCESS,\\n                MemValue(false) => internal_error(__FILE__, __LINE__, \\"store got false from mem_write_value\\"),\\n                MemException(e) => { handle_mem_exception(vaddr, e); RETIRE_FAIL }\\n              }\\n            }\\n          }\\n        }\\n      }\\n  }\\n}","description":"\\nThe STORE instruction format is used for storing data from a register into\\nmemory. The specific operation is determined by the word width (size) and\\nmemory ordering semantics (acquire, release). The memory address is computed\\nby adding the immediate offset (imm) to the value in register rs1, and the\\ndata is taken from register rs2.\\n "},{"mnemonic":"unzip","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b000010001111","size":12},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbkb"],"function":"{\\n  assert(sizeof(xlen) == 32);\\n  let rs1_val = X(rs1);\\n  result : xlenbits = zeros();\\n  foreach (i from 0 to (sizeof(xlen_bytes)*4 - 1)) {\\n    result[i] = rs1_val[i*2];\\n    result[i + sizeof(xlen_bytes)*4] = rs1_val[i*2 + 1];\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"uret","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b0000000","size":7},{"field":"0b00010","size":5},{"field":"0b00000","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"{\\n  if   not(haveUsrMode()) | not(sys_enable_next())\\n  then handle_illegal()\\n  else if not(ext_check_xret_priv(User))\\n  then ext_fail_xret_priv()\\n  else set_next_pc(exception_handler(cur_privilege, CTL_URET(), PC));\\n  RETIRE_FAIL\\n}","description":"TBD"},{"mnemonic":"vaadd.vv","name":"TBD","operands":[{"name":"funct6","type":"mvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVV_VAADDU   => {\\n                          let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VAADD    => {\\n                          let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUBU   => {\\n                          let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUB    => {\\n                          let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VDIVU    => {\\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          to_bits(SEW, q)\\n                        },\\n        MVV_VDIV     => {\\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* check for signed overflow */\\n                          let q\' : int = if q > elem_max then elem_min else q;\\n                          to_bits(SEW, q\')\\n                        },\\n        MVV_VREMU    => {\\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        },\\n        MVV_VREM     => {\\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vaadd.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VAADDU       => {\\n                              let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VAADD        => {\\n                              let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUBU       => {\\n                              let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUB        => {\\n                              let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VSLIDE1UP    => {\\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        MVX_VSLIDE1DOWN  => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            },\\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VDIVU        => {\\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\\n                              to_bits(SEW, q)\\n                            },\\n        MVX_VDIV         => {\\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* check for signed overflow */\\n                              let q\' : int = if q > elem_max then elem_min else q;\\n                              to_bits(SEW, q\')\\n                            },\\n        MVX_VREMU        => {\\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            },\\n        MVX_VREM         => {\\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vaaddu.vv","name":"TBD","operands":[{"name":"funct6","type":"mvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVV_VAADDU   => {\\n                          let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VAADD    => {\\n                          let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUBU   => {\\n                          let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUB    => {\\n                          let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VDIVU    => {\\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          to_bits(SEW, q)\\n                        },\\n        MVV_VDIV     => {\\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* check for signed overflow */\\n                          let q\' : int = if q > elem_max then elem_min else q;\\n                          to_bits(SEW, q\')\\n                        },\\n        MVV_VREMU    => {\\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        },\\n        MVV_VREM     => {\\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vaaddu.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VAADDU       => {\\n                              let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VAADD        => {\\n                              let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUBU       => {\\n                              let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUB        => {\\n                              let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VSLIDE1UP    => {\\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        MVX_VSLIDE1DOWN  => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            },\\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VDIVU        => {\\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\\n                              to_bits(SEW, q)\\n                            },\\n        MVX_VDIV         => {\\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* check for signed overflow */\\n                              let q\' : int = if q > elem_max then elem_min else q;\\n                              to_bits(SEW, q\')\\n                            },\\n        MVX_VREMU        => {\\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            },\\n        MVX_VREM         => {\\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vadc.vim","name":"TBD","operands":[{"name":"funct6","type":"vimsfunct6"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simm,v0","format":"TBD","fields":[{"field":"encdec_vimsfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  /* for bypassing normal masking in init_masked_result */\\n  vec_trues : vector(\'n, dec, bool) = undefined;\\n  foreach (i from 0 to (num_elem - 1)) {\\n    vec_trues[i] = true\\n  };\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VIMS_VADC     => to_bits(SEW, unsigned(vs2_val[i]) + unsigned(imm_val) + unsigned(bool_to_bits(vm_val[i])))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vadc.vvm","name":"TBD","operands":[{"name":"funct6","type":"vvmsfunct6"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1,v0","format":"TBD","fields":[{"field":"encdec_vvmsfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  /* for bypassing normal masking in init_masked_result */\\n  vec_trues : vector(\'n, dec, bool) = undefined;\\n  foreach (i from 0 to (num_elem - 1)) {\\n    vec_trues[i] = true\\n  };\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VVMS_VADC     => to_bits(SEW, unsigned(vs2_val[i]) + unsigned(vs1_val[i]) + unsigned(bool_to_bits(vm_val[i]))),\\n        VVMS_VSBC     => to_bits(SEW, unsigned(vs2_val[i]) - unsigned(vs1_val[i]) - unsigned(bool_to_bits(vm_val[i])))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vadc.vxm","name":"TBD","operands":[{"name":"funct6","type":"vxmsfunct6"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1,v0","format":"TBD","fields":[{"field":"encdec_vxmsfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  /* for bypassing normal masking in init_masked_result */\\n  vec_trues : vector(\'n, dec, bool) = undefined;\\n  foreach (i from 0 to (num_elem - 1)) {\\n    vec_trues[i] = true\\n  };\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VXMS_VADC     => to_bits(SEW, unsigned(vs2_val[i]) + unsigned(rs1_val) + unsigned(bool_to_bits(vm_val[i]))),\\n        VXMS_VSBC     => to_bits(SEW, unsigned(vs2_val[i]) - unsigned(rs1_val) - unsigned(bool_to_bits(vm_val[i])))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vadd.vi","name":"TBD","operands":[{"name":"funct6","type":"vifunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VI_VADD    => vs2_val[i] + imm_val,\\n        VI_VRSUB   => imm_val - vs2_val[i],\\n        VI_VAND    => vs2_val[i] & imm_val,\\n        VI_VOR     => vs2_val[i] | imm_val,\\n        VI_VXOR    => vs2_val[i] ^ imm_val,\\n        VI_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, imm_val) ),\\n        VI_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, imm_val) ),\\n        VI_VSLL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VI_VSRL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VI_VSRA    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VI_VSSRL   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VI_VSSRA   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vadd.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vadd.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vand.vi","name":"TBD","operands":[{"name":"funct6","type":"vifunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VI_VADD    => vs2_val[i] + imm_val,\\n        VI_VRSUB   => imm_val - vs2_val[i],\\n        VI_VAND    => vs2_val[i] & imm_val,\\n        VI_VOR     => vs2_val[i] | imm_val,\\n        VI_VXOR    => vs2_val[i] ^ imm_val,\\n        VI_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, imm_val) ),\\n        VI_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, imm_val) ),\\n        VI_VSLL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VI_VSRL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VI_VSRA    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VI_VSSRL   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VI_VSSRA   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vand.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vand.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vasub.vv","name":"TBD","operands":[{"name":"funct6","type":"mvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVV_VAADDU   => {\\n                          let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VAADD    => {\\n                          let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUBU   => {\\n                          let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUB    => {\\n                          let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VDIVU    => {\\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          to_bits(SEW, q)\\n                        },\\n        MVV_VDIV     => {\\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* check for signed overflow */\\n                          let q\' : int = if q > elem_max then elem_min else q;\\n                          to_bits(SEW, q\')\\n                        },\\n        MVV_VREMU    => {\\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        },\\n        MVV_VREM     => {\\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vasub.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VAADDU       => {\\n                              let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VAADD        => {\\n                              let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUBU       => {\\n                              let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUB        => {\\n                              let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VSLIDE1UP    => {\\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        MVX_VSLIDE1DOWN  => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            },\\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VDIVU        => {\\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\\n                              to_bits(SEW, q)\\n                            },\\n        MVX_VDIV         => {\\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* check for signed overflow */\\n                              let q\' : int = if q > elem_max then elem_min else q;\\n                              to_bits(SEW, q\')\\n                            },\\n        MVX_VREMU        => {\\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            },\\n        MVX_VREM         => {\\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vasubu.vv","name":"TBD","operands":[{"name":"funct6","type":"mvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVV_VAADDU   => {\\n                          let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VAADD    => {\\n                          let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUBU   => {\\n                          let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUB    => {\\n                          let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VDIVU    => {\\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          to_bits(SEW, q)\\n                        },\\n        MVV_VDIV     => {\\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* check for signed overflow */\\n                          let q\' : int = if q > elem_max then elem_min else q;\\n                          to_bits(SEW, q\')\\n                        },\\n        MVV_VREMU    => {\\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        },\\n        MVV_VREM     => {\\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vasubu.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VAADDU       => {\\n                              let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VAADD        => {\\n                              let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUBU       => {\\n                              let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUB        => {\\n                              let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VSLIDE1UP    => {\\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        MVX_VSLIDE1DOWN  => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            },\\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VDIVU        => {\\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\\n                              to_bits(SEW, q)\\n                            },\\n        MVX_VDIV         => {\\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* check for signed overflow */\\n                              let q\' : int = if q > elem_max then elem_min else q;\\n                              to_bits(SEW, q\')\\n                            },\\n        MVX_VREMU        => {\\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            },\\n        MVX_VREM         => {\\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vcompress.vm","name":"TBD","operands":[{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let start_element = get_start_element();\\n  let end_element = get_end_element();\\n  let SEW = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  /* vcompress should always be executed with a vstart of 0 */\\n  if start_element != 0 | vs1 == vd | vs2 == vd | illegal_vd_unmasked()\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vs1_val : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n\\n  /* body elements */\\n  vd_idx : nat = 0;\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if i <= end_element then {\\n      if vs1_val[i] then {\\n        let \'p = vd_idx;\\n        assert(\'p < \'n);\\n        result[\'p] = vs2_val[i];\\n        vd_idx = vd_idx + 1;\\n      }\\n    }\\n  };\\n  /* tail elements */\\n  if vd_idx < num_elem then {\\n    let tail_ag : agtype = get_vtype_vta();\\n    let \'p = vd_idx;\\n    foreach (i from \'p to (num_elem - 1)) {\\n      result[i] = match tail_ag {\\n        UNDISTURBED => vd_val[i],\\n        AGNOSTIC    => vd_val[i] /* TODO: configuration support */\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vdiv.vv","name":"TBD","operands":[{"name":"funct6","type":"mvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVV_VAADDU   => {\\n                          let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VAADD    => {\\n                          let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUBU   => {\\n                          let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUB    => {\\n                          let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VDIVU    => {\\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          to_bits(SEW, q)\\n                        },\\n        MVV_VDIV     => {\\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* check for signed overflow */\\n                          let q\' : int = if q > elem_max then elem_min else q;\\n                          to_bits(SEW, q\')\\n                        },\\n        MVV_VREMU    => {\\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        },\\n        MVV_VREM     => {\\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vdiv.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VAADDU       => {\\n                              let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VAADD        => {\\n                              let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUBU       => {\\n                              let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUB        => {\\n                              let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VSLIDE1UP    => {\\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        MVX_VSLIDE1DOWN  => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            },\\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VDIVU        => {\\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\\n                              to_bits(SEW, q)\\n                            },\\n        MVX_VDIV         => {\\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* check for signed overflow */\\n                              let q\' : int = if q > elem_max then elem_min else q;\\n                              to_bits(SEW, q\')\\n                            },\\n        MVX_VREMU        => {\\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            },\\n        MVX_VREM         => {\\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vdivu.vv","name":"TBD","operands":[{"name":"funct6","type":"mvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVV_VAADDU   => {\\n                          let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VAADD    => {\\n                          let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUBU   => {\\n                          let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUB    => {\\n                          let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VDIVU    => {\\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          to_bits(SEW, q)\\n                        },\\n        MVV_VDIV     => {\\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* check for signed overflow */\\n                          let q\' : int = if q > elem_max then elem_min else q;\\n                          to_bits(SEW, q\')\\n                        },\\n        MVV_VREMU    => {\\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        },\\n        MVV_VREM     => {\\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vdivu.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VAADDU       => {\\n                              let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VAADD        => {\\n                              let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUBU       => {\\n                              let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUB        => {\\n                              let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VSLIDE1UP    => {\\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        MVX_VSLIDE1DOWN  => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            },\\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VDIVU        => {\\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\\n                              to_bits(SEW, q)\\n                            },\\n        MVX_VDIV         => {\\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* check for signed overflow */\\n                              let q\' : int = if q > elem_max then elem_min else q;\\n                              to_bits(SEW, q\')\\n                            },\\n        MVX_VREMU        => {\\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            },\\n        MVX_VREM         => {\\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfadd.vf","name":"TBD","operands":[{"name":"funct6","type":"fvffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VSGNJ         => [rs1_val[\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJN        => (0b1 ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJX        => ([vs2_val[i][\'m - 1]] ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSLIDE1UP     => {\\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        VF_VSLIDE1DOWN   => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfadd.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSGNJ    => [vs1_val[i][\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJX   => ([vs2_val[i][\'m - 1]] ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0]\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfclass.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfunary1","type":"vfunary1"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010011","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary1_vs1(vfunary1)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfunary1 {\\n        FVV_VSQRT      => {\\n                            let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                              16  => riscv_f16Sqrt(rm_3b, vs2_val[i]),\\n                              32  => riscv_f32Sqrt(rm_3b, vs2_val[i]),\\n                              64  => riscv_f64Sqrt(rm_3b, vs2_val[i])\\n                            };\\n                            accrue_fflags(fflags);\\n                            elem\\n                          },\\n        FVV_VRSQRT7    => {\\n                            let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                              16  => riscv_f16Rsqrte7(rm_3b, vs2_val[i]),\\n                              32  => riscv_f32Rsqrte7(rm_3b, vs2_val[i]),\\n                              64  => riscv_f64Rsqrte7(rm_3b, vs2_val[i])\\n                            };\\n                            accrue_fflags(fflags);\\n                            elem\\n                          },\\n        FVV_VREC7      => {\\n                            let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                              16  => riscv_f16Recip7(rm_3b, vs2_val[i]),\\n                              32  => riscv_f32Recip7(rm_3b, vs2_val[i]),\\n                              64  => riscv_f64Recip7(rm_3b, vs2_val[i])\\n                            };\\n                            accrue_fflags(fflags);\\n                            elem\\n                          },\\n        FVV_VCLASS     => fp_class(vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfcvt.f.x.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfunary0","type":"vfunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary0_vs1(vfunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfunary0 {\\n        FV_CVT_XU_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToUi16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToUi32(rm_3b, vs2_val[i]),\\n                                64 => riscv_f64ToUi64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_X_F       => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToI16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToI32(rm_3b, vs2_val[i]),\\n                                64 => riscv_f64ToI64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_F_XU      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\\n                                32 => riscv_ui32ToF32(rm_3b, vs2_val[i]),\\n                                64 => riscv_ui64ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_F_X       => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\\n                                32 => riscv_i32ToF32(rm_3b, vs2_val[i]),\\n                                64 => riscv_i64ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_RTZ_XU_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToUi16(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToUi32(0b001, vs2_val[i]),\\n                                64 => riscv_f64ToUi64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_RTZ_X_F   => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToI16(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToI32(0b001, vs2_val[i]),\\n                                64 => riscv_f64ToI64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfcvt.f.xu.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfunary0","type":"vfunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary0_vs1(vfunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfunary0 {\\n        FV_CVT_XU_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToUi16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToUi32(rm_3b, vs2_val[i]),\\n                                64 => riscv_f64ToUi64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_X_F       => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToI16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToI32(rm_3b, vs2_val[i]),\\n                                64 => riscv_f64ToI64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_F_XU      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\\n                                32 => riscv_ui32ToF32(rm_3b, vs2_val[i]),\\n                                64 => riscv_ui64ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_F_X       => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\\n                                32 => riscv_i32ToF32(rm_3b, vs2_val[i]),\\n                                64 => riscv_i64ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_RTZ_XU_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToUi16(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToUi32(0b001, vs2_val[i]),\\n                                64 => riscv_f64ToUi64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_RTZ_X_F   => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToI16(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToI32(0b001, vs2_val[i]),\\n                                64 => riscv_f64ToI64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfcvt.rtz.x.f.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfunary0","type":"vfunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary0_vs1(vfunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfunary0 {\\n        FV_CVT_XU_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToUi16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToUi32(rm_3b, vs2_val[i]),\\n                                64 => riscv_f64ToUi64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_X_F       => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToI16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToI32(rm_3b, vs2_val[i]),\\n                                64 => riscv_f64ToI64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_F_XU      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\\n                                32 => riscv_ui32ToF32(rm_3b, vs2_val[i]),\\n                                64 => riscv_ui64ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_F_X       => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\\n                                32 => riscv_i32ToF32(rm_3b, vs2_val[i]),\\n                                64 => riscv_i64ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_RTZ_XU_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToUi16(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToUi32(0b001, vs2_val[i]),\\n                                64 => riscv_f64ToUi64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_RTZ_X_F   => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToI16(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToI32(0b001, vs2_val[i]),\\n                                64 => riscv_f64ToI64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfcvt.rtz.xu.f.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfunary0","type":"vfunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary0_vs1(vfunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfunary0 {\\n        FV_CVT_XU_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToUi16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToUi32(rm_3b, vs2_val[i]),\\n                                64 => riscv_f64ToUi64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_X_F       => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToI16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToI32(rm_3b, vs2_val[i]),\\n                                64 => riscv_f64ToI64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_F_XU      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\\n                                32 => riscv_ui32ToF32(rm_3b, vs2_val[i]),\\n                                64 => riscv_ui64ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_F_X       => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\\n                                32 => riscv_i32ToF32(rm_3b, vs2_val[i]),\\n                                64 => riscv_i64ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_RTZ_XU_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToUi16(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToUi32(0b001, vs2_val[i]),\\n                                64 => riscv_f64ToUi64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_RTZ_X_F   => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToI16(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToI32(0b001, vs2_val[i]),\\n                                64 => riscv_f64ToI64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfcvt.x.f.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfunary0","type":"vfunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary0_vs1(vfunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfunary0 {\\n        FV_CVT_XU_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToUi16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToUi32(rm_3b, vs2_val[i]),\\n                                64 => riscv_f64ToUi64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_X_F       => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToI16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToI32(rm_3b, vs2_val[i]),\\n                                64 => riscv_f64ToI64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_F_XU      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\\n                                32 => riscv_ui32ToF32(rm_3b, vs2_val[i]),\\n                                64 => riscv_ui64ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_F_X       => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\\n                                32 => riscv_i32ToF32(rm_3b, vs2_val[i]),\\n                                64 => riscv_i64ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_RTZ_XU_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToUi16(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToUi32(0b001, vs2_val[i]),\\n                                64 => riscv_f64ToUi64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_RTZ_X_F   => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToI16(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToI32(0b001, vs2_val[i]),\\n                                64 => riscv_f64ToI64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfcvt.xu.f.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfunary0","type":"vfunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary0_vs1(vfunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfunary0 {\\n        FV_CVT_XU_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToUi16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToUi32(rm_3b, vs2_val[i]),\\n                                64 => riscv_f64ToUi64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_X_F       => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToI16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToI32(rm_3b, vs2_val[i]),\\n                                64 => riscv_f64ToI64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_F_XU      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\\n                                32 => riscv_ui32ToF32(rm_3b, vs2_val[i]),\\n                                64 => riscv_ui64ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_F_X       => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\\n                                32 => riscv_i32ToF32(rm_3b, vs2_val[i]),\\n                                64 => riscv_i64ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_RTZ_XU_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToUi16(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToUi32(0b001, vs2_val[i]),\\n                                64 => riscv_f64ToUi64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FV_CVT_RTZ_X_F   => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                16 => riscv_f16ToI16(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToI32(0b001, vs2_val[i]),\\n                                64 => riscv_f64ToI64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfdiv.vf","name":"TBD","operands":[{"name":"funct6","type":"fvffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VSGNJ         => [rs1_val[\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJN        => (0b1 ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJX        => ([vs2_val[i][\'m - 1]] ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSLIDE1UP     => {\\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        VF_VSLIDE1DOWN   => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfdiv.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSGNJ    => [vs1_val[i][\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJX   => ([vs2_val[i][\'m - 1]] ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0]\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfirst.m","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,vs2vm","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"0b10001","size":5},{"field":"0b010","size":3},{"field":"rd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = unsigned(vlenb) * 8;\\n\\n  if illegal_vd_unmasked() | not(assert_vstart(0)) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool) = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\\n  result      : vector(\'n, dec, bool) = undefined;\\n  mask        : vector(\'n, dec, bool) = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vs2_val, vm_val);\\n\\n  index : int = -1;\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if index == -1 then {\\n      if mask[i] & vs2_val[i] then index = i;\\n    };\\n  };\\n\\n  X(rd) = to_bits(sizeof(xlen), index);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmacc.vf","name":"TBD","operands":[{"name":"funct6","type":"fvfmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VMACC    => fp_muladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VNMACC   => fp_nmulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VMSAC    => fp_mulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VNMSAC   => fp_nmuladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VMADD    => fp_muladd(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VNMADD   => fp_nmulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VMSUB    => fp_mulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VNMSUB   => fp_nmuladd(rm_3b, rs1_val, vd_val[i], vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmacc.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FVV_VMACC    => fp_muladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VNMACC   => fp_nmulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VMSAC    => fp_mulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VNMSAC   => fp_nmuladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VMADD    => fp_muladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VNMADD   => fp_nmulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VMSUB    => fp_mulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VNMSUB   => fp_nmuladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmadd.vf","name":"TBD","operands":[{"name":"funct6","type":"fvfmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VMACC    => fp_muladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VNMACC   => fp_nmulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VMSAC    => fp_mulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VNMSAC   => fp_nmuladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VMADD    => fp_muladd(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VNMADD   => fp_nmulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VMSUB    => fp_mulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VNMSUB   => fp_nmuladd(rm_3b, rs1_val, vd_val[i], vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmadd.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FVV_VMACC    => fp_muladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VNMACC   => fp_nmulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VMSAC    => fp_mulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VNMSAC   => fp_nmuladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VMADD    => fp_muladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VNMADD   => fp_nmulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VMSUB    => fp_mulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VNMSUB   => fp_nmuladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmax.vf","name":"TBD","operands":[{"name":"funct6","type":"fvffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VSGNJ         => [rs1_val[\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJN        => (0b1 ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJX        => ([vs2_val[i][\'m - 1]] ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSLIDE1UP     => {\\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        VF_VSLIDE1DOWN   => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmax.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSGNJ    => [vs1_val[i][\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJX   => ([vs2_val[i][\'m - 1]] ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0]\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmerge.vfm","name":"TBD","operands":[{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1,v0","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b         = fcsr.FRM();\\n  let start_element = get_start_element();\\n  let end_element   = get_end_element();\\n  let SEW           = get_sew();\\n  let LMUL_pow      = get_lmul_pow();\\n  let num_elem      = get_num_elem(LMUL_pow, SEW); /* max(VLMAX,VLEN/SEW)) */\\n  let real_num_elem = if LMUL_pow >= 0 then num_elem else num_elem / (0 - LMUL_pow); /* VLMAX */\\n\\n  if illegal_fp_vd_masked(vd, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n\\n  let tail_ag : agtype = get_vtype_vta();\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if i < start_element then {\\n      result[i] = vd_val[i]\\n    } else if i > end_element | i >= real_num_elem then {\\n      result[i] = match tail_ag {\\n        UNDISTURBED => vd_val[i],\\n        AGNOSTIC    => vd_val[i] /* TODO: configuration support */\\n      }\\n    } else {\\n      /* the merge operates on all body elements */\\n      result[i] = if vm_val[i] then rs1_val else vs2_val[i]\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmin.vf","name":"TBD","operands":[{"name":"funct6","type":"fvffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VSGNJ         => [rs1_val[\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJN        => (0b1 ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJX        => ([vs2_val[i][\'m - 1]] ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSLIDE1UP     => {\\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        VF_VSLIDE1DOWN   => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmin.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSGNJ    => [vs1_val[i][\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJX   => ([vs2_val[i][\'m - 1]] ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0]\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmsac.vf","name":"TBD","operands":[{"name":"funct6","type":"fvfmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VMACC    => fp_muladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VNMACC   => fp_nmulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VMSAC    => fp_mulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VNMSAC   => fp_nmuladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VMADD    => fp_muladd(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VNMADD   => fp_nmulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VMSUB    => fp_mulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VNMSUB   => fp_nmuladd(rm_3b, rs1_val, vd_val[i], vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmsac.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FVV_VMACC    => fp_muladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VNMACC   => fp_nmulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VMSAC    => fp_mulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VNMSAC   => fp_nmuladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VMADD    => fp_muladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VNMADD   => fp_nmulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VMSUB    => fp_mulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VNMSUB   => fp_nmuladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmsub.vf","name":"TBD","operands":[{"name":"funct6","type":"fvfmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VMACC    => fp_muladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VNMACC   => fp_nmulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VMSAC    => fp_mulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VNMSAC   => fp_nmuladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VMADD    => fp_muladd(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VNMADD   => fp_nmulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VMSUB    => fp_mulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VNMSUB   => fp_nmuladd(rm_3b, rs1_val, vd_val[i], vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmsub.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FVV_VMACC    => fp_muladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VNMACC   => fp_nmulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VMSAC    => fp_mulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VNMSAC   => fp_nmuladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VMADD    => fp_muladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VNMADD   => fp_nmulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VMSUB    => fp_mulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VNMSUB   => fp_nmuladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmul.vf","name":"TBD","operands":[{"name":"funct6","type":"fvffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VSGNJ         => [rs1_val[\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJN        => (0b1 ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJX        => ([vs2_val[i][\'m - 1]] ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSLIDE1UP     => {\\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        VF_VSLIDE1DOWN   => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmul.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSGNJ    => [vs1_val[i][\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJX   => ([vs2_val[i][\'m - 1]] ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0]\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmv.f.s","name":"TBD","operands":[{"name":"vs2","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,vs2","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"0b00000","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let num_elem = get_num_elem(0, SEW);\\n\\n  if illegal_fp_vd_unmasked(SEW, rm_3b) | SEW > sizeof(flen)\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(num_elem > 0 & SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, 0, vs2);\\n  match \'m {\\n    16 => F_H(rd) = vs2_val[0],\\n    32 => F_S(rd) = vs2_val[0],\\n    64 => F_D(rd) = vs2_val[0]\\n  };\\n  vstart = zeros();\\n\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmv.s.f","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"0b1","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let num_elem = get_num_elem(0, SEW);\\n\\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(num_elem > 0 & SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, 0, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, 0, vd_val, vm_val);\\n\\n  /* one body element */\\n  if mask[0] then result[0] = rs1_val;\\n\\n  /* others treated as tail elements */\\n  let tail_ag : agtype = get_vtype_vta();\\n  foreach (i from 1 to (num_elem - 1)) {\\n    result[i] = match tail_ag {\\n      UNDISTURBED => vd_val[i],\\n      AGNOSTIC    => vd_val[i] /* TODO: configuration support */\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, 0, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfmv.v.f","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b1","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then result[i] = rs1_val\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfncvt.f.f.w","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfnunary0","type":"vfnunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfnunary0_vs1(vfnunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfnunary0 {\\n        FNV_CVT_XU_F     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToUi8(rm_3b, vs2_val[i]),\\n                                16 => riscv_f32ToUi16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToUi32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_X_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToI8(rm_3b, vs2_val[i]),\\n                                16 => riscv_f32ToI16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToI32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_XU     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_ui32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_ui64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_X      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_i32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_i64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_ROD_F_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f32ToF16(0b110, vs2_val[i]),\\n                                32 => riscv_f64ToF32(0b110, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_RTZ_XU_F => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToUi8(0b001, vs2_val[i]),\\n                                16 => riscv_f32ToUi16(0b001, vs2_val[i]),\\n                                32 => riscv_f64ToUi32(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_RTZ_X_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToI8(0b001, vs2_val[i]),\\n                                16 => riscv_f32ToI16(0b001, vs2_val[i]),\\n                                32 => riscv_f64ToI32(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfncvt.f.x.w","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfnunary0","type":"vfnunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfnunary0_vs1(vfnunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfnunary0 {\\n        FNV_CVT_XU_F     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToUi8(rm_3b, vs2_val[i]),\\n                                16 => riscv_f32ToUi16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToUi32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_X_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToI8(rm_3b, vs2_val[i]),\\n                                16 => riscv_f32ToI16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToI32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_XU     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_ui32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_ui64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_X      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_i32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_i64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_ROD_F_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f32ToF16(0b110, vs2_val[i]),\\n                                32 => riscv_f64ToF32(0b110, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_RTZ_XU_F => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToUi8(0b001, vs2_val[i]),\\n                                16 => riscv_f32ToUi16(0b001, vs2_val[i]),\\n                                32 => riscv_f64ToUi32(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_RTZ_X_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToI8(0b001, vs2_val[i]),\\n                                16 => riscv_f32ToI16(0b001, vs2_val[i]),\\n                                32 => riscv_f64ToI32(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfncvt.f.xu.w","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfnunary0","type":"vfnunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfnunary0_vs1(vfnunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfnunary0 {\\n        FNV_CVT_XU_F     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToUi8(rm_3b, vs2_val[i]),\\n                                16 => riscv_f32ToUi16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToUi32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_X_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToI8(rm_3b, vs2_val[i]),\\n                                16 => riscv_f32ToI16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToI32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_XU     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_ui32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_ui64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_X      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_i32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_i64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_ROD_F_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f32ToF16(0b110, vs2_val[i]),\\n                                32 => riscv_f64ToF32(0b110, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_RTZ_XU_F => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToUi8(0b001, vs2_val[i]),\\n                                16 => riscv_f32ToUi16(0b001, vs2_val[i]),\\n                                32 => riscv_f64ToUi32(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_RTZ_X_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToI8(0b001, vs2_val[i]),\\n                                16 => riscv_f32ToI16(0b001, vs2_val[i]),\\n                                32 => riscv_f64ToI32(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfncvt.rod.f.f.w","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfnunary0","type":"vfnunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfnunary0_vs1(vfnunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfnunary0 {\\n        FNV_CVT_XU_F     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToUi8(rm_3b, vs2_val[i]),\\n                                16 => riscv_f32ToUi16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToUi32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_X_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToI8(rm_3b, vs2_val[i]),\\n                                16 => riscv_f32ToI16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToI32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_XU     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_ui32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_ui64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_X      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_i32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_i64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_ROD_F_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f32ToF16(0b110, vs2_val[i]),\\n                                32 => riscv_f64ToF32(0b110, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_RTZ_XU_F => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToUi8(0b001, vs2_val[i]),\\n                                16 => riscv_f32ToUi16(0b001, vs2_val[i]),\\n                                32 => riscv_f64ToUi32(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_RTZ_X_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToI8(0b001, vs2_val[i]),\\n                                16 => riscv_f32ToI16(0b001, vs2_val[i]),\\n                                32 => riscv_f64ToI32(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfncvt.rtz.x.f.w","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfnunary0","type":"vfnunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfnunary0_vs1(vfnunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfnunary0 {\\n        FNV_CVT_XU_F     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToUi8(rm_3b, vs2_val[i]),\\n                                16 => riscv_f32ToUi16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToUi32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_X_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToI8(rm_3b, vs2_val[i]),\\n                                16 => riscv_f32ToI16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToI32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_XU     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_ui32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_ui64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_X      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_i32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_i64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_ROD_F_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f32ToF16(0b110, vs2_val[i]),\\n                                32 => riscv_f64ToF32(0b110, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_RTZ_XU_F => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToUi8(0b001, vs2_val[i]),\\n                                16 => riscv_f32ToUi16(0b001, vs2_val[i]),\\n                                32 => riscv_f64ToUi32(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_RTZ_X_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToI8(0b001, vs2_val[i]),\\n                                16 => riscv_f32ToI16(0b001, vs2_val[i]),\\n                                32 => riscv_f64ToI32(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfncvt.rtz.xu.f.w","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfnunary0","type":"vfnunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfnunary0_vs1(vfnunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfnunary0 {\\n        FNV_CVT_XU_F     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToUi8(rm_3b, vs2_val[i]),\\n                                16 => riscv_f32ToUi16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToUi32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_X_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToI8(rm_3b, vs2_val[i]),\\n                                16 => riscv_f32ToI16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToI32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_XU     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_ui32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_ui64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_X      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_i32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_i64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_ROD_F_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f32ToF16(0b110, vs2_val[i]),\\n                                32 => riscv_f64ToF32(0b110, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_RTZ_XU_F => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToUi8(0b001, vs2_val[i]),\\n                                16 => riscv_f32ToUi16(0b001, vs2_val[i]),\\n                                32 => riscv_f64ToUi32(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_RTZ_X_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToI8(0b001, vs2_val[i]),\\n                                16 => riscv_f32ToI16(0b001, vs2_val[i]),\\n                                32 => riscv_f64ToI32(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfncvt.x.f.w","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfnunary0","type":"vfnunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfnunary0_vs1(vfnunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfnunary0 {\\n        FNV_CVT_XU_F     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToUi8(rm_3b, vs2_val[i]),\\n                                16 => riscv_f32ToUi16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToUi32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_X_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToI8(rm_3b, vs2_val[i]),\\n                                16 => riscv_f32ToI16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToI32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_XU     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_ui32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_ui64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_X      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_i32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_i64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_ROD_F_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f32ToF16(0b110, vs2_val[i]),\\n                                32 => riscv_f64ToF32(0b110, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_RTZ_XU_F => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToUi8(0b001, vs2_val[i]),\\n                                16 => riscv_f32ToUi16(0b001, vs2_val[i]),\\n                                32 => riscv_f64ToUi32(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_RTZ_X_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToI8(0b001, vs2_val[i]),\\n                                16 => riscv_f32ToI16(0b001, vs2_val[i]),\\n                                32 => riscv_f64ToI32(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfncvt.xu.f.w","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfnunary0","type":"vfnunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfnunary0_vs1(vfnunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfnunary0 {\\n        FNV_CVT_XU_F     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToUi8(rm_3b, vs2_val[i]),\\n                                16 => riscv_f32ToUi16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToUi32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_X_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToI8(rm_3b, vs2_val[i]),\\n                                16 => riscv_f32ToI16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToI32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_XU     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_ui32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_ui64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_X      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_i32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_i64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_F_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f32ToF16(rm_3b, vs2_val[i]),\\n                                32 => riscv_f64ToF32(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_ROD_F_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f32ToF16(0b110, vs2_val[i]),\\n                                32 => riscv_f64ToF32(0b110, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_RTZ_XU_F => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToUi8(0b001, vs2_val[i]),\\n                                16 => riscv_f32ToUi16(0b001, vs2_val[i]),\\n                                32 => riscv_f64ToUi32(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FNV_CVT_RTZ_X_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                                8  => riscv_f16ToI8(0b001, vs2_val[i]),\\n                                16 => riscv_f32ToI16(0b001, vs2_val[i]),\\n                                32 => riscv_f64ToI32(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfnmacc.vf","name":"TBD","operands":[{"name":"funct6","type":"fvfmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VMACC    => fp_muladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VNMACC   => fp_nmulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VMSAC    => fp_mulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VNMSAC   => fp_nmuladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VMADD    => fp_muladd(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VNMADD   => fp_nmulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VMSUB    => fp_mulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VNMSUB   => fp_nmuladd(rm_3b, rs1_val, vd_val[i], vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfnmacc.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FVV_VMACC    => fp_muladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VNMACC   => fp_nmulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VMSAC    => fp_mulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VNMSAC   => fp_nmuladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VMADD    => fp_muladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VNMADD   => fp_nmulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VMSUB    => fp_mulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VNMSUB   => fp_nmuladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfnmadd.vf","name":"TBD","operands":[{"name":"funct6","type":"fvfmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VMACC    => fp_muladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VNMACC   => fp_nmulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VMSAC    => fp_mulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VNMSAC   => fp_nmuladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VMADD    => fp_muladd(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VNMADD   => fp_nmulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VMSUB    => fp_mulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VNMSUB   => fp_nmuladd(rm_3b, rs1_val, vd_val[i], vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfnmadd.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FVV_VMACC    => fp_muladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VNMACC   => fp_nmulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VMSAC    => fp_mulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VNMSAC   => fp_nmuladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VMADD    => fp_muladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VNMADD   => fp_nmulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VMSUB    => fp_mulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VNMSUB   => fp_nmuladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfnmsac.vf","name":"TBD","operands":[{"name":"funct6","type":"fvfmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VMACC    => fp_muladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VNMACC   => fp_nmulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VMSAC    => fp_mulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VNMSAC   => fp_nmuladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VMADD    => fp_muladd(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VNMADD   => fp_nmulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VMSUB    => fp_mulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VNMSUB   => fp_nmuladd(rm_3b, rs1_val, vd_val[i], vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfnmsac.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FVV_VMACC    => fp_muladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VNMACC   => fp_nmulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VMSAC    => fp_mulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VNMSAC   => fp_nmuladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VMADD    => fp_muladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VNMADD   => fp_nmulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VMSUB    => fp_mulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VNMSUB   => fp_nmuladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfnmsub.vf","name":"TBD","operands":[{"name":"funct6","type":"fvfmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VMACC    => fp_muladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VNMACC   => fp_nmulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VMSAC    => fp_mulsub(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VNMSAC   => fp_nmuladd(rm_3b, rs1_val, vs2_val[i], vd_val[i]),\\n        VF_VMADD    => fp_muladd(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VNMADD   => fp_nmulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VMSUB    => fp_mulsub(rm_3b, rs1_val, vd_val[i], vs2_val[i]),\\n        VF_VNMSUB   => fp_nmuladd(rm_3b, rs1_val, vd_val[i], vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfnmsub.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FVV_VMACC    => fp_muladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VNMACC   => fp_nmulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VMSAC    => fp_mulsub(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VNMSAC   => fp_nmuladd(rm_3b, vs1_val[i], vs2_val[i], vd_val[i]),\\n        FVV_VMADD    => fp_muladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VNMADD   => fp_nmulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VMSUB    => fp_mulsub(rm_3b, vs1_val[i], vd_val[i], vs2_val[i]),\\n        FVV_VNMSUB   => fp_nmuladd(rm_3b, vs1_val[i], vd_val[i], vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfrdiv.vf","name":"TBD","operands":[{"name":"funct6","type":"fvffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VSGNJ         => [rs1_val[\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJN        => (0b1 ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJX        => ([vs2_val[i][\'m - 1]] ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSLIDE1UP     => {\\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        VF_VSLIDE1DOWN   => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfrec7.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfunary1","type":"vfunary1"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010011","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary1_vs1(vfunary1)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfunary1 {\\n        FVV_VSQRT      => {\\n                            let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                              16  => riscv_f16Sqrt(rm_3b, vs2_val[i]),\\n                              32  => riscv_f32Sqrt(rm_3b, vs2_val[i]),\\n                              64  => riscv_f64Sqrt(rm_3b, vs2_val[i])\\n                            };\\n                            accrue_fflags(fflags);\\n                            elem\\n                          },\\n        FVV_VRSQRT7    => {\\n                            let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                              16  => riscv_f16Rsqrte7(rm_3b, vs2_val[i]),\\n                              32  => riscv_f32Rsqrte7(rm_3b, vs2_val[i]),\\n                              64  => riscv_f64Rsqrte7(rm_3b, vs2_val[i])\\n                            };\\n                            accrue_fflags(fflags);\\n                            elem\\n                          },\\n        FVV_VREC7      => {\\n                            let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                              16  => riscv_f16Recip7(rm_3b, vs2_val[i]),\\n                              32  => riscv_f32Recip7(rm_3b, vs2_val[i]),\\n                              64  => riscv_f64Recip7(rm_3b, vs2_val[i])\\n                            };\\n                            accrue_fflags(fflags);\\n                            elem\\n                          },\\n        FVV_VCLASS     => fp_class(vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfredmax.vs","name":"TBD","operands":[{"name":"funct6","type":"rfvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rfvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\\n\\n  if funct6 == FVV_VFWREDOSUM | funct6 == FVV_VFWREDUSUM then\\n    process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\\n  else\\n    process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\\n}","description":"TBD"},{"mnemonic":"vfredmin.vs","name":"TBD","operands":[{"name":"funct6","type":"rfvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rfvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\\n\\n  if funct6 == FVV_VFWREDOSUM | funct6 == FVV_VFWREDUSUM then\\n    process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\\n  else\\n    process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\\n}","description":"TBD"},{"mnemonic":"vfredosum.vs","name":"TBD","operands":[{"name":"funct6","type":"rfvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rfvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\\n\\n  if funct6 == FVV_VFWREDOSUM | funct6 == FVV_VFWREDUSUM then\\n    process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\\n  else\\n    process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\\n}","description":"TBD"},{"mnemonic":"vfredusum.vs","name":"TBD","operands":[{"name":"funct6","type":"rfvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rfvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\\n\\n  if funct6 == FVV_VFWREDOSUM | funct6 == FVV_VFWREDUSUM then\\n    process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\\n  else\\n    process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\\n}","description":"TBD"},{"mnemonic":"vfrsqrt7.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfunary1","type":"vfunary1"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010011","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary1_vs1(vfunary1)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfunary1 {\\n        FVV_VSQRT      => {\\n                            let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                              16  => riscv_f16Sqrt(rm_3b, vs2_val[i]),\\n                              32  => riscv_f32Sqrt(rm_3b, vs2_val[i]),\\n                              64  => riscv_f64Sqrt(rm_3b, vs2_val[i])\\n                            };\\n                            accrue_fflags(fflags);\\n                            elem\\n                          },\\n        FVV_VRSQRT7    => {\\n                            let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                              16  => riscv_f16Rsqrte7(rm_3b, vs2_val[i]),\\n                              32  => riscv_f32Rsqrte7(rm_3b, vs2_val[i]),\\n                              64  => riscv_f64Rsqrte7(rm_3b, vs2_val[i])\\n                            };\\n                            accrue_fflags(fflags);\\n                            elem\\n                          },\\n        FVV_VREC7      => {\\n                            let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                              16  => riscv_f16Recip7(rm_3b, vs2_val[i]),\\n                              32  => riscv_f32Recip7(rm_3b, vs2_val[i]),\\n                              64  => riscv_f64Recip7(rm_3b, vs2_val[i])\\n                            };\\n                            accrue_fflags(fflags);\\n                            elem\\n                          },\\n        FVV_VCLASS     => fp_class(vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfrsub.vf","name":"TBD","operands":[{"name":"funct6","type":"fvffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VSGNJ         => [rs1_val[\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJN        => (0b1 ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJX        => ([vs2_val[i][\'m - 1]] ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSLIDE1UP     => {\\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        VF_VSLIDE1DOWN   => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfsgnj.vf","name":"TBD","operands":[{"name":"funct6","type":"fvffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VSGNJ         => [rs1_val[\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJN        => (0b1 ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJX        => ([vs2_val[i][\'m - 1]] ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSLIDE1UP     => {\\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        VF_VSLIDE1DOWN   => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfsgnj.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSGNJ    => [vs1_val[i][\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJX   => ([vs2_val[i][\'m - 1]] ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0]\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfsgnjn.vf","name":"TBD","operands":[{"name":"funct6","type":"fvffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VSGNJ         => [rs1_val[\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJN        => (0b1 ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJX        => ([vs2_val[i][\'m - 1]] ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSLIDE1UP     => {\\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        VF_VSLIDE1DOWN   => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfsgnjn.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSGNJ    => [vs1_val[i][\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJX   => ([vs2_val[i][\'m - 1]] ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0]\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfsgnjx.vf","name":"TBD","operands":[{"name":"funct6","type":"fvffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VSGNJ         => [rs1_val[\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJN        => (0b1 ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJX        => ([vs2_val[i][\'m - 1]] ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSLIDE1UP     => {\\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        VF_VSLIDE1DOWN   => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfsgnjx.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSGNJ    => [vs1_val[i][\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJX   => ([vs2_val[i][\'m - 1]] ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0]\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfslide1down.vf","name":"TBD","operands":[{"name":"funct6","type":"fvffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VSGNJ         => [rs1_val[\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJN        => (0b1 ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJX        => ([vs2_val[i][\'m - 1]] ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSLIDE1UP     => {\\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        VF_VSLIDE1DOWN   => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfslide1up.vf","name":"TBD","operands":[{"name":"funct6","type":"fvffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VSGNJ         => [rs1_val[\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJN        => (0b1 ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJX        => ([vs2_val[i][\'m - 1]] ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSLIDE1UP     => {\\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        VF_VSLIDE1DOWN   => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfsqrt.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfunary1","type":"vfunary1"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010011","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfunary1_vs1(vfunary1)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfunary1 {\\n        FVV_VSQRT      => {\\n                            let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                              16  => riscv_f16Sqrt(rm_3b, vs2_val[i]),\\n                              32  => riscv_f32Sqrt(rm_3b, vs2_val[i]),\\n                              64  => riscv_f64Sqrt(rm_3b, vs2_val[i])\\n                            };\\n                            accrue_fflags(fflags);\\n                            elem\\n                          },\\n        FVV_VRSQRT7    => {\\n                            let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                              16  => riscv_f16Rsqrte7(rm_3b, vs2_val[i]),\\n                              32  => riscv_f32Rsqrte7(rm_3b, vs2_val[i]),\\n                              64  => riscv_f64Rsqrte7(rm_3b, vs2_val[i])\\n                            };\\n                            accrue_fflags(fflags);\\n                            elem\\n                          },\\n        FVV_VREC7      => {\\n                            let (fflags, elem) : (bits_fflags, bits(\'m)) = match \'m {\\n                              16  => riscv_f16Recip7(rm_3b, vs2_val[i]),\\n                              32  => riscv_f32Recip7(rm_3b, vs2_val[i]),\\n                              64  => riscv_f64Recip7(rm_3b, vs2_val[i])\\n                            };\\n                            accrue_fflags(fflags);\\n                            elem\\n                          },\\n        FVV_VCLASS     => fp_class(vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfsub.vf","name":"TBD","operands":[{"name":"funct6","type":"fvffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VF_VADD          => fp_add(rm_3b, vs2_val[i], rs1_val),\\n        VF_VSUB          => fp_sub(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRSUB         => fp_sub(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VMIN          => fp_min(vs2_val[i], rs1_val),\\n        VF_VMAX          => fp_max(vs2_val[i], rs1_val),\\n        VF_VMUL          => fp_mul(rm_3b, vs2_val[i], rs1_val),\\n        VF_VDIV          => fp_div(rm_3b, vs2_val[i], rs1_val),\\n        VF_VRDIV         => fp_div(rm_3b, rs1_val, vs2_val[i]),\\n        VF_VSGNJ         => [rs1_val[\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJN        => (0b1 ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSGNJX        => ([vs2_val[i][\'m - 1]] ^ [rs1_val[\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        VF_VSLIDE1UP     => {\\n                              if vs2 == vd then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        VF_VSLIDE1DOWN   => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfsub.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_normal(vd, vm, SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FVV_VADD     => fp_add(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSUB     => fp_sub(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VMIN     => fp_min(vs2_val[i], vs1_val[i]),\\n        FVV_VMAX     => fp_max(vs2_val[i], vs1_val[i]),\\n        FVV_VMUL     => fp_mul(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VDIV     => fp_div(rm_3b, vs2_val[i], vs1_val[i]),\\n        FVV_VSGNJ    => [vs1_val[i][\'m - 1]] @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJN   => (0b1 ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0],\\n        FVV_VSGNJX   => ([vs2_val[i][\'m - 1]] ^ [vs1_val[i][\'m - 1]]) @ vs2_val[i][(\'m - 2)..0]\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwadd.vf","name":"TBD","operands":[{"name":"funct6","type":"fwvffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fwvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWVF_VADD    => fp_add(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val)),\\n        FWVF_VSUB    => fp_sub(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val)),\\n        FWVF_VMUL    => fp_mul(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwadd.vv","name":"TBD","operands":[{"name":"funct6","type":"fwvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fwvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWVV_VADD    => fp_add(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i])),\\n        FWVV_VSUB    => fp_sub(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i])),\\n        FWVV_VMUL    => fp_mul(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i]))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwadd.wf","name":"TBD","operands":[{"name":"funct6","type":"fwffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fwffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen)\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWF_VADD     => fp_add(rm_3b, vs2_val[i], fp_widen(rs1_val)),\\n        FWF_VSUB     => fp_sub(rm_3b, vs2_val[i], fp_widen(rs1_val))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwadd.wv","name":"TBD","operands":[{"name":"funct6","type":"fwvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fwvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWV_VADD     => fp_add(rm_3b, vs2_val[i], fp_widen(vs1_val[i])),\\n        FWV_VSUB     => fp_sub(rm_3b, vs2_val[i], fp_widen(vs1_val[i]))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwcvt.f.f.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfwunary0","type":"vfwunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfwunary0_vs1(vfwunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 8 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfwunary0 {\\n        FWV_CVT_XU_F     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToUi32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToUi64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_X_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToI32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToI64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_XU     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\\n                                16 => riscv_ui32ToF32(rm_3b, zero_extend(vs2_val[i])),\\n                                32 => riscv_ui32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_X      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\\n                                16 => riscv_i32ToF32(rm_3b, sign_extend(vs2_val[i])),\\n                                32 => riscv_i32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToF32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_RTZ_XU_F => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToUi32(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToUi64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_RTZ_X_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToI32(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToI64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwcvt.f.x.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfwunary0","type":"vfwunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfwunary0_vs1(vfwunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 8 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfwunary0 {\\n        FWV_CVT_XU_F     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToUi32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToUi64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_X_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToI32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToI64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_XU     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\\n                                16 => riscv_ui32ToF32(rm_3b, zero_extend(vs2_val[i])),\\n                                32 => riscv_ui32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_X      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\\n                                16 => riscv_i32ToF32(rm_3b, sign_extend(vs2_val[i])),\\n                                32 => riscv_i32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToF32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_RTZ_XU_F => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToUi32(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToUi64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_RTZ_X_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToI32(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToI64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwcvt.f.xu.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfwunary0","type":"vfwunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfwunary0_vs1(vfwunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 8 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfwunary0 {\\n        FWV_CVT_XU_F     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToUi32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToUi64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_X_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToI32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToI64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_XU     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\\n                                16 => riscv_ui32ToF32(rm_3b, zero_extend(vs2_val[i])),\\n                                32 => riscv_ui32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_X      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\\n                                16 => riscv_i32ToF32(rm_3b, sign_extend(vs2_val[i])),\\n                                32 => riscv_i32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToF32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_RTZ_XU_F => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToUi32(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToUi64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_RTZ_X_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToI32(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToI64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwcvt.rtz.x.f.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfwunary0","type":"vfwunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfwunary0_vs1(vfwunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 8 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfwunary0 {\\n        FWV_CVT_XU_F     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToUi32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToUi64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_X_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToI32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToI64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_XU     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\\n                                16 => riscv_ui32ToF32(rm_3b, zero_extend(vs2_val[i])),\\n                                32 => riscv_ui32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_X      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\\n                                16 => riscv_i32ToF32(rm_3b, sign_extend(vs2_val[i])),\\n                                32 => riscv_i32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToF32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_RTZ_XU_F => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToUi32(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToUi64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_RTZ_X_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToI32(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToI64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwcvt.rtz.xu.f.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfwunary0","type":"vfwunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfwunary0_vs1(vfwunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 8 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfwunary0 {\\n        FWV_CVT_XU_F     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToUi32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToUi64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_X_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToI32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToI64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_XU     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\\n                                16 => riscv_ui32ToF32(rm_3b, zero_extend(vs2_val[i])),\\n                                32 => riscv_ui32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_X      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\\n                                16 => riscv_i32ToF32(rm_3b, sign_extend(vs2_val[i])),\\n                                32 => riscv_i32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToF32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_RTZ_XU_F => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToUi32(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToUi64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_RTZ_X_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToI32(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToI64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwcvt.x.f.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfwunary0","type":"vfwunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfwunary0_vs1(vfwunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 8 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfwunary0 {\\n        FWV_CVT_XU_F     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToUi32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToUi64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_X_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToI32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToI64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_XU     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\\n                                16 => riscv_ui32ToF32(rm_3b, zero_extend(vs2_val[i])),\\n                                32 => riscv_ui32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_X      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\\n                                16 => riscv_i32ToF32(rm_3b, sign_extend(vs2_val[i])),\\n                                32 => riscv_i32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToF32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_RTZ_XU_F => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToUi32(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToUi64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_RTZ_X_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToI32(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToI64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwcvt.xu.f.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vfwunary0","type":"vfwunary0"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"encdec_vfwunary0_vs1(vfwunary0)","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 8 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match vfwunary0 {\\n        FWV_CVT_XU_F     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToUi32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToUi64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_X_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToI32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToI64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_XU     => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => riscv_ui32ToF16(rm_3b, zero_extend(vs2_val[i])),\\n                                16 => riscv_ui32ToF32(rm_3b, zero_extend(vs2_val[i])),\\n                                32 => riscv_ui32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_X      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => riscv_i32ToF16(rm_3b, sign_extend(vs2_val[i])),\\n                                16 => riscv_i32ToF32(rm_3b, sign_extend(vs2_val[i])),\\n                                32 => riscv_i32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_F_F      => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToF32(rm_3b, vs2_val[i]),\\n                                32 => riscv_f32ToF64(rm_3b, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_RTZ_XU_F => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToUi32(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToUi64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            },\\n        FWV_CVT_RTZ_X_F  => {\\n                              let (fflags, elem) : (bits_fflags, bits(\'o)) = match \'m {\\n                                8  => { handle_illegal(); return RETIRE_FAIL },\\n                                16 => riscv_f16ToI32(0b001, vs2_val[i]),\\n                                32 => riscv_f32ToI64(0b001, vs2_val[i])\\n                              };\\n                              accrue_fflags(fflags);\\n                              elem\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwmacc.vf","name":"TBD","operands":[{"name":"funct6","type":"fwvfmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fwvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWVF_VMACC   => fp_muladd(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVF_VNMACC  => fp_nmulsub(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVF_VMSAC   => fp_mulsub(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVF_VNMSAC  => fp_nmuladd(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwmacc.vv","name":"TBD","operands":[{"name":"funct6","type":"fwvvmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fwvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs1","size":5},{"field":"vs2","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWVV_VMACC   => fp_muladd(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVV_VNMACC  => fp_nmulsub(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVV_VMSAC   => fp_mulsub(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVV_VNMSAC  => fp_nmuladd(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwmsac.vf","name":"TBD","operands":[{"name":"funct6","type":"fwvfmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fwvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWVF_VMACC   => fp_muladd(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVF_VNMACC  => fp_nmulsub(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVF_VMSAC   => fp_mulsub(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVF_VNMSAC  => fp_nmuladd(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwmsac.vv","name":"TBD","operands":[{"name":"funct6","type":"fwvvmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fwvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs1","size":5},{"field":"vs2","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWVV_VMACC   => fp_muladd(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVV_VNMACC  => fp_nmulsub(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVV_VMSAC   => fp_mulsub(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVV_VNMSAC  => fp_nmuladd(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwmul.vf","name":"TBD","operands":[{"name":"funct6","type":"fwvffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fwvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWVF_VADD    => fp_add(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val)),\\n        FWVF_VSUB    => fp_sub(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val)),\\n        FWVF_VMUL    => fp_mul(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwmul.vv","name":"TBD","operands":[{"name":"funct6","type":"fwvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fwvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWVV_VADD    => fp_add(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i])),\\n        FWVV_VSUB    => fp_sub(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i])),\\n        FWVV_VMUL    => fp_mul(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i]))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwnmacc.vf","name":"TBD","operands":[{"name":"funct6","type":"fwvfmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fwvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWVF_VMACC   => fp_muladd(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVF_VNMACC  => fp_nmulsub(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVF_VMSAC   => fp_mulsub(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVF_VNMSAC  => fp_nmuladd(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwnmacc.vv","name":"TBD","operands":[{"name":"funct6","type":"fwvvmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fwvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs1","size":5},{"field":"vs2","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWVV_VMACC   => fp_muladd(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVV_VNMACC  => fp_nmulsub(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVV_VMSAC   => fp_mulsub(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVV_VNMSAC  => fp_nmuladd(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwnmsac.vf","name":"TBD","operands":[{"name":"funct6","type":"fwvfmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fwvfmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWVF_VMACC   => fp_muladd(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVF_VNMACC  => fp_nmulsub(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVF_VMSAC   => fp_mulsub(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVF_VNMSAC  => fp_nmuladd(rm_3b, fp_widen(rs1_val), fp_widen(vs2_val[i]), vd_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwnmsac.vv","name":"TBD","operands":[{"name":"funct6","type":"fwvvmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs1","type":"regidx"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_fwvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs1","size":5},{"field":"vs2","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWVV_VMACC   => fp_muladd(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVV_VNMACC  => fp_nmulsub(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVV_VMSAC   => fp_mulsub(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i]),\\n        FWVV_VNMSAC  => fp_nmuladd(rm_3b, fp_widen(vs1_val[i]), fp_widen(vs2_val[i]), vd_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwredosum.vs","name":"TBD","operands":[{"name":"funct6","type":"rfvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rfvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\\n\\n  if funct6 == FVV_VFWREDOSUM | funct6 == FVV_VFWREDUSUM then\\n    process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\\n  else\\n    process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\\n}","description":"TBD"},{"mnemonic":"vfwredusum.vs","name":"TBD","operands":[{"name":"funct6","type":"rfvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rfvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\\n\\n  if funct6 == FVV_VFWREDOSUM | funct6 == FVV_VFWREDUSUM then\\n    process_rfvv_widen(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\\n  else\\n    process_rfvv_single(funct6, vm, vs2, vs1, vd, num_elem_vs, SEW, LMUL_pow)\\n}","description":"TBD"},{"mnemonic":"vfwsub.vf","name":"TBD","operands":[{"name":"funct6","type":"fwvffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fwvffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWVF_VADD    => fp_add(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val)),\\n        FWVF_VSUB    => fp_sub(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val)),\\n        FWVF_VMUL    => fp_mul(rm_3b, fp_widen(vs2_val[i]), fp_widen(rs1_val))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwsub.vv","name":"TBD","operands":[{"name":"funct6","type":"fwvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fwvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWVV_VADD    => fp_add(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i])),\\n        FWVV_VSUB    => fp_sub(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i])),\\n        FWVV_VMUL    => fp_mul(rm_3b, fp_widen(vs2_val[i]), fp_widen(vs1_val[i]))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwsub.wf","name":"TBD","operands":[{"name":"funct6","type":"fwffunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fwffunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen)\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWF_VADD     => fp_add(rm_3b, vs2_val[i], fp_widen(rs1_val)),\\n        FWF_VSUB     => fp_sub(rm_3b, vs2_val[i], fp_widen(rs1_val))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vfwsub.wv","name":"TBD","operands":[{"name":"funct6","type":"fwvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fwvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_fp_variable_width(vd, vm, SEW, rm_3b, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW >= 16 & SEW_widen <= 64);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        FWV_VADD     => fp_add(rm_3b, vs2_val[i], fp_widen(vs1_val[i])),\\n        FWV_VSUB     => fp_sub(rm_3b, vs2_val[i], fp_widen(vs1_val[i]))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vid.v","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vd","type":"regidx"}],"syntax":"vdvm","format":"TBD","fields":[{"field":"0b010100","size":6},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"0b10001","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then result[i] = to_bits(SEW, i)\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"viota.m","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010100","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"0b10000","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) | not(assert_vstart(0)) | vd == vs2\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  sum : int = 0;\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = to_bits(SEW, sum);\\n      if vs2_val[i] then sum = sum + 1\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vle16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vle16ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vle32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vle32ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vle64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vle64ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vle8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vle8ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlm.v","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"vd_or_vs3","type":"regidx"},{"name":"op","type":"vmlsop"}],"syntax":"vd_or_vs3,(rs1)","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01011","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vd_or_vs3","size":5},{"field":"encdec_lsop(op)","size":7}],"extensions":["V"],"function":"{\\n  let EEW = 8;\\n  let EMUL_pow = 0;\\n  let vl_val = unsigned(vl);\\n  let evl : int = if vl_val % 8 == 0 then vl_val / 8 else vl_val / 8 + 1; /* the effective vector length is evl=ceil(vl/8) */\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  assert(evl >= 0);\\n  process_vm(vd_or_vs3, rs1, num_elem, evl, op)\\n}","description":"TBD"},{"mnemonic":"vloxei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg2ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg2ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg2ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg2ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg3ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg3ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg3ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg3ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg4ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg4ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg4ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg4ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg5ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg5ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg5ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg5ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg6ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg6ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg6ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg6ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg7ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg7ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg7ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg7ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg8ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg8ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg8ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vloxseg8ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b11","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 3)\\n}","description":"TBD"},{"mnemonic":"vlre16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlre32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlre64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlre8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlse16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlse32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlse64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlse8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg2e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg2e16ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg2e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg2e32ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg2e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg2e64ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg2e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg2e8ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg2re16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg2re32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg2re64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg2re8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg3e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg3e16ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg3e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg3e32ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg3e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg3e64ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg3e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg3e8ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg3re16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg3re32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg3re64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg3re8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg4e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg4e16ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg4e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg4e32ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg4e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg4e64ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg4e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg4e8ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg4re16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg4re32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg4re64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg4re8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg5e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg5e16ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg5e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg5e32ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg5e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg5e64ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg5e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg5e8ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg5re16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg5re32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg5re64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg5re8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg6e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg6e16ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg6e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg6e32ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg6e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg6e64ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg6e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg6e8ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg6re16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg6re32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg6re64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg6re8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg7e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg7e16ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg7e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg7e32ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg7e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg7e64ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg7e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg7e8ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg7re16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg7re32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg7re64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg7re8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg8e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg8e16ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg8e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg8e32ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg8e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg8e64ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg8e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW); /* # of element of each register group */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlseg(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg8e8ff.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b10000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsegff(nf_int, vm, vd, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlseg8re16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg8re32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg8re64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlseg8re8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlre(nf_int, vd, load_width_bytes, rs1, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vlsseg2e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg2e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg2e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg2e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg3e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg3e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg3e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg3e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg4e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg4e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg4e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg4e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg5e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg5e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg5e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg5e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg6e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg6e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg6e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg6e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg7e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg7e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg7e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg7e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg8e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg8e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg8e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vlsseg8e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_load(vd, vm, nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlsseg(nf_int, vm, vd, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vluxei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg2ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg2ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg2ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg2ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg3ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg3ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg3ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg3ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg4ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg4ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg4ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg4ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg5ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg5ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg5ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg5ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg6ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg6ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg6ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg6ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg7ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg7ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg7ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg7ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg8ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg8ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg8ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vluxseg8ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vd","type":"regidx"}],"syntax":"vd,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vd","size":5},{"field":"0b0000111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_load(vd, vm, nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vlxseg(nf_int, vm, vd, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vmacc.vv","name":"TBD","operands":[{"name":"funct6","type":"mvvmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_mvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVV_VMACC  => get_slice_int(SEW, signed(vs1_val[i]) * signed(vs2_val[i]), 0) + vd_val[i],\\n        MVV_VNMSAC => vd_val[i] - get_slice_int(SEW, signed(vs1_val[i]) * signed(vs2_val[i]), 0),\\n        MVV_VMADD  => get_slice_int(SEW, signed(vs1_val[i]) * signed(vd_val[i]), 0) + vs2_val[i],\\n        MVV_VNMSUB => vs2_val[i] - get_slice_int(SEW, signed(vs1_val[i]) * signed(vd_val[i]), 0)\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmacc.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_mvxmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VMACC  => get_slice_int(SEW, signed(rs1_val) * signed(vs2_val[i]), 0) + vd_val[i],\\n        MVX_VNMSAC => vd_val[i] - get_slice_int(SEW, signed(rs1_val) * signed(vs2_val[i]), 0),\\n        MVX_VMADD  => get_slice_int(SEW, signed(rs1_val) * signed(vd_val[i]), 0) + vs2_val[i],\\n        MVX_VNMSUB => vs2_val[i] - get_slice_int(SEW, signed(rs1_val) * signed(vd_val[i]), 0)\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmadc.vi","name":"TBD","operands":[{"name":"funct6","type":"vimcfunct6"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simm","format":"TBD","fields":[{"field":"encdec_vimcfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VIMC_VMADC    => unsigned(vs2_val[i]) + unsigned(imm_val) > 2 ^ SEW - 1\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmadc.vim","name":"TBD","operands":[{"name":"funct6","type":"vimfunct6"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simm,v0","format":"TBD","fields":[{"field":"encdec_vimfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VIM_VMADC    => unsigned(vs2_val[i]) + unsigned(imm_val) + unsigned(bool_to_bits(vm_val[i])) > 2 ^ SEW - 1\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmadc.vv","name":"TBD","operands":[{"name":"funct6","type":"vvmcfunct6"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_vvmcfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VVMC_VMADC    => unsigned(vs2_val[i]) + unsigned(vs1_val[i]) > 2 ^ SEW - 1,\\n        VVMC_VMSBC    => unsigned(vs2_val[i]) - unsigned(vs1_val[i]) < 0\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmadc.vvm","name":"TBD","operands":[{"name":"funct6","type":"vvmfunct6"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1,v0","format":"TBD","fields":[{"field":"encdec_vvmfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VVM_VMADC    => unsigned(vs2_val[i]) + unsigned(vs1_val[i]) + unsigned(bool_to_bits(vm_val[i])) > 2 ^ SEW - 1,\\n        VVM_VMSBC    => unsigned(vs2_val[i]) - unsigned(vs1_val[i]) - unsigned(bool_to_bits(vm_val[i])) < 0\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmadc.vx","name":"TBD","operands":[{"name":"funct6","type":"vxmcfunct6"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1","format":"TBD","fields":[{"field":"encdec_vxmcfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VXMC_VMADC    => unsigned(vs2_val[i]) + unsigned(rs1_val) > 2 ^ SEW - 1,\\n        VXMC_VMSBC    => unsigned(vs2_val[i]) - unsigned(rs1_val) < 0\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmadc.vxm","name":"TBD","operands":[{"name":"funct6","type":"vxmfunct6"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1,v0","format":"TBD","fields":[{"field":"encdec_vxmfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VXM_VMADC    => unsigned(vs2_val[i]) + unsigned(rs1_val) + unsigned(bool_to_bits(vm_val[i])) > 2 ^ SEW - 1,\\n        VXM_VMSBC    => unsigned(vs2_val[i]) - unsigned(rs1_val) - unsigned(bool_to_bits(vm_val[i])) < 0\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmadd.vv","name":"TBD","operands":[{"name":"funct6","type":"mvvmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_mvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVV_VMACC  => get_slice_int(SEW, signed(vs1_val[i]) * signed(vs2_val[i]), 0) + vd_val[i],\\n        MVV_VNMSAC => vd_val[i] - get_slice_int(SEW, signed(vs1_val[i]) * signed(vs2_val[i]), 0),\\n        MVV_VMADD  => get_slice_int(SEW, signed(vs1_val[i]) * signed(vd_val[i]), 0) + vs2_val[i],\\n        MVV_VNMSUB => vs2_val[i] - get_slice_int(SEW, signed(vs1_val[i]) * signed(vd_val[i]), 0)\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmadd.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_mvxmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VMACC  => get_slice_int(SEW, signed(rs1_val) * signed(vs2_val[i]), 0) + vd_val[i],\\n        MVX_VNMSAC => vd_val[i] - get_slice_int(SEW, signed(rs1_val) * signed(vs2_val[i]), 0),\\n        MVX_VMADD  => get_slice_int(SEW, signed(rs1_val) * signed(vd_val[i]), 0) + vs2_val[i],\\n        MVX_VNMSUB => vs2_val[i] - get_slice_int(SEW, signed(rs1_val) * signed(vd_val[i]), 0)\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmand.mm","name":"TBD","operands":[{"name":"funct6","type":"mmfunct6"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_mmfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = unsigned(vlenb) * 8;\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vs1_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs1);\\n  let vs2_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\\n  let vd_val  : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool) = undefined;\\n  mask        : vector(\'n, dec, bool) = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MM_VMAND     => vs2_val[i] & vs1_val[i],\\n        MM_VMNAND    => not(vs2_val[i] & vs1_val[i]),\\n        MM_VMANDNOT  => vs2_val[i] & not(vs1_val[i]),\\n        MM_VMXOR     => vs2_val[i] != vs1_val[i],\\n        MM_VMOR      => vs2_val[i] | vs1_val[i],\\n        MM_VMNOR     => not(vs2_val[i] | vs1_val[i]),\\n        MM_VMORNOT   => vs2_val[i] | not(vs1_val[i]),\\n        MM_VMXNOR    => vs2_val[i] == vs1_val[i]\\n      }\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmandnot.mm","name":"TBD","operands":[{"name":"funct6","type":"mmfunct6"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_mmfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = unsigned(vlenb) * 8;\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vs1_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs1);\\n  let vs2_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\\n  let vd_val  : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool) = undefined;\\n  mask        : vector(\'n, dec, bool) = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MM_VMAND     => vs2_val[i] & vs1_val[i],\\n        MM_VMNAND    => not(vs2_val[i] & vs1_val[i]),\\n        MM_VMANDNOT  => vs2_val[i] & not(vs1_val[i]),\\n        MM_VMXOR     => vs2_val[i] != vs1_val[i],\\n        MM_VMOR      => vs2_val[i] | vs1_val[i],\\n        MM_VMNOR     => not(vs2_val[i] | vs1_val[i]),\\n        MM_VMORNOT   => vs2_val[i] | not(vs1_val[i]),\\n        MM_VMXNOR    => vs2_val[i] == vs1_val[i]\\n      }\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmax.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmax.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmaxu.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmaxu.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmerge.vim","name":"TBD","operands":[{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simm,v0","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let start_element = get_start_element();\\n  let end_element   = get_end_element();\\n  let SEW           = get_sew();\\n  let LMUL_pow      = get_lmul_pow();\\n  let num_elem      = get_num_elem(LMUL_pow, SEW); /* max(VLMAX,VLEN/SEW)) */\\n  let real_num_elem = if LMUL_pow >= 0 then num_elem else num_elem / (0 - LMUL_pow); /* VLMAX */\\n\\n  if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n\\n  let tail_ag : agtype = get_vtype_vta();\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if i < start_element then {\\n      result[i] = vd_val[i]\\n    } else if i > end_element | i >= real_num_elem then {\\n      result[i] = match tail_ag {\\n        UNDISTURBED => vd_val[i],\\n        AGNOSTIC    => vd_val[i] /* TODO: configuration support */\\n      }\\n    } else {\\n      /* the merge operates on all body elements */\\n      result[i] = if vm_val[i] then imm_val else vs2_val[i]\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmerge.vvm","name":"TBD","operands":[{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1,v0","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let start_element = get_start_element();\\n  let end_element   = get_end_element();\\n  let SEW           = get_sew();\\n  let LMUL_pow      = get_lmul_pow();\\n  let num_elem      = get_num_elem(LMUL_pow, SEW); /* max(VLMAX,VLEN/SEW)) */\\n  let real_num_elem = if LMUL_pow >= 0 then num_elem else num_elem / (0 - LMUL_pow); /* VLMAX */\\n\\n  if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n\\n  let tail_ag : agtype = get_vtype_vta();\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if i < start_element then {\\n      result[i] = vd_val[i]\\n    } else if i > end_element | i >= real_num_elem then {\\n      result[i] = match tail_ag {\\n        UNDISTURBED => vd_val[i],\\n        AGNOSTIC    => vd_val[i] /* TODO: configuration support */\\n      }\\n    } else {\\n      /* the merge operates on all body elements */\\n      result[i] = if vm_val[i] then vs1_val[i] else vs2_val[i]\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmerge.vxm","name":"TBD","operands":[{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1,v0","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let start_element = get_start_element();\\n  let end_element   = get_end_element();\\n  let SEW           = get_sew();\\n  let LMUL_pow      = get_lmul_pow();\\n  let num_elem      = get_num_elem(LMUL_pow, SEW); /* max(VLMAX,VLEN/SEW)) */\\n  let real_num_elem = if LMUL_pow >= 0 then num_elem else num_elem / (0 - LMUL_pow); /* VLMAX */\\n\\n  if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n\\n  let tail_ag : agtype = get_vtype_vta();\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if i < start_element then {\\n      result[i] = vd_val[i]\\n    } else if i > end_element | i >= real_num_elem then {\\n      result[i] = match tail_ag {\\n        UNDISTURBED => vd_val[i],\\n        AGNOSTIC    => vd_val[i] /* TODO: configuration support */\\n      }\\n    } else {\\n      /* the merge operates on all body elements */\\n      result[i] = if vm_val[i] then rs1_val else vs2_val[i]\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmfeq.vf","name":"TBD","operands":[{"name":"funct6","type":"fvfmfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvfmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VFM_VMFEQ    => fp_eq(vs2_val[i], rs1_val),\\n        VFM_VMFNE    => ~(fp_eq(vs2_val[i], rs1_val)),\\n        VFM_VMFLE    => fp_le(vs2_val[i], rs1_val),\\n        VFM_VMFLT    => fp_lt(vs2_val[i], rs1_val),\\n        VFM_VMFGE    => fp_ge(vs2_val[i], rs1_val),\\n        VFM_VMFGT    => fp_gt(vs2_val[i], rs1_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmfeq.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvmfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        FVVM_VMFEQ    => fp_eq(vs2_val[i], vs1_val[i]),\\n        FVVM_VMFNE    => ~(fp_eq(vs2_val[i], vs1_val[i])),\\n        FVVM_VMFLE    => fp_le(vs2_val[i], vs1_val[i]),\\n        FVVM_VMFLT    => fp_lt(vs2_val[i], vs1_val[i])\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmfge.vf","name":"TBD","operands":[{"name":"funct6","type":"fvfmfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvfmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VFM_VMFEQ    => fp_eq(vs2_val[i], rs1_val),\\n        VFM_VMFNE    => ~(fp_eq(vs2_val[i], rs1_val)),\\n        VFM_VMFLE    => fp_le(vs2_val[i], rs1_val),\\n        VFM_VMFLT    => fp_lt(vs2_val[i], rs1_val),\\n        VFM_VMFGE    => fp_ge(vs2_val[i], rs1_val),\\n        VFM_VMFGT    => fp_gt(vs2_val[i], rs1_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmfgt.vf","name":"TBD","operands":[{"name":"funct6","type":"fvfmfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvfmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VFM_VMFEQ    => fp_eq(vs2_val[i], rs1_val),\\n        VFM_VMFNE    => ~(fp_eq(vs2_val[i], rs1_val)),\\n        VFM_VMFLE    => fp_le(vs2_val[i], rs1_val),\\n        VFM_VMFLT    => fp_lt(vs2_val[i], rs1_val),\\n        VFM_VMFGE    => fp_ge(vs2_val[i], rs1_val),\\n        VFM_VMFGT    => fp_gt(vs2_val[i], rs1_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmfle.vf","name":"TBD","operands":[{"name":"funct6","type":"fvfmfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvfmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VFM_VMFEQ    => fp_eq(vs2_val[i], rs1_val),\\n        VFM_VMFNE    => ~(fp_eq(vs2_val[i], rs1_val)),\\n        VFM_VMFLE    => fp_le(vs2_val[i], rs1_val),\\n        VFM_VMFLT    => fp_lt(vs2_val[i], rs1_val),\\n        VFM_VMFGE    => fp_ge(vs2_val[i], rs1_val),\\n        VFM_VMFGT    => fp_gt(vs2_val[i], rs1_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmfle.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvmfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        FVVM_VMFEQ    => fp_eq(vs2_val[i], vs1_val[i]),\\n        FVVM_VMFNE    => ~(fp_eq(vs2_val[i], vs1_val[i])),\\n        FVVM_VMFLE    => fp_le(vs2_val[i], vs1_val[i]),\\n        FVVM_VMFLT    => fp_lt(vs2_val[i], vs1_val[i])\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmflt.vf","name":"TBD","operands":[{"name":"funct6","type":"fvfmfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvfmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VFM_VMFEQ    => fp_eq(vs2_val[i], rs1_val),\\n        VFM_VMFNE    => ~(fp_eq(vs2_val[i], rs1_val)),\\n        VFM_VMFLE    => fp_le(vs2_val[i], rs1_val),\\n        VFM_VMFLT    => fp_lt(vs2_val[i], rs1_val),\\n        VFM_VMFGE    => fp_ge(vs2_val[i], rs1_val),\\n        VFM_VMFGT    => fp_gt(vs2_val[i], rs1_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmflt.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvmfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        FVVM_VMFEQ    => fp_eq(vs2_val[i], vs1_val[i]),\\n        FVVM_VMFNE    => ~(fp_eq(vs2_val[i], vs1_val[i])),\\n        FVVM_VMFLE    => fp_le(vs2_val[i], vs1_val[i]),\\n        FVVM_VMFLT    => fp_lt(vs2_val[i], vs1_val[i])\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmfne.vf","name":"TBD","operands":[{"name":"funct6","type":"fvfmfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_fvfmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar_fp(rs1, \'m);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VFM_VMFEQ    => fp_eq(vs2_val[i], rs1_val),\\n        VFM_VMFNE    => ~(fp_eq(vs2_val[i], rs1_val)),\\n        VFM_VMFLE    => fp_le(vs2_val[i], rs1_val),\\n        VFM_VMFLT    => fp_lt(vs2_val[i], rs1_val),\\n        VFM_VMFGE    => fp_ge(vs2_val[i], rs1_val),\\n        VFM_VMFGT    => fp_gt(vs2_val[i], rs1_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmfne.vv","name":"TBD","operands":[{"name":"funct6","type":"fvvmfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_fvvmfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b001","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let rm_3b    = fcsr.FRM();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_fp_vd_unmasked(SEW, rm_3b) then { handle_illegal(); return RETIRE_FAIL };\\n  assert(SEW != 8);\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        FVVM_VMFEQ    => fp_eq(vs2_val[i], vs1_val[i]),\\n        FVVM_VMFNE    => ~(fp_eq(vs2_val[i], vs1_val[i])),\\n        FVVM_VMFLE    => fp_le(vs2_val[i], vs1_val[i]),\\n        FVVM_VMFLT    => fp_lt(vs2_val[i], vs1_val[i])\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmin.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmin.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vminu.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vminu.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmnand.mm","name":"TBD","operands":[{"name":"funct6","type":"mmfunct6"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_mmfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = unsigned(vlenb) * 8;\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vs1_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs1);\\n  let vs2_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\\n  let vd_val  : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool) = undefined;\\n  mask        : vector(\'n, dec, bool) = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MM_VMAND     => vs2_val[i] & vs1_val[i],\\n        MM_VMNAND    => not(vs2_val[i] & vs1_val[i]),\\n        MM_VMANDNOT  => vs2_val[i] & not(vs1_val[i]),\\n        MM_VMXOR     => vs2_val[i] != vs1_val[i],\\n        MM_VMOR      => vs2_val[i] | vs1_val[i],\\n        MM_VMNOR     => not(vs2_val[i] | vs1_val[i]),\\n        MM_VMORNOT   => vs2_val[i] | not(vs1_val[i]),\\n        MM_VMXNOR    => vs2_val[i] == vs1_val[i]\\n      }\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmnor.mm","name":"TBD","operands":[{"name":"funct6","type":"mmfunct6"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_mmfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = unsigned(vlenb) * 8;\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vs1_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs1);\\n  let vs2_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\\n  let vd_val  : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool) = undefined;\\n  mask        : vector(\'n, dec, bool) = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MM_VMAND     => vs2_val[i] & vs1_val[i],\\n        MM_VMNAND    => not(vs2_val[i] & vs1_val[i]),\\n        MM_VMANDNOT  => vs2_val[i] & not(vs1_val[i]),\\n        MM_VMXOR     => vs2_val[i] != vs1_val[i],\\n        MM_VMOR      => vs2_val[i] | vs1_val[i],\\n        MM_VMNOR     => not(vs2_val[i] | vs1_val[i]),\\n        MM_VMORNOT   => vs2_val[i] | not(vs1_val[i]),\\n        MM_VMXNOR    => vs2_val[i] == vs1_val[i]\\n      }\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmor.mm","name":"TBD","operands":[{"name":"funct6","type":"mmfunct6"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_mmfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = unsigned(vlenb) * 8;\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vs1_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs1);\\n  let vs2_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\\n  let vd_val  : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool) = undefined;\\n  mask        : vector(\'n, dec, bool) = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MM_VMAND     => vs2_val[i] & vs1_val[i],\\n        MM_VMNAND    => not(vs2_val[i] & vs1_val[i]),\\n        MM_VMANDNOT  => vs2_val[i] & not(vs1_val[i]),\\n        MM_VMXOR     => vs2_val[i] != vs1_val[i],\\n        MM_VMOR      => vs2_val[i] | vs1_val[i],\\n        MM_VMNOR     => not(vs2_val[i] | vs1_val[i]),\\n        MM_VMORNOT   => vs2_val[i] | not(vs1_val[i]),\\n        MM_VMXNOR    => vs2_val[i] == vs1_val[i]\\n      }\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmornot.mm","name":"TBD","operands":[{"name":"funct6","type":"mmfunct6"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_mmfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = unsigned(vlenb) * 8;\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vs1_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs1);\\n  let vs2_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\\n  let vd_val  : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool) = undefined;\\n  mask        : vector(\'n, dec, bool) = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MM_VMAND     => vs2_val[i] & vs1_val[i],\\n        MM_VMNAND    => not(vs2_val[i] & vs1_val[i]),\\n        MM_VMANDNOT  => vs2_val[i] & not(vs1_val[i]),\\n        MM_VMXOR     => vs2_val[i] != vs1_val[i],\\n        MM_VMOR      => vs2_val[i] | vs1_val[i],\\n        MM_VMNOR     => not(vs2_val[i] | vs1_val[i]),\\n        MM_VMORNOT   => vs2_val[i] | not(vs1_val[i]),\\n        MM_VMXNOR    => vs2_val[i] == vs1_val[i]\\n      }\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsbc.vv","name":"TBD","operands":[{"name":"funct6","type":"vvmcfunct6"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_vvmcfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VVMC_VMADC    => unsigned(vs2_val[i]) + unsigned(vs1_val[i]) > 2 ^ SEW - 1,\\n        VVMC_VMSBC    => unsigned(vs2_val[i]) - unsigned(vs1_val[i]) < 0\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsbc.vvm","name":"TBD","operands":[{"name":"funct6","type":"vvmfunct6"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1,v0","format":"TBD","fields":[{"field":"encdec_vvmfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VVM_VMADC    => unsigned(vs2_val[i]) + unsigned(vs1_val[i]) + unsigned(bool_to_bits(vm_val[i])) > 2 ^ SEW - 1,\\n        VVM_VMSBC    => unsigned(vs2_val[i]) - unsigned(vs1_val[i]) - unsigned(bool_to_bits(vm_val[i])) < 0\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsbc.vx","name":"TBD","operands":[{"name":"funct6","type":"vxmcfunct6"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1","format":"TBD","fields":[{"field":"encdec_vxmcfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VXMC_VMADC    => unsigned(vs2_val[i]) + unsigned(rs1_val) > 2 ^ SEW - 1,\\n        VXMC_VMSBC    => unsigned(vs2_val[i]) - unsigned(rs1_val) < 0\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsbc.vxm","name":"TBD","operands":[{"name":"funct6","type":"vxmfunct6"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1,v0","format":"TBD","fields":[{"field":"encdec_vxmfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, LMUL_pow, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VXM_VMADC    => unsigned(vs2_val[i]) + unsigned(rs1_val) + unsigned(bool_to_bits(vm_val[i])) > 2 ^ SEW - 1,\\n        VXM_VMSBC    => unsigned(vs2_val[i]) - unsigned(rs1_val) - unsigned(bool_to_bits(vm_val[i])) < 0\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsbf.m","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010100","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"0b00001","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = unsigned(vlenb) * 8;\\n\\n  if illegal_normal(vd, vm) | not(assert_vstart(0)) | vd == vs2\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool) = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\\n  let vd_val  : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool) = undefined;\\n  mask        : vector(\'n, dec, bool) = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vd_val, vm_val);\\n\\n  found_elem : bool = false;\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      if vs2_val[i] then found_elem = true;\\n      result[i] = if found_elem then false else true\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmseq.vi","name":"TBD","operands":[{"name":"funct6","type":"vicmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vicmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VICMP_VMSEQ    => vs2_val[i] == imm_val,\\n        VICMP_VMSNE    => vs2_val[i] != imm_val,\\n        VICMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(imm_val),\\n        VICMP_VMSLE    => signed(vs2_val[i]) <= signed(imm_val),\\n        VICMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(imm_val),\\n        VICMP_VMSGT    => signed(vs2_val[i]) > signed(imm_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmseq.vv","name":"TBD","operands":[{"name":"funct6","type":"vvcmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VVCMP_VMSEQ    => vs2_val[i] == vs1_val[i],\\n        VVCMP_VMSNE    => vs2_val[i] != vs1_val[i],\\n        VVCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(vs1_val[i]),\\n        VVCMP_VMSLT    => signed(vs2_val[i]) < signed(vs1_val[i]),\\n        VVCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(vs1_val[i]),\\n        VVCMP_VMSLE    => signed(vs2_val[i]) <= signed(vs1_val[i])\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmseq.vx","name":"TBD","operands":[{"name":"funct6","type":"vxcmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VXCMP_VMSEQ    => vs2_val[i] == rs1_val,\\n        VXCMP_VMSNE    => vs2_val[i] != rs1_val,\\n        VXCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(rs1_val),\\n        VXCMP_VMSLT    => signed(vs2_val[i]) < signed(rs1_val),\\n        VXCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(rs1_val),\\n        VXCMP_VMSLE    => signed(vs2_val[i]) <= signed(rs1_val),\\n        VXCMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(rs1_val),\\n        VXCMP_VMSGT    => signed(vs2_val[i]) > signed(rs1_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsgt.vi","name":"TBD","operands":[{"name":"funct6","type":"vicmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vicmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VICMP_VMSEQ    => vs2_val[i] == imm_val,\\n        VICMP_VMSNE    => vs2_val[i] != imm_val,\\n        VICMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(imm_val),\\n        VICMP_VMSLE    => signed(vs2_val[i]) <= signed(imm_val),\\n        VICMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(imm_val),\\n        VICMP_VMSGT    => signed(vs2_val[i]) > signed(imm_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsgt.vx","name":"TBD","operands":[{"name":"funct6","type":"vxcmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VXCMP_VMSEQ    => vs2_val[i] == rs1_val,\\n        VXCMP_VMSNE    => vs2_val[i] != rs1_val,\\n        VXCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(rs1_val),\\n        VXCMP_VMSLT    => signed(vs2_val[i]) < signed(rs1_val),\\n        VXCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(rs1_val),\\n        VXCMP_VMSLE    => signed(vs2_val[i]) <= signed(rs1_val),\\n        VXCMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(rs1_val),\\n        VXCMP_VMSGT    => signed(vs2_val[i]) > signed(rs1_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsgtu.vi","name":"TBD","operands":[{"name":"funct6","type":"vicmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vicmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VICMP_VMSEQ    => vs2_val[i] == imm_val,\\n        VICMP_VMSNE    => vs2_val[i] != imm_val,\\n        VICMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(imm_val),\\n        VICMP_VMSLE    => signed(vs2_val[i]) <= signed(imm_val),\\n        VICMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(imm_val),\\n        VICMP_VMSGT    => signed(vs2_val[i]) > signed(imm_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsgtu.vx","name":"TBD","operands":[{"name":"funct6","type":"vxcmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VXCMP_VMSEQ    => vs2_val[i] == rs1_val,\\n        VXCMP_VMSNE    => vs2_val[i] != rs1_val,\\n        VXCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(rs1_val),\\n        VXCMP_VMSLT    => signed(vs2_val[i]) < signed(rs1_val),\\n        VXCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(rs1_val),\\n        VXCMP_VMSLE    => signed(vs2_val[i]) <= signed(rs1_val),\\n        VXCMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(rs1_val),\\n        VXCMP_VMSGT    => signed(vs2_val[i]) > signed(rs1_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsif.m","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010100","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"0b00011","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = unsigned(vlenb) * 8;\\n\\n  if illegal_normal(vd, vm) | not(assert_vstart(0)) | vd == vs2\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool) = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\\n  let vd_val  : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool) = undefined;\\n  mask        : vector(\'n, dec, bool) = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vd_val, vm_val);\\n\\n  found_elem : bool = false;\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = if found_elem then false else true;\\n      if vs2_val[i] then found_elem = true\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsle.vi","name":"TBD","operands":[{"name":"funct6","type":"vicmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vicmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VICMP_VMSEQ    => vs2_val[i] == imm_val,\\n        VICMP_VMSNE    => vs2_val[i] != imm_val,\\n        VICMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(imm_val),\\n        VICMP_VMSLE    => signed(vs2_val[i]) <= signed(imm_val),\\n        VICMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(imm_val),\\n        VICMP_VMSGT    => signed(vs2_val[i]) > signed(imm_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsle.vv","name":"TBD","operands":[{"name":"funct6","type":"vvcmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VVCMP_VMSEQ    => vs2_val[i] == vs1_val[i],\\n        VVCMP_VMSNE    => vs2_val[i] != vs1_val[i],\\n        VVCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(vs1_val[i]),\\n        VVCMP_VMSLT    => signed(vs2_val[i]) < signed(vs1_val[i]),\\n        VVCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(vs1_val[i]),\\n        VVCMP_VMSLE    => signed(vs2_val[i]) <= signed(vs1_val[i])\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsle.vx","name":"TBD","operands":[{"name":"funct6","type":"vxcmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VXCMP_VMSEQ    => vs2_val[i] == rs1_val,\\n        VXCMP_VMSNE    => vs2_val[i] != rs1_val,\\n        VXCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(rs1_val),\\n        VXCMP_VMSLT    => signed(vs2_val[i]) < signed(rs1_val),\\n        VXCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(rs1_val),\\n        VXCMP_VMSLE    => signed(vs2_val[i]) <= signed(rs1_val),\\n        VXCMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(rs1_val),\\n        VXCMP_VMSGT    => signed(vs2_val[i]) > signed(rs1_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsleu.vi","name":"TBD","operands":[{"name":"funct6","type":"vicmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vicmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VICMP_VMSEQ    => vs2_val[i] == imm_val,\\n        VICMP_VMSNE    => vs2_val[i] != imm_val,\\n        VICMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(imm_val),\\n        VICMP_VMSLE    => signed(vs2_val[i]) <= signed(imm_val),\\n        VICMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(imm_val),\\n        VICMP_VMSGT    => signed(vs2_val[i]) > signed(imm_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsleu.vv","name":"TBD","operands":[{"name":"funct6","type":"vvcmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VVCMP_VMSEQ    => vs2_val[i] == vs1_val[i],\\n        VVCMP_VMSNE    => vs2_val[i] != vs1_val[i],\\n        VVCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(vs1_val[i]),\\n        VVCMP_VMSLT    => signed(vs2_val[i]) < signed(vs1_val[i]),\\n        VVCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(vs1_val[i]),\\n        VVCMP_VMSLE    => signed(vs2_val[i]) <= signed(vs1_val[i])\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsleu.vx","name":"TBD","operands":[{"name":"funct6","type":"vxcmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VXCMP_VMSEQ    => vs2_val[i] == rs1_val,\\n        VXCMP_VMSNE    => vs2_val[i] != rs1_val,\\n        VXCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(rs1_val),\\n        VXCMP_VMSLT    => signed(vs2_val[i]) < signed(rs1_val),\\n        VXCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(rs1_val),\\n        VXCMP_VMSLE    => signed(vs2_val[i]) <= signed(rs1_val),\\n        VXCMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(rs1_val),\\n        VXCMP_VMSGT    => signed(vs2_val[i]) > signed(rs1_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmslt.vv","name":"TBD","operands":[{"name":"funct6","type":"vvcmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VVCMP_VMSEQ    => vs2_val[i] == vs1_val[i],\\n        VVCMP_VMSNE    => vs2_val[i] != vs1_val[i],\\n        VVCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(vs1_val[i]),\\n        VVCMP_VMSLT    => signed(vs2_val[i]) < signed(vs1_val[i]),\\n        VVCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(vs1_val[i]),\\n        VVCMP_VMSLE    => signed(vs2_val[i]) <= signed(vs1_val[i])\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmslt.vx","name":"TBD","operands":[{"name":"funct6","type":"vxcmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VXCMP_VMSEQ    => vs2_val[i] == rs1_val,\\n        VXCMP_VMSNE    => vs2_val[i] != rs1_val,\\n        VXCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(rs1_val),\\n        VXCMP_VMSLT    => signed(vs2_val[i]) < signed(rs1_val),\\n        VXCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(rs1_val),\\n        VXCMP_VMSLE    => signed(vs2_val[i]) <= signed(rs1_val),\\n        VXCMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(rs1_val),\\n        VXCMP_VMSGT    => signed(vs2_val[i]) > signed(rs1_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsltu.vv","name":"TBD","operands":[{"name":"funct6","type":"vvcmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VVCMP_VMSEQ    => vs2_val[i] == vs1_val[i],\\n        VVCMP_VMSNE    => vs2_val[i] != vs1_val[i],\\n        VVCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(vs1_val[i]),\\n        VVCMP_VMSLT    => signed(vs2_val[i]) < signed(vs1_val[i]),\\n        VVCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(vs1_val[i]),\\n        VVCMP_VMSLE    => signed(vs2_val[i]) <= signed(vs1_val[i])\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsltu.vx","name":"TBD","operands":[{"name":"funct6","type":"vxcmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VXCMP_VMSEQ    => vs2_val[i] == rs1_val,\\n        VXCMP_VMSNE    => vs2_val[i] != rs1_val,\\n        VXCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(rs1_val),\\n        VXCMP_VMSLT    => signed(vs2_val[i]) < signed(rs1_val),\\n        VXCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(rs1_val),\\n        VXCMP_VMSLE    => signed(vs2_val[i]) <= signed(rs1_val),\\n        VXCMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(rs1_val),\\n        VXCMP_VMSGT    => signed(vs2_val[i]) > signed(rs1_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsne.vi","name":"TBD","operands":[{"name":"funct6","type":"vicmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vicmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VICMP_VMSEQ    => vs2_val[i] == imm_val,\\n        VICMP_VMSNE    => vs2_val[i] != imm_val,\\n        VICMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(imm_val),\\n        VICMP_VMSLE    => signed(vs2_val[i]) <= signed(imm_val),\\n        VICMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(imm_val),\\n        VICMP_VMSGT    => signed(vs2_val[i]) > signed(imm_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsne.vv","name":"TBD","operands":[{"name":"funct6","type":"vvcmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VVCMP_VMSEQ    => vs2_val[i] == vs1_val[i],\\n        VVCMP_VMSNE    => vs2_val[i] != vs1_val[i],\\n        VVCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(vs1_val[i]),\\n        VVCMP_VMSLT    => signed(vs2_val[i]) < signed(vs1_val[i]),\\n        VVCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(vs1_val[i]),\\n        VVCMP_VMSLE    => signed(vs2_val[i]) <= signed(vs1_val[i])\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsne.vx","name":"TBD","operands":[{"name":"funct6","type":"vxcmpfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxcmpfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool)     = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let res : bool = match funct6 {\\n        VXCMP_VMSEQ    => vs2_val[i] == rs1_val,\\n        VXCMP_VMSNE    => vs2_val[i] != rs1_val,\\n        VXCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(rs1_val),\\n        VXCMP_VMSLT    => signed(vs2_val[i]) < signed(rs1_val),\\n        VXCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(rs1_val),\\n        VXCMP_VMSLE    => signed(vs2_val[i]) <= signed(rs1_val),\\n        VXCMP_VMSGTU   => unsigned(vs2_val[i]) > unsigned(rs1_val),\\n        VXCMP_VMSGT    => signed(vs2_val[i]) > signed(rs1_val)\\n      };\\n      result[i] = res\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmsof.m","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010100","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"0b00010","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = unsigned(vlenb) * 8;\\n\\n  if illegal_normal(vd, vm) | not(assert_vstart(0)) | vd == vs2\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool) = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\\n  let vd_val  : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool) = undefined;\\n  mask        : vector(\'n, dec, bool) = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vd_val, vm_val);\\n\\n  found_elem : bool = false;\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      if vs2_val[i] & not(found_elem) then {\\n        result[i] = true;\\n        found_elem = true\\n      } else {\\n        result[i] = false\\n      }\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmul.vv","name":"TBD","operands":[{"name":"funct6","type":"mvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVV_VAADDU   => {\\n                          let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VAADD    => {\\n                          let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUBU   => {\\n                          let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUB    => {\\n                          let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VDIVU    => {\\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          to_bits(SEW, q)\\n                        },\\n        MVV_VDIV     => {\\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* check for signed overflow */\\n                          let q\' : int = if q > elem_max then elem_min else q;\\n                          to_bits(SEW, q\')\\n                        },\\n        MVV_VREMU    => {\\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        },\\n        MVV_VREM     => {\\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmul.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VAADDU       => {\\n                              let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VAADD        => {\\n                              let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUBU       => {\\n                              let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUB        => {\\n                              let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VSLIDE1UP    => {\\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        MVX_VSLIDE1DOWN  => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            },\\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VDIVU        => {\\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\\n                              to_bits(SEW, q)\\n                            },\\n        MVX_VDIV         => {\\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* check for signed overflow */\\n                              let q\' : int = if q > elem_max then elem_min else q;\\n                              to_bits(SEW, q\')\\n                            },\\n        MVX_VREMU        => {\\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            },\\n        MVX_VREM         => {\\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmulh.vv","name":"TBD","operands":[{"name":"funct6","type":"mvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVV_VAADDU   => {\\n                          let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VAADD    => {\\n                          let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUBU   => {\\n                          let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUB    => {\\n                          let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VDIVU    => {\\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          to_bits(SEW, q)\\n                        },\\n        MVV_VDIV     => {\\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* check for signed overflow */\\n                          let q\' : int = if q > elem_max then elem_min else q;\\n                          to_bits(SEW, q\')\\n                        },\\n        MVV_VREMU    => {\\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        },\\n        MVV_VREM     => {\\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmulh.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VAADDU       => {\\n                              let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VAADD        => {\\n                              let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUBU       => {\\n                              let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUB        => {\\n                              let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VSLIDE1UP    => {\\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        MVX_VSLIDE1DOWN  => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            },\\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VDIVU        => {\\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\\n                              to_bits(SEW, q)\\n                            },\\n        MVX_VDIV         => {\\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* check for signed overflow */\\n                              let q\' : int = if q > elem_max then elem_min else q;\\n                              to_bits(SEW, q\')\\n                            },\\n        MVX_VREMU        => {\\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            },\\n        MVX_VREM         => {\\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmulhsu.vv","name":"TBD","operands":[{"name":"funct6","type":"mvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVV_VAADDU   => {\\n                          let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VAADD    => {\\n                          let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUBU   => {\\n                          let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUB    => {\\n                          let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VDIVU    => {\\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          to_bits(SEW, q)\\n                        },\\n        MVV_VDIV     => {\\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* check for signed overflow */\\n                          let q\' : int = if q > elem_max then elem_min else q;\\n                          to_bits(SEW, q\')\\n                        },\\n        MVV_VREMU    => {\\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        },\\n        MVV_VREM     => {\\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmulhsu.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VAADDU       => {\\n                              let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VAADD        => {\\n                              let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUBU       => {\\n                              let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUB        => {\\n                              let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VSLIDE1UP    => {\\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        MVX_VSLIDE1DOWN  => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            },\\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VDIVU        => {\\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\\n                              to_bits(SEW, q)\\n                            },\\n        MVX_VDIV         => {\\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* check for signed overflow */\\n                              let q\' : int = if q > elem_max then elem_min else q;\\n                              to_bits(SEW, q\')\\n                            },\\n        MVX_VREMU        => {\\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            },\\n        MVX_VREM         => {\\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmulhu.vv","name":"TBD","operands":[{"name":"funct6","type":"mvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVV_VAADDU   => {\\n                          let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VAADD    => {\\n                          let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUBU   => {\\n                          let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUB    => {\\n                          let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VDIVU    => {\\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          to_bits(SEW, q)\\n                        },\\n        MVV_VDIV     => {\\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* check for signed overflow */\\n                          let q\' : int = if q > elem_max then elem_min else q;\\n                          to_bits(SEW, q\')\\n                        },\\n        MVV_VREMU    => {\\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        },\\n        MVV_VREM     => {\\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmulhu.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VAADDU       => {\\n                              let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VAADD        => {\\n                              let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUBU       => {\\n                              let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUB        => {\\n                              let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VSLIDE1UP    => {\\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        MVX_VSLIDE1DOWN  => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            },\\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VDIVU        => {\\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\\n                              to_bits(SEW, q)\\n                            },\\n        MVX_VDIV         => {\\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* check for signed overflow */\\n                              let q\' : int = if q > elem_max then elem_min else q;\\n                              to_bits(SEW, q\')\\n                            },\\n        MVX_VREMU        => {\\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            },\\n        MVX_VREM         => {\\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmv.s.x","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"0b1","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let num_elem = get_num_elem(0, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  assert(num_elem > 0);\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, \'m);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, 0, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, 0, vd_val, vm_val);\\n\\n  /* one body element */\\n  if mask[0] then result[0] = rs1_val;\\n\\n  /* others treated as tail elements */\\n  let tail_ag : agtype = get_vtype_vta();\\n  foreach (i from 1 to (num_elem - 1)) {\\n    result[i] = match tail_ag {\\n      UNDISTURBED => vd_val[i],\\n      AGNOSTIC    => vd_val[i] /* TODO: configuration support */\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, 0, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmv.v.i","name":"TBD","operands":[{"name":"vd","type":"regidx"},{"name":"simm","type":"bits(5)"}],"syntax":"vd,simm","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b1","size":1},{"field":"0b00000","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then result[i] = imm_val\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmv.v.v","name":"TBD","operands":[{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b1","size":1},{"field":"0b00000","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then result[i] = vs1_val[i]\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmv.v.x","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1","format":"TBD","fields":[{"field":"0b010111","size":6},{"field":"0b1","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, \'m);\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then result[i] = rs1_val\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmv.x.s","name":"TBD","operands":[{"name":"vs2","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,vs2","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"0b00000","size":5},{"field":"0b010","size":3},{"field":"rd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let num_elem = get_num_elem(0, SEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  assert(num_elem > 0);\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, 0, vs2);\\n  X(rd) = if sizeof(xlen) < SEW then slice(vs2_val[0], 0, sizeof(xlen))\\n          else if sizeof(xlen) > SEW then sign_extend(vs2_val[0])\\n          else vs2_val[0];\\n  vstart = zeros();\\n\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmv1r.v","name":"TBD","operands":[{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2","format":"TBD","fields":[{"field":"0b100111","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let start_element = get_start_element();\\n  let SEW     = get_sew();\\n  let imm_val = unsigned(zero_extend(sizeof(xlen), simm));\\n  let EMUL    = imm_val + 1;\\n\\n  if not(EMUL == 1 | EMUL == 2 | EMUL == 4 | EMUL == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let EMUL_pow = log2(EMUL);\\n  let num_elem = get_num_elem(EMUL_pow, SEW);\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, EMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, EMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    result[i] = if i < start_element then vd_val[i] else vs2_val[i]\\n  };\\n\\n  write_vreg(num_elem, SEW, EMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmv2r.v","name":"TBD","operands":[{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2","format":"TBD","fields":[{"field":"0b100111","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let start_element = get_start_element();\\n  let SEW     = get_sew();\\n  let imm_val = unsigned(zero_extend(sizeof(xlen), simm));\\n  let EMUL    = imm_val + 1;\\n\\n  if not(EMUL == 1 | EMUL == 2 | EMUL == 4 | EMUL == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let EMUL_pow = log2(EMUL);\\n  let num_elem = get_num_elem(EMUL_pow, SEW);\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, EMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, EMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    result[i] = if i < start_element then vd_val[i] else vs2_val[i]\\n  };\\n\\n  write_vreg(num_elem, SEW, EMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmv4r.v","name":"TBD","operands":[{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2","format":"TBD","fields":[{"field":"0b100111","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let start_element = get_start_element();\\n  let SEW     = get_sew();\\n  let imm_val = unsigned(zero_extend(sizeof(xlen), simm));\\n  let EMUL    = imm_val + 1;\\n\\n  if not(EMUL == 1 | EMUL == 2 | EMUL == 4 | EMUL == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let EMUL_pow = log2(EMUL);\\n  let num_elem = get_num_elem(EMUL_pow, SEW);\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, EMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, EMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    result[i] = if i < start_element then vd_val[i] else vs2_val[i]\\n  };\\n\\n  write_vreg(num_elem, SEW, EMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmv8r.v","name":"TBD","operands":[{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2","format":"TBD","fields":[{"field":"0b100111","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let start_element = get_start_element();\\n  let SEW     = get_sew();\\n  let imm_val = unsigned(zero_extend(sizeof(xlen), simm));\\n  let EMUL    = imm_val + 1;\\n\\n  if not(EMUL == 1 | EMUL == 2 | EMUL == 4 | EMUL == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let EMUL_pow = log2(EMUL);\\n  let num_elem = get_num_elem(EMUL_pow, SEW);\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, 0b1, 0b00000);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, EMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, EMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    result[i] = if i < start_element then vd_val[i] else vs2_val[i]\\n  };\\n\\n  write_vreg(num_elem, SEW, EMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmxnor.mm","name":"TBD","operands":[{"name":"funct6","type":"mmfunct6"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_mmfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = unsigned(vlenb) * 8;\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vs1_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs1);\\n  let vs2_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\\n  let vd_val  : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool) = undefined;\\n  mask        : vector(\'n, dec, bool) = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MM_VMAND     => vs2_val[i] & vs1_val[i],\\n        MM_VMNAND    => not(vs2_val[i] & vs1_val[i]),\\n        MM_VMANDNOT  => vs2_val[i] & not(vs1_val[i]),\\n        MM_VMXOR     => vs2_val[i] != vs1_val[i],\\n        MM_VMOR      => vs2_val[i] | vs1_val[i],\\n        MM_VMNOR     => not(vs2_val[i] | vs1_val[i]),\\n        MM_VMORNOT   => vs2_val[i] | not(vs1_val[i]),\\n        MM_VMXNOR    => vs2_val[i] == vs1_val[i]\\n      }\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vmxor.mm","name":"TBD","operands":[{"name":"funct6","type":"mmfunct6"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1","format":"TBD","fields":[{"field":"encdec_mmfunct6(funct6)","size":6},{"field":"0b1","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = unsigned(vlenb) * 8;\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vs1_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs1);\\n  let vs2_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\\n  let vd_val  : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vd);\\n  result      : vector(\'n, dec, bool) = undefined;\\n  mask        : vector(\'n, dec, bool) = undefined;\\n\\n  (result, mask) = init_masked_result_carry(num_elem, SEW, 0, vd_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MM_VMAND     => vs2_val[i] & vs1_val[i],\\n        MM_VMNAND    => not(vs2_val[i] & vs1_val[i]),\\n        MM_VMANDNOT  => vs2_val[i] & not(vs1_val[i]),\\n        MM_VMXOR     => vs2_val[i] != vs1_val[i],\\n        MM_VMOR      => vs2_val[i] | vs1_val[i],\\n        MM_VMNOR     => not(vs2_val[i] | vs1_val[i]),\\n        MM_VMORNOT   => vs2_val[i] | not(vs1_val[i]),\\n        MM_VMXNOR    => vs2_val[i] == vs1_val[i]\\n      }\\n    }\\n  };\\n\\n  write_vmask(num_elem, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vnclip.wi","name":"TBD","operands":[{"name":"funct6","type":"nifunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_nifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW_widen <= 64);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let shift_amount = get_shift_amount(imm_val, SEW_widen);\\n      let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n      result[i] = match funct6 {\\n        NI_VNCLIPU => {\\n                        let result_wide = (vs2_val[i] >> shift_amount) + zero_extend(\'o, rounding_incr);\\n                        unsigned_saturation(\'m, result_wide)\\n                      },\\n        NI_VNCLIP  => {\\n                        let v_double : bits(\'m * 4) = sign_extend(vs2_val[i]);\\n                        let result_wide = slice(v_double >> shift_amount, 0, \'o) + zero_extend(\'o, rounding_incr);\\n                        signed_saturation(\'m, result_wide)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vnclip.wv","name":"TBD","operands":[{"name":"funct6","type":"nvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_nvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW_widen <= 64);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let shift_amount = get_shift_amount(vs1_val[i], SEW_widen);\\n      let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n      result[i] = match funct6 {\\n        NV_VNCLIPU => {\\n                        let result_wide = (vs2_val[i] >> shift_amount) + zero_extend(\'o, rounding_incr);\\n                        unsigned_saturation(\'m, result_wide);\\n                      },\\n        NV_VNCLIP  => {\\n                        let v_double : bits(\'m * 4) = sign_extend(vs2_val[i]);\\n                        let result_wide = slice(v_double >> shift_amount, 0, \'o) + zero_extend(\'o, rounding_incr);\\n                        signed_saturation(\'m, result_wide);\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vnclip.wx","name":"TBD","operands":[{"name":"funct6","type":"nxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_nxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW_widen <= 64);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let shift_amount = get_shift_amount(rs1_val, SEW_widen);\\n      let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n      result[i] = match funct6 {\\n        NX_VNCLIPU => {\\n                        let result_wide = (vs2_val[i] >> shift_amount) + zero_extend(\'o, rounding_incr);\\n                        unsigned_saturation(\'m, result_wide)\\n                      },\\n        NX_VNCLIP  => {\\n                        let v_double : bits(\'m * 4) = sign_extend(vs2_val[i]);\\n                        let result_wide = slice(v_double >> shift_amount, 0, \'o) + zero_extend(\'o, rounding_incr);\\n                        signed_saturation(\'m, result_wide)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vnclipu.wi","name":"TBD","operands":[{"name":"funct6","type":"nifunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_nifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW_widen <= 64);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let shift_amount = get_shift_amount(imm_val, SEW_widen);\\n      let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n      result[i] = match funct6 {\\n        NI_VNCLIPU => {\\n                        let result_wide = (vs2_val[i] >> shift_amount) + zero_extend(\'o, rounding_incr);\\n                        unsigned_saturation(\'m, result_wide)\\n                      },\\n        NI_VNCLIP  => {\\n                        let v_double : bits(\'m * 4) = sign_extend(vs2_val[i]);\\n                        let result_wide = slice(v_double >> shift_amount, 0, \'o) + zero_extend(\'o, rounding_incr);\\n                        signed_saturation(\'m, result_wide)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vnclipu.wv","name":"TBD","operands":[{"name":"funct6","type":"nvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_nvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW_widen <= 64);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let shift_amount = get_shift_amount(vs1_val[i], SEW_widen);\\n      let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n      result[i] = match funct6 {\\n        NV_VNCLIPU => {\\n                        let result_wide = (vs2_val[i] >> shift_amount) + zero_extend(\'o, rounding_incr);\\n                        unsigned_saturation(\'m, result_wide);\\n                      },\\n        NV_VNCLIP  => {\\n                        let v_double : bits(\'m * 4) = sign_extend(vs2_val[i]);\\n                        let result_wide = slice(v_double >> shift_amount, 0, \'o) + zero_extend(\'o, rounding_incr);\\n                        signed_saturation(\'m, result_wide);\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vnclipu.wx","name":"TBD","operands":[{"name":"funct6","type":"nxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_nxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW_widen <= 64);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      let shift_amount = get_shift_amount(rs1_val, SEW_widen);\\n      let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n      result[i] = match funct6 {\\n        NX_VNCLIPU => {\\n                        let result_wide = (vs2_val[i] >> shift_amount) + zero_extend(\'o, rounding_incr);\\n                        unsigned_saturation(\'m, result_wide)\\n                      },\\n        NX_VNCLIP  => {\\n                        let v_double : bits(\'m * 4) = sign_extend(vs2_val[i]);\\n                        let result_wide = slice(v_double >> shift_amount, 0, \'o) + zero_extend(\'o, rounding_incr);\\n                        signed_saturation(\'m, result_wide)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vnmsac.vv","name":"TBD","operands":[{"name":"funct6","type":"mvvmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_mvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVV_VMACC  => get_slice_int(SEW, signed(vs1_val[i]) * signed(vs2_val[i]), 0) + vd_val[i],\\n        MVV_VNMSAC => vd_val[i] - get_slice_int(SEW, signed(vs1_val[i]) * signed(vs2_val[i]), 0),\\n        MVV_VMADD  => get_slice_int(SEW, signed(vs1_val[i]) * signed(vd_val[i]), 0) + vs2_val[i],\\n        MVV_VNMSUB => vs2_val[i] - get_slice_int(SEW, signed(vs1_val[i]) * signed(vd_val[i]), 0)\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vnmsac.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_mvxmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VMACC  => get_slice_int(SEW, signed(rs1_val) * signed(vs2_val[i]), 0) + vd_val[i],\\n        MVX_VNMSAC => vd_val[i] - get_slice_int(SEW, signed(rs1_val) * signed(vs2_val[i]), 0),\\n        MVX_VMADD  => get_slice_int(SEW, signed(rs1_val) * signed(vd_val[i]), 0) + vs2_val[i],\\n        MVX_VNMSUB => vs2_val[i] - get_slice_int(SEW, signed(rs1_val) * signed(vd_val[i]), 0)\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vnmsub.vv","name":"TBD","operands":[{"name":"funct6","type":"mvvmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_mvvmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVV_VMACC  => get_slice_int(SEW, signed(vs1_val[i]) * signed(vs2_val[i]), 0) + vd_val[i],\\n        MVV_VNMSAC => vd_val[i] - get_slice_int(SEW, signed(vs1_val[i]) * signed(vs2_val[i]), 0),\\n        MVV_VMADD  => get_slice_int(SEW, signed(vs1_val[i]) * signed(vd_val[i]), 0) + vs2_val[i],\\n        MVV_VNMSUB => vs2_val[i] - get_slice_int(SEW, signed(vs1_val[i]) * signed(vd_val[i]), 0)\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vnmsub.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxmafunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_mvxmafunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VMACC  => get_slice_int(SEW, signed(rs1_val) * signed(vs2_val[i]), 0) + vd_val[i],\\n        MVX_VNMSAC => vd_val[i] - get_slice_int(SEW, signed(rs1_val) * signed(vs2_val[i]), 0),\\n        MVX_VMADD  => get_slice_int(SEW, signed(rs1_val) * signed(vd_val[i]), 0) + vs2_val[i],\\n        MVX_VNMSUB => vs2_val[i] - get_slice_int(SEW, signed(rs1_val) * signed(vd_val[i]), 0)\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vnsra.wi","name":"TBD","operands":[{"name":"funct6","type":"nisfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_nisfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW_widen <= 64);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        NIS_VNSRL  => {\\n                        let shift_amount = get_shift_amount(imm_val, SEW_widen);\\n                        slice(vs2_val[i] >> shift_amount, 0, SEW)\\n                      },\\n        NIS_VNSRA  => {\\n                        let shift_amount = get_shift_amount(imm_val, SEW_widen);\\n                        let v_double : bits(\'o * 2) = sign_extend(vs2_val[i]);\\n                        let arith_shifted : bits(\'o) = slice(v_double >> shift_amount, 0, SEW_widen);\\n                        slice(arith_shifted, 0, SEW)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vnsra.wv","name":"TBD","operands":[{"name":"funct6","type":"nvsfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_nvsfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW_widen <= 64);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        NVS_VNSRL  => {\\n                        let shift_amount = get_shift_amount(vs1_val[i], SEW_widen);\\n                        slice(vs2_val[i] >> shift_amount, 0, SEW)\\n                      },\\n        NVS_VNSRA  => {\\n                        let shift_amount = get_shift_amount(vs1_val[i], SEW_widen);\\n                        let v_double : bits(\'o * 2) = sign_extend(vs2_val[i]);\\n                        let arith_shifted : bits(\'o) = slice(v_double >> shift_amount, 0, SEW_widen);\\n                        slice(arith_shifted, 0, SEW)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vnsra.wx","name":"TBD","operands":[{"name":"funct6","type":"nxsfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_nxsfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW_widen <= 64);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        NXS_VNSRL  => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW_widen);\\n                        slice(vs2_val[i] >> shift_amount, 0, SEW)\\n                      },\\n        NXS_VNSRA  => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW_widen);\\n                        let v_double : bits(\'o * 2) = sign_extend(vs2_val[i]);\\n                        let arith_shifted : bits(\'o) = slice(v_double >> shift_amount, 0, SEW_widen);\\n                        slice(arith_shifted, 0, SEW)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vnsrl.wi","name":"TBD","operands":[{"name":"funct6","type":"nisfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_nisfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW_widen <= 64);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        NIS_VNSRL  => {\\n                        let shift_amount = get_shift_amount(imm_val, SEW_widen);\\n                        slice(vs2_val[i] >> shift_amount, 0, SEW)\\n                      },\\n        NIS_VNSRA  => {\\n                        let shift_amount = get_shift_amount(imm_val, SEW_widen);\\n                        let v_double : bits(\'o * 2) = sign_extend(vs2_val[i]);\\n                        let arith_shifted : bits(\'o) = slice(v_double >> shift_amount, 0, SEW_widen);\\n                        slice(arith_shifted, 0, SEW)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vnsrl.wv","name":"TBD","operands":[{"name":"funct6","type":"nvsfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_nvsfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW_widen <= 64);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        NVS_VNSRL  => {\\n                        let shift_amount = get_shift_amount(vs1_val[i], SEW_widen);\\n                        slice(vs2_val[i] >> shift_amount, 0, SEW)\\n                      },\\n        NVS_VNSRA  => {\\n                        let shift_amount = get_shift_amount(vs1_val[i], SEW_widen);\\n                        let v_double : bits(\'o * 2) = sign_extend(vs2_val[i]);\\n                        let arith_shifted : bits(\'o) = slice(v_double >> shift_amount, 0, SEW_widen);\\n                        slice(arith_shifted, 0, SEW)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vnsrl.wx","name":"TBD","operands":[{"name":"funct6","type":"nxsfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_nxsfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_widen, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW_widen <= 64);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        NXS_VNSRL  => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW_widen);\\n                        slice(vs2_val[i] >> shift_amount, 0, SEW)\\n                      },\\n        NXS_VNSRA  => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW_widen);\\n                        let v_double : bits(\'o * 2) = sign_extend(vs2_val[i]);\\n                        let arith_shifted : bits(\'o) = slice(v_double >> shift_amount, 0, SEW_widen);\\n                        slice(arith_shifted, 0, SEW)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vor.vi","name":"TBD","operands":[{"name":"funct6","type":"vifunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VI_VADD    => vs2_val[i] + imm_val,\\n        VI_VRSUB   => imm_val - vs2_val[i],\\n        VI_VAND    => vs2_val[i] & imm_val,\\n        VI_VOR     => vs2_val[i] | imm_val,\\n        VI_VXOR    => vs2_val[i] ^ imm_val,\\n        VI_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, imm_val) ),\\n        VI_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, imm_val) ),\\n        VI_VSLL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VI_VSRL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VI_VSRA    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VI_VSSRL   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VI_VSSRA   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vor.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vor.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vpopc.m","name":"TBD","operands":[{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,vs2vm","format":"TBD","fields":[{"field":"0b010000","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"0b10000","size":5},{"field":"0b010","size":3},{"field":"rd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = unsigned(vlenb) * 8;\\n\\n  if illegal_vd_unmasked() | not(assert_vstart(0)) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool) = read_vmask(num_elem, vm, 0b00000);\\n  let vs2_val : vector(\'n, dec, bool) = read_vmask(num_elem, 0b0, vs2);\\n  result      : vector(\'n, dec, bool) = undefined;\\n  mask        : vector(\'n, dec, bool) = undefined;\\n\\n  (result, mask) = init_masked_result_cmp(num_elem, SEW, 0, vs2_val, vm_val);\\n\\n  count : nat = 0;\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] & vs2_val[i] then count = count + 1;\\n  };\\n\\n  X(rd) = to_bits(sizeof(xlen), count);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vredand.vs","name":"TBD","operands":[{"name":"funct6","type":"rmvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\\n  let num_elem_vd = get_num_elem(0, SEW); /* vd regardless of LMUL setting */\\n\\n  if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\\n\\n  let \'n = num_elem_vs;\\n  let \'d = num_elem_vd;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\\n  let vd_val  : vector(\'d, dec, bits(\'m)) = read_vreg(num_elem_vd, SEW, 0, vd);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\\n  let mask    : vector(\'n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\\n\\n  sum : bits(\'m) = read_single_element(SEW, 0, vs1); /* vs1 regardless of LMUL setting */\\n  foreach (i from 0 to (num_elem_vs - 1)) {\\n    if mask[i] then {\\n      sum = match funct6 {\\n        MVV_VREDSUM   => sum + vs2_val[i],\\n        MVV_VREDAND   => sum & vs2_val[i],\\n        MVV_VREDOR    => sum | vs2_val[i],\\n        MVV_VREDXOR   => sum ^ vs2_val[i],\\n        MVV_VREDMIN   => to_bits(SEW, min(signed(vs2_val[i]), signed(sum))),\\n        MVV_VREDMINU  => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(sum))),\\n        MVV_VREDMAX   => to_bits(SEW, max(signed(vs2_val[i]), signed(sum))),\\n        MVV_VREDMAXU  => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(sum)))\\n      }\\n    }\\n  };\\n\\n  write_single_element(SEW, 0, vd, sum);\\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\\n  /* TODO: configuration support for agnostic behavior */\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vredmax.vs","name":"TBD","operands":[{"name":"funct6","type":"rmvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\\n  let num_elem_vd = get_num_elem(0, SEW); /* vd regardless of LMUL setting */\\n\\n  if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\\n\\n  let \'n = num_elem_vs;\\n  let \'d = num_elem_vd;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\\n  let vd_val  : vector(\'d, dec, bits(\'m)) = read_vreg(num_elem_vd, SEW, 0, vd);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\\n  let mask    : vector(\'n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\\n\\n  sum : bits(\'m) = read_single_element(SEW, 0, vs1); /* vs1 regardless of LMUL setting */\\n  foreach (i from 0 to (num_elem_vs - 1)) {\\n    if mask[i] then {\\n      sum = match funct6 {\\n        MVV_VREDSUM   => sum + vs2_val[i],\\n        MVV_VREDAND   => sum & vs2_val[i],\\n        MVV_VREDOR    => sum | vs2_val[i],\\n        MVV_VREDXOR   => sum ^ vs2_val[i],\\n        MVV_VREDMIN   => to_bits(SEW, min(signed(vs2_val[i]), signed(sum))),\\n        MVV_VREDMINU  => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(sum))),\\n        MVV_VREDMAX   => to_bits(SEW, max(signed(vs2_val[i]), signed(sum))),\\n        MVV_VREDMAXU  => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(sum)))\\n      }\\n    }\\n  };\\n\\n  write_single_element(SEW, 0, vd, sum);\\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\\n  /* TODO: configuration support for agnostic behavior */\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vredmaxu.vs","name":"TBD","operands":[{"name":"funct6","type":"rmvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\\n  let num_elem_vd = get_num_elem(0, SEW); /* vd regardless of LMUL setting */\\n\\n  if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\\n\\n  let \'n = num_elem_vs;\\n  let \'d = num_elem_vd;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\\n  let vd_val  : vector(\'d, dec, bits(\'m)) = read_vreg(num_elem_vd, SEW, 0, vd);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\\n  let mask    : vector(\'n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\\n\\n  sum : bits(\'m) = read_single_element(SEW, 0, vs1); /* vs1 regardless of LMUL setting */\\n  foreach (i from 0 to (num_elem_vs - 1)) {\\n    if mask[i] then {\\n      sum = match funct6 {\\n        MVV_VREDSUM   => sum + vs2_val[i],\\n        MVV_VREDAND   => sum & vs2_val[i],\\n        MVV_VREDOR    => sum | vs2_val[i],\\n        MVV_VREDXOR   => sum ^ vs2_val[i],\\n        MVV_VREDMIN   => to_bits(SEW, min(signed(vs2_val[i]), signed(sum))),\\n        MVV_VREDMINU  => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(sum))),\\n        MVV_VREDMAX   => to_bits(SEW, max(signed(vs2_val[i]), signed(sum))),\\n        MVV_VREDMAXU  => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(sum)))\\n      }\\n    }\\n  };\\n\\n  write_single_element(SEW, 0, vd, sum);\\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\\n  /* TODO: configuration support for agnostic behavior */\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vredmin.vs","name":"TBD","operands":[{"name":"funct6","type":"rmvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\\n  let num_elem_vd = get_num_elem(0, SEW); /* vd regardless of LMUL setting */\\n\\n  if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\\n\\n  let \'n = num_elem_vs;\\n  let \'d = num_elem_vd;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\\n  let vd_val  : vector(\'d, dec, bits(\'m)) = read_vreg(num_elem_vd, SEW, 0, vd);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\\n  let mask    : vector(\'n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\\n\\n  sum : bits(\'m) = read_single_element(SEW, 0, vs1); /* vs1 regardless of LMUL setting */\\n  foreach (i from 0 to (num_elem_vs - 1)) {\\n    if mask[i] then {\\n      sum = match funct6 {\\n        MVV_VREDSUM   => sum + vs2_val[i],\\n        MVV_VREDAND   => sum & vs2_val[i],\\n        MVV_VREDOR    => sum | vs2_val[i],\\n        MVV_VREDXOR   => sum ^ vs2_val[i],\\n        MVV_VREDMIN   => to_bits(SEW, min(signed(vs2_val[i]), signed(sum))),\\n        MVV_VREDMINU  => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(sum))),\\n        MVV_VREDMAX   => to_bits(SEW, max(signed(vs2_val[i]), signed(sum))),\\n        MVV_VREDMAXU  => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(sum)))\\n      }\\n    }\\n  };\\n\\n  write_single_element(SEW, 0, vd, sum);\\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\\n  /* TODO: configuration support for agnostic behavior */\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vredminu.vs","name":"TBD","operands":[{"name":"funct6","type":"rmvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\\n  let num_elem_vd = get_num_elem(0, SEW); /* vd regardless of LMUL setting */\\n\\n  if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\\n\\n  let \'n = num_elem_vs;\\n  let \'d = num_elem_vd;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\\n  let vd_val  : vector(\'d, dec, bits(\'m)) = read_vreg(num_elem_vd, SEW, 0, vd);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\\n  let mask    : vector(\'n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\\n\\n  sum : bits(\'m) = read_single_element(SEW, 0, vs1); /* vs1 regardless of LMUL setting */\\n  foreach (i from 0 to (num_elem_vs - 1)) {\\n    if mask[i] then {\\n      sum = match funct6 {\\n        MVV_VREDSUM   => sum + vs2_val[i],\\n        MVV_VREDAND   => sum & vs2_val[i],\\n        MVV_VREDOR    => sum | vs2_val[i],\\n        MVV_VREDXOR   => sum ^ vs2_val[i],\\n        MVV_VREDMIN   => to_bits(SEW, min(signed(vs2_val[i]), signed(sum))),\\n        MVV_VREDMINU  => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(sum))),\\n        MVV_VREDMAX   => to_bits(SEW, max(signed(vs2_val[i]), signed(sum))),\\n        MVV_VREDMAXU  => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(sum)))\\n      }\\n    }\\n  };\\n\\n  write_single_element(SEW, 0, vd, sum);\\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\\n  /* TODO: configuration support for agnostic behavior */\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vredor.vs","name":"TBD","operands":[{"name":"funct6","type":"rmvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\\n  let num_elem_vd = get_num_elem(0, SEW); /* vd regardless of LMUL setting */\\n\\n  if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\\n\\n  let \'n = num_elem_vs;\\n  let \'d = num_elem_vd;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\\n  let vd_val  : vector(\'d, dec, bits(\'m)) = read_vreg(num_elem_vd, SEW, 0, vd);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\\n  let mask    : vector(\'n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\\n\\n  sum : bits(\'m) = read_single_element(SEW, 0, vs1); /* vs1 regardless of LMUL setting */\\n  foreach (i from 0 to (num_elem_vs - 1)) {\\n    if mask[i] then {\\n      sum = match funct6 {\\n        MVV_VREDSUM   => sum + vs2_val[i],\\n        MVV_VREDAND   => sum & vs2_val[i],\\n        MVV_VREDOR    => sum | vs2_val[i],\\n        MVV_VREDXOR   => sum ^ vs2_val[i],\\n        MVV_VREDMIN   => to_bits(SEW, min(signed(vs2_val[i]), signed(sum))),\\n        MVV_VREDMINU  => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(sum))),\\n        MVV_VREDMAX   => to_bits(SEW, max(signed(vs2_val[i]), signed(sum))),\\n        MVV_VREDMAXU  => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(sum)))\\n      }\\n    }\\n  };\\n\\n  write_single_element(SEW, 0, vd, sum);\\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\\n  /* TODO: configuration support for agnostic behavior */\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vredsum.vs","name":"TBD","operands":[{"name":"funct6","type":"rmvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\\n  let num_elem_vd = get_num_elem(0, SEW); /* vd regardless of LMUL setting */\\n\\n  if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\\n\\n  let \'n = num_elem_vs;\\n  let \'d = num_elem_vd;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\\n  let vd_val  : vector(\'d, dec, bits(\'m)) = read_vreg(num_elem_vd, SEW, 0, vd);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\\n  let mask    : vector(\'n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\\n\\n  sum : bits(\'m) = read_single_element(SEW, 0, vs1); /* vs1 regardless of LMUL setting */\\n  foreach (i from 0 to (num_elem_vs - 1)) {\\n    if mask[i] then {\\n      sum = match funct6 {\\n        MVV_VREDSUM   => sum + vs2_val[i],\\n        MVV_VREDAND   => sum & vs2_val[i],\\n        MVV_VREDOR    => sum | vs2_val[i],\\n        MVV_VREDXOR   => sum ^ vs2_val[i],\\n        MVV_VREDMIN   => to_bits(SEW, min(signed(vs2_val[i]), signed(sum))),\\n        MVV_VREDMINU  => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(sum))),\\n        MVV_VREDMAX   => to_bits(SEW, max(signed(vs2_val[i]), signed(sum))),\\n        MVV_VREDMAXU  => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(sum)))\\n      }\\n    }\\n  };\\n\\n  write_single_element(SEW, 0, vd, sum);\\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\\n  /* TODO: configuration support for agnostic behavior */\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vredxor.vs","name":"TBD","operands":[{"name":"funct6","type":"rmvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\\n  let num_elem_vd = get_num_elem(0, SEW); /* vd regardless of LMUL setting */\\n\\n  if illegal_reduction() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\\n\\n  let \'n = num_elem_vs;\\n  let \'d = num_elem_vd;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\\n  let vd_val  : vector(\'d, dec, bits(\'m)) = read_vreg(num_elem_vd, SEW, 0, vd);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\\n  let mask    : vector(\'n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\\n\\n  sum : bits(\'m) = read_single_element(SEW, 0, vs1); /* vs1 regardless of LMUL setting */\\n  foreach (i from 0 to (num_elem_vs - 1)) {\\n    if mask[i] then {\\n      sum = match funct6 {\\n        MVV_VREDSUM   => sum + vs2_val[i],\\n        MVV_VREDAND   => sum & vs2_val[i],\\n        MVV_VREDOR    => sum | vs2_val[i],\\n        MVV_VREDXOR   => sum ^ vs2_val[i],\\n        MVV_VREDMIN   => to_bits(SEW, min(signed(vs2_val[i]), signed(sum))),\\n        MVV_VREDMINU  => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(sum))),\\n        MVV_VREDMAX   => to_bits(SEW, max(signed(vs2_val[i]), signed(sum))),\\n        MVV_VREDMAXU  => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(sum)))\\n      }\\n    }\\n  };\\n\\n  write_single_element(SEW, 0, vd, sum);\\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\\n  /* TODO: configuration support for agnostic behavior */\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vrem.vv","name":"TBD","operands":[{"name":"funct6","type":"mvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVV_VAADDU   => {\\n                          let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VAADD    => {\\n                          let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUBU   => {\\n                          let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUB    => {\\n                          let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VDIVU    => {\\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          to_bits(SEW, q)\\n                        },\\n        MVV_VDIV     => {\\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* check for signed overflow */\\n                          let q\' : int = if q > elem_max then elem_min else q;\\n                          to_bits(SEW, q\')\\n                        },\\n        MVV_VREMU    => {\\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        },\\n        MVV_VREM     => {\\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vrem.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VAADDU       => {\\n                              let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VAADD        => {\\n                              let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUBU       => {\\n                              let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUB        => {\\n                              let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VSLIDE1UP    => {\\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        MVX_VSLIDE1DOWN  => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            },\\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VDIVU        => {\\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\\n                              to_bits(SEW, q)\\n                            },\\n        MVX_VDIV         => {\\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* check for signed overflow */\\n                              let q\' : int = if q > elem_max then elem_min else q;\\n                              to_bits(SEW, q\')\\n                            },\\n        MVX_VREMU        => {\\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            },\\n        MVX_VREM         => {\\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vremu.vv","name":"TBD","operands":[{"name":"funct6","type":"mvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_mvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVV_VAADDU   => {\\n                          let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VAADD    => {\\n                          let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                          slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUBU   => {\\n                          let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VASUB    => {\\n                          let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i]);\\n                          let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                          slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                        },\\n        MVV_VMUL     => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), 0),\\n        MVV_VMULH    => get_slice_int(SEW, signed(vs2_val[i]) * signed(vs1_val[i]), SEW),\\n        MVV_VMULHU   => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VMULHSU  => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(vs1_val[i]), SEW),\\n        MVV_VDIVU    => {\\n                          let q : int = if unsigned(vs1_val[i]) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          to_bits(SEW, q)\\n                        },\\n        MVV_VDIV     => {\\n                          let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                          let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                          let q : int = if signed(vs1_val[i]) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* check for signed overflow */\\n                          let q\' : int = if q > elem_max then elem_min else q;\\n                          to_bits(SEW, q\')\\n                        },\\n        MVV_VREMU    => {\\n                          let r : int = if unsigned(vs1_val[i]) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        },\\n        MVV_VREM     => {\\n                          let r : int = if signed(vs1_val[i]) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(vs1_val[i]));\\n                          /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                          to_bits(SEW, r)\\n                        }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vremu.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VAADDU       => {\\n                              let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VAADD        => {\\n                              let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUBU       => {\\n                              let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUB        => {\\n                              let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VSLIDE1UP    => {\\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        MVX_VSLIDE1DOWN  => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            },\\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VDIVU        => {\\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\\n                              to_bits(SEW, q)\\n                            },\\n        MVX_VDIV         => {\\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* check for signed overflow */\\n                              let q\' : int = if q > elem_max then elem_min else q;\\n                              to_bits(SEW, q\')\\n                            },\\n        MVX_VREMU        => {\\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            },\\n        MVX_VREM         => {\\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vrgather.vi","name":"TBD","operands":[{"name":"funct6","type":"visgfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_visgfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : nat                       = unsigned(zero_extend(sizeof(xlen), simm));\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VI_VSLIDEUP    => {\\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                            if i >= imm_val then vs2_val[i - imm_val] else vd_val[i]\\n                          },\\n        VI_VSLIDEDOWN  => {\\n                            let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                            assert(VLMAX > 0 & VLMAX <= \'n);\\n                            if i + imm_val < VLMAX then vs2_val[i + imm_val] else zeros()\\n                          },\\n        VI_VRGATHER    => {\\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                            let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                            assert(VLMAX > 0 & VLMAX <= \'n);\\n                            if imm_val < VLMAX then vs2_val[imm_val] else zeros()\\n                          }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vrgather.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vrgather.vx","name":"TBD","operands":[{"name":"funct6","type":"vxsgfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxsgfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : nat                       = unsigned(X(rs1));\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VSLIDEUP    => {\\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                            if i >= rs1_val then vs2_val[i - rs1_val] else vd_val[i]\\n                          },\\n        VX_VSLIDEDOWN  => {\\n                            let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                            assert(VLMAX > 0 & VLMAX <= \'n);\\n                            if i + rs1_val < VLMAX then vs2_val[i + rs1_val] else zeros()\\n                          },\\n        VX_VRGATHER    => {\\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                            let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                            assert(VLMAX > 0 & VLMAX <= \'n);\\n                            if rs1_val < VLMAX then vs2_val[rs1_val] else zeros()\\n                          }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vrgatherei16.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vrsub.vi","name":"TBD","operands":[{"name":"funct6","type":"vifunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VI_VADD    => vs2_val[i] + imm_val,\\n        VI_VRSUB   => imm_val - vs2_val[i],\\n        VI_VAND    => vs2_val[i] & imm_val,\\n        VI_VOR     => vs2_val[i] | imm_val,\\n        VI_VXOR    => vs2_val[i] ^ imm_val,\\n        VI_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, imm_val) ),\\n        VI_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, imm_val) ),\\n        VI_VSLL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VI_VSRL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VI_VSRA    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VI_VSSRL   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VI_VSSRA   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vrsub.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsadd.vi","name":"TBD","operands":[{"name":"funct6","type":"vifunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VI_VADD    => vs2_val[i] + imm_val,\\n        VI_VRSUB   => imm_val - vs2_val[i],\\n        VI_VAND    => vs2_val[i] & imm_val,\\n        VI_VOR     => vs2_val[i] | imm_val,\\n        VI_VXOR    => vs2_val[i] ^ imm_val,\\n        VI_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, imm_val) ),\\n        VI_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, imm_val) ),\\n        VI_VSLL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VI_VSRL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VI_VSRA    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VI_VSSRL   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VI_VSSRA   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsadd.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsadd.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsaddu.vi","name":"TBD","operands":[{"name":"funct6","type":"vifunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VI_VADD    => vs2_val[i] + imm_val,\\n        VI_VRSUB   => imm_val - vs2_val[i],\\n        VI_VAND    => vs2_val[i] & imm_val,\\n        VI_VOR     => vs2_val[i] | imm_val,\\n        VI_VXOR    => vs2_val[i] ^ imm_val,\\n        VI_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, imm_val) ),\\n        VI_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, imm_val) ),\\n        VI_VSLL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VI_VSRL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VI_VSRA    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VI_VSSRL   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VI_VSSRA   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsaddu.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsaddu.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsbc.vvm","name":"TBD","operands":[{"name":"funct6","type":"vvmsfunct6"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1,v0","format":"TBD","fields":[{"field":"encdec_vvmsfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  /* for bypassing normal masking in init_masked_result */\\n  vec_trues : vector(\'n, dec, bool) = undefined;\\n  foreach (i from 0 to (num_elem - 1)) {\\n    vec_trues[i] = true\\n  };\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VVMS_VADC     => to_bits(SEW, unsigned(vs2_val[i]) + unsigned(vs1_val[i]) + unsigned(bool_to_bits(vm_val[i]))),\\n        VVMS_VSBC     => to_bits(SEW, unsigned(vs2_val[i]) - unsigned(vs1_val[i]) - unsigned(bool_to_bits(vm_val[i])))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsbc.vxm","name":"TBD","operands":[{"name":"funct6","type":"vxmsfunct6"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1,v0","format":"TBD","fields":[{"field":"encdec_vxmsfunct6(funct6)","size":6},{"field":"0b0","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_vd_masked(vd) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  /* for bypassing normal masking in init_masked_result */\\n  vec_trues : vector(\'n, dec, bool) = undefined;\\n  foreach (i from 0 to (num_elem - 1)) {\\n    vec_trues[i] = true\\n  };\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask_carry(num_elem, 0b0, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vec_trues);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VXMS_VADC     => to_bits(SEW, unsigned(vs2_val[i]) + unsigned(rs1_val) + unsigned(bool_to_bits(vm_val[i]))),\\n        VXMS_VSBC     => to_bits(SEW, unsigned(vs2_val[i]) - unsigned(rs1_val) - unsigned(bool_to_bits(vm_val[i])))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vse16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vse32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vse64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vse8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsetivli","name":"TBD","operands":[{"name":"ma","type":"bits(1)"},{"name":"ta","type":"bits(1)"},{"name":"sew","type":"bits(3)"},{"name":"lmul","type":"bits(3)"},{"name":"uimm","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,uimm,sew_flag(sew)maybe_lmul_flag(lmul)maybe_ta_flag(ta)maybe_ma_flag(ma)","format":"TBD","fields":[{"field":"0b1100","size":4},{"field":"ma","size":1},{"field":"ta","size":1},{"field":"sew","size":3},{"field":"lmul","size":3},{"field":"uimm","size":5},{"field":"0b111","size":3},{"field":"rd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let VLEN_pow      = get_vlen_pow();\\n  let ELEN_pow      = get_elen_pow();\\n  let LMUL_pow_ori  = get_lmul_pow();\\n  let SEW_pow_ori   = get_sew_pow();\\n  let ratio_pow_ori = SEW_pow_ori - LMUL_pow_ori;\\n\\n  /* set vtype */\\n  vtype->bits() = 0b0 @ zeros(sizeof(xlen) - 9) @ ma @ ta @ sew @ lmul;\\n\\n  /* check legal SEW and LMUL and calculate VLMAX */\\n  let LMUL_pow_new = get_lmul_pow();\\n  let SEW_pow_new  = get_sew_pow();\\n  if SEW_pow_new > LMUL_pow_new + ELEN_pow then {\\n    /* Note: Implementations can set vill or trap if the vtype setting is not supported.\\n     * TODO: configuration support for both solutions\\n     */\\n    vtype->bits() = 0b1 @ zeros(sizeof(xlen) - 1); /* set vtype.vill */\\n    vl = zeros();\\n    print_reg(\\"CSR vtype <- \\" ^ BitStr(vtype.bits()));\\n    print_reg(\\"CSR vl <- \\" ^ BitStr(vl));\\n    return RETIRE_SUCCESS\\n  };\\n  let VLMAX = int_power(2, VLEN_pow + LMUL_pow_new - SEW_pow_new);\\n  let AVL   = unsigned(uimm); /* AVL is encoded as 5-bit zero-extended imm in the rs1 field */\\n\\n  /* set vl according to VLMAX and AVL */\\n  vl = if AVL <= VLMAX then to_bits(sizeof(xlen), AVL)\\n       else if AVL < 2 * VLMAX then to_bits(sizeof(xlen), (AVL + 1) / 2)\\n       else to_bits(sizeof(xlen), VLMAX);\\n  /* Note: ceil(AVL / 2) <= vl <= VLMAX when VLMAX < AVL < (2 * VLMAX)\\n   * TODO: configuration support for either using ceil(AVL / 2) or VLMAX\\n   */\\n  X(rd) = vl;\\n  print_reg(\\"CSR vtype <- \\" ^ BitStr(vtype.bits()));\\n  print_reg(\\"CSR vl <- \\" ^ BitStr(vl));\\n\\n  /* reset vstart to 0 */\\n  vstart = zeros();\\n  print_reg(\\"CSR vstart <- \\" ^ BitStr(vstart));\\n\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsetvli","name":"TBD","operands":[{"name":"op","type":"vsetop"},{"name":"ma","type":"bits(1)"},{"name":"ta","type":"bits(1)"},{"name":"sew","type":"bits(3)"},{"name":"lmul","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,sew_flag(sew)maybe_lmul_flag(lmul)maybe_ta_flag(ta)maybe_ma_flag(ma)","format":"TBD","fields":[{"field":"encdec_vsetop(op)","size":4},{"field":"ma","size":1},{"field":"ta","size":1},{"field":"sew","size":3},{"field":"lmul","size":3},{"field":"rs1","size":5},{"field":"0b111","size":3},{"field":"rd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let VLEN_pow      = get_vlen_pow();\\n  let ELEN_pow      = get_elen_pow();\\n  let LMUL_pow_ori  = get_lmul_pow();\\n  let SEW_pow_ori   = get_sew_pow();\\n  let ratio_pow_ori = SEW_pow_ori - LMUL_pow_ori;\\n\\n  /* set vtype */\\n  match op {\\n    VSETVLI => {\\n      vtype->bits() = 0b0 @ zeros(sizeof(xlen) - 9) @ ma @ ta @ sew @ lmul\\n    },\\n    VSETVL  => {\\n      let rs2 : regidx = sew[1 .. 0] @ lmul;\\n      vtype->bits() = X(rs2)\\n    }\\n  };\\n\\n  /* check legal SEW and LMUL and calculate VLMAX */\\n  let LMUL_pow_new = get_lmul_pow();\\n  let SEW_pow_new  = get_sew_pow();\\n  if SEW_pow_new > LMUL_pow_new + ELEN_pow then {\\n    /* Note: Implementations can set vill or trap if the vtype setting is not supported.\\n     * TODO: configuration support for both solutions\\n     */\\n    vtype->bits() = 0b1 @ zeros(sizeof(xlen) - 1); /* set vtype.vill */\\n    vl = zeros();\\n    print_reg(\\"CSR vtype <- \\" ^ BitStr(vtype.bits()));\\n    print_reg(\\"CSR vl <- \\" ^ BitStr(vl));\\n    return RETIRE_SUCCESS\\n  };\\n  let VLMAX = int_power(2, VLEN_pow + LMUL_pow_new - SEW_pow_new);\\n\\n  /* set vl according to VLMAX and AVL */\\n  if (rs1 != 0b00000) then { /* normal stripmining */\\n    let rs1_val = X(rs1);\\n    let AVL = unsigned(rs1_val);\\n    vl = if AVL <= VLMAX then to_bits(sizeof(xlen), AVL)\\n         else if AVL < 2 * VLMAX then to_bits(sizeof(xlen), (AVL + 1) / 2)\\n         else to_bits(sizeof(xlen), VLMAX);\\n    /* Note: ceil(AVL / 2) <= vl <= VLMAX when VLMAX < AVL < (2 * VLMAX)\\n     * TODO: configuration support for either using ceil(AVL / 2) or VLMAX\\n     */\\n    X(rd) = vl;\\n  } else if (rd != 0b00000) then { /* set vl to VLMAX */\\n    let AVL = unsigned(ones(sizeof(xlen)));\\n    vl = to_bits(sizeof(xlen), VLMAX);\\n    X(rd) = vl;\\n  } else { /* keep existing vl */\\n    let AVL = unsigned(vl);\\n    let ratio_pow_new = SEW_pow_new - LMUL_pow_new;\\n    if (ratio_pow_new != ratio_pow_ori) then {\\n      /* Note: Implementations can set vill or trap if the vtype setting is not supported.\\n       * TODO: configuration support for both solutions\\n       */\\n      vtype->bits() = 0b1 @ zeros(sizeof(xlen) - 1); /* set vtype.vill */\\n      vl = zeros();\\n    }\\n  };\\n  print_reg(\\"CSR vtype <- \\" ^ BitStr(vtype.bits()));\\n  print_reg(\\"CSR vl <- \\" ^ BitStr(vl));\\n\\n  /* reset vstart to 0 */\\n  vstart = zeros();\\n  print_reg(\\"CSR vstart <- \\" ^ BitStr(vstart));\\n\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsetvli","name":"TBD","operands":[{"name":"op","type":"vsetop"},{"name":"ma","type":"bits(1)"},{"name":"ta","type":"bits(1)"},{"name":"sew","type":"bits(3)"},{"name":"lmul","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,sew_flag(sew)maybe_lmul_flag(lmul)maybe_ta_flag(ta)maybe_ma_flag(ma)","format":"TBD","fields":[{"field":"encdec_vsetop(op)","size":4},{"field":"ma","size":1},{"field":"ta","size":1},{"field":"sew","size":3},{"field":"lmul","size":3},{"field":"rs1","size":5},{"field":"0b111","size":3},{"field":"rd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let VLEN_pow      = get_vlen_pow();\\n  let ELEN_pow      = get_elen_pow();\\n  let LMUL_pow_ori  = get_lmul_pow();\\n  let SEW_pow_ori   = get_sew_pow();\\n  let ratio_pow_ori = SEW_pow_ori - LMUL_pow_ori;\\n\\n  /* set vtype */\\n  match op {\\n    VSETVLI => {\\n      vtype->bits() = 0b0 @ zeros(sizeof(xlen) - 9) @ ma @ ta @ sew @ lmul\\n    },\\n    VSETVL  => {\\n      let rs2 : regidx = sew[1 .. 0] @ lmul;\\n      vtype->bits() = X(rs2)\\n    }\\n  };\\n\\n  /* check legal SEW and LMUL and calculate VLMAX */\\n  let LMUL_pow_new = get_lmul_pow();\\n  let SEW_pow_new  = get_sew_pow();\\n  if SEW_pow_new > LMUL_pow_new + ELEN_pow then {\\n    /* Note: Implementations can set vill or trap if the vtype setting is not supported.\\n     * TODO: configuration support for both solutions\\n     */\\n    vtype->bits() = 0b1 @ zeros(sizeof(xlen) - 1); /* set vtype.vill */\\n    vl = zeros();\\n    print_reg(\\"CSR vtype <- \\" ^ BitStr(vtype.bits()));\\n    print_reg(\\"CSR vl <- \\" ^ BitStr(vl));\\n    return RETIRE_SUCCESS\\n  };\\n  let VLMAX = int_power(2, VLEN_pow + LMUL_pow_new - SEW_pow_new);\\n\\n  /* set vl according to VLMAX and AVL */\\n  if (rs1 != 0b00000) then { /* normal stripmining */\\n    let rs1_val = X(rs1);\\n    let AVL = unsigned(rs1_val);\\n    vl = if AVL <= VLMAX then to_bits(sizeof(xlen), AVL)\\n         else if AVL < 2 * VLMAX then to_bits(sizeof(xlen), (AVL + 1) / 2)\\n         else to_bits(sizeof(xlen), VLMAX);\\n    /* Note: ceil(AVL / 2) <= vl <= VLMAX when VLMAX < AVL < (2 * VLMAX)\\n     * TODO: configuration support for either using ceil(AVL / 2) or VLMAX\\n     */\\n    X(rd) = vl;\\n  } else if (rd != 0b00000) then { /* set vl to VLMAX */\\n    let AVL = unsigned(ones(sizeof(xlen)));\\n    vl = to_bits(sizeof(xlen), VLMAX);\\n    X(rd) = vl;\\n  } else { /* keep existing vl */\\n    let AVL = unsigned(vl);\\n    let ratio_pow_new = SEW_pow_new - LMUL_pow_new;\\n    if (ratio_pow_new != ratio_pow_ori) then {\\n      /* Note: Implementations can set vill or trap if the vtype setting is not supported.\\n       * TODO: configuration support for both solutions\\n       */\\n      vtype->bits() = 0b1 @ zeros(sizeof(xlen) - 1); /* set vtype.vill */\\n      vl = zeros();\\n    }\\n  };\\n  print_reg(\\"CSR vtype <- \\" ^ BitStr(vtype.bits()));\\n  print_reg(\\"CSR vl <- \\" ^ BitStr(vl));\\n\\n  /* reset vstart to 0 */\\n  vstart = zeros();\\n  print_reg(\\"CSR vstart <- \\" ^ BitStr(vstart));\\n\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsext.vf2","name":"TBD","operands":[{"name":"funct6","type":"vext2funct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vext2_vs1(funct6)","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_half = SEW / 2;\\n  let LMUL_pow_half = LMUL_pow - 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_half, LMUL_pow_half) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_half, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_half;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_half, LMUL_pow_half, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW > SEW_half);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VEXT2_ZVF2 => zero_extend(vs2_val[i]),\\n        VEXT2_SVF2 => sign_extend(vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsext.vf4","name":"TBD","operands":[{"name":"funct6","type":"vext4funct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vext4_vs1(funct6)","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_quart = SEW / 4;\\n  let LMUL_pow_quart = LMUL_pow - 2;\\n\\n  if  illegal_variable_width(vd, vm, SEW_quart, LMUL_pow_quart) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_quart, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_quart;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_quart, LMUL_pow_quart, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW > SEW_quart);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VEXT4_ZVF4 => zero_extend(vs2_val[i]),\\n        VEXT4_SVF4 => sign_extend(vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsext.vf8","name":"TBD","operands":[{"name":"funct6","type":"vext8funct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vext8_vs1(funct6)","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_eighth = SEW / 8;\\n  let LMUL_pow_eighth = LMUL_pow - 3;\\n\\n  if  illegal_variable_width(vd, vm, SEW_eighth, LMUL_pow_eighth) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_eighth, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_eighth;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_eighth, LMUL_pow_eighth, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW > SEW_eighth);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VEXT8_ZVF8 => zero_extend(vs2_val[i]),\\n        VEXT8_SVF8 => sign_extend(vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vslide1down.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VAADDU       => {\\n                              let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VAADD        => {\\n                              let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUBU       => {\\n                              let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUB        => {\\n                              let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VSLIDE1UP    => {\\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        MVX_VSLIDE1DOWN  => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            },\\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VDIVU        => {\\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\\n                              to_bits(SEW, q)\\n                            },\\n        MVX_VDIV         => {\\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* check for signed overflow */\\n                              let q\' : int = if q > elem_max then elem_min else q;\\n                              to_bits(SEW, q\')\\n                            },\\n        MVX_VREMU        => {\\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            },\\n        MVX_VREM         => {\\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vslide1up.vx","name":"TBD","operands":[{"name":"funct6","type":"mvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_mvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        MVX_VAADDU       => {\\n                              let result_add = zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VAADD        => {\\n                              let result_add = sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_add, 1);\\n                              slice(result_add >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUBU       => {\\n                              let result_sub = zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VASUB        => {\\n                              let result_sub = sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val);\\n                              let rounding_incr = get_fixed_rounding_incr(result_sub, 1);\\n                              slice(result_sub >> 1, 0, \'m) + zero_extend(\'m, rounding_incr)\\n                            },\\n        MVX_VSLIDE1UP    => {\\n                              if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              if i == 0 then rs1_val else vs2_val[i - 1]\\n                            },\\n        MVX_VSLIDE1DOWN  => {\\n                              let last_elem = get_end_element();\\n                              assert(last_elem < num_elem);\\n                              if i < last_elem then vs2_val[i + 1] else rs1_val\\n                            },\\n        MVX_VMUL         => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), 0),\\n        MVX_VMULH        => get_slice_int(SEW, signed(vs2_val[i]) * signed(rs1_val), SEW),\\n        MVX_VMULHU       => get_slice_int(SEW, unsigned(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VMULHSU      => get_slice_int(SEW, signed(vs2_val[i]) * unsigned(rs1_val), SEW),\\n        MVX_VDIVU        => {\\n                              let q : int = if unsigned(rs1_val) == 0 then -1 else quot_round_zero(unsigned(vs2_val[i]), unsigned(rs1_val));\\n                              to_bits(SEW, q)\\n                            },\\n        MVX_VDIV         => {\\n                              let elem_max : int = 2 ^ (SEW - 1) - 1;\\n                              let elem_min : int = 0 - 2 ^ (SEW - 1);\\n                              let q : int = if signed(rs1_val) == 0 then -1 else quot_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* check for signed overflow */\\n                              let q\' : int = if q > elem_max then elem_min else q;\\n                              to_bits(SEW, q\')\\n                            },\\n        MVX_VREMU        => {\\n                              let r : int = if unsigned(rs1_val) == 0 then unsigned(vs2_val[i]) else rem_round_zero(unsigned(vs2_val[i]), unsigned (rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            },\\n        MVX_VREM         => {\\n                              let r : int = if signed(rs1_val) == 0 then signed(vs2_val[i]) else rem_round_zero(signed(vs2_val[i]), signed(rs1_val));\\n                              /* signed overflow case returns zero naturally as required due to -1 divisor */\\n                              to_bits(SEW, r)\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vslidedown.vi","name":"TBD","operands":[{"name":"funct6","type":"visgfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_visgfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : nat                       = unsigned(zero_extend(sizeof(xlen), simm));\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VI_VSLIDEUP    => {\\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                            if i >= imm_val then vs2_val[i - imm_val] else vd_val[i]\\n                          },\\n        VI_VSLIDEDOWN  => {\\n                            let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                            assert(VLMAX > 0 & VLMAX <= \'n);\\n                            if i + imm_val < VLMAX then vs2_val[i + imm_val] else zeros()\\n                          },\\n        VI_VRGATHER    => {\\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                            let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                            assert(VLMAX > 0 & VLMAX <= \'n);\\n                            if imm_val < VLMAX then vs2_val[imm_val] else zeros()\\n                          }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vslidedown.vx","name":"TBD","operands":[{"name":"funct6","type":"vxsgfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxsgfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : nat                       = unsigned(X(rs1));\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VSLIDEUP    => {\\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                            if i >= rs1_val then vs2_val[i - rs1_val] else vd_val[i]\\n                          },\\n        VX_VSLIDEDOWN  => {\\n                            let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                            assert(VLMAX > 0 & VLMAX <= \'n);\\n                            if i + rs1_val < VLMAX then vs2_val[i + rs1_val] else zeros()\\n                          },\\n        VX_VRGATHER    => {\\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                            let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                            assert(VLMAX > 0 & VLMAX <= \'n);\\n                            if rs1_val < VLMAX then vs2_val[rs1_val] else zeros()\\n                          }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vslideup.vi","name":"TBD","operands":[{"name":"funct6","type":"visgfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_visgfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : nat                       = unsigned(zero_extend(sizeof(xlen), simm));\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VI_VSLIDEUP    => {\\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                            if i >= imm_val then vs2_val[i - imm_val] else vd_val[i]\\n                          },\\n        VI_VSLIDEDOWN  => {\\n                            let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                            assert(VLMAX > 0 & VLMAX <= \'n);\\n                            if i + imm_val < VLMAX then vs2_val[i + imm_val] else zeros()\\n                          },\\n        VI_VRGATHER    => {\\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                            let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                            assert(VLMAX > 0 & VLMAX <= \'n);\\n                            if imm_val < VLMAX then vs2_val[imm_val] else zeros()\\n                          }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vslideup.vx","name":"TBD","operands":[{"name":"funct6","type":"vxsgfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxsgfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : nat                       = unsigned(X(rs1));\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VSLIDEUP    => {\\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                            if i >= rs1_val then vs2_val[i - rs1_val] else vd_val[i]\\n                          },\\n        VX_VSLIDEDOWN  => {\\n                            let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                            assert(VLMAX > 0 & VLMAX <= \'n);\\n                            if i + rs1_val < VLMAX then vs2_val[i + rs1_val] else zeros()\\n                          },\\n        VX_VRGATHER    => {\\n                            if (vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                            let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                            assert(VLMAX > 0 & VLMAX <= \'n);\\n                            if rs1_val < VLMAX then vs2_val[rs1_val] else zeros()\\n                          }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsll.vi","name":"TBD","operands":[{"name":"funct6","type":"vifunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VI_VADD    => vs2_val[i] + imm_val,\\n        VI_VRSUB   => imm_val - vs2_val[i],\\n        VI_VAND    => vs2_val[i] & imm_val,\\n        VI_VOR     => vs2_val[i] | imm_val,\\n        VI_VXOR    => vs2_val[i] ^ imm_val,\\n        VI_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, imm_val) ),\\n        VI_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, imm_val) ),\\n        VI_VSLL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VI_VSRL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VI_VSRA    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VI_VSSRL   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VI_VSSRA   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsll.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsll.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsm.v","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"vd_or_vs3","type":"regidx"},{"name":"op","type":"vmlsop"}],"syntax":"vd_or_vs3,(rs1)","format":"TBD","fields":[{"field":"0b000","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01011","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vd_or_vs3","size":5},{"field":"encdec_lsop(op)","size":7}],"extensions":["V"],"function":"{\\n  let EEW = 8;\\n  let EMUL_pow = 0;\\n  let vl_val = unsigned(vl);\\n  let evl : int = if vl_val % 8 == 0 then vl_val / 8 else vl_val / 8 + 1; /* the effective vector length is evl=ceil(vl/8) */\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n\\n  if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };\\n\\n  assert(evl >= 0);\\n  process_vm(vd_or_vs3, rs1, num_elem, evl, op)\\n}","description":"TBD"},{"mnemonic":"vsmul.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsmul.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsoxei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg2ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg2ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg2ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg2ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg3ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg3ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg3ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg3ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg4ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg4ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg4ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg4ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg5ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg5ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg5ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg5ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg6ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg6ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg6ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg6ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg7ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg7ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg7ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg7ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg8ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg8ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg8ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsoxseg8ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsr.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = 1;\\n  let EEW = 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vsra.vi","name":"TBD","operands":[{"name":"funct6","type":"vifunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VI_VADD    => vs2_val[i] + imm_val,\\n        VI_VRSUB   => imm_val - vs2_val[i],\\n        VI_VAND    => vs2_val[i] & imm_val,\\n        VI_VOR     => vs2_val[i] | imm_val,\\n        VI_VXOR    => vs2_val[i] ^ imm_val,\\n        VI_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, imm_val) ),\\n        VI_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, imm_val) ),\\n        VI_VSLL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VI_VSRL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VI_VSRA    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VI_VSSRL   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VI_VSSRA   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsra.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsra.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsrl.vi","name":"TBD","operands":[{"name":"funct6","type":"vifunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VI_VADD    => vs2_val[i] + imm_val,\\n        VI_VRSUB   => imm_val - vs2_val[i],\\n        VI_VAND    => vs2_val[i] & imm_val,\\n        VI_VOR     => vs2_val[i] | imm_val,\\n        VI_VXOR    => vs2_val[i] ^ imm_val,\\n        VI_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, imm_val) ),\\n        VI_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, imm_val) ),\\n        VI_VSLL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VI_VSRL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VI_VSRA    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VI_VSSRL   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VI_VSSRA   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsrl.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsrl.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsse16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsse32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsse64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsse8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg2e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg2e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg2e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg2e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg2r.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = 1;\\n  let EEW = 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vsseg3e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg3e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg3e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg3e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg3r.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = 1;\\n  let EEW = 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vsseg4e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg4e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg4e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg4e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg4r.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = 1;\\n  let EEW = 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vsseg5e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg5e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg5e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg5e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg5r.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = 1;\\n  let EEW = 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vsseg6e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg6e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg6e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg6e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg6r.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = 1;\\n  let EEW = 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vsseg7e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg7e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg7e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg7e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg7r.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = 1;\\n  let EEW = 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vsseg8e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg8e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg8e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg8e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"vm","size":1},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsseg(nf_int, vm, vs3, load_width_bytes, rs1, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vsseg8r.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"rs1","type":"regidx"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1)","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b00","size":2},{"field":"0b1","size":1},{"field":"0b01000","size":5},{"field":"rs1","size":5},{"field":"0b000","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = 1;\\n  let EEW = 8;\\n  let VLEN = unsigned(vlenb) * 8;\\n  let elem_per_reg : int = VLEN / EEW;\\n  let nf_int = nfields_int(nf);\\n\\n  assert(elem_per_reg >= 0);\\n  if not(nf_int == 1 | nf_int == 2 | nf_int == 4 | nf_int == 8) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsre(nf_int, load_width_bytes, rs1, vs3, elem_per_reg)\\n}","description":"TBD"},{"mnemonic":"vssra.vi","name":"TBD","operands":[{"name":"funct6","type":"vifunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VI_VADD    => vs2_val[i] + imm_val,\\n        VI_VRSUB   => imm_val - vs2_val[i],\\n        VI_VAND    => vs2_val[i] & imm_val,\\n        VI_VOR     => vs2_val[i] | imm_val,\\n        VI_VXOR    => vs2_val[i] ^ imm_val,\\n        VI_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, imm_val) ),\\n        VI_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, imm_val) ),\\n        VI_VSLL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VI_VSRL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VI_VSRA    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VI_VSSRL   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VI_VSSRA   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vssra.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vssra.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vssrl.vi","name":"TBD","operands":[{"name":"funct6","type":"vifunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VI_VADD    => vs2_val[i] + imm_val,\\n        VI_VRSUB   => imm_val - vs2_val[i],\\n        VI_VAND    => vs2_val[i] & imm_val,\\n        VI_VOR     => vs2_val[i] | imm_val,\\n        VI_VXOR    => vs2_val[i] ^ imm_val,\\n        VI_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, imm_val) ),\\n        VI_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, imm_val) ),\\n        VI_VSLL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VI_VSRL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VI_VSRA    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VI_VSSRL   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VI_VSSRA   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vssrl.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vssrl.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vssseg2e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg2e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg2e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg2e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg3e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg3e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg3e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg3e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg4e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg4e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg4e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg4e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg5e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg5e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg5e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg5e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg6e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg6e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg6e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg6e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg7e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg7e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg7e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg7e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg8e16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg8e32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg8e64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssseg8e8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),rs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b10","size":2},{"field":"vm","size":1},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let load_width_bytes = vlewidth_bytesnumber(width);\\n  let EEW = load_width_bytes * 8;\\n  let EEW_pow = vlewidth_pow(width);\\n  let SEW_pow = get_sew_pow();\\n  let LMUL_pow = get_lmul_pow();\\n  let EMUL_pow = EEW_pow - SEW_pow + LMUL_pow;\\n  let num_elem = get_num_elem(EMUL_pow, EEW);\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_store(nf_int, EEW, EMUL_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vssseg(nf_int, vm, vs3, load_width_bytes, rs1, rs2, EMUL_pow, num_elem)\\n}","description":"TBD"},{"mnemonic":"vssub.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vssub.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vssubu.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vssubu.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsub.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsub.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vsuxei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg2ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg2ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg2ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg2ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg3ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg3ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg3ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg3ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg4ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg4ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg4ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg4ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg5ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg5ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg5ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg5ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg6ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg6ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg6ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg6ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg7ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg7ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg7ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg7ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg8ei16.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg8ei32.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg8ei64.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vsuxseg8ei8.v","name":"TBD","operands":[{"name":"nf","type":"bits(3)"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"width","type":"vlewidth"},{"name":"vs3","type":"regidx"}],"syntax":"vs3,(rs1),vs2vm","format":"TBD","fields":[{"field":"nf","size":3},{"field":"0b0","size":1},{"field":"0b01","size":2},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"encdec_vlewidth(width)","size":3},{"field":"vs3","size":5},{"field":"0b0100111","size":7}],"extensions":["V"],"function":"{\\n  let EEW_index_pow = vlewidth_pow(width);\\n  let EEW_index_bytes = vlewidth_bytesnumber(width);\\n  let EEW_data_pow = get_sew_pow();\\n  let EEW_data_bytes = get_sew_bytes();\\n  let EMUL_data_pow = get_lmul_pow();\\n  let EMUL_index_pow = EEW_index_pow - EEW_data_pow + EMUL_data_pow;\\n  let num_elem = get_num_elem(EMUL_data_pow, EEW_data_bytes * 8); /* number of data and indices are the same */\\n  let nf_int = nfields_int(nf);\\n\\n  if illegal_indexed_store(nf_int, EEW_index_bytes * 8, EMUL_index_pow, EMUL_data_pow) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  process_vsxseg(nf_int, vm, vs3, EEW_index_bytes, EEW_data_bytes, EMUL_index_pow, EMUL_data_pow, rs1, vs2, num_elem, 1)\\n}","description":"TBD"},{"mnemonic":"vwadd.vv","name":"TBD","operands":[{"name":"funct6","type":"wvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WVV_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\\n        WVV_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\\n        WVV_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\\n        WVV_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i])),\\n        WVV_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(vs1_val[i])),\\n        WVV_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(vs1_val[i])),\\n        WVV_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(vs1_val[i]))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwadd.vx","name":"TBD","operands":[{"name":"funct6","type":"wvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WVX_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\\n        WVX_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\\n        WVX_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\\n        WVX_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val)),\\n        WVX_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(rs1_val)),\\n        WVX_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(rs1_val)),\\n        WVX_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(rs1_val))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwadd.wv","name":"TBD","operands":[{"name":"funct6","type":"wvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WV_VADD  => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\\n        WV_VSUB  => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\\n        WV_VADDU => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\\n        WV_VSUBU => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i]))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwadd.wx","name":"TBD","operands":[{"name":"funct6","type":"wxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen)\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WX_VADD  => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\\n        WX_VSUB  => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\\n        WX_VADDU => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\\n        WX_VSUBU => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwaddu.vv","name":"TBD","operands":[{"name":"funct6","type":"wvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WVV_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\\n        WVV_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\\n        WVV_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\\n        WVV_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i])),\\n        WVV_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(vs1_val[i])),\\n        WVV_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(vs1_val[i])),\\n        WVV_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(vs1_val[i]))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwaddu.vx","name":"TBD","operands":[{"name":"funct6","type":"wvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WVX_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\\n        WVX_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\\n        WVX_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\\n        WVX_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val)),\\n        WVX_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(rs1_val)),\\n        WVX_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(rs1_val)),\\n        WVX_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(rs1_val))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwaddu.wv","name":"TBD","operands":[{"name":"funct6","type":"wvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WV_VADD  => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\\n        WV_VSUB  => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\\n        WV_VADDU => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\\n        WV_VSUBU => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i]))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwaddu.wx","name":"TBD","operands":[{"name":"funct6","type":"wxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen)\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WX_VADD  => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\\n        WX_VSUB  => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\\n        WX_VADDU => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\\n        WX_VSUBU => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwmacc.vv","name":"TBD","operands":[{"name":"funct6","type":"wmvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_wmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WMVV_VWMACC   => to_bits(SEW_widen, signed(vs1_val[i]) * signed(vs2_val[i])) + vd_val[i],\\n        WMVV_VWMACCU  => to_bits(SEW_widen, unsigned(vs1_val[i]) * unsigned(vs2_val[i])) + vd_val[i],\\n        WMVV_VWMACCSU => to_bits(SEW_widen, signed(vs1_val[i]) * unsigned(vs2_val[i]))+ vd_val[i]\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwmacc.vx","name":"TBD","operands":[{"name":"funct6","type":"wmvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_wmvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WMVX_VWMACCU  => (to_bits(SEW_widen, unsigned(rs1_val) * unsigned(vs2_val[i]) )) + vd_val[i],\\n        WMVX_VWMACC   => (to_bits(SEW_widen, signed(rs1_val) * signed(vs2_val[i]) )) + vd_val[i],\\n        WMVX_VWMACCUS => (to_bits(SEW_widen, unsigned(rs1_val) * signed(vs2_val[i]) ))+ vd_val[i],\\n        WMVX_VWMACCSU => (to_bits(SEW_widen, signed(rs1_val) * unsigned(vs2_val[i]) ))+ vd_val[i]\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwmaccsu.vv","name":"TBD","operands":[{"name":"funct6","type":"wmvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_wmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WMVV_VWMACC   => to_bits(SEW_widen, signed(vs1_val[i]) * signed(vs2_val[i])) + vd_val[i],\\n        WMVV_VWMACCU  => to_bits(SEW_widen, unsigned(vs1_val[i]) * unsigned(vs2_val[i])) + vd_val[i],\\n        WMVV_VWMACCSU => to_bits(SEW_widen, signed(vs1_val[i]) * unsigned(vs2_val[i]))+ vd_val[i]\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwmaccsu.vx","name":"TBD","operands":[{"name":"funct6","type":"wmvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_wmvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WMVX_VWMACCU  => (to_bits(SEW_widen, unsigned(rs1_val) * unsigned(vs2_val[i]) )) + vd_val[i],\\n        WMVX_VWMACC   => (to_bits(SEW_widen, signed(rs1_val) * signed(vs2_val[i]) )) + vd_val[i],\\n        WMVX_VWMACCUS => (to_bits(SEW_widen, unsigned(rs1_val) * signed(vs2_val[i]) ))+ vd_val[i],\\n        WMVX_VWMACCSU => (to_bits(SEW_widen, signed(rs1_val) * unsigned(vs2_val[i]) ))+ vd_val[i]\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwmaccu.vv","name":"TBD","operands":[{"name":"funct6","type":"wmvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs1,vs2vm","format":"TBD","fields":[{"field":"encdec_wmvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WMVV_VWMACC   => to_bits(SEW_widen, signed(vs1_val[i]) * signed(vs2_val[i])) + vd_val[i],\\n        WMVV_VWMACCU  => to_bits(SEW_widen, unsigned(vs1_val[i]) * unsigned(vs2_val[i])) + vd_val[i],\\n        WMVV_VWMACCSU => to_bits(SEW_widen, signed(vs1_val[i]) * unsigned(vs2_val[i]))+ vd_val[i]\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwmaccu.vx","name":"TBD","operands":[{"name":"funct6","type":"wmvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_wmvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WMVX_VWMACCU  => (to_bits(SEW_widen, unsigned(rs1_val) * unsigned(vs2_val[i]) )) + vd_val[i],\\n        WMVX_VWMACC   => (to_bits(SEW_widen, signed(rs1_val) * signed(vs2_val[i]) )) + vd_val[i],\\n        WMVX_VWMACCUS => (to_bits(SEW_widen, unsigned(rs1_val) * signed(vs2_val[i]) ))+ vd_val[i],\\n        WMVX_VWMACCSU => (to_bits(SEW_widen, signed(rs1_val) * unsigned(vs2_val[i]) ))+ vd_val[i]\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwmaccus.vx","name":"TBD","operands":[{"name":"funct6","type":"wmvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,rs1,vs2vm","format":"TBD","fields":[{"field":"encdec_wmvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WMVX_VWMACCU  => (to_bits(SEW_widen, unsigned(rs1_val) * unsigned(vs2_val[i]) )) + vd_val[i],\\n        WMVX_VWMACC   => (to_bits(SEW_widen, signed(rs1_val) * signed(vs2_val[i]) )) + vd_val[i],\\n        WMVX_VWMACCUS => (to_bits(SEW_widen, unsigned(rs1_val) * signed(vs2_val[i]) ))+ vd_val[i],\\n        WMVX_VWMACCSU => (to_bits(SEW_widen, signed(rs1_val) * unsigned(vs2_val[i]) ))+ vd_val[i]\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwmul.vv","name":"TBD","operands":[{"name":"funct6","type":"wvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WVV_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\\n        WVV_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\\n        WVV_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\\n        WVV_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i])),\\n        WVV_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(vs1_val[i])),\\n        WVV_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(vs1_val[i])),\\n        WVV_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(vs1_val[i]))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwmul.vx","name":"TBD","operands":[{"name":"funct6","type":"wvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WVX_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\\n        WVX_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\\n        WVX_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\\n        WVX_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val)),\\n        WVX_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(rs1_val)),\\n        WVX_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(rs1_val)),\\n        WVX_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(rs1_val))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwmulsu.vv","name":"TBD","operands":[{"name":"funct6","type":"wvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WVV_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\\n        WVV_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\\n        WVV_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\\n        WVV_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i])),\\n        WVV_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(vs1_val[i])),\\n        WVV_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(vs1_val[i])),\\n        WVV_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(vs1_val[i]))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwmulsu.vx","name":"TBD","operands":[{"name":"funct6","type":"wvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WVX_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\\n        WVX_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\\n        WVX_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\\n        WVX_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val)),\\n        WVX_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(rs1_val)),\\n        WVX_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(rs1_val)),\\n        WVX_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(rs1_val))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwmulu.vv","name":"TBD","operands":[{"name":"funct6","type":"wvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WVV_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\\n        WVV_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\\n        WVV_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\\n        WVV_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i])),\\n        WVV_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(vs1_val[i])),\\n        WVV_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(vs1_val[i])),\\n        WVV_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(vs1_val[i]))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwmulu.vx","name":"TBD","operands":[{"name":"funct6","type":"wvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WVX_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\\n        WVX_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\\n        WVX_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\\n        WVX_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val)),\\n        WVX_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(rs1_val)),\\n        WVX_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(rs1_val)),\\n        WVX_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(rs1_val))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwredsum.vs","name":"TBD","operands":[{"name":"funct6","type":"rivvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rivvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\\n  let num_elem_vd = get_num_elem(0, SEW_widen); /* vd regardless of LMUL setting */\\n\\n  if illegal_reduction_widen(SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\\n\\n  let \'n = num_elem_vs;\\n  let \'d = num_elem_vd;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\\n  let vd_val  : vector(\'d, dec, bits(\'o)) = read_vreg(num_elem_vd, SEW_widen, 0, vd);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\\n  let mask    : vector(\'n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\\n\\n  sum : bits(\'o) = read_single_element(SEW_widen, 0, vs1); /* vs1 regardless of LMUL setting */\\n  foreach (i from 0 to (num_elem_vs - 1)) {\\n    if mask[i] then {\\n      let elem : bits(\'o) = match funct6 {\\n        IVV_VWREDSUMU  => to_bits(SEW_widen, unsigned(vs2_val[i])),\\n        IVV_VWREDSUM   => to_bits(SEW_widen, signed(vs2_val[i]))\\n      };\\n      sum = sum + elem\\n    }\\n  };\\n\\n  write_single_element(SEW_widen, 0, vd, sum);\\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\\n  /* TODO: configuration support for agnostic behavior */\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwredsumu.vs","name":"TBD","operands":[{"name":"funct6","type":"rivvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_rivvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n  let num_elem_vs = get_num_elem(LMUL_pow, SEW);\\n  let num_elem_vd = get_num_elem(0, SEW_widen); /* vd regardless of LMUL setting */\\n\\n  if illegal_reduction_widen(SEW_widen, LMUL_pow_widen) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  if unsigned(vl) == 0 then return RETIRE_SUCCESS; /* if vl=0, no operation is performed */\\n\\n  let \'n = num_elem_vs;\\n  let \'d = num_elem_vd;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem_vs, vm, 0b00000);\\n  let vd_val  : vector(\'d, dec, bits(\'o)) = read_vreg(num_elem_vd, SEW_widen, 0, vd);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem_vs, SEW, LMUL_pow, vs2);\\n  let mask    : vector(\'n, dec, bool)     = init_masked_source(num_elem_vs, LMUL_pow, vm_val);\\n\\n  sum : bits(\'o) = read_single_element(SEW_widen, 0, vs1); /* vs1 regardless of LMUL setting */\\n  foreach (i from 0 to (num_elem_vs - 1)) {\\n    if mask[i] then {\\n      let elem : bits(\'o) = match funct6 {\\n        IVV_VWREDSUMU  => to_bits(SEW_widen, unsigned(vs2_val[i])),\\n        IVV_VWREDSUM   => to_bits(SEW_widen, signed(vs2_val[i]))\\n      };\\n      sum = sum + elem\\n    }\\n  };\\n\\n  write_single_element(SEW_widen, 0, vd, sum);\\n  /* other elements in vd are treated as tail elements, currently remain unchanged */\\n  /* TODO: configuration support for agnostic behavior */\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwsub.vv","name":"TBD","operands":[{"name":"funct6","type":"wvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WVV_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\\n        WVV_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\\n        WVV_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\\n        WVV_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i])),\\n        WVV_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(vs1_val[i])),\\n        WVV_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(vs1_val[i])),\\n        WVV_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(vs1_val[i]))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwsub.vx","name":"TBD","operands":[{"name":"funct6","type":"wvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WVX_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\\n        WVX_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\\n        WVX_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\\n        WVX_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val)),\\n        WVX_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(rs1_val)),\\n        WVX_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(rs1_val)),\\n        WVX_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(rs1_val))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwsub.wv","name":"TBD","operands":[{"name":"funct6","type":"wvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WV_VADD  => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\\n        WV_VSUB  => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\\n        WV_VADDU => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\\n        WV_VSUBU => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i]))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwsub.wx","name":"TBD","operands":[{"name":"funct6","type":"wxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen)\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WX_VADD  => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\\n        WX_VSUB  => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\\n        WX_VADDU => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\\n        WX_VSUBU => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwsubu.vv","name":"TBD","operands":[{"name":"funct6","type":"wvvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen)) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WVV_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\\n        WVV_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\\n        WVV_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\\n        WVV_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i])),\\n        WVV_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(vs1_val[i])),\\n        WVV_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(vs1_val[i])),\\n        WVV_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(vs1_val[i]))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwsubu.vx","name":"TBD","operands":[{"name":"funct6","type":"wvxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wvxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WVX_VADD    => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\\n        WVX_VSUB    => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\\n        WVX_VADDU   => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\\n        WVX_VSUBU   => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val)),\\n        WVX_VWMUL   => to_bits(SEW_widen, signed(vs2_val[i]) * signed(rs1_val)),\\n        WVX_VWMULU  => to_bits(SEW_widen, unsigned(vs2_val[i]) * unsigned(rs1_val)),\\n        WVX_VWMULSU => to_bits(SEW_widen, signed(vs2_val[i]) * unsigned(rs1_val))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwsubu.wv","name":"TBD","operands":[{"name":"funct6","type":"wvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_wvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen) |\\n      not(valid_reg_overlap(vs1, vd, LMUL_pow, LMUL_pow_widen))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WV_VADD  => to_bits(SEW_widen, signed(vs2_val[i]) + signed(vs1_val[i])),\\n        WV_VSUB  => to_bits(SEW_widen, signed(vs2_val[i]) - signed(vs1_val[i])),\\n        WV_VADDU => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(vs1_val[i])),\\n        WV_VSUBU => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(vs1_val[i]))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vwsubu.wx","name":"TBD","operands":[{"name":"funct6","type":"wxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_wxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b110","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_widen      = SEW * 2;\\n  let LMUL_pow_widen = LMUL_pow + 1;\\n\\n  if illegal_variable_width(vd, vm, SEW_widen, LMUL_pow_widen)\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_widen;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_widen, LMUL_pow_widen, vs2);\\n  result      : vector(\'n, dec, bits(\'o)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW_widen, LMUL_pow_widen, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        WX_VADD  => to_bits(SEW_widen, signed(vs2_val[i]) + signed(rs1_val)),\\n        WX_VSUB  => to_bits(SEW_widen, signed(vs2_val[i]) - signed(rs1_val)),\\n        WX_VADDU => to_bits(SEW_widen, unsigned(vs2_val[i]) + unsigned(rs1_val)),\\n        WX_VSUBU => to_bits(SEW_widen, unsigned(vs2_val[i]) - unsigned(rs1_val))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW_widen, LMUL_pow_widen, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vxor.vi","name":"TBD","operands":[{"name":"funct6","type":"vifunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"simm","type":"bits(5)"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,simmvm","format":"TBD","fields":[{"field":"encdec_vifunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"simm","size":5},{"field":"0b011","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let imm_val : bits(\'m)                  = sign_extend(simm);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VI_VADD    => vs2_val[i] + imm_val,\\n        VI_VRSUB   => imm_val - vs2_val[i],\\n        VI_VAND    => vs2_val[i] & imm_val,\\n        VI_VOR     => vs2_val[i] | imm_val,\\n        VI_VXOR    => vs2_val[i] ^ imm_val,\\n        VI_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, imm_val) ),\\n        VI_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, imm_val) ),\\n        VI_VSLL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VI_VSRL    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VI_VSRA    => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VI_VSSRL   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VI_VSSRA   => {\\n                        let shift_amount = get_shift_amount(zero_extend(\'m, simm), SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vxor.vv","name":"TBD","operands":[{"name":"funct6","type":"vvfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,vs1vm","format":"TBD","fields":[{"field":"encdec_vvfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vs1","size":5},{"field":"0b000","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW_pow  = get_sew_pow();\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let VLEN_pow = get_vlen_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vs1_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VV_VADD          => vs2_val[i] + vs1_val[i],\\n        VV_VSUB          => vs2_val[i] - vs1_val[i],\\n        VV_VAND          => vs2_val[i] & vs1_val[i],\\n        VV_VOR           => vs2_val[i] | vs1_val[i],\\n        VV_VXOR          => vs2_val[i] ^ vs1_val[i],\\n        VV_VSADDU        => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, vs1_val[i])),\\n        VV_VSADD         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSSUBU        => {\\n                              if unsigned(vs2_val[i]) < unsigned(vs1_val[i]) then zeros()\\n                              else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, vs1_val[i]))\\n                            },\\n        VV_VSSUB         => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, vs1_val[i])),\\n        VV_VSMUL         => {\\n                              let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(vs1_val[i]));\\n                              let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                              let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                              signed_saturation(\'m, result_wide[\'m..0])\\n                            },\\n        VV_VSLL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] << shift_amount\\n                            },\\n        VV_VSRL          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              vs2_val[i] >> shift_amount\\n                            },\\n        VV_VSRA          => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW)\\n                            },\\n        VV_VSSRL         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VSSRA         => {\\n                              let shift_amount = get_shift_amount(vs1_val[i], SEW);\\n                              let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                              let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                              slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                            },\\n        VV_VMINU         => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMIN          => to_bits(SEW, min(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VMAXU         => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(vs1_val[i]))),\\n        VV_VMAX          => to_bits(SEW, max(signed(vs2_val[i]), signed(vs1_val[i]))),\\n        VV_VRGATHER      => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              let idx = unsigned(vs1_val[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            },\\n        VV_VRGATHEREI16  => {\\n                              if (vs1 == vd | vs2 == vd) then { handle_illegal(); return RETIRE_FAIL };\\n                              /* vrgatherei16.vv uses SEW/LMUL for the data in vs2 but EEW=16 and EMUL = (16/SEW)*LMUL for the indices in vs1 */\\n                              let vs1_new : vector(\'n, dec, bits(16)) = read_vreg(num_elem, 16, 4 + LMUL_pow - SEW_pow, vs1);\\n                              let idx = unsigned(vs1_new[i]);\\n                              let VLMAX = int_power(2, LMUL_pow + VLEN_pow - SEW_pow);\\n                              assert(VLMAX <= \'n);\\n                              if idx < VLMAX then vs2_val[idx] else zeros()\\n                            }\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vxor.vx","name":"TBD","operands":[{"name":"funct6","type":"vxfunct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2,rs1vm","format":"TBD","fields":[{"field":"encdec_vxfunct6(funct6)","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW      = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n\\n  if illegal_normal(vd, vm) then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let rs1_val : bits(\'m)                  = get_scalar(rs1, SEW);\\n  let vs2_val : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VX_VADD    => vs2_val[i] + rs1_val,\\n        VX_VSUB    => vs2_val[i] - rs1_val,\\n        VX_VRSUB   => rs1_val - vs2_val[i],\\n        VX_VAND    => vs2_val[i] & rs1_val,\\n        VX_VOR     => vs2_val[i] | rs1_val,\\n        VX_VXOR    => vs2_val[i] ^ rs1_val,\\n        VX_VSADDU  => unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) + zero_extend(\'m + 1, rs1_val) ),\\n        VX_VSADD   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) + sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSSUBU  => {\\n                        if unsigned(vs2_val[i]) < unsigned(rs1_val) then zeros()\\n                        else unsigned_saturation(\'m, zero_extend(\'m + 1, vs2_val[i]) - zero_extend(\'m + 1, rs1_val) )\\n                      },\\n        VX_VSSUB   => signed_saturation(\'m, sign_extend(\'m + 1, vs2_val[i]) - sign_extend(\'m + 1, rs1_val) ),\\n        VX_VSMUL   => {\\n                        let result_mul = to_bits(\'m * 2, signed(vs2_val[i]) * signed(rs1_val));\\n                        let rounding_incr = get_fixed_rounding_incr(result_mul, \'m - 1);\\n                        let result_wide = (result_mul >> (\'m - 1)) + zero_extend(\'m * 2, rounding_incr);\\n                        signed_saturation(\'m, result_wide[\'m..0])\\n                      },\\n        VX_VSLL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] << shift_amount\\n                      },\\n        VX_VSRL    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        vs2_val[i] >> shift_amount\\n                      },\\n        VX_VSRA    => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW)\\n                      },\\n        VX_VSSRL   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        (vs2_val[i] >> shift_amount) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VSSRA   => {\\n                        let shift_amount = get_shift_amount(rs1_val, SEW);\\n                        let rounding_incr = get_fixed_rounding_incr(vs2_val[i], shift_amount);\\n                        let v_double : bits(\'m * 2) = sign_extend(vs2_val[i]);\\n                        slice(v_double >> shift_amount, 0, SEW) + zero_extend(\'m, rounding_incr)\\n                      },\\n        VX_VMINU   => to_bits(SEW, min(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMIN    => to_bits(SEW, min(signed(vs2_val[i]), signed(rs1_val))),\\n        VX_VMAXU   => to_bits(SEW, max(unsigned(vs2_val[i]), unsigned(rs1_val))),\\n        VX_VMAX    => to_bits(SEW, max(signed(vs2_val[i]), signed(rs1_val)))\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vzext.vf2","name":"TBD","operands":[{"name":"funct6","type":"vext2funct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vext2_vs1(funct6)","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_half = SEW / 2;\\n  let LMUL_pow_half = LMUL_pow - 1;\\n\\n  if  illegal_variable_width(vd, vm, SEW_half, LMUL_pow_half) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_half, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_half;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_half, LMUL_pow_half, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW > SEW_half);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VEXT2_ZVF2 => zero_extend(vs2_val[i]),\\n        VEXT2_SVF2 => sign_extend(vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vzext.vf4","name":"TBD","operands":[{"name":"funct6","type":"vext4funct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vext4_vs1(funct6)","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_quart = SEW / 4;\\n  let LMUL_pow_quart = LMUL_pow - 2;\\n\\n  if  illegal_variable_width(vd, vm, SEW_quart, LMUL_pow_quart) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_quart, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_quart;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_quart, LMUL_pow_quart, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW > SEW_quart);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VEXT4_ZVF4 => zero_extend(vs2_val[i]),\\n        VEXT4_SVF4 => sign_extend(vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"vzext.vf8","name":"TBD","operands":[{"name":"funct6","type":"vext8funct6"},{"name":"vm","type":"bits(1)"},{"name":"vs2","type":"regidx"},{"name":"vd","type":"regidx"}],"syntax":"vd,vs2vm","format":"TBD","fields":[{"field":"0b010010","size":6},{"field":"vm","size":1},{"field":"vs2","size":5},{"field":"vext8_vs1(funct6)","size":5},{"field":"0b010","size":3},{"field":"vd","size":5},{"field":"0b1010111","size":7}],"extensions":["V"],"function":"{\\n  let SEW = get_sew();\\n  let LMUL_pow = get_lmul_pow();\\n  let num_elem = get_num_elem(LMUL_pow, SEW);\\n  let SEW_eighth = SEW / 8;\\n  let LMUL_pow_eighth = LMUL_pow - 3;\\n\\n  if  illegal_variable_width(vd, vm, SEW_eighth, LMUL_pow_eighth) |\\n      not(valid_reg_overlap(vs2, vd, LMUL_pow_eighth, LMUL_pow))\\n  then { handle_illegal(); return RETIRE_FAIL };\\n\\n  let \'n = num_elem;\\n  let \'m = SEW;\\n  let \'o = SEW_eighth;\\n\\n  let vm_val  : vector(\'n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);\\n  let vd_val  : vector(\'n, dec, bits(\'m)) = read_vreg(num_elem, SEW, LMUL_pow, vd);\\n  let vs2_val : vector(\'n, dec, bits(\'o)) = read_vreg(num_elem, SEW_eighth, LMUL_pow_eighth, vs2);\\n  result      : vector(\'n, dec, bits(\'m)) = undefined;\\n  mask        : vector(\'n, dec, bool)     = undefined;\\n\\n  (result, mask) = init_masked_result(num_elem, SEW, LMUL_pow, vd_val, vm_val);\\n\\n  assert(SEW > SEW_eighth);\\n  foreach (i from 0 to (num_elem - 1)) {\\n    if mask[i] then {\\n      result[i] = match funct6 {\\n        VEXT8_ZVF8 => zero_extend(vs2_val[i]),\\n        VEXT8_SVF8 => sign_extend(vs2_val[i])\\n      }\\n    }\\n  };\\n\\n  write_vreg(num_elem, SEW, LMUL_pow, vd, result);\\n  vstart = zeros();\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"wfi","name":"TBD","operands":[],"syntax":"","format":"TBD","fields":[{"field":"0b000100000101","size":12},{"field":"0b00000","size":5},{"field":"0b000","size":3},{"field":"0b00000","size":5},{"field":"0b1110011","size":7}],"extensions":[],"function":"match cur_privilege {\\n    Machine    => { platform_wfi(); RETIRE_SUCCESS },\\n    Supervisor => if   mstatus.TW() == 0b1\\n                  then { handle_illegal(); RETIRE_FAIL }\\n                  else { platform_wfi(); RETIRE_SUCCESS },\\n    User       => { handle_illegal(); RETIRE_FAIL }\\n  }","description":"TBD"},{"mnemonic":"xnor","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"brop_zbb"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0110000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbb","Zbkb"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ANDN => rs1_val & ~(rs2_val),\\n    RISCV_ORN  => rs1_val | ~(rs2_val),\\n    RISCV_XNOR => ~(rs1_val ^ rs2_val),\\n    RISCV_MAX  => to_bits(sizeof(xlen), max(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MAXU => to_bits(sizeof(xlen), max(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_MIN  => to_bits(sizeof(xlen), min(signed(rs1_val),   signed(rs2_val))),\\n    RISCV_MINU => to_bits(sizeof(xlen), min(unsigned(rs1_val), unsigned(rs2_val))),\\n    RISCV_ROL  => if sizeof(xlen) == 32\\n                  then rs1_val <<< rs2_val[4..0]\\n                  else rs1_val <<< rs2_val[5..0],\\n    RISCV_ROR  => if sizeof(xlen) == 32\\n                  then rs1_val >>> rs2_val[4..0]\\n                  else rs1_val >>> rs2_val[5..0]\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"xor","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"rop"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0100000","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b101","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  let result : xlenbits = match op {\\n    RISCV_ADD  => rs1_val + rs2_val,\\n    RISCV_SLT  => zero_extend(bool_to_bits(rs1_val <_s rs2_val)),\\n    RISCV_SLTU => zero_extend(bool_to_bits(rs1_val <_u rs2_val)),\\n    RISCV_AND  => rs1_val & rs2_val,\\n    RISCV_OR   => rs1_val | rs2_val,\\n    RISCV_XOR  => rs1_val ^ rs2_val,\\n    RISCV_SLL  => if   sizeof(xlen) == 32\\n                  then rs1_val << (rs2_val[4..0])\\n                  else rs1_val << (rs2_val[5..0]),\\n    RISCV_SRL  => if   sizeof(xlen) == 32\\n                  then rs1_val >> (rs2_val[4..0])\\n                  else rs1_val >> (rs2_val[5..0]),\\n    RISCV_SUB  => rs1_val - rs2_val,\\n    RISCV_SRA  => if   sizeof(xlen) == 32\\n                  then shift_right_arith32(rs1_val, rs2_val[4..0])\\n                  else shift_right_arith64(rs1_val, rs2_val[5..0])\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe R-type (Register-type) instruction format is used for operations\\nthat involve three registers. The specific operation is determined\\nby the opcode and funct7 fields. The result is written to the\\ndestination register (rd), and the source operands are specified\\nby the source registers (rs1 and rs2). The format is common for\\narithmetic, logical, and shift operations.\\n "},{"mnemonic":"xori","name":"TBD","operands":[{"name":"imm","type":"bits(12)"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"iop"}],"syntax":"rd,rs1,imm","format":"TBD","fields":[{"field":"imm","size":12},{"field":"rs1","size":5},{"field":"encdec_iop(op)","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":[],"function":"{\\n  let rs1_val = X(rs1);\\n  let immext : xlenbits = sign_extend(imm);\\n  let result : xlenbits = match op {\\n    RISCV_ADDI  => rs1_val + immext,\\n    RISCV_SLTI  => zero_extend(bool_to_bits(rs1_val <_s immext)),\\n    RISCV_SLTIU => zero_extend(bool_to_bits(rs1_val <_u immext)),\\n    RISCV_ANDI  => rs1_val & immext,\\n    RISCV_ORI   => rs1_val | immext,\\n    RISCV_XORI  => rs1_val ^ immext\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"\\nThe ITYPE instruction operates on an immediate value, adding, comparing, or\\nperforming bitwise operations with the contents of register rs1.\\nThe immediate value, rs1, and the operation code (iop) determine the operation.\\nThe result is stored in register rd.\\nThe supported immediate operations (iop) include:\\n  - \\"addi\\"  : Add immediate\\n  - \\"slti\\"  : Set less than immediate (signed)\\n  - \\"sltiu\\" : Set less than immediate (unsigned)\\n  - \\"andi\\"  : AND immediate\\n  - \\"ori\\"   : OR immediate\\n  - \\"xori\\"  : XOR immediate\\n *\\nNote: The immediate value is sign-extended before performing the operation.\\n "},{"mnemonic":"xperm4","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b010","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbkx"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  result : xlenbits = zeros();\\n  foreach (i from 0 to (sizeof(xlen) - 4) by 4) {\\n    let index = unsigned(rs2_val[i+3..i]);\\n    result[i+3..i] = if 4*index < sizeof(xlen)\\n                     then rs1_val[4*index+3..4*index]\\n                     else zeros()\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"xperm8","name":"TBD","operands":[{"name":"rs2","type":"regidx"},{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1,rs2","format":"TBD","fields":[{"field":"0b0010100","size":7},{"field":"rs2","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"rd","size":5},{"field":"0b0110011","size":7}],"extensions":["Zbkx"],"function":"{\\n  let rs1_val = X(rs1);\\n  let rs2_val = X(rs2);\\n  result : xlenbits = zeros();\\n  foreach (i from 0 to (sizeof(xlen) - 8) by 8) {\\n    let index = unsigned(rs2_val[i+7..i]);\\n    result[i+7..i] = if 8*index < sizeof(xlen)\\n                     then rs1_val[8*index+7..8*index]\\n                     else zeros()\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"zext.h","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"},{"name":"op","type":"extop_zbb"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b0000100","size":7},{"field":"0b00000","size":5},{"field":"rs1","size":5},{"field":"0b100","size":3},{"field":"rd","size":5},{"field":"0b0111011","size":7}],"extensions":["Zbb"],"function":"{\\n  let rs1_val = X(rs1);\\n  let result : xlenbits = match op {\\n    RISCV_SEXTB => sign_extend(rs1_val[7..0]),\\n    RISCV_SEXTH => sign_extend(rs1_val[15..0]),\\n    RISCV_ZEXTH => zero_extend(rs1_val[15..0])\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"},{"mnemonic":"zip","name":"TBD","operands":[{"name":"rs1","type":"regidx"},{"name":"rd","type":"regidx"}],"syntax":"rd,rs1","format":"TBD","fields":[{"field":"0b000010001111","size":12},{"field":"rs1","size":5},{"field":"0b001","size":3},{"field":"rd","size":5},{"field":"0b0010011","size":7}],"extensions":["Zbkb"],"function":"{\\n  assert(sizeof(xlen) == 32);\\n  let rs1_val = X(rs1);\\n  result : xlenbits = zeros();\\n  foreach (i from 0 to (sizeof(xlen_bytes)*4 - 1)) {\\n    result[i*2] = rs1_val[i];\\n    result[i*2 + 1] = rs1_val[i + sizeof(xlen_bytes)*4];\\n  };\\n  X(rd) = result;\\n  RETIRE_SUCCESS\\n}","description":"TBD"}],"bd":["I","R","TBD"],"Rw":["A","C","D","F","M","V","Zba","Zbb","Zbc","Zbkb","Zbkc","Zbkx","Zbs","Zfa","Zfh","Zicond","Zknd","Zkne","Zknh","Zksed","Zksh"]}'),Kx=t(29),Qx=[];function Jx(e,n,t){Qx.push(e)}var $x=function(e){d(t,e);var n=v(t);function t(e){var i;s(this,t),(i=n.call(this,e)).toggleDarkMode=function(){i.setState((function(e){var n=!e.isDarkMode;return localStorage.setItem("isDarkMode",n),{isDarkMode:n}}),(function(){document.body.classList.toggle("darkmode",i.state.isDarkMode)}))},i.genData=function(e){for(var n=[],t=0;t<e.length;t++)(i.state.search_mnemonics&&e[t].mnemonic.startsWith(i.state.search)||i.state.search_names&&i.state.search.split(" ").every(i.matchEach,e[t].name.toLowerCase()))&&i.state.formatSet.includes(e[t].format)&&i.matchAny(e[t].extensions,i.state.extensionSet)&&n.push((0,Zx.jsx)(Ya,{title:i.genTitle(e[t]),children:i.genItem(e[t])},e[t].mnemonic));return n},0==Qx.length&&jx.bd.forEach(Jx);var l="true"===localStorage.getItem("isDarkMode");return i.state={data:jx.NE,extensionSet:jx.Rw,formatSet:Qx,search:"",search_mnemonics:!0,search_names:!1,isDarkMode:l},i}return r(t,[{key:"componentDidMount",value:function(){document.body.classList.toggle("darkmode",this.state.isDarkMode)}},{key:"displayMnemonic",value:function(e){var n="               ",t=15-e.mnemonic.length;t<2&&(t=2);var i=e.mnemonic+n.substr(0,t)+e.syntax,s="";try{if(e.conditions.length>0){s="(";for(var l="",r=0;r<e.conditions.length;r++)s+=l+e.conditions[r].field+"="+e.conditions[r].value,l=", ";s+=")"}}catch(d){}var a="mnemonics-table-"+e.mnemonic;return(0,Zx.jsx)("table",{children:(0,Zx.jsx)("tbody",{children:(0,Zx.jsxs)("tr",{children:[(0,Zx.jsx)("td",{children:(0,Zx.jsx)(Kx.CopyToClipboard,{text:i,children:(0,Zx.jsx)(kg,{className:"syntax",feedback:"Copied to clipboard",copyButtonDescription:"Copy",ariaLabel:"mnemonic",type:"inline",children:i},"syntax")})}),(0,Zx.jsx)("td",{children:(0,Zx.jsx)("p",{className:"conditions",children:s})})]})})},a)}},{key:"displayField",value:function(e,n){return e.field.startsWith("0b")?e.field.substring(2).split("").map((function(e,t){return(0,Zx.jsx)("td",{className:"instruction-field",colSpan:1,children:e},n+"-"+t)})):(0,Zx.jsx)("td",{className:"instruction-field",colSpan:e.size,children:e.field},n)}},{key:"displayFields",value:function(e){for(var n=[],t=0;t<e.length;t++)n.push(this.displayField(e[t],t));return n}},{key:"displayBitScale",value:function(e,n){for(var t=[],i=n-1;i>=0;i--)t.push((0,Zx.jsx)("td",{className:"instruction-bit-number",children:("0"+i.toString()).slice(-2)},i));return t}},{key:"displayLayoutRows",value:function(e,n){for(var t=[],i=0,s=0,l=0;l<e.length;l++)(i+=parseInt(e[l].size))>=n&&(t.push((0,Zx.jsx)("tr",{children:this.displayFields(e.slice(s,l+1))},s)),s=l+1,i=0);return t}},{key:"displayLayout",value:function(e){for(var n=[],t=0,i=0;i<e.length;i++)t+=parseInt(e[i].size);return t>32&&(t=32),n.push(this.displayLayoutRows(e,t)),n.push((0,Zx.jsx)("tr",{children:this.displayBitScale(e,t)},"bitScale")),n}},{key:"genItem",value:function(e){return(0,Zx.jsx)("div",{className:"expandContainer",children:(0,Zx.jsxs)("div",{className:"column",children:[this.displayMnemonic(e),(0,Zx.jsx)("br",{}),(0,Zx.jsx)("table",{style:{width:"100%"},children:(0,Zx.jsx)("tbody",{children:(0,Zx.jsxs)("tr",{children:[(0,Zx.jsx)("td",{children:(0,Zx.jsx)("table",{className:"instruction-layout",children:(0,Zx.jsx)("tbody",{children:this.displayLayout(e.fields)})})}),(0,Zx.jsxs)("td",{style:{textAlign:"right"},children:[e.format,"-type"]})]})})}),(0,Zx.jsx)("br",{}),(0,Zx.jsx)(Kx.CopyToClipboard,{text:e.function,children:(0,Zx.jsx)(kg,{className:"pseudocode",type:"multi",feedback:"Copied to clipboard",children:(0,Zx.jsx)("p",{className:"inner",children:e.function})},"pseudocode")}),(0,Zx.jsx)("br",{}),(0,Zx.jsx)("div",{className:"prose",children:e.description})]})})}},{key:"genTitle",value:function(e){return(0,Zx.jsx)("table",{className:"item",children:(0,Zx.jsx)("tbody",{children:(0,Zx.jsxs)("tr",{children:[(0,Zx.jsx)("td",{className:"itemtitledesc",children:e.name}),(0,Zx.jsx)("td",{className:"itemtitlemnem",children:e.mnemonic}),(0,Zx.jsx)("td",{className:"itemtitleext",children:e.extensions.join()})]})})})}},{key:"matchEach",value:function(e){return this.includes(e)}},{key:"matchAny",value:function(e,n){var t=document.getElementById("all-extensions");if(!t)return!0;if(0==e.length)return t.checked;if(e.length>0&&0==n.length)return!1;for(var i=0;i<e.length;i++)if(n.includes(e[i]))return!0;return!1}},{key:"genExtensionLabel",value:function(e){return(0,Zx.jsx)("table",{className:"extensionlabel",children:(0,Zx.jsx)("tbody",{children:(0,Zx.jsx)("tr",{children:(0,Zx.jsx)("td",{className:"extensionversion",children:e})})})})}},{key:"genExtensionCheckboxes",value:function(e){for(var n=this,t=[],i=function(i){t.push((0,Zx.jsx)(Ga,{defaultChecked:!0,className:"checkbox",id:e[i],labelText:n.genExtensionLabel(e[i]),disabled:!1,hideLabel:!1,onChange:function(t,s,l){n.filterByExtensions(s.checked,e[i])}},e[i]))},s=0;s<e.length;s++)i(s);return t}},{key:"genFormatCheckboxes",value:function(e){for(var n=this,t=[],i=function(i){t.push((0,Zx.jsx)(Ga,{defaultChecked:!0,className:"checkbox",id:e[i],labelText:e[i],disabled:!1,hideLabel:!1,onChange:function(t,s,l){n.filterByFormats(s.checked,e[i])}},e[i]))},s=0;s<e.length;s++)i(s);return t}},{key:"search",value:function(){var e=document.getElementById("search-1");this.setState({search:e.value.toLowerCase()})}},{key:"filterAllExtensions",value:function(e){var n=[];e&&(n=jx.Rw);for(var t=0;t<jx.Rw.length;t++){document.getElementById(jx.Rw[t]).checked=e}this.setState({extensionSet:n})}},{key:"filterAllFormats",value:function(e){var n=[];e&&(n=Qx);for(var t=0;t<Qx.length;t++){document.getElementById(Qx[t]).checked=e}this.setState({formatSet:n})}},{key:"filterByExtensions",value:function(e,n){var t=[];if(e)(t=this.state.extensionSet).push(n);else for(var i=0;i<this.state.extensionSet.length;i++)this.state.extensionSet[i]!==n&&t.push(this.state.extensionSet[i]);this.setState({extensionSet:t})}},{key:"filterByFormats",value:function(e,n){var t=[];if(e)(t=this.state.formatSet).push(n);else for(var i=0;i<this.state.formatSet.length;i++)this.state.formatSet[i]!==n&&t.push(this.state.formatSet[i]);this.setState({formatSet:t})}},{key:"genMultiLine",value:function(e,n){var t=[];try{n.split("\n").map((function(e){return t.push(e),t.push((0,Zx.jsx)("br",{}))}))}catch(i){}return t}},{key:"displayOps",value:function(e,n){for(var t="",i="",s=0;s<e.length;s++){e[s].optional[0]-"0"<=n&&(t+=i+e[s].name,i=",")}return t}},{key:"render",value:function(){var e=this,n=this.state.isDarkMode,t=n?"app dark-mode":"App";return(0,Zx.jsx)("div",{className:t,children:(0,Zx.jsx)("div",{"data-floating-menu-container":"true",role:"main",className:"pageContainer",children:(0,Zx.jsxs)("div",{className:"homeContainer",children:[(0,Zx.jsx)(Gx,{isDarkMode:n,toggleDarkMode:this.toggleDarkMode}),(0,Zx.jsxs)("div",{className:"mainContainer",children:[(0,Zx.jsxs)("div",{className:"filterContainer",children:[(0,Zx.jsx)(j,{children:(0,Zx.jsx)(Ya,{title:"Extensions",children:(0,Zx.jsxs)("fieldset",{className:"checkboxes",children:[(0,Zx.jsx)(Ga,{defaultChecked:!0,className:"checkbox",id:"all-extensions",labelText:"[all]",disabled:!1,hideLabel:!1,onChange:function(n,t,i){e.filterAllExtensions(t.checked)}}),this.genExtensionCheckboxes(jx.Rw)]})})}),(0,Zx.jsx)(j,{children:(0,Zx.jsx)(Ya,{title:"Instruction formats",children:(0,Zx.jsxs)("fieldset",{className:"checkboxes",children:[(0,Zx.jsx)(Ga,{defaultChecked:!0,className:"checkbox",id:"all-forms",labelText:"[all]",disabled:!1,hideLabel:!1,onChange:function(n,t,i){e.filterAllFormats(t.checked)}}),this.genFormatCheckboxes(jx.bd)]})})})]}),(0,Zx.jsxs)("div",{className:"accordianContainer",children:[(0,Zx.jsx)("div",{className:"searchContainer",children:(0,Zx.jsx)("table",{children:(0,Zx.jsx)("tbody",{children:(0,Zx.jsxs)("tr",{children:[(0,Zx.jsx)("td",{style:{width:"50%",justifyContent:"center"},children:(0,Zx.jsx)(Ex,{className:"some-class",name:"",defaultValue:"",labelText:"Search",closeButtonLabelText:"",placeholder:"Search",onChange:function(){e.search()},id:"search-1"})}),(0,Zx.jsxs)("td",{children:[(0,Zx.jsx)(Ga,{defaultChecked:!0,className:"checkbox",id:"search-mnemonics",labelText:"mnemonics",disabled:!1,hideLabel:!1,onChange:function(n,t,i){e.setState({search_mnemonics:t.checked})}}),(0,Zx.jsx)(Ga,{className:"checkbox",id:"search-names",labelText:"names",disabled:!1,hideLabel:!1,onChange:function(n,t,i){e.setState({search_names:t.checked})}})]})]})})})}),(0,Zx.jsx)(j,{children:this.genData(this.state.data)})]})]})]})})})}}]),t}(n.Component),ez=$x;i.render((0,Zx.jsx)(n.StrictMode,{children:(0,Zx.jsx)(ez,{})}),document.getElementById("root"))}()}();
//# sourceMappingURL=main.b919b6b4.js.map