{
    "instructions": [
        {
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Branch",
                    "form": "I",
                    "mnemonic": "b",
                    "operands": [
                        "target_addr"
                    ],
                    "conditions": [
                        {
                            "field": "AA",
                            "value": "0"
                        },
                        {
                            "field": "LK",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Branch",
                    "form": "I",
                    "mnemonic": "ba",
                    "operands": [
                        "target_addr"
                    ],
                    "conditions": [
                        {
                            "field": "AA",
                            "value": "1"
                        },
                        {
                            "field": "LK",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Branch",
                    "form": "I",
                    "mnemonic": "bl",
                    "operands": [
                        "target_addr"
                    ],
                    "conditions": [
                        {
                            "field": "AA",
                            "value": "0"
                        },
                        {
                            "field": "LK",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Branch",
                    "form": "I",
                    "mnemonic": "bla",
                    "operands": [
                        "target_addr"
                    ],
                    "conditions": [
                        {
                            "field": "AA",
                            "value": "1"
                        },
                        {
                            "field": "LK",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "18",
                    "size": "6"
                },
                {
                    "name": "LI",
                    "size": "24"
                },
                {
                    "name": "AA",
                    "size": "1"
                },
                {
                    "name": "LK",
                    "size": "1"
                }
            ],
            "code": [
                "if AA then NIA :=<sub>iea</sub> EXTS(LI || 0b00)",
                "else       NIA :=<sub>iea</sub> CIA + EXTS(LI || 0b00)",
                "if LK then LR :=<sub>iea</sub> CIA + 4"
            ],
            "body": [
                "",
                "",
                "target_addr specifies the branch target address.",
                "",
                "If AA=0 then the branch target address is the sum of LI||0b00",
                "sign-extended and the address of this instruction, with the",
                "high-order 32 bits of the branch target address set to 0 in 32-bit",
                "mode.",
                "",
                "If AA=1 then the branch target address is the value LI||0b00",
                "sign-extended, with the high-order 32 bits of the branch target",
                "address set to 0 in 32-bit mode.",
                "",
                "If LK=1 then the effective address of the instruction following the",
                "Branch instruction is placed into the Link Register.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Branch Conditional",
                    "form": "B",
                    "mnemonic": "bc",
                    "operands": [
                        "BO",
                        "BI",
                        "target_addr"
                    ],
                    "conditions": [
                        {
                            "field": "AA",
                            "value": "0"
                        },
                        {
                            "field": "LK",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Branch Conditional",
                    "form": "B",
                    "mnemonic": "bca",
                    "operands": [
                        "BO",
                        "BI",
                        "target_addr"
                    ],
                    "conditions": [
                        {
                            "field": "AA",
                            "value": "1"
                        },
                        {
                            "field": "LK",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Branch Conditional",
                    "form": "B",
                    "mnemonic": "bcl",
                    "operands": [
                        "BO",
                        "BI",
                        "target_addr"
                    ],
                    "conditions": [
                        {
                            "field": "AA",
                            "value": "0"
                        },
                        {
                            "field": "LK",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Branch Conditional",
                    "form": "B",
                    "mnemonic": "bcla",
                    "operands": [
                        "BO",
                        "BI",
                        "target_addr"
                    ],
                    "conditions": [
                        {
                            "field": "AA",
                            "value": "1"
                        },
                        {
                            "field": "LK",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "16",
                    "size": "6"
                },
                {
                    "name": "BO",
                    "size": "5"
                },
                {
                    "name": "BI",
                    "size": "5"
                },
                {
                    "name": "BD",
                    "size": "14"
                },
                {
                    "name": "AA",
                    "size": "1"
                },
                {
                    "name": "LK",
                    "size": "1"
                }
            ],
            "code": [
                "if (64-bit mode)",
                "  then M := 0",
                "  else M := 32",
                "if ~BO<sub>2</sub> then CTR := CTR - 1",
                "ctr_ok := BO<sub>2</sub> | ((CTR<sub>M:63</sub> != 0) ^ BO<sub>3</sub>)",
                "cond_ok := BO<sub>0</sub> | (CR<sub>BI+32</sub> == BO<sub>1</sub>)",
                "if ctr_ok & cond_ok then",
                "  if AA then NIA :=<sub>iea</sub> EXTS(BD || 0b00)",
                "  else       NIA :=<sub>iea</sub> CIA + EXTS(BD || 0b00)",
                "if LK then LR :=<sub>iea</sub> CIA + 4"
            ],
            "body": [
                "",
                "",
                "BI+32 specifies the Condition Register bit to be tested.",
                "The BO field is used to resolve the branch as described in",
                "Figure.",
                "target_addr specifies the branch target address.",
                "",
                "If AA=0 then the branch target address is the sum of BD||0b00",
                "sign-extended and the address of this instruction, with the",
                "high-order 32 bits of the branch target address set to 0 in 32-bit",
                "mode.",
                "",
                "If AA=1 then the branch target address is the value BD||0b00",
                "sign-extended, with the high-order 32 bits of the branch target",
                "address set to 0 in 32-bit mode.",
                "",
                "If LK=1 then the effective address of the instruction following the",
                "Branch instruction is placed into the Link Register.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Branch Conditional to Link Register",
                    "form": "XL",
                    "mnemonic": "bclr",
                    "operands": [
                        "BO",
                        "BI",
                        "BH"
                    ],
                    "conditions": [
                        {
                            "field": "LK",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Branch Conditional to Link Register",
                    "form": "XL",
                    "mnemonic": "bclrl",
                    "operands": [
                        "BO",
                        "BI",
                        "BH"
                    ],
                    "conditions": [
                        {
                            "field": "LK",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "BO",
                    "size": "5"
                },
                {
                    "name": "BI",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "BH",
                    "size": "2"
                },
                {
                    "name": "16",
                    "size": "10"
                },
                {
                    "name": "LK",
                    "size": "1"
                }
            ],
            "code": [
                "if (64-bit mode)",
                "  then M := 0",
                "  else M := 32",
                "if ~BO<sub>2</sub> then CTR := CTR - 1",
                "ctr_ok := BO<sub>2</sub> | ((CTR<sub>M:63</sub> != 0) ^ BO<sub>3</sub>",
                "cond_ok := BO<sub>0</sub> | (CR<sub>BI+32</sub> == BO<sub>1</sub>)",
                "if ctr_ok & cond_ok then NIA :=<sub>iea</sub> LR<sub>0:61</sub> || 0b00",
                "if LK then LR :=<sub>iea</sub> CIA + 4"
            ],
            "body": [
                "",
                "",
                "BI+32 specifies the Condition Register bit to be tested.",
                "The BO field is used to resolve the branch as described in",
                "Figure.",
                "The BH field is used as described in",
                "Figure.",
                "The branch target address is LR0:61||0b00, with the",
                "high-order 32 bits of the branch target address set to 0 in 32-bit",
                "mode.",
                "",
                "If LK=1 then the effective address of the instruction following the",
                "Branch instruction is placed into the Link Register.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Branch Conditional to Count Register",
                    "form": "XL",
                    "mnemonic": "bcctr",
                    "operands": [
                        "BO",
                        "BI",
                        "BH"
                    ],
                    "conditions": [
                        {
                            "field": "LK",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Branch Conditional to Count Register",
                    "form": "XL",
                    "mnemonic": "bcctrl",
                    "operands": [
                        "BO",
                        "BI",
                        "BH"
                    ],
                    "conditions": [
                        {
                            "field": "LK",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "BO",
                    "size": "5"
                },
                {
                    "name": "BI",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "BH",
                    "size": "2"
                },
                {
                    "name": "528",
                    "size": "10"
                },
                {
                    "name": "LK",
                    "size": "1"
                }
            ],
            "code": [
                "cond_ok := BO<sub>0</sub> | (CR<sub>BI+32</sub> == BO<sub>1</sub>)",
                "if cond_ok then NIA :=<sub>iea</sub> CTR<sub>0:61</sub> || 0b00",
                "if LK then LR :=<sub>iea</sub> CIA + 4"
            ],
            "body": [
                "",
                "",
                "BI+32 specifies the Condition Register bit to be tested.",
                "The BO field is used to resolve the branch as described in",
                "Figure.",
                "The BH field is used as described in",
                "Figure.",
                "The branch target address is CTR0:61||0b00, with",
                "the high-order 32 bits of the branch target address set to 0 in",
                "32-bit mode.",
                "",
                "If LK=1 then the effective address of the instruction following the",
                "Branch instruction is placed into the Link Register.",
                "",
                "If the decrement and test CTR option is specified",
                "(BO2=0), the instruction form is invalid.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Branch Conditional to Branch Target Address Register",
                    "form": "XL",
                    "mnemonic": "bctar",
                    "operands": [
                        "BO",
                        "BI",
                        "BH"
                    ],
                    "conditions": [
                        {
                            "field": "LK",
                            "value": "0"
                        }
                    ],
                    "release": "v2.07"
                },
                {
                    "name": "Branch Conditional to Branch Target Address Register",
                    "form": "XL",
                    "mnemonic": "bctarl",
                    "operands": [
                        "BO",
                        "BI",
                        "BH"
                    ],
                    "conditions": [
                        {
                            "field": "LK",
                            "value": "1"
                        }
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "BO",
                    "size": "5"
                },
                {
                    "name": "BI",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "BH",
                    "size": "2"
                },
                {
                    "name": "560",
                    "size": "10"
                },
                {
                    "name": "LK",
                    "size": "1"
                }
            ],
            "code": [
                "if (64-bit mode)",
                "  then M := 0",
                "  else M := 32",
                "if ~BO<sub>2</sub> then CTR := CTR - 1",
                "ctr_ok := BO<sub>2</sub> | ((CTR<sub>M:63</sub> != 0) ^ BO<sub>3</sub>",
                "cond_ok := BO<sub>0</sub> | (CR<sub>BI+32</sub> == BO<sub>1</sub>)",
                "if ctr_ok & cond_ok then NIA :=<sub>iea</sub> TAR<sub>0:61</sub> || 0b00",
                "if LK then LR :=<sub>iea</sub> CIA + 4"
            ],
            "body": [
                "",
                "",
                "BI+32 specifies the Condition Register bit to be tested.",
                "The BO field is used to resolve the branch as described in",
                "Figure.",
                "The BH field is used as described in",
                "Figure.",
                "The branch target address is TAR0:61||0b00, with",
                "the high-order 32 bits of the branch target address set to 0 in",
                "32-bit mode.",
                "",
                "If LK=1 then the effective address of the instruction following the",
                "Branch instruction is placed into the Link Register.",
                "",
                "Special Registers Altered:",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Condition Register AND",
                    "form": "XL",
                    "mnemonic": "crand",
                    "operands": [
                        "BT",
                        "BA",
                        "BB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "BA",
                    "size": "5"
                },
                {
                    "name": "BB",
                    "size": "5"
                },
                {
                    "name": "257",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> & CR<sub>BB+32</sub>"
            ],
            "body": [
                "",
                "",
                "The bit in the Condition Register specified by BA+32 is ANDed with",
                "the bit in the Condition Register specified by BB+32, and the result",
                "is placed into the bit in the Condition Register specified by BT+32.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Condition Register OR",
                    "form": "XL",
                    "mnemonic": "cror",
                    "operands": [
                        "BT",
                        "BA",
                        "BB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "BA",
                    "size": "5"
                },
                {
                    "name": "BB",
                    "size": "5"
                },
                {
                    "name": "449",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> | CR<sub>BB+32</sub>"
            ],
            "body": [
                "",
                "",
                "The bit in the Condition Register specified by BA+32 is ORed with the",
                "bit in the Condition Register specified by BB+32, and the result is",
                "placed into the bit in the Condition Register specified by BT+32.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Condition Register NAND",
                    "form": "XL",
                    "mnemonic": "crnand",
                    "operands": [
                        "BT",
                        "BA",
                        "BB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "BA",
                    "size": "5"
                },
                {
                    "name": "BB",
                    "size": "5"
                },
                {
                    "name": "225",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>BT+32</sub> := ~(CR<sub>BA+32</sub> & CR<sub>BB+32</sub>)"
            ],
            "body": [
                "",
                "",
                "The bit in the Condition Register specified by BA+32 is ANDed with",
                "the bit in the Condition Register specified by BB+32, and the",
                "complemented result is placed into the bit in the Condition Register",
                "specified by BT+32.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Condition Register XOR",
                    "form": "XL",
                    "mnemonic": "crxor",
                    "operands": [
                        "BT",
                        "BA",
                        "BB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "BA",
                    "size": "5"
                },
                {
                    "name": "BB",
                    "size": "5"
                },
                {
                    "name": "193",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> ^ CR<sub>BB+32</sub>"
            ],
            "body": [
                "",
                "",
                "The bit in the Condition Register specified by BA+32 is XORed with",
                "the bit in the Condition Register specified by BB+32, and the result",
                "is placed into the bit in the Condition Register specified by BT+32.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Condition Register NOR",
                    "form": "XL",
                    "mnemonic": "crnor",
                    "operands": [
                        "BT",
                        "BA",
                        "BB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "BA",
                    "size": "5"
                },
                {
                    "name": "BB",
                    "size": "5"
                },
                {
                    "name": "33",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>BT+32</sub> := ~(CR<sub>BA+32</sub> | CR<sub>BB+32</sub>)"
            ],
            "body": [
                "",
                "",
                "The bit in the Condition Register specified by BA+32 is ORed with the",
                "bit in the Condition Register specified by BB+32, and the",
                "complemented result is placed into the bit in the Condition Register",
                "specified by BT+32.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Condition Register AND with Complement",
                    "form": "XL",
                    "mnemonic": "crandc",
                    "operands": [
                        "BT",
                        "BA",
                        "BB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "BA",
                    "size": "5"
                },
                {
                    "name": "BB",
                    "size": "5"
                },
                {
                    "name": "129",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> & ~CR<sub>BB+32</sub>"
            ],
            "body": [
                "",
                "",
                "The bit in the Condition Register specified by BA+32 is ANDed with",
                "the complement of the bit in the Condition Register specified by",
                "BB+32, and the result is placed into the bit in the Condition",
                "Register specified by BT+32.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Condition Register Equivalent",
                    "form": "XL",
                    "mnemonic": "creqv",
                    "operands": [
                        "BT",
                        "BA",
                        "BB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "BA",
                    "size": "5"
                },
                {
                    "name": "BB",
                    "size": "5"
                },
                {
                    "name": "289",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> == CR<sub>BB+32</sub>"
            ],
            "body": [
                "",
                "",
                "The bit in the Condition Register specified by BA+32 is XORed with",
                "the bit in the Condition Register specified by BB+32, and the",
                "complemented result is placed into the bit in the Condition Register",
                "specified by BT+32.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Condition Register OR with Complement",
                    "form": "XL",
                    "mnemonic": "crorc",
                    "operands": [
                        "BT",
                        "BA",
                        "BB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "BA",
                    "size": "5"
                },
                {
                    "name": "BB",
                    "size": "5"
                },
                {
                    "name": "417",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>BT+32</sub> := CR<sub>BA+32</sub> | ~CR<sub>BB+32</sub>"
            ],
            "body": [
                "",
                "",
                "The bit in the Condition Register specified by BA+32 is ORed with the",
                "complement of the bit in the Condition Register specified by BB+32,",
                "and the result is placed into the bit in the Condition Register",
                "specified by BT+32.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move Condition Register Field",
                    "form": "XL",
                    "mnemonic": "mcrf",
                    "operands": [
                        "BF",
                        "BFA"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "BFA",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "7"
                },
                {
                    "name": "0",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>4BF+32:4BF+35</sub> := CR<sub>4BFA+32:4BFA+35</sub>"
            ],
            "body": [
                "",
                "",
                "The contents of Condition Register field BFA are copied to Condition",
                "Register field BF.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "System Call",
                    "form": "SC",
                    "mnemonic": "sc",
                    "operands": [
                        "LEV"
                    ],
                    "conditions": [],
                    "release": "PPC"
                },
                {
                    "name": "System Call Vectored",
                    "form": "SC",
                    "mnemonic": "scv",
                    "operands": [
                        "LEV"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "17",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "14"
                },
                {
                    "name": "LEV",
                    "size": "7"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "1",
                    "size": "2"
                }
            ],
            "code": [],
            "body": [
                "",
                "These instructions call the system to perform a service.",
                "A complete description of these instructions can be found in",
                "Section of Book",
                "III.",
                "",
                "The first form of the instruction (sc) provides a",
                "single system call.",
                "The second form of the instruction (scv) provides",
                "the capability for 128 unique system calls.",
                "",
                "The use of the LEV field is described in Book III.",
                "In the first form of the instruction the LEV values greater than 1",
                "are reserved, and bits 0:5 of the LEV field (instruction bits 20:25)",
                "are treated as a reserved field.",
                "",
                "When control is returned to the program that executed the System Call or System Call Vectored instruction, the",
                "contents of the registers will depend on the register conventions",
                "used by the program providing the system service.",
                "",
                "These instructions are context synchronizing (see Book III).",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Byte and Zero",
                    "form": "D",
                    "mnemonic": "lbz",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                },
                {
                    "name": "Prefixed Load Byte and Zero",
                    "form": "MLS:D",
                    "mnemonic": "plbz",
                    "operands": [
                        "RT",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "12",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "34",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"lbz\" then",
                "  EA := (RA|0) + EXTS64(D)",
                "if \"plbz\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"plbz\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTZ(MEM(EA, 1))"
            ],
            "body": [
                "",
                "",
                "For lbz, let the effective address (EA) be the sum (RA|0)+EXTS64(D).",
                "",
                "For plbz with R=0, let EA",
                "be the sum of the contents of register RA, or the value 0",
                "if RA=0, and the value d0||d1,",
                "sign-extended to 64 bits.",
                "",
                "For plbz with R=1, let EA",
                "be the sum of the address of the instruction and the value d0||d1, sign-extended to 64 bits.",
                "",
                "The byte in storage addressed by EA is loaded into",
                "RT56:63.",
                "RT0:55 are set to 0.",
                "",
                "For plbz, if R is equal to 1 and RA is not equal to 0, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Byte and Zero Indexed",
                    "form": "X",
                    "mnemonic": "lbzx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "87",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := <sup>56</sup>0 || MEM(EA, 1)"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The byte in storage addressed by EA is loaded into",
                "RT56:63.",
                "RT0:55 are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Byte and Zero with Update",
                    "form": "D",
                    "mnemonic": "lbzu",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "35",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "RT := <sup>56</sup>0 || MEM(EA, 1)",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum",
                "(RA)+D.",
                "The byte in storage addressed by EA is loaded into",
                "RT56:63.",
                "RT0:55 are set to 0.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0 or RA=RT, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Byte and Zero with Update Indexed",
                    "form": "X",
                    "mnemonic": "lbzux",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "119",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := <sup>56</sup>0 || MEM(EA, 1)",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+(RB).",
                "The byte in storage addressed by EA is loaded into",
                "RT56:63.",
                "RT0:55 are set to 0.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0 or RA=RT, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Halfword and Zero",
                    "form": "D",
                    "mnemonic": "lhz",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                },
                {
                    "name": "Prefixed Load Halfword and Zero",
                    "form": "MLS:D",
                    "mnemonic": "plhz",
                    "operands": [
                        "RT",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "12",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "40",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"lhz\" then",
                "  EA := (RA|0) + EXTS64(D)",
                "if \"plhz\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"plhz\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTZ(MEM(EA, 2))"
            ],
            "body": [
                "",
                "",
                "For lhz, let the effective address (EA) be the sum (RA|0)+EXTS64(D).",
                "",
                "For plhz with R=0, let the effective",
                "address (EA) be the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For plhz with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "The halfword in storage addressed by EA is loaded into",
                "RT48:63.",
                "RT0:47 are set to 0.",
                "",
                "For plhz, if R is equal to 1 and RA is not equal to 0, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Halfword and Zero Indexed",
                    "form": "X",
                    "mnemonic": "lhzx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "279",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := <sup>48</sup>0 || MEM(EA, 2)"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The halfword in storage addressed by EA is loaded into",
                "RT48:63.",
                "RT0:47 are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Halfword and Zero with Update",
                    "form": "D",
                    "mnemonic": "lhzu",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "41",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "RT := <sup>48</sup>0 || MEM(EA, 2)",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+D.",
                "The halfword in storage addressed by EA is loaded into RT48:63.",
                "RT0:47 are set to 0.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0 or RA=RT, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Halfword and Zero with Update Indexed",
                    "form": "X",
                    "mnemonic": "lhzux",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "311",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := <sup>48</sup>0 || MEM(EA, 2)",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+(RB).",
                "The halfword in storage addressed by EA is loaded into",
                "RT48:63.",
                "RT0:47 are set to 0.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0 or RA=RT, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Halfword Algebraic",
                    "form": "D",
                    "mnemonic": "lha",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                },
                {
                    "name": "Prefixed Load Halfword Algebraic",
                    "form": "MLS:D",
                    "mnemonic": "plha",
                    "operands": [
                        "RT",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "12",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "42",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"lha\" then",
                "  EA := (RA|0) + EXTS64(D)",
                "if \"plha\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"plha\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTS(MEM(EA, 2))"
            ],
            "body": [
                "",
                "",
                "For lha, let the effective address (EA) be the sum (RA|0)+EXTS64(D).",
                "",
                "For plha with R=0, let the effective",
                "address (EA) be the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For plha with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "The halfword in storage addressed by EA is loaded into",
                "RT48:63.",
                "RT0:47 are filled with",
                "a copy of bit 0 of the loaded halfword.",
                "",
                "For plha, if R is equal to 1 and RA is not equal to 0, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Halfword Algebraic Indexed",
                    "form": "X",
                    "mnemonic": "lhax",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "343",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := EXTS(MEM(EA, 2))"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The halfword in storage addressed by EA is loaded into",
                "RT48:63.",
                "RT0:47 are filled with",
                "a copy of bit 0 of the loaded halfword.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Halfword Algebraic with Update",
                    "form": "D",
                    "mnemonic": "lhau",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "43",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "RT := EXTS(MEM(EA, 2))",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)",
                "+D.",
                "The halfword in storage addressed by EA is loaded into",
                "RT48:63.",
                "RT0:47 are filled with",
                "a copy of bit 0 of the loaded halfword.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0 or RA=RT, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Halfword Algebraic with Update Indexed",
                    "form": "X",
                    "mnemonic": "lhaux",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "375",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := EXTS(MEM(EA, 2))",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+(RB).",
                "The halfword in storage addressed by EA is loaded into",
                "RT48:63.",
                "RT0:47 are filled with",
                "a copy of bit 0 of the loaded halfword.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0 or RA=RT, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Word and Zero",
                    "form": "D",
                    "mnemonic": "lwz",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                },
                {
                    "name": "Prefixed Load Word and Zero",
                    "form": "MLS:D",
                    "mnemonic": "plwz",
                    "operands": [
                        "RT",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "12",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "32",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"lwz\" then",
                "  EA := (RA|0) + EXTS64(D)",
                "if \"plwz\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"plwz\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := <sup>32</sup>0 || MEM(EA, 4)"
            ],
            "body": [
                "",
                "",
                "For lwz, let the effective address (EA) be the sum (RA|0)+EXTS64(D).",
                "",
                "For plwz with R=0, let the effective",
                "address (EA) be the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For plwz with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "The word in storage addressed by EA is loaded into",
                "RT32:63.",
                "RT0:31 are set to 0.",
                "",
                "For plwz, if R is equal to 1 and RA is not equal to 0, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Word and Zero Indexed",
                    "form": "X",
                    "mnemonic": "lwzx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "23",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := <sup>32</sup>0 || MEM(EA, 4)"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The word in storage addressed by EA is loaded into",
                "RT32:63.",
                "RT0:31 are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Word and Zero with Update",
                    "form": "D",
                    "mnemonic": "lwzu",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "33",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "RT := <sup>32</sup>0 || MEM(EA, 4)",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)",
                "+D.",
                "The word in storage addressed by EA is loaded into",
                "RT32:63.",
                "RT0:31 are set to 0.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0 or RA=RT, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Word and Zero with Update Indexed",
                    "form": "X",
                    "mnemonic": "lwzux",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "55",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := <sup>32</sup>0 || MEM(EA, 4)",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+(RB).",
                "The word in storage addressed by EA is loaded into",
                "RT32:63.",
                "RT0:31 are set to 0.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0 or RA=RT, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Word Algebraic",
                    "form": "DS",
                    "mnemonic": "lwa",
                    "operands": [
                        "RT",
                        "DS(RA)"
                    ],
                    "conditions": [],
                    "release": "PPC"
                },
                {
                    "name": "Prefixed Load Word Algebraic",
                    "form": "8LS:D",
                    "mnemonic": "plwa",
                    "operands": [
                        "RT",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "8",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "41",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"lwa\" then",
                "  EA := (RA|0) + EXTS64(DS||0b00)",
                "if \"plwa\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"plwa\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := EXTS(MEM(EA, 4))"
            ],
            "body": [
                "",
                "",
                "For lwa, let the effective address (EA) be the sum (RA|0)+EXTS64(DS||0b00).",
                "",
                "For plwa with R=0, let the effective",
                "address (EA) be the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For plwa with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "The word in storage addressed by EA is loaded into",
                "RT32:63.",
                "RT0:31 are filled with",
                "a copy of bit 0 of the loaded word.",
                "",
                "For plwa, if R is equal to 1 and RA is not equal to 0, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Word Algebraic Indexed",
                    "form": "X",
                    "mnemonic": "lwax",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "341",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := EXTS(MEM(EA, 4))"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The word in storage addressed by EA is loaded into",
                "RT32:63.",
                "RT0:31 are filled with",
                "a copy of bit 0 of the loaded word.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Word Algebraic with Update Indexed",
                    "form": "X",
                    "mnemonic": "lwaux",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "373",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := EXTS(MEM(EA, 4))",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+(RB).",
                "The word in storage addressed by EA is loaded into RT32:63.",
                "RT0:31 are filled with",
                "a copy of bit 0 of the loaded word.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0 or RA=RT, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Doubleword",
                    "form": "DS",
                    "mnemonic": "ld",
                    "operands": [
                        "RT",
                        "DS(RA)"
                    ],
                    "conditions": [],
                    "release": "PPC"
                },
                {
                    "name": "Prefixed Load Doubleword",
                    "form": "8LS:D",
                    "mnemonic": "pld",
                    "operands": [
                        "RT",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "8",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "57",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"ld\" then",
                "  EA := (RA|0) + EXTS64(DS||0b00)",
                "if \"pld\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"pld\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "RT := MEM(EA, 8)"
            ],
            "body": [
                "",
                "",
                "For ld, let the effective address (EA) be the sum (RA|0)+EXTS64(DS||0b00).",
                "",
                "For pld with R=0, let the effective",
                "address (EA) be the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For pld with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "The doubleword in storage addressed by EA is loaded into",
                "RT.",
                "",
                "For pld, if R is equal to 1 and RA is not equal to 0, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Doubleword Indexed",
                    "form": "X",
                    "mnemonic": "ldx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "21",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := MEM(EA, 8)"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The doubleword in storage addressed by EA is loaded into",
                "RT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Doubleword with Update",
                    "form": "DS",
                    "mnemonic": "ldu",
                    "operands": [
                        "RT",
                        "DS(RA)"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "58",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DS",
                    "size": "14"
                },
                {
                    "name": "1",
                    "size": "2"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(DS || 0b00)",
                "RT := MEM(EA, 8)",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+(DS||0b00).",
                "The doubleword in storage addressed by EA is loaded into",
                "RT.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0 or RA=RT, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Doubleword with Update Indexed",
                    "form": "X",
                    "mnemonic": "ldux",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "53",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "RT := MEM(EA, 8)",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+(RB).",
                "The doubleword in storage addressed by EA is loaded into",
                "RT.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0 or RA=RT, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Byte",
                    "form": "D",
                    "mnemonic": "stb",
                    "operands": [
                        "RS",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                },
                {
                    "name": "Prefixed Store Byte",
                    "form": "MLS:D",
                    "mnemonic": "pstb",
                    "operands": [
                        "RS",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "12",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "38",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"stb\" then",
                "  EA := (RA|0) + EXTS64(D)",
                "if \"pstb\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"pstb\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 1) := (RS)<sub>56:63</sub>"
            ],
            "body": [
                "",
                "",
                "For stb, let the effective address (EA) be the sum (RA|0)+EXTS64(D).",
                "",
                "For pstb with R=0, let the effective",
                "address (EA) be the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For pstb with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "(RS)56:63 are stored",
                "into the byte in storage addressed by EA.",
                "",
                "For pstb, if R is equal to 1 and RA is not equal to 0, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Byte Indexed",
                    "form": "X",
                    "mnemonic": "stbx",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "215",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 1) := (RS)<sub>56:63</sub>"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "(RS)56:63 are stored",
                "into the byte in storage addressed by EA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Byte with Update",
                    "form": "D",
                    "mnemonic": "stbu",
                    "operands": [
                        "RS",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "39",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 1) := (RS)<sub>56:63</sub>",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+D.",
                "(RS)56:63 are stored",
                "into the byte in storage addressed by EA.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Byte with Update Indexed",
                    "form": "X",
                    "mnemonic": "stbux",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "247",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 1) := (RS)<sub>56:63</sub>",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+(RB).",
                "(RS)56:63 are stored",
                "into the byte in storage addressed by EA.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Halfword",
                    "form": "D",
                    "mnemonic": "sth",
                    "operands": [
                        "RS",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                },
                {
                    "name": "Prefixed Store Halfword",
                    "form": "MLS:D",
                    "mnemonic": "psth",
                    "operands": [
                        "RS",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "12",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "44",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"sth\" then",
                "  EA := (RA|0) + EXTS64(D)",
                "if \"psth\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"psth\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 2) := (RS)<sub>48:63</sub>"
            ],
            "body": [
                "",
                "",
                "For sth, let the effective address (EA) be the sum (RA|0)+EXTS64(D).",
                "",
                "For psth with R=0, let the effective",
                "address (EA) be the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For psth with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "(RS)48:63 are stored",
                "into the halfword in storage addressed by EA.",
                "",
                "For psth, if R is equal to 1 and RA is not equal to 0, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Halfword Indexed",
                    "form": "X",
                    "mnemonic": "sthx",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "407",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 2) := (RS)<sub>48:63</sub>"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "(RS)48:63 are stored",
                "into the halfword in storage addressed by EA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Halfword with Update",
                    "form": "D",
                    "mnemonic": "sthu",
                    "operands": [
                        "RS",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "45",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 2) := (RS)<sub>48:63</sub>",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+D.",
                "(RS)48:63 are stored",
                "into the halfword in storage addressed by EA.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Halfword with Update Indexed",
                    "form": "X",
                    "mnemonic": "sthux",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "439",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 2) := (RS)<sub>48:63</sub>",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+(RB).",
                "(RS)48:63 are stored",
                "into the halfword in storage addressed by EA.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Word",
                    "form": "D",
                    "mnemonic": "stw",
                    "operands": [
                        "RS",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                },
                {
                    "name": "Prefixed Store Word",
                    "form": "MLS:D",
                    "mnemonic": "pstw",
                    "operands": [
                        "RS",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "12",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "36",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"stw\" then",
                "  EA := (RA|0) + EXTS64(D)",
                "if \"pstw\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"pstw\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 4) := (RS)<sub>32:63</sub>"
            ],
            "body": [
                "",
                "",
                "For stw, let the effective address (EA) be the sum (RA|0)+EXTS64(D).",
                "",
                "For pstw with R=0, let the effective",
                "address (EA) be the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For pstw with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "(RS)32:63 are stored",
                "into the word in storage addressed by EA.",
                "",
                "For pstw, if R is equal to 1 and RA is not equal to 0, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Word Indexed",
                    "form": "X",
                    "mnemonic": "stwx",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "151",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 4) := (RS)<sub>32:63</sub>"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "(RS)32:63 are stored",
                "into the word in storage addressed by EA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Word with Update",
                    "form": "D",
                    "mnemonic": "stwu",
                    "operands": [
                        "RS",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "37",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 4) := (RS)<sub>32:63</sub>",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+D.",
                "(RS)32:63 are stored",
                "into the word in storage addressed by EA.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Word with Update Indexed",
                    "form": "X",
                    "mnemonic": "stwux",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "183",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 4) := (RS)<sub>32:63</sub>",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+(RB).",
                "(RS)32:63 are stored",
                "into the word in storage addressed by EA.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Doubleword",
                    "form": "DS",
                    "mnemonic": "std",
                    "operands": [
                        "RS",
                        "DS(RA)"
                    ],
                    "conditions": [],
                    "release": "PPC"
                },
                {
                    "name": "Prefixed Store Doubleword",
                    "form": "8LS:D",
                    "mnemonic": "pstd",
                    "operands": [
                        "RS",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "8",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "61",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"std\" then",
                "  EA := (RA|0) + EXTS64(DS||0b00)",
                "if \"pstd\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"pstd\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 8) := (RS)"
            ],
            "body": [
                "",
                "",
                "For std, let the effective address (EA) be the sum (RA|0)+EXTS64(DS||0b00).",
                "",
                "For pstd with R=0, let the effective",
                "address (EA) be the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For pstd with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "(RS) is stored into the doubleword in storage addressed",
                "by EA.",
                "",
                "For pstd, if R is equal to 1 and RA is not equal to 0, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Doubleword Indexed",
                    "form": "X",
                    "mnemonic": "stdx",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "149",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 8) := (RS)"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "(RS) is stored into the doubleword in storage addressed",
                "by EA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Doubleword with Update",
                    "form": "DS",
                    "mnemonic": "stdu",
                    "operands": [
                        "RS",
                        "DS(RA)"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "62",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DS",
                    "size": "14"
                },
                {
                    "name": "1",
                    "size": "2"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(DS || 0b00)",
                "MEM(EA, 8) := (RS)",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+(DS||0b00).",
                "",
                "(RS) is stored into the doubleword in storage addressed",
                "by EA.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Doubleword with Update Indexed",
                    "form": "X",
                    "mnemonic": "stdux",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "181",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 8) := (RS)",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+(RB).",
                "",
                "(RS) is stored into the doubleword in storage addressed",
                "by EA.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Quadword",
                    "form": "DQ",
                    "mnemonic": "lq",
                    "operands": [
                        "RTp",
                        "DQ(RA)"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                },
                {
                    "name": "Prefixed Load Quadword",
                    "form": "8LS:D",
                    "mnemonic": "plq",
                    "operands": [
                        "RTp",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "8",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "56",
                    "size": "6"
                },
                {
                    "name": "RTp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"lq\" then",
                "  EA := (RA|0) + EXTS64(DQ||0b0000)",
                "if \"plq\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"plq\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "if Big-Endian byte ordering then",
                "  RTp||RTp+1 := MEM(EA,16)",
                "if \"lq\" and Little-Endian byte ordering then",
                "  RTp||RTp+1 := MEM(EA,16)",
                "if \"plq\" and Little-Endian byte ordering then",
                "  RTp+1||RTp := MEM(EA,16)"
            ],
            "body": [
                "",
                "",
                "For lq, let the effective address (EA) be the sum of the contents of register RA, or the",
                "value 0 if RA=0, and the value DQ||0b0000, sign-extended to 64 bits.",
                "",
                "For plq with R=0, let the effective",
                "address (EA) be the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For plq with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "For Big-Endian byte ordering, the quadword in storage addressed by",
                "EA is loaded into RTp||RTp+1.",
                "",
                "For lq and Little-Endian byte ordering, the",
                "quadword in storage addressed by EA is byte-reversed and",
                "loaded into RTp||RTp+1.",
                "",
                "For plq and Little-Endian byte ordering, the",
                "quadword in storage addressed by EA is byte-reversed and",
                "loaded into RTp+1||RTp.",
                "",
                "If RTp is odd or RTp=RA, the instruction form",
                "is invalid.",
                "If RTp=RA, an attempt to execute this instruction will",
                "invoke the system illegal instruction error handler.",
                "(The RTp=RA case includes the case of RTp=RA=0.)",
                "",
                "The quadword in storage addressed by EA is loaded into an",
                "even-odd pair of GPRs as follows.",
                "In Big-Endian mode, the even-numbered GPR is loaded with the",
                "doubleword from storage addressed by EA and the",
                "odd-numbered GPR is loaded with the doubleword addressed by",
                "EA+8.",
                "In Little-Endian mode, the even-numbered GPR is loaded with the",
                "byte-reversed  doubleword from storage addressed by EA+8",
                "and the odd-numbered GPR is loaded with the byte-reversed doubleword",
                "addressed by EA.",
                "",
                "For plq, if R is equal to 1 and RA is not equal to 0, the instruction form is",
                "invalid.",
                "Programming NoteIn versions of the architecture prior to v2.07, this instruction was",
                "privileged.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Quadword",
                    "form": "DS",
                    "mnemonic": "stq",
                    "operands": [
                        "RSp",
                        "DS(RA)"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                },
                {
                    "name": "Prefixed Store Quadword",
                    "form": "8LS:D",
                    "mnemonic": "pstq",
                    "operands": [
                        "RSp",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "8",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "RSp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"stq\" then",
                "  EA := (RA|0) + EXTS64(DS||0b00)",
                "if \"pstq\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"pstq\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "if Big-Endian byte ordering then",
                "  MEM(EA,16) := (RSp)||(RSp+1)",
                "if \"stq\" and Little-Endian byte ordering then",
                "  MEM(EA,16) := (RSp)||(RSp+1)",
                "if \"pstq\" and Little-Endian byte ordering then",
                "  MEM(EA,16) := (RSp+1)||(RSp)"
            ],
            "body": [
                "",
                "",
                "For stq, let the effective address (EA) be the sum of the contents of register RA, or the",
                "value 0 if RA=0, and the value DS||0b00, sign-extended to 64 bits.",
                "",
                "For pstq with R=0, let the effective",
                "address (EA) be the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For pstq with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "For Big-Endian byte ordering, the content of register pair RSp||RSp+1 is stored into the quadword in storage addressed by EA.",
                "",
                "For stq and Little-Endian byte ordering, the",
                "content of register pair RSp||RSp+1 is byte-reversed and",
                "stored into the quadword in storage addressed by EA.",
                "",
                "For pstq and Little-Endian byte ordering, the",
                "content of register pair RSp+1||RSp is byte-reversed and",
                "stored into the quadword in storage addressed by EA.",
                "",
                "If RSp is odd, the instruction form is invalid.",
                "",
                "The contents of an even-odd pair of GPRs is stored into the quadword",
                "in storage addressed by EA as follows.",
                "In Big-Endian mode, the even-numbered GPR is stored into the",
                "doubleword in storage addressed by EA and the",
                "odd-numbered GPR is stored into the doubleword addressed by",
                "EA+8.",
                "In Little-Endian mode, the even-numbered GPR is stored byte-reversed",
                "into the doubleword in storage addressed by EA+8 and the",
                "odd-numbered GPR is stored byte-reversed into the doubleword",
                "addressed by EA.",
                "",
                "For pstq, if R is equal to 1",
                "and RA is not equal to 0, the instruction form is invalid.",
                "",
                "Programming NoteIn versions of the architecture prior to V.",
                "2.07, this instruction was privileged.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Halfword Byte-Reverse Indexed",
                    "form": "X",
                    "mnemonic": "lhbrx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "790",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "load_data := MEM(EA, 2)",
                "RT := <sup>48</sup>0 || load_data<sub>8:15</sub> || load_data<sub>0:7</sub>"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "Bits 0:7 of the halfword in storage addressed by EA are",
                "loaded into RT56:63.",
                "",
                "Bits 8:15 of the halfword in storage addressed by EA are",
                "loaded into RT48:55.",
                "",
                "RT0:47 are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Halfword Byte-Reverse Indexed",
                    "form": "X",
                    "mnemonic": "sthbrx",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "918",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 2) := (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub>"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "(RS)56:63 are stored",
                "into bits 0:7 of the halfword in storage addressed by EA.",
                "",
                "(RS)48:55 are stored",
                "into bits 8:15 of the halfword in storage addressed by EA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Word Byte-Reverse Indexed",
                    "form": "X",
                    "mnemonic": "lwbrx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "534",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "load_data := MEM(EA, 4)",
                "RT := <sup>32</sup>0 || load_data<sub>24:31</sub> || load_data<sub>16:23</sub>",
                "        || load_data<sub>8:15</sub> || load_data<sub>0:7</sub>"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "Bits 0:7 of the word in storage addressed by EA are",
                "loaded into RT56:63.",
                "",
                "Bits 8:15 of the word in storage addressed by EA are",
                "loaded into RT48:55.",
                "",
                "Bits 16:23 of the word in storage addressed by EA are",
                "loaded into RT40:47.",
                "",
                "Bits 24:31 of the word in storage addressed by EA are",
                "loaded into RT32:39.",
                "",
                "RT0:31 are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Word Byte-Reverse Indexed",
                    "form": "X",
                    "mnemonic": "stwbrx",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "662",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 4) := (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub> || (RS)<sub>40:47</sub> ||(RS)<sub>32:39</sub>"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "(RS)56:63 are stored",
                "into bits 0:7 of the word in storage addressed by EA.",
                "",
                "(RS)48:55 are stored",
                "into bits 8:15 of the word in storage addressed by EA.",
                "",
                "(RS)40:47 are stored",
                "into bits 16:23 of the word in storage addressed by EA.",
                "",
                "(RS)32:39 are stored",
                "into bits 24:31 of the word in storage addressed by EA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Doubleword Byte-Reverse Indexed",
                    "form": "X",
                    "mnemonic": "ldbrx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "532",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "load_data := MEM(EA, 8)",
                "RT :=  load_data<sub>56:63</sub> || load_data<sub>48:55</sub>",
                "       || load_data<sub>40:47</sub> || load_data<sub>32:39</sub>",
                "       || load_data<sub>24:31</sub> || load_data<sub>16:23</sub>",
                "       || load_data<sub>8:15</sub>  || load_data<sub>0:7</sub>"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "Bits 0:7 of the doubleword in storage addressed by EA are",
                "loaded into RT56:63.",
                "",
                "Bits 8:15 of the doubleword in storage addressed by EA",
                "are loaded into RT48:55.",
                "",
                "Bits 16:23 of the doubleword in storage addressed by EA",
                "are loaded into RT40:47.",
                "",
                "Bits 24:31 of the doubleword in storage addressed by EA",
                "are loaded into RT32:39.",
                "",
                "Bits 32:39 of the doubleword in storage addressed by EA",
                "are loaded into RT24:31.",
                "",
                "Bits 40:47 of the doubleword in storage addressed by EA",
                "are loaded into RT16:23.",
                "",
                "Bits 48:55 of the doubleword in storage addressed by EA",
                "are loaded into RT8:15.",
                "",
                "Bits 56:63 of the doubleword in storage addressed by EA",
                "are loaded into RT0:7.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Doubleword Byte-Reverse Indexed",
                    "form": "X",
                    "mnemonic": "stdbrx",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "660",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 8) := (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub>",
                "               || (RS)<sub>40:47</sub> || (RS)<sub>32:39</sub>",
                "               || (RS)<sub>24:31</sub> || (RS)<sub>16:23</sub>",
                "               || (RS)<sub>8:15</sub>  || (RS)<sub>0:7</sub>"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "(RS)56:63 are stored",
                "into bits 0:7 of the doubleword in storage addressed by EA.",
                "",
                "(RS)48:55 are stored",
                "into bits 8:15 of the doubleword in storage addressed by EA.",
                "",
                "(RS)40:47 are stored",
                "into bits 16:23 of the doubleword in storage addressed by EA.",
                "",
                "(RS)32:39 are stored",
                "into bits 23:31 of the doubleword in storage addressed by EA.",
                "",
                "(RS)24:31 are stored",
                "into bits 32:39 of the doubleword in storage addressed by EA.",
                "",
                "(RS)16:23 are stored",
                "into bits 40:47 of the doubleword in storage addressed by EA.",
                "",
                "(RS)8:15 are stored",
                "into bits 48:55 of the doubleword in storage addressed by EA.",
                "",
                "(RS)0:7 are stored into",
                "bits 56:63 of the doubleword in storage addressed by EA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Multiple Word",
                    "form": "D",
                    "mnemonic": "lmw",
                    "operands": [
                        "RT",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "46",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(D)",
                "r := RT",
                "do while r <= 31",
                "  GPR(r) := <sup>32</sup>0 || MEM(EA, 4)",
                "  r := r + 1",
                "  EA := EA + 4"
            ],
            "body": [
                "",
                "",
                "Let n = (32-RT).",
                "Let the effective address (EA) be the sum (RA|0)+D.",
                "",
                "n consecutive words starting at EA are loaded into the",
                "low-order 32 bits of GPRs RT through 31.",
                "The high-order 32 bits of these GPRs are set to zero.",
                "",
                "If RA is in the range of registers to be loaded,",
                "including the case in which RA=0, the instruction form is",
                "invalid.",
                "",
                "This instruction is not supported in Little-Endian mode.",
                "If it is executed in Little-Endian mode, the system alignment error",
                "handler is invoked.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Multiple Word",
                    "form": "D",
                    "mnemonic": "stmw",
                    "operands": [
                        "RS",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "47",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(D)",
                "r := RS",
                "do while r <= 31",
                "  MEM(EA, 4) := GPR(r)<sub>32:63</sub>",
                "  r := r + 1",
                "  EA := EA + 4"
            ],
            "body": [
                "",
                "",
                "Let n = (32-RS).",
                "Let the effective address (EA) be the sum (RA|0)+D.",
                "",
                "n consecutive words starting at EA are stored from the",
                "low-order 32 bits of GPRs RS through 31.",
                "",
                "This instruction is not supported in Little-Endian mode.",
                "If it is executed in Little-Endian mode, the system alignment error",
                "handler is invoked.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load String Word Immediate",
                    "form": "X",
                    "mnemonic": "lswi",
                    "operands": [
                        "RT",
                        "RA",
                        "NB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "NB",
                    "size": "5"
                },
                {
                    "name": "597",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then EA := 0",
                "else           EA := (RA)",
                "if NB = 0 then n := 32",
                "else           n := NB",
                "r := RT - 1",
                "i := 32",
                "do while n > 0",
                "  if i = 32 then",
                "     r := r + 1 (mod 32)",
                "     GPR(r) := 0",
                "  GPR(r)<sub>i:i+7</sub> := MEM(EA, 1)",
                "  i := i + 8",
                "  if i = 64 then i := 32",
                "  EA := EA + 1",
                "  n := n - 1"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be (RA|0).",
                "Let n = NB if NB0,",
                "n = 32 if NB=0; n is the number",
                "of bytes to load.",
                "Let nr=CEIL(n/4); nr is the number of",
                "registers to receive data.",
                "",
                "n consecutive bytes starting at EA are loaded",
                "into GPRs RT through RT+nr-1.",
                "Data are loaded into the low-order four bytes of each GPR; the",
                "high-order four bytes are set to 0.",
                "",
                "Bytes are loaded left to right in each register.",
                "The sequence of registers wraps around to GPR 0 if required.",
                "If the low-order four bytes of register RT+nr-1 are only",
                "partially filled, the unfilled low-order byte(s) of that register are",
                "set to 0.",
                "",
                "If RA is in the range of registers to be loaded,",
                "including the case in which RA=0, the instruction form is",
                "invalid.",
                "",
                "This instruction is not supported in Little-Endian mode.",
                "If it is executed in Little-Endian mode, the system alignment error",
                "handler is invoked.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load String Word Indexed",
                    "form": "X",
                    "mnemonic": "lswx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "533",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "n := XER<sub>57:63</sub>",
                "r := RT - 1",
                "i := 32",
                "RT := undefined",
                "do while n > 0",
                "  if i = 32 then",
                "     r := r + 1 (mod 32)",
                "     GPR(r) := 0",
                "  GPR(r)<sub>i:i+7</sub> := MEM(EA, 1)",
                "  i := i + 8",
                "  if i = 64 then i := 32",
                "  EA := EA + 1",
                "  n := n - 1"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "Let n=XER57:63; n is",
                "the number of bytes to load.",
                "Let nr=CEIL(n/4); nr is the number of registers to",
                "receive data.",
                "",
                "If n0, n consecutive bytes starting at EA are loaded",
                "into GPRs RT through RT+nr-1.",
                "Data are loaded into the low-order four bytes of each GPR; the",
                "high-order four bytes are set to 0.",
                "",
                "Bytes are loaded left to right in each register.",
                "The sequence of registers wraps around to GPR 0 if required.",
                "If the low-order four bytes of register RT+nr-1 are only",
                "partially filled, the unfilled low-order byte(s) of that register are",
                "set to 0.",
                "",
                "If n=0, the contents of register RT are undefined.",
                "",
                "If RA or RB is in the range of registers to",
                "be loaded, including the case in which RA=0, the",
                "instruction is treated as if the instruction form were invalid.",
                "If RT=RA or RT=RB, the instruction form is",
                "invalid.",
                "",
                "This instruction is not supported in Little-Endian mode.",
                "If it is executed in Little-Endian mode and n0, the system",
                "alignment error handler is invoked.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store String Word Immediate",
                    "form": "X",
                    "mnemonic": "stswi",
                    "operands": [
                        "RS",
                        "RA",
                        "NB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "NB",
                    "size": "5"
                },
                {
                    "name": "725",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then EA := 0",
                "else           EA := (RA)",
                "if NB = 0 then n := 32",
                "else           n := NB",
                "r := RS - 1",
                "i := 32",
                "do while n > 0",
                "  if i = 32 then r := r + 1 (mod 32)",
                "  MEM(EA, 1) := GPR(r)<sub>i:i+7</sub>",
                "  i := i + 8",
                "  if i = 64 then i := 32",
                "  EA := EA + 1",
                "  n := n - 1"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be (RA|0).",
                "Let n = NB if NB0,",
                "n=32 if NB=0; n is the number of bytes to",
                "store.",
                "Let nr=CEIL(n/4); nr is the number of registers to",
                "supply data.",
                "",
                "n consecutive bytes starting at EA are stored from GPRs",
                "RS through RS+nr-1.",
                "Data are stored from the low-order four bytes of each GPR.",
                "",
                "Bytes are stored left to right from each register.",
                "The sequence of registers wraps around to GPR 0 if required.",
                "",
                "This instruction is not supported in Little-Endian mode.",
                "If it is executed in Little-Endian mode, the system alignment error",
                "handler is invoked.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store String Word Indexed",
                    "form": "X",
                    "mnemonic": "stswx",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "661",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "n := XER<sub>57:63</sub>",
                "r := RS - 1",
                "i := 32",
                "do while n > 0",
                "  if i = 32 then r := r + 1 (mod 32)",
                "  MEM(EA, 1) := GPR(r)<sub>i:i+7</sub>",
                "  i := i + 8",
                "  if i = 64 then i := 32",
                "  EA := EA + 1",
                "  n := n - 1"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "Let n = XER57:63;",
                "n is the number of bytes to store.",
                "Let nr = CEIL(n/4); nr is the number of registers to",
                "supply data.",
                "",
                "If n0, n consecutive bytes starting at",
                "EA are stored from GPRs RS through RS+nr-1. Data are stored from the low-order four bytes of each GPR.",
                "",
                "Bytes are stored left to right from each register.",
                "The sequence of registers wraps around to GPR 0 if required.",
                "",
                "If n=0, no bytes are stored.",
                "",
                "This instruction is not supported in Little-Endian mode.",
                "If it is executed in Little-Endian mode and n0, the",
                "system alignment error handler is invoked.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Add Immediate",
                    "form": "D",
                    "mnemonic": "addi",
                    "operands": [
                        "RT",
                        "RA",
                        "SI"
                    ],
                    "conditions": [],
                    "release": "P1"
                },
                {
                    "name": "Prefixed Add Immediate",
                    "form": "MLS:D",
                    "mnemonic": "paddi",
                    "operands": [
                        "RT",
                        "RA",
                        "SI",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "12",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "si0",
                    "size": "18"
                },
                {
                    "name": "14",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "si1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"addi\" then",
                "  RT := (RA|0) + EXTS64(SI)",
                "if \"paddi\" & R=0 then",
                "  RT := (RA|0) + EXTS64(si0||si1)",
                "if \"paddi\" & R=1 then",
                "  RT := CIA + EXTS64(si0||si1)"
            ],
            "body": [
                "",
                "",
                "For addi, let the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "SI, sign-extended to 64 bits, is placed into register",
                "RT.",
                "",
                "For paddi with R=0, the sum of the",
                "contents of register RA, or the value 0 if RA=0, and the value si0||si1, sign-extended",
                "to 64 bits, is placed into register RT.",
                "",
                "For paddi with R=1, the sum of the",
                "address of the instruction and the value si0||si1, sign-extended to 64 bits, is placed into register RT.",
                "",
                "For paddi, if R is equal to",
                "1 and RA is not equal to 0, the instruction",
                "form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Add Immediate Shifted",
                    "form": "D",
                    "mnemonic": "addis",
                    "operands": [
                        "RT",
                        "RA",
                        "SI"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "15",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SI",
                    "size": "16"
                }
            ],
            "code": [
                "if RA = 0 then RT := EXTS(SI || <sup>16</sup>0)",
                "else           RT := (RA) + EXTS(SI || <sup>16</sup>0)"
            ],
            "body": [
                "",
                "",
                "The sum (RA|0) + (SI||0x0000) is placed into register",
                "RT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Add PC Immediate Shifted",
                    "form": "DX",
                    "mnemonic": "addpcis",
                    "operands": [
                        "RT",
                        "D"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "5"
                },
                {
                    "name": "d0",
                    "size": "10"
                },
                {
                    "name": "2",
                    "size": "5"
                },
                {
                    "name": "d2",
                    "size": "1"
                }
            ],
            "code": [
                "D := d0||d1||d2",
                "RT := NIA + EXTS(D || <sup>16</sup>0)"
            ],
            "body": [
                "",
                "",
                "The sum of NIA + (D||0x0000) is placed into register RT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Add",
                    "form": "XO",
                    "mnemonic": "add",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Add",
                    "form": "XO",
                    "mnemonic": "add.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Add",
                    "form": "XO",
                    "mnemonic": "addo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Add",
                    "form": "XO",
                    "mnemonic": "addo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "266",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := (RA) + (RB)"
            ],
            "body": [
                "",
                "",
                "The sum (RA) + (RB) is placed into register RT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Add Immediate Carrying",
                    "form": "D",
                    "mnemonic": "addic",
                    "operands": [
                        "RT",
                        "RA",
                        "SI"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "12",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SI",
                    "size": "16"
                }
            ],
            "code": [
                "RT := (RA) + EXTS(SI)"
            ],
            "body": [
                "",
                "",
                "The sum (RA) + SI is placed into register RT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Add Immediate Carrying and Record",
                    "form": "D",
                    "mnemonic": "addic.",
                    "operands": [
                        "RT",
                        "RA",
                        "SI"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "13",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SI",
                    "size": "16"
                }
            ],
            "code": [
                "RT := (RA) + EXTS(SI)"
            ],
            "body": [
                "",
                "",
                "The sum (RA) + SI is placed into register RT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Subtract From",
                    "form": "XO",
                    "mnemonic": "subf",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Subtract From",
                    "form": "XO",
                    "mnemonic": "subf.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Subtract From",
                    "form": "XO",
                    "mnemonic": "subfo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Subtract From",
                    "form": "XO",
                    "mnemonic": "subfo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "40",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := ~(RA) + (RB) + 1"
            ],
            "body": [
                "",
                "",
                "The sum (RA) + (RB) + 1 is placed into register",
                "RT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Subtract From Immediate Carrying",
                    "form": "D",
                    "mnemonic": "subfic",
                    "operands": [
                        "RT",
                        "RA",
                        "SI"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "8",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SI",
                    "size": "16"
                }
            ],
            "code": [
                "RT := ~(RA) + EXTS(SI) + 1"
            ],
            "body": [
                "",
                "",
                "The sum (RA) + SI + 1 is placed into register",
                "RT.",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract"
            ]
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Add Carrying",
                    "form": "XO",
                    "mnemonic": "addc",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Add Carrying",
                    "form": "XO",
                    "mnemonic": "addc.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Add Carrying",
                    "form": "XO",
                    "mnemonic": "addco",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Add Carrying",
                    "form": "XO",
                    "mnemonic": "addco.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "10",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := (RA) + (RB)"
            ],
            "body": [
                "",
                "",
                "The sum (RA) + (RB) is placed into register RT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Subtract From Carrying",
                    "form": "XO",
                    "mnemonic": "subfc",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Subtract From Carrying",
                    "form": "XO",
                    "mnemonic": "subfc.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Subtract From Carrying",
                    "form": "XO",
                    "mnemonic": "subfco",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Subtract From Carrying",
                    "form": "XO",
                    "mnemonic": "subfco.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "8",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := ~(RA) + (RB) + 1"
            ],
            "body": [
                "",
                "",
                "The sum (RA) + (RB) + 1 is placed into register",
                "RT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Add Extended",
                    "form": "XO",
                    "mnemonic": "adde",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Add Extended",
                    "form": "XO",
                    "mnemonic": "adde.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Add Extended",
                    "form": "XO",
                    "mnemonic": "addeo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Add Extended",
                    "form": "XO",
                    "mnemonic": "addeo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "138",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := (RA) + (RB) + CA"
            ],
            "body": [
                "",
                "",
                "The sum (RA) + (RB) + CA is placed into register",
                "RT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Subtract From Extended",
                    "form": "XO",
                    "mnemonic": "subfe",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Subtract From Extended",
                    "form": "XO",
                    "mnemonic": "subfe.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Subtract From Extended",
                    "form": "XO",
                    "mnemonic": "subfeo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Subtract From Extended",
                    "form": "XO",
                    "mnemonic": "subfeo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "136",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := ~(RA) + (RB) + CA"
            ],
            "body": [
                "",
                "",
                "The sum (RA) + (RB) + CA is placed into register",
                "RT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Add to Minus One Extended",
                    "form": "XO",
                    "mnemonic": "addme",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Add to Minus One Extended",
                    "form": "XO",
                    "mnemonic": "addme.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Add to Minus One Extended",
                    "form": "XO",
                    "mnemonic": "addmeo",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Add to Minus One Extended",
                    "form": "XO",
                    "mnemonic": "addmeo.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "234",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := (RA) + CA - 1"
            ],
            "body": [
                "",
                "",
                "The sum (RA) + CA + 641 is placed into register RT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Add to Zero Extended",
                    "form": "XO",
                    "mnemonic": "addze",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Add to Zero Extended",
                    "form": "XO",
                    "mnemonic": "addze.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Add to Zero Extended",
                    "form": "XO",
                    "mnemonic": "addzeo",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Add to Zero Extended",
                    "form": "XO",
                    "mnemonic": "addzeo.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "202",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := (RA) + CA"
            ],
            "body": [
                "",
                "",
                "The sum (RA) + CA is placed into register RT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Subtract From Minus One Extended",
                    "form": "XO",
                    "mnemonic": "subfme",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Subtract From Minus One Extended",
                    "form": "XO",
                    "mnemonic": "subfme.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Subtract From Minus One Extended",
                    "form": "XO",
                    "mnemonic": "subfmeo",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Subtract From Minus One Extended",
                    "form": "XO",
                    "mnemonic": "subfmeo.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "232",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := ~(RA) + CA - 1"
            ],
            "body": [
                "",
                "",
                "The sum (RA) + CA +",
                "641 is placed into",
                "register RT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Subtract From Zero Extended",
                    "form": "XO",
                    "mnemonic": "subfze",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Subtract From Zero Extended",
                    "form": "XO",
                    "mnemonic": "subfze.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Subtract From Zero Extended",
                    "form": "XO",
                    "mnemonic": "subfzeo",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Subtract From Zero Extended",
                    "form": "XO",
                    "mnemonic": "subfzeo.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "200",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := ~(RA) + CA"
            ],
            "body": [
                "",
                "",
                "The sum (RA) + CA is placed into register",
                "RT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Add Extended using alternate carry bit",
                    "form": "Z23",
                    "mnemonic": "addex",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "CY"
                    ],
                    "conditions": [],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "CY",
                    "size": "2"
                },
                {
                    "name": "170",
                    "size": "8"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if CY=0 then RT := (RA) + (RB) + OV"
            ],
            "body": [
                "",
                "",
                "For CY=0, the sum (RA) + (RB) + OV is placed",
                "into register RT.",
                "",
                "For CY=0, OV is set to 1 if there is a carry",
                "out of bit 0 of the sum in 64-bit mode or there is a carry out of bit",
                "32 of the sum in 32-bit mode, and set to 0 otherwise.",
                "OV32 is set to 1 if there is a carry out of bit 32 bit of",
                "the sum.",
                "",
                "CY=1, CY=2, and CY=3 are reserved.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Negate",
                    "form": "XO",
                    "mnemonic": "neg",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Negate",
                    "form": "XO",
                    "mnemonic": "neg.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Negate",
                    "form": "XO",
                    "mnemonic": "nego",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Negate",
                    "form": "XO",
                    "mnemonic": "nego.",
                    "operands": [
                        "RT",
                        "RA"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "104",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := ~(RA) + 1"
            ],
            "body": [
                "",
                "",
                "The sum (RA) + 1 is placed into register",
                "RT.",
                "",
                "If the processor is in 64-bit mode and register RA",
                "contains the most negative 64-bit number (0x8000_0000_0000_0000),",
                "the result is the most negative number",
                "and, if OE=1, OV is set to 1.",
                "If (RA)32:63 contain",
                "the most negative 32-bit number (0x8000_0000) and",
                "OE=1, OV32 is set to 1.",
                "",
                "Similarly, if the processor is in 32-bit mode and (RA)32:63 contain the most",
                "negative 32-bit number (0x8000_0000),",
                "the low-order 32",
                "bits of the result contain the most negative 32-bit number and, if",
                "OE=1, OV and OV32 are set to 1.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Multiply Low Immediate",
                    "form": "D",
                    "mnemonic": "mulli",
                    "operands": [
                        "RT",
                        "RA",
                        "SI"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "7",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SI",
                    "size": "16"
                }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) * EXTS(SI)",
                "RT := prod<sub>64:127</sub>"
            ],
            "body": [
                "",
                "",
                "The 64-bit first operand is (RA).",
                "The 64-bit second operand is the sign-extended value of the",
                "SI field.",
                "The low-order 64 bits of the 128-bit product of the operands are",
                "placed into register RT.",
                "",
                "Both operands and the product are interpreted as signed integers.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Multiply Low Word",
                    "form": "XO",
                    "mnemonic": "mullw",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Multiply Low Word",
                    "form": "XO",
                    "mnemonic": "mullw.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Multiply Low Word",
                    "form": "XO",
                    "mnemonic": "mullwo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Multiply Low Word",
                    "form": "XO",
                    "mnemonic": "mullwo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "235",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RT := (RA)<sub>32:63</sub> * (RB)<sub>32:63</sub>"
            ],
            "body": [
                "",
                "",
                "The 32-bit operands are the low-order 32 bits of RA and",
                "of RB.",
                "The 64-bit product of the operands is placed into register RT.",
                "",
                "If OE=1 then OV and OV32 are set",
                "to 1 if the product cannot be represented in 32 bits.",
                "",
                "Both operands and the product are interpreted as signed integers.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Multiply High Word",
                    "form": "XO",
                    "mnemonic": "mulhw",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Multiply High Word",
                    "form": "XO",
                    "mnemonic": "mulhw.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "75",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "prod<sub>0:63</sub> := (RA)<sub>32:63</sub> * (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := prod<sub>0:31</sub>",
                "RT<sub>0:31</sub> := undefined"
            ],
            "body": [
                "",
                "",
                "The 32-bit operands are the low-order 32 bits of RA and",
                "of RB.",
                "The high-order 32 bits of the 64-bit product of the operands are",
                "placed into RT32:63.",
                "The contents of RT0:31",
                "are undefined.",
                "",
                "Both operands and the product are interpreted as signed integers.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Multiply High Word Unsigned",
                    "form": "XO",
                    "mnemonic": "mulhwu",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Multiply High Word Unsigned",
                    "form": "XO",
                    "mnemonic": "mulhwu.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "11",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "prod<sub>0:63</sub> := (RA)<sub>32:63</sub> * (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := prod<sub>0:31</sub>",
                "RT<sub>0:31</sub> := undefined"
            ],
            "body": [
                "",
                "",
                "The 32-bit operands are the low-order 32 bits of RA and",
                "of RB.",
                "The high-order 32 bits of the 64-bit product of the operands are",
                "placed into RT32:63.",
                "The contents of RT0:31",
                "are undefined.",
                "",
                "Both operands and the product are interpreted as unsigned integers,",
                "except that if Rc=1 the first three bits of CR Field 0",
                "are set by signed comparison of the result to zero.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Divide Word",
                    "form": "XO",
                    "mnemonic": "divw",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Divide Word",
                    "form": "XO",
                    "mnemonic": "divw.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Divide Word",
                    "form": "XO",
                    "mnemonic": "divwo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Divide Word",
                    "form": "XO",
                    "mnemonic": "divwo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "491",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:31 </sub> := (RA)<sub>32:63</sub>",
                "divisor<sub>0:31</sub> := (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := dividend / divisor",
                "RT<sub>0:31</sub> := undefined"
            ],
            "body": [
                "",
                "",
                "The 32-bit dividend is (RA)32:63.",
                "The 32-bit divisor is (RB)32:63.",
                "The 32-bit quotient is placed into RT32:63.",
                "The contents of RT0:31",
                "are undefined. The remainder is not supplied as a result.",
                "",
                "Both operands and the quotient are interpreted as signed integers.",
                "The quotient is the unique signed integer that satisfies",
                "",
                "dividend = (quotient  divisor) + r",
                "",
                "where 0  r ",
                "|divisor| if the dividend is nonnegative, and -|divisor|",
                " r  0 if the dividend is",
                "negative.",
                "",
                "If an attempt is made to perform any of the divisions",
                "",
                "",
                "",
                "",
                "then the contents of register RT are undefined as are",
                "(ifRc=1) the contents of the LT, GT, and",
                "EQ bits of CR Field 0.",
                "In these cases, if OE=1 then OV and OV32 are",
                "set to 1.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Divide Word Unsigned",
                    "form": "XO",
                    "mnemonic": "divwu",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Divide Word Unsigned",
                    "form": "XO",
                    "mnemonic": "divwu.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Divide Word Unsigned",
                    "form": "XO",
                    "mnemonic": "divwuo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Divide Word Unsigned",
                    "form": "XO",
                    "mnemonic": "divwuo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "459",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:31 </sub> := (RA)<sub>32:63</sub>",
                "divisor<sub>0:31</sub> := (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := dividend / divisor",
                "RT<sub>0:31</sub> := undefined"
            ],
            "body": [
                "",
                "",
                "The 32 bit dividend is (RA)32:63.",
                "The 32-bit divisor is (RB)32:63.",
                "The 32-bit quotient is placed into RT32:63.",
                "The contents of RT0:31",
                "are undefined. The remainder is not supplied as a result.",
                "",
                "Both operands and the quotient are interpreted as unsigned integers,",
                "except that if Rc=1 the first three bits of CR Field 0",
                "are set by signed comparison of the result to zero.",
                "The quotient is the unique unsigned integer that satisfies",
                "",
                "dividend = (quotient  divisor) + r",
                "",
                "where 0  r  divisor.",
                "",
                "If an attempt is made to perform the division",
                "",
                "",
                "",
                "",
                "then the contents of register RT are undefined as are (if",
                "Rc=1) the contents of the LT, GT,",
                "and EQ bits of CR Field 0.",
                "In this case, if OE=1 then OV and OV32 are set to 1.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Divide Word Extended",
                    "form": "XO",
                    "mnemonic": "divwe",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Divide Word Extended",
                    "form": "XO",
                    "mnemonic": "divwe.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Divide Word Extended",
                    "form": "XO",
                    "mnemonic": "divweo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Divide Word Extended",
                    "form": "XO",
                    "mnemonic": "divweo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "427",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:63</sub> := (RA)<sub>32:63</sub> || <sup>32</sup>0",
                "divisor<sub>0:31</sub> := (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := dividend / divisor",
                "RT<sub>0:31</sub> := undefined"
            ],
            "body": [
                "",
                "",
                "The 64-bit dividend is (RA)32:63 ||",
                "320.",
                "The 32-bit divisor is (RB)32:63.",
                "If the quotient can be represented in 32 bits, it is placed into",
                "RT32:63.",
                "The contents of RT0:31",
                "are undefined. The remainder is not supplied as a result.",
                "",
                "Both operands and the quotient are interpreted as signed integers.",
                "The quotient is the unique signed integer that satisfies",
                "",
                "dividend = (quotient  divisor) + r",
                "",
                "where 0  r ",
                "|divisor| if the dividend is nonnegative, and -|divisor|",
                " r  0 if the dividend is",
                "negative.",
                "",
                "If the quotient cannot be represented in 32 bits, or if an attempt is",
                "made to perform the division",
                "",
                "",
                "",
                "",
                "then the contents of register RT are undefined as are (if",
                "Rc=1) the contents of the LT, GT, and",
                "EQ bits of CR Field 0.",
                "In these cases, if OE=1 then OV and",
                "OV32 are set to 1.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Divide Word Extended Unsigned",
                    "form": "XO",
                    "mnemonic": "divweu",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Divide Word Extended Unsigned",
                    "form": "XO",
                    "mnemonic": "divweu.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Divide Word Extended Unsigned",
                    "form": "XO",
                    "mnemonic": "divweuo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Divide Word Extended Unsigned",
                    "form": "XO",
                    "mnemonic": "divweuo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "395",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:63</sub> := (RA)<sub>32:63</sub> || <sup>32</sup>0",
                "divisor<sub>0:31</sub> := (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub> := dividend / divisor",
                "RT<sub>0:31</sub> := undefined"
            ],
            "body": [
                "",
                "",
                "The 64-bit dividend is (RA)32:63 ||",
                "320.",
                "The 32-bit divisor is (RB)32:63.",
                "If the quotient can be represented in 32 bits, it is placed into",
                "RT32:63.",
                "The contents of RT0:31",
                "are undefined. The remainder is not supplied as a result.",
                "",
                "Both operands and the quotient are interpreted as unsigned integers,",
                "except that if Rc=1 the first three bits of CR Field 0 are set by",
                "signed comparison of the result to zero.",
                "The quotient is the unique unsigned integer that satisfies",
                "",
                "dividend = (quotient  divisor) + r",
                "",
                "where 0  r  divisor.",
                "",
                "If (RA)  (RB), or if an attempt is made",
                "to perform the division",
                "",
                "",
                "",
                "",
                "then the contents of register RT are undefined as are (if",
                "Rc=1) the contents of the LT, GT,",
                "and EQ bits of CR Field 0.",
                "In these cases, if OE=1 then OV and",
                "OV32 are set to 1.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Modulo Signed Word",
                    "form": "X",
                    "mnemonic": "modsw",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "779",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:31 </sub> := (RA)<sub>32:63</sub>",
                "divisor<sub>0:31 </sub>  := (RB)<sub>32:63</sub>-",
                "RT<sub>32:63</sub>       := dividend % divisor",
                "RT<sub>0:31 </sub>       := undefined"
            ],
            "body": [
                "",
                "",
                "The 32-bit dividend is (RA)32:63.",
                "The 32-bit divisor is (RB)32:63.",
                "The 32-bit remainder of the dividend divided by the divisor is placed",
                "into RT32:63.",
                "The contents of RT0:31",
                "are undefined. The quotient is not supplied as a result.",
                "",
                "Both operands and the remainder are interpreted as signed integers.",
                "The remainder is the unique signed integer that satisfies",
                "",
                "",
                "",
                "",
                "where 0  remainder  |divisor| if",
                "the dividend is nonnegative, and -|divisor| ",
                "remainder  0 if the dividend is negative.",
                "",
                "If an attempt is made to perform any of the divisions",
                "",
                "",
                "",
                "",
                "then the contents of register RT are undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Modulo Unsigned Word",
                    "form": "X",
                    "mnemonic": "moduw",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "267",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:31 </sub> := (RA)<sub>32:63</sub>",
                "divisor<sub>0:31 </sub>  := (RB)<sub>32:63</sub>",
                "RT<sub>32:63</sub>       := dividend % divisor",
                "RT<sub>0:31 </sub>       := undefined"
            ],
            "body": [
                "",
                "",
                "The 32-bit dividend is (RA)32:63.",
                "The 32-bit divisor is (RB)32:63.",
                "The 32-bit remainder of the dividend divided by the divisor is placed",
                "into RT32:63.",
                "The contents of RT0:31 are undefined.",
                "The quotient is not supplied as a result.",
                "",
                "Both operands and the remainder are interpreted as unsigned integers.",
                "The remainder is the unique signed integer that satisfies",
                "",
                "",
                "",
                "",
                "where 0  remainder  divisor.",
                "",
                "If an attempt is made to perform any of the divisions",
                "",
                "",
                "",
                "",
                "then the contents of register RT are undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Deliver A Random Number",
                    "form": "X",
                    "mnemonic": "darn",
                    "operands": [
                        "RT",
                        "L"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "L",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "755",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RT := random(L)"
            ],
            "body": [
                "",
                "",
                "A random number is placed into register RT in a format",
                "selected by L as shown in the following table.",
                "The value 0xFFFFFFFF_FFFFFFFF indicates an error",
                "condition.",
                "For L=0, the random number range is 0:0xFFFFFFFF.",
                "For L=1 and L=2, the random number range is",
                "0:0xFFFFFFFF_FFFFFFFE.",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Multiply Low Doubleword",
                    "form": "XO",
                    "mnemonic": "mulld",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Multiply Low Doubleword",
                    "form": "XO",
                    "mnemonic": "mulld.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Multiply Low Doubleword",
                    "form": "XO",
                    "mnemonic": "mulldo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Multiply Low Doubleword",
                    "form": "XO",
                    "mnemonic": "mulldo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "233",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) * (RB)",
                "RT := prod<sub>64:127</sub>"
            ],
            "body": [
                "",
                "",
                "The 64-bit operands are (RA) and (RB).",
                "The low-order 64 bits of the 128-bit product of the operands are",
                "placed into register RT.",
                "",
                "If OE=1 then OV and OV32 are set",
                "to 1 if the product cannot be represented in 64 bits.",
                "",
                "Both operands and the product are interpreted as signed integers.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Multiply High Doubleword",
                    "form": "XO",
                    "mnemonic": "mulhd",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Multiply High Doubleword",
                    "form": "XO",
                    "mnemonic": "mulhd.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "73",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) * (RB)",
                "RT := prod<sub>0:63</sub>"
            ],
            "body": [
                "",
                "",
                "The 64-bit operands are (RA) and (RB).",
                "The high-order 64 bits of the 128-bit product of the operands are",
                "placed into register RT.",
                "",
                "Both operands and the product are interpreted as signed integers.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Multiply High Doubleword Unsigned",
                    "form": "XO",
                    "mnemonic": "mulhdu",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Multiply High Doubleword Unsigned",
                    "form": "XO",
                    "mnemonic": "mulhdu.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "9",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) * (RB)",
                "RT := prod<sub>0:63</sub>"
            ],
            "body": [
                "",
                "",
                "The 64-bit operands are (RA) and (RB).",
                "The high-order 64 bits of the 128-bit product of the operands are",
                "placed into register RT.",
                "",
                "Both operands and the product are interpreted as unsigned integers,",
                "except that if Rc=1 the first three bits of CR Field 0",
                "are set by signed comparison of the result to zero.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Multiply-Add High Doubleword",
                    "form": "VA",
                    "mnemonic": "maddhd",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "RC"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "48",
                    "size": "6"
                }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) * (RB)",
                "sum<sub>0:127</sub>  := prod + EXTS(RC)",
                "RT := sum<sub>0:63</sub>"
            ],
            "body": [
                "",
                "",
                "The 64-bit operands are (RA), (RB), and",
                "(RC).",
                "The 128-bit product of the operands (RA) and (RB) is added to (RC).",
                "The high-order 64 bits of the 128-bit sum are placed into register",
                "RT.",
                "",
                "All three operands and the result are interpreted as signed integers.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Multiply-Add High Doubleword Unsigned",
                    "form": "VA",
                    "mnemonic": "maddhdu",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "RC"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "49",
                    "size": "6"
                }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) * (RB)",
                "sum<sub>0:127</sub>  := prod + EXTZ(RC)",
                "RT := sum<sub>0:63</sub>"
            ],
            "body": [
                "",
                "",
                "The 64-bit operands are (RA), (RB), and",
                "(RC).",
                "The 128-bit product of the operands (RA) and (RB) is added to (RC).",
                "The high-order 64 bits of the 128-bit sum are placed into register",
                "RT.",
                "",
                "All three operands and the result are interpreted as unsigned",
                "integers.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Multiply-Add Low Doubleword",
                    "form": "VA",
                    "mnemonic": "maddld",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "RC"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "51",
                    "size": "6"
                }
            ],
            "code": [
                "prod<sub>0:127</sub> := (RA) * (RB)",
                "sum<sub>0:127</sub>  := prod + EXTS(RC)",
                "RT := sum<sub>64:127</sub>"
            ],
            "body": [
                "",
                "",
                "The 64-bit operands are (RA), (RB), and",
                "(RC).",
                "The 128-bit product of the operands (RA) and (RB) is added to (RC).",
                "The low-order 64 bits of the 128-bit sum are placed into register",
                "RT.",
                "",
                "All three operands and the result are interpreted as signed integers.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Divide Doubleword",
                    "form": "XO",
                    "mnemonic": "divd",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Divide Doubleword",
                    "form": "XO",
                    "mnemonic": "divd.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Divide Doubleword",
                    "form": "XO",
                    "mnemonic": "divdo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Divide Doubleword",
                    "form": "XO",
                    "mnemonic": "divdo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "489",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:63</sub> := (RA)",
                "divisor<sub>0:63</sub> := (RB)",
                "RT := dividend / divisor"
            ],
            "body": [
                "",
                "",
                "The 64-bit dividend is (RA).",
                "The 64-bit divisor is (RB).",
                "The 64-bit quotient is placed into register RT.",
                "The remainder is not supplied as a result.",
                "",
                "Both operands and the quotient are interpreted as signed integers.",
                "The quotient is the unique signed integer that satisfies",
                "",
                "dividend = (quotient  divisor) + r",
                "",
                "where 0  r  |divisor| if the",
                "dividend is nonnegative, and -|divisor| ",
                "r  0 if the dividend is negative.",
                "",
                "If an attempt is made to perform any of the divisions",
                "",
                "",
                "",
                "",
                "then the contents of register RT are undefined as are (if Rc=1) the",
                "contents of the LT, GT, and EQ bits of CR Field 0.",
                "In these cases, if OE=1 then OV and OV32 are set to 1.",
                "",
                ""
            ],
            "intrinsics": [
                "vec_div"
            ]
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Divide Doubleword Unsigned",
                    "form": "XO",
                    "mnemonic": "divdu",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Divide Doubleword Unsigned",
                    "form": "XO",
                    "mnemonic": "divdu.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Divide Doubleword Unsigned",
                    "form": "XO",
                    "mnemonic": "divduo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Divide Doubleword Unsigned",
                    "form": "XO",
                    "mnemonic": "divduo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "457",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:63</sub> := (RA)",
                "divisor<sub>0:63</sub> := (RB)",
                "RT := dividend / divisor"
            ],
            "body": [
                "",
                "",
                "The 64-bit dividend is (RA).",
                "The 64-bit divisor is (RB).",
                "The 64-bit quotient is placed into register RT.",
                "The remainder is not supplied as a result.",
                "",
                "Both operands and the quotient are interpreted as unsigned integers,",
                "except that if Rc=1 the first three bits of CR Field 0",
                "are set by signed comparison of the result to zero.",
                "The quotient is the unique unsigned integer that satisfies",
                "",
                "dividend = (quotient  divisor) + r",
                "",
                "where 0  r  divisor.",
                "",
                "If an attempt is made to perform the division",
                "",
                "",
                "",
                "",
                "then the contents of register RT are undefined as are (if",
                "Rc=1) the contents of the LT, GT,",
                "and EQ bits of CR Field 0.",
                "In this case, if OE=1 then OV and OV32 are set to 1.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Divide Doubleword Extended",
                    "form": "XO",
                    "mnemonic": "divde",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Divide Doubleword Extended",
                    "form": "XO",
                    "mnemonic": "divde.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Divide Doubleword Extended",
                    "form": "XO",
                    "mnemonic": "divdeo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Divide Doubleword Extended",
                    "form": "XO",
                    "mnemonic": "divdeo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "425",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:127</sub> := (RA) || <sup>64</sup>0",
                "divisor<sub>0:63</sub> := (RB)",
                "RT := dividend / divisor"
            ],
            "body": [
                "",
                "",
                "The 128-bit dividend is (RA) ||",
                "640.",
                "The 64-bit divisor is (RB).",
                "If the quotient can be represented in 64 bits, it is placed into",
                "register RT. The remainder is not supplied as a result.",
                "",
                "Both operands and the quotient are interpreted as signed integers.",
                "The quotient is the unique signed integer that satisfies",
                "",
                "dividend = (quotient  divisor) + r",
                "",
                "where 0  r ",
                "|divisor| if the dividend is nonnegative, and -|divisor|",
                " r  0 if the dividend is",
                "negative.",
                "",
                "If the quotient cannot be represented in 64 bits, or if an attempt is",
                "made to perform the division",
                "",
                "",
                "",
                "",
                "then the contents of register RT are undefined as are (if",
                "Rc=1) the contents of the LT, GT, and",
                "EQ bits of CR Field 0.",
                "In these cases, if OE=1 then OV and",
                "OV32 are set to 1.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Divide Doubleword Extended Unsigned",
                    "form": "XO",
                    "mnemonic": "divdeu",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Divide Doubleword Extended Unsigned",
                    "form": "XO",
                    "mnemonic": "divdeu.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "0"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Divide Doubleword Extended Unsigned",
                    "form": "XO",
                    "mnemonic": "divdeuo",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Divide Doubleword Extended Unsigned",
                    "form": "XO",
                    "mnemonic": "divdeuo.",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "OE",
                            "value": "1"
                        },
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "OE=1",
                    "size": "1"
                },
                {
                    "name": "393",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "dividend<sub>0:127</sub> := (RA) || <sup>64</sup>0",
                "divisor<sub>0:63</sub> := (RB)",
                "RT := dividend / divisor"
            ],
            "body": [
                "",
                "",
                "The 128-bit dividend is (RA) ||",
                "640.",
                "The 64-bit divisor is (RB).",
                "If the quotient can be represented in 64 bits, it is placed into",
                "register RT. The remainder is not supplied as a result.",
                "",
                "Both operands and the quotient are interpreted as unsigned integers,",
                "except that if Rc=1 the first three bits of CR Field 0",
                "are set by signed comparison of the result to zero.",
                "The quotient is the unique unsigned integer that satisfies",
                "",
                "dividend = (quotient  divisor) + r",
                "",
                "where 0  r  divisor.",
                "",
                "If (RA)  (RB), or if an attempt is made",
                "to perform the division",
                "",
                "",
                "",
                "",
                "then the contents of register RT are undefined as are (if",
                "Rc=1) the contents of the LT, GT,",
                "and EQ bits of CR Field 0.",
                "In these cases, if OE=1 then OV and",
                "OV32 are set to 1.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Modulo Signed Doubleword",
                    "form": "X",
                    "mnemonic": "modsd",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "777",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "dividend := (RA)",
                "divisor  := (RB)",
                "RT       := dividend % divisor"
            ],
            "body": [
                "",
                "The 64-bit dividend is (RA).",
                "The 64-bit divisor is (RB).",
                "The 64-bit remainder of the dividend divided by the divisor is placed",
                "into register RT.",
                "The quotient is not supplied as a result.",
                "",
                "Both operands and the remainder are interpreted as signed integers.",
                "The remainder is the unique signed integer that satisfies",
                "",
                "",
                "",
                "",
                "where 0  remainder  |divisor| if",
                "the dividend is nonnegative, and -|divisor| ",
                "remainder  0 if the dividend is negative.",
                "",
                "If an attempt is made to perform any of the divisions",
                "",
                "",
                "",
                "",
                "then the contents of register RT are undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Modulo Unsigned Doubleword",
                    "form": "X",
                    "mnemonic": "modud",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "265",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "dividend := (RA)",
                "divisor  := (RB)",
                "RT       := dividend % divisor"
            ],
            "body": [
                "",
                "The 64-bit dividend is (RA).",
                "The 64-bit divisor is (RB).",
                "The 64-bit remainder of the dividend divided by the divisor is placed",
                "into register RT.",
                "The quotient is not supplied as a result.",
                "",
                "Both operands and the remainder are interpreted as unsigned integers.",
                "The remainder is the unique signed integer that satisfies",
                "",
                "",
                "",
                "",
                "where 0  remainder  divisor.",
                "",
                "If an attempt is made to perform any of the divisions",
                "",
                "",
                "",
                "",
                "then the contents of register RT are undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Compare Immediate",
                    "form": "D",
                    "mnemonic": "cmpi",
                    "operands": [
                        "BF",
                        "L",
                        "RA",
                        "SI"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "11",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SI",
                    "size": "16"
                }
            ],
            "code": [
                "if L = 0 then a := EXTS((RA)<sub>32:63</sub>)",
                "        else a := (RA)",
                "if      a < EXTS(SI) then c := 0b100",
                "else if a > EXTS(SI) then c := 0b010",
                "else                      c := 0b001",
                "CR<sub>4BF+32:4BF+35</sub> := c || XER<sub>SO</sub>"
            ],
            "body": [
                "",
                "",
                "The contents of register RA ((RA)32:63 sign-extended to 64 bits",
                "if L=0) are compared with the sign-extended value of the",
                "SI field, treating the operands as signed integers.",
                "The result of the comparison is placed into CR field BF.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Compare",
                    "form": "X",
                    "mnemonic": "cmp",
                    "operands": [
                        "BF",
                        "L",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if L = 0 then a := EXTS((RA)<sub>32:63</sub>)",
                "             b := EXTS((RB)<sub>32:63</sub>)",
                "        else a := (RA)",
                "             b := (RB)",
                "if      a < b then c := 0b100",
                "else if a > b then c := 0b010",
                "else               c := 0b001",
                "CR<sub>4BF+32:4BF+35</sub> := c || XER<sub>SO</sub>"
            ],
            "body": [
                "",
                "",
                "The contents of register RA ((RA)32:63 if L=0) are",
                "compared with the contents of register RB ((RB)32:63 if L=0),",
                "treating the operands as signed integers.",
                "The result of the comparison is placed into CR field BF.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Compare Logical Immediate",
                    "form": "D",
                    "mnemonic": "cmpli",
                    "operands": [
                        "BF",
                        "L",
                        "RA",
                        "UI"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "10",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "UI",
                    "size": "16"
                }
            ],
            "code": [
                "if L = 0 then a := <sup>32</sup>0 || (RA)<sub>32:63</sub>",
                "        else a := (RA)",
                "if      a <<sup>u</sup> (<sup>48</sup>0 || UI) then c := 0b100",
                "else if a ><sup>u</sup> (<sup>48</sup>0 || UI) then c := 0b010",
                "else                         c := 0b001",
                "CR<sub>4BF+32:4BF+35</sub> := c || XER<sub>SO</sub>"
            ],
            "body": [
                "",
                "",
                "The contents of register RA ((RA)32:63 zero-extended to 64 bits",
                "if L=0) are compared with",
                "480||UI, treating",
                "the operands as unsigned integers.",
                "The result of the comparison is placed into CR field BF.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Compare Logical",
                    "form": "X",
                    "mnemonic": "cmpl",
                    "operands": [
                        "BF",
                        "L",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "32",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if L = 0 then a := <sup>32</sup>0 || (RA)<sub>32:63</sub>",
                "             b := <sup>32</sup>0 || (RB)<sub>32:63</sub>",
                "        else a := (RA)",
                "             b := (RB)",
                "if      a <<sup>u</sup> b then c := 0b100",
                "else if a ><sup>u</sup> b then c := 0b010",
                "else                c := 0b001",
                "CR<sub>4BF+32:4BF+35</sub> := c || XER<sub>SO</sub>"
            ],
            "body": [
                "",
                "",
                "The contents of register RA ((RA)32:63 if L=0) are",
                "compared with the contents of register RB ((RB)32:63 if L=0),",
                "treating the operands as unsigned integers.",
                "The result of the comparison is placed into CR field BF.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Compare Ranged Byte",
                    "form": "X",
                    "mnemonic": "cmprb",
                    "operands": [
                        "BF",
                        "L",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "192",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "src1    := EXTZ((RA)<sub>56:63</sub>)",
                "",
                "src21hi := EXTZ((RB)<sub>32:39</sub>)",
                "src21lo := EXTZ((RB)<sub>40:47</sub>)",
                "src22hi := EXTZ((RB)<sub>48:55</sub>)",
                "src22lo := EXTZ((RB)<sub>56:63</sub>)",
                "",
                "if L=0 then",
                "  in_range :=  (src22lo <= src1) & (src1 <= src22hi)",
                "else",
                "  in_range := ((src21lo <= src1) & (src1 <= src21hi)) |",
                "  in_range := ((src22lo <= src1) & (src1 <= src22hi))",
                "",
                "CR<sub>4BF+32:4BF+35</sub> := 0b0 || in_range || 0b00"
            ],
            "body": [
                "",
                "",
                "Let src1 be the unsigned integer value in bits 56:63 of",
                "register RA.",
                "",
                "Let src21hi be the unsigned integer value in bits 32:39",
                "of register RB.",
                "",
                "Let src21lo be the unsigned integer value in bits 40:47",
                "of register RB.",
                "",
                "Let src22hi be the unsigned integer value in bits 48:55",
                "of register RB.",
                "",
                "Let src22lo be the unsigned integer value in bits 56:63",
                "of register RB.",
                "",
                "Let x be considered in range of y:z if",
                "the value x is greater than or equal to the value",
                "y and the value x is less than or equal to",
                "the value z.",
                "",
                "When L=0, the value in_range is set to 1 if",
                "src1 is in range of src22lo:src22hi.",
                "Otherwise, the value in_range is set to 0.",
                "",
                "When L=1, the value in_range is set to 1 if",
                "either src1 is in range of src21lo:src21hi,",
                "or src1 is in range of src22lo:src22hi.",
                "Otherwise, the value in_range is set to 0.",
                "",
                "CR field BF is set to the value 0b0 concatenated with in_range concatenated with",
                "0b00.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Compare Equal Byte",
                    "form": "X",
                    "mnemonic": "cmpeqb",
                    "operands": [
                        "BF",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "224",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "src1 := GPR[RA].bit[56:63]",
                "",
                "match := (src1 = (RB)<sub>00:07</sub>) | (src1 = (RB)<sub>08:15</sub>) |",
                "        (src1 = (RB)<sub>16:23</sub>) | (src1 = (RB)<sub>24:31</sub>) |",
                "        (src1 = (RB)<sub>32:39</sub>) | (src1 = (RB)<sub>40:47</sub>) |",
                "        (src1 = (RB)<sub>48:55</sub>) | (src1 = (RB)<sub>56:63</sub>)",
                "",
                "CR<sub>4BF+32:4BF+35</sub> := 0b0 || match || 0b00"
            ],
            "body": [
                "",
                "",
                "CR field BF is set to indicate if the",
                "contents of bits 56:63 of register RA are equal to the",
                "contents of any of the 8 bytes in register RB.",
                "",
                "Results are undefined in 32-bit mode.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Trap Word Immediate",
                    "form": "D",
                    "mnemonic": "twi",
                    "operands": [
                        "TO",
                        "RA",
                        "SI"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "3",
                    "size": "6"
                },
                {
                    "name": "TO",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SI",
                    "size": "16"
                }
            ],
            "code": [
                "a := EXTS((RA)<sub>32:63</sub>)",
                "if (a < EXTS(SI)) & TO<sub>0</sub>  then TRAP",
                "if (a > EXTS(SI)) & TO<sub>1</sub>  then TRAP",
                "if (a = EXTS(SI)) & TO<sub>2</sub>  then TRAP",
                "if (a <<sup>u</sup> EXTS(SI)) & TO<sub>3</sub> then TRAP",
                "if (a ><sup>u</sup> EXTS(SI)) & TO<sub>4</sub> then TRAP"
            ],
            "body": [
                "",
                "",
                "The contents of RA32:63",
                "are compared with the sign-extended value of the SI",
                "field.",
                "If any bit in the TO field is set to 1 and its",
                "corresponding condition is met by the result of the comparison, the",
                "system trap handler is invoked.",
                "",
                "If the trap conditions are met, this instruction is",
                "context synchronizing (see Book III).",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Trap Word",
                    "form": "X",
                    "mnemonic": "tw",
                    "operands": [
                        "TO",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "TO",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "4",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "a := EXTS((RA)<sub>32:63</sub>)",
                "b := EXTS((RB)<sub>32:63</sub>)",
                "if (a < b) & TO<sub>0</sub> then TRAP",
                "if (a > b) & TO<sub>1</sub> then TRAP",
                "if (a = b) & TO<sub>2</sub> then TRAP",
                "if (a <<sup>u</sup> b) & TO<sub>3</sub> then TRAP",
                "if (a ><sup>u</sup> b) & TO<sub>4</sub> then TRAP"
            ],
            "body": [
                "",
                "",
                "The contents of RA32:63",
                "are compared with the contents of RB32:63.",
                "If any bit in the TO field is set to 1 and its",
                "corresponding condition is met by the result of the comparison, the",
                "system trap handler is invoked.",
                "",
                "If the trap conditions are met, this instruction is",
                "context synchronizing (see Book III).",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Trap Doubleword Immediate",
                    "form": "D",
                    "mnemonic": "tdi",
                    "operands": [
                        "TO",
                        "RA",
                        "SI"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "2",
                    "size": "6"
                },
                {
                    "name": "TO",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SI",
                    "size": "16"
                }
            ],
            "code": [
                "a := (RA)",
                "b := EXTS(SI)",
                "if (a < b) & TO<sub>0</sub> then TRAP",
                "if (a > b) & TO<sub>1</sub> then TRAP",
                "if (a = b) & TO<sub>2</sub> then TRAP",
                "if (a <<sup>u</sup> b) & TO<sub>3</sub> then TRAP",
                "if (a ><sup>u</sup> b) & TO<sub>4</sub> then TRAP"
            ],
            "body": [
                "",
                "",
                "The contents of register RA are compared with the",
                "sign-extended value of the SI field.",
                "If any bit in the TO field is set to 1 and its",
                "corresponding condition is met by the result of the comparison, the",
                "system trap handler is invoked.",
                "",
                "If the trap conditions are met, this instruction is context",
                "synchronizing (see Book III).",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Trap Doubleword",
                    "form": "X",
                    "mnemonic": "td",
                    "operands": [
                        "TO",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "TO",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "68",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "a := (RA)",
                "b := (RB)",
                "if (a < b) & TO<sub>0</sub> then TRAP",
                "if (a > b) & TO<sub>1</sub> then TRAP",
                "if (a = b) & TO<sub>2</sub> then TRAP",
                "if (a <<sup>u</sup> b) & TO<sub>3</sub> then TRAP",
                "if (a ><sup>u</sup> b) & TO<sub>4</sub> then TRAP"
            ],
            "body": [
                "",
                "",
                "The contents of register RA are compared with the",
                "contents of register RB.",
                "If any bit in the TO field is set to 1 and its",
                "corresponding condition is met by the result of the comparison, the",
                "system trap handler is invoked.",
                "",
                "If the trap conditions are met, this instruction is context",
                "synchronizing (see Book III).",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Integer Select",
                    "form": "A",
                    "mnemonic": "isel",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "BC"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "BC",
                    "size": "5"
                },
                {
                    "name": "15",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA=0 then a := 0 else a := (RA)",
                "if CR<sub>BC+32</sub>=1 then",
                "  RT := a",
                "else",
                "  RT := (RB)"
            ],
            "body": [
                "",
                "",
                "If the contents of bit BC+32 of the Condition Register",
                "are equal to 1, then the contents of register RA (or 0)",
                "are placed into register RT.",
                "Otherwise, the contents of register RB are placed into",
                "register RT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "AND Immediate",
                    "form": "D",
                    "mnemonic": "andi.",
                    "operands": [
                        "RA",
                        "RS",
                        "UI"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "28",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "UI",
                    "size": "16"
                }
            ],
            "code": [
                "RA := (RS) & (<sup>48</sup>0 || UI)"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are ANDed with",
                "480||UI and the",
                "result is placed into register RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "AND Immediate Shifted",
                    "form": "D",
                    "mnemonic": "andis.",
                    "operands": [
                        "RA",
                        "RS",
                        "UI"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "29",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "UI",
                    "size": "16"
                }
            ],
            "code": [
                "RA := (RS) & (<sup>32</sup>0 || UI || <sup>16</sup>0)"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are ANDed with",
                "320||UI||160 and",
                "the result is placed into register RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "OR Immediate",
                    "form": "D",
                    "mnemonic": "ori",
                    "operands": [
                        "RA",
                        "RS",
                        "UI"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "24",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "UI",
                    "size": "16"
                }
            ],
            "code": [
                "RA := (RS) | (<sup>48</sup>0 || UI)"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are ORed with",
                "480||UI and the",
                "result is placed into register RA.",
                "",
                "The preferred no-op (an instruction that does nothing) is:",
                "",
                "",
                "",
                "",
                "Some other forms of ori Rx,Rx,0 provide special functions;",
                "see",
                "Section",
                "of Book III.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "OR Immediate Shifted",
                    "form": "D",
                    "mnemonic": "oris",
                    "operands": [
                        "RA",
                        "RS",
                        "UI"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "25",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "UI",
                    "size": "16"
                }
            ],
            "code": [
                "RA := (RS) | (<sup>32</sup>0 || UI || <sup>16</sup>0)"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are ORed with",
                "320||UI||160 and",
                "the result is placed into register RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "XOR Immediate",
                    "form": "D",
                    "mnemonic": "xori",
                    "operands": [
                        "RA",
                        "RS",
                        "UI"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "26",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "UI",
                    "size": "16"
                }
            ],
            "code": [
                "RA := (RS) XOR (<sup>48</sup>0 || UI)"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are XORed with",
                "480||UI and the",
                "result is placed into register RA.",
                "",
                "The executed form of a no-op (an instruction that does nothing,",
                "but consumes execution resources nevertheless) is:",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract"
            ]
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "XOR Immediate Shifted",
                    "form": "D",
                    "mnemonic": "xoris",
                    "operands": [
                        "RA",
                        "RS",
                        "UI"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "27",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "UI",
                    "size": "16"
                }
            ],
            "code": [
                "RA := (RS) XOR (<sup>32</sup>0 || UI || <sup>16</sup>0)"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are XORed with",
                "320||UI||160 and",
                "the result is placed into register RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "AND",
                    "form": "X",
                    "mnemonic": "and",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "AND",
                    "form": "X",
                    "mnemonic": "and.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "28",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS) & (RB)"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are ANDed with the contents",
                "of register RB and the result is placed into register RA.",
                "",
                "Some forms of and Rx, Rx, Rx provide special",
                "functions; see",
                "Section",
                "of Book III.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "XOR",
                    "form": "X",
                    "mnemonic": "xor",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "XOR",
                    "form": "X",
                    "mnemonic": "xor.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "316",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS) ^ (RB)"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are XORed with the contents",
                "of register RB and the result is placed into register",
                "RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "NAND",
                    "form": "X",
                    "mnemonic": "nand",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "NAND",
                    "form": "X",
                    "mnemonic": "nand.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "476",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RA := ~((RS) & (RB))"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are ANDed with the contents",
                "of register RB and the complemented result is placed into",
                "register RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "OR",
                    "form": "X",
                    "mnemonic": "or",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "OR",
                    "form": "X",
                    "mnemonic": "or.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "444",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS) | (RB)"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are ORed with the contents of",
                "register RB and the result is placed into register RA.",
                "",
                "Some forms of or Rx,Rx,Rx provide special functions; see",
                "Section of Book II and",
                "Section of Book II.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "OR with Complement",
                    "form": "X",
                    "mnemonic": "orc",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "OR with Complement",
                    "form": "X",
                    "mnemonic": "orc.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "412",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS) | ~(RB)"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are ORed with the complement",
                "of the contents of register RB and the result is placed",
                "into register RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "NOR",
                    "form": "X",
                    "mnemonic": "nor",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "NOR",
                    "form": "X",
                    "mnemonic": "nor.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "124",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RA := ~((RS) | (RB))"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are ORed with the contents of",
                "register RB and the complemented result is placed into",
                "register RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Equivalent",
                    "form": "X",
                    "mnemonic": "eqv",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Equivalent",
                    "form": "X",
                    "mnemonic": "eqv.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "284",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS) == (RB)"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are XORed with the contents",
                "of register RB and the complemented result is placed into",
                "register RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "AND with Complement",
                    "form": "X",
                    "mnemonic": "andc",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "AND with Complement",
                    "form": "X",
                    "mnemonic": "andc.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "60",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS) & ~(RB)"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are ANDed with the complement",
                "of the contents of register RB and the result is placed",
                "into register RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Extend Sign Byte",
                    "form": "X",
                    "mnemonic": "extsb",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Extend Sign Byte",
                    "form": "X",
                    "mnemonic": "extsb.",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "954",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "s := (RS)<sub>56</sub>",
                "RA<sub>56:63</sub> := (RS)<sub>56:63</sub>",
                "RA<sub>0:55</sub> := <sup>56</sup>s"
            ],
            "body": [
                "",
                "",
                "(RS)56:63 are placed",
                "into RA56:63.",
                "RA0:55 are filled with",
                "a copy of (RS)56.",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract"
            ]
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Extend Sign Halfword",
                    "form": "X",
                    "mnemonic": "extsh",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Extend Sign Halfword",
                    "form": "X",
                    "mnemonic": "extsh.",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "922",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "s := (RS)<sub>48</sub>",
                "RA<sub>48:63</sub> := (RS)<sub>48:63</sub>",
                "RA<sub>0:47</sub> := <sup>48</sup>s"
            ],
            "body": [
                "",
                "",
                "(RS)48:63 are placed",
                "into RA48:63.",
                "RA0:47 are filled with",
                "a copy of (RS)48.",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract"
            ]
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Compare Bytes",
                    "form": "X",
                    "mnemonic": "cmpb",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "508",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "do n = 0 to 7",
                "  if RS<sub>8n:8n+7</sub> = (RB)<sub>8n:8n+7</sub> then",
                "     RA<sub>8n:8n+7</sub> := <sup>8</sup>1",
                "  else",
                "     RA<sub>8n:8n+7</sub> := <sup>8</sup>0"
            ],
            "body": [
                "",
                "",
                "Each byte of the contents of register RS is compared to",
                "each corresponding byte of the contents in register RB.",
                "If they are equal, the corresponding byte in RA is set to",
                "0xFF.",
                "Otherwise the corresponding byte in RA is set to",
                "0x00.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Count Leading Zeros Word",
                    "form": "X",
                    "mnemonic": "cntlzw",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Count Leading Zeros Word",
                    "form": "X",
                    "mnemonic": "cntlzw.",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "26",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := 32",
                "",
                "do while n < 64",
                "  if (RS)<sub>n</sub> = 1 then leave",
                "  n := n + 1",
                "",
                "RA := n - 32"
            ],
            "body": [
                "",
                "",
                "",
                "A count of the number of consecutive zero bits starting at bit 32 of",
                "register RS is placed into register RA.",
                "This number ranges from 0 to 32, inclusive.",
                "",
                "If Rc is equal to 1, CR field 0 is set to",
                "reflect the result.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_any_eq",
                "vec_any_ge",
                "vec_any_gt",
                "vec_any_le",
                "vec_any_lt",
                "vec_any_nan",
                "vec_any_ne",
                "vec_any_nge",
                "vec_any_ngt",
                "vec_any_nle",
                "vec_any_nlt",
                "vec_any_numeric",
                "vec_any_out"
            ]
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Count Trailing Zeros Word",
                    "form": "X",
                    "mnemonic": "cnttzw",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "Count Trailing Zeros Word",
                    "form": "X",
                    "mnemonic": "cnttzw.",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "538",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := 0",
                "",
                "do while n < 32",
                "  if (RS)<sub>63-n</sub> = 0b1 then leave",
                "  n  := n + 1",
                "",
                "RA := EXTZ64(n)"
            ],
            "body": [
                "",
                "",
                "A count of the number of consecutive zero bits starting at bit 63 of",
                "the rightmost word of register RS is placed into register",
                "RA. This number ranges from 0 to 32, inclusive.",
                "",
                "If Rc is equal to 1, CR field 0 is set to",
                "reflect the result.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Population Count Bytes",
                    "form": "X",
                    "mnemonic": "popcntb",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [],
                    "release": "v2.02"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "122",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "do i = 0 to 7",
                "  n := 0",
                "  do j = 0 to 7",
                "     if (RS)<sub>(i8)+j</sub> = 1 then",
                "         n := n+1",
                "  RA<sub>(i8):(i8)+7</sub> := n"
            ],
            "body": [
                "",
                "",
                "A count of the number of one bits in each byte of register RS is placed into the corresponding byte of register RA.",
                "This number ranges from 0 to 8, inclusive.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Population Count Words",
                    "form": "X",
                    "mnemonic": "popcntw",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "378",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "do i = 0 to 1",
                "  n := 0",
                "  do j = 0 to 31",
                "     if (RS)<sub>(i32)+j</sub> = 1 then",
                "         n := n+1",
                "  RA<sub>(i32):(i32)+31</sub> := n"
            ],
            "body": [
                "",
                "",
                "A count of the number of one bits in each word of register RS is placed into the corresponding word of register RA.",
                "This number ranges from 0 to 32, inclusive.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Parity Word",
                    "form": "X",
                    "mnemonic": "prtyw",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "154",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "s := 0",
                "t := 0",
                "do i = 0 to 3",
                "  s := s ^ (RS)<sub>i8+7</sub>",
                "do i = 4 to 7",
                "  t := t ^ (RS)<sub>i8+7</sub>",
                "RA<sub>0:31</sub> := <sup>31</sup>0 || s",
                "RA<sub>32:63</sub> := <sup>31</sup>0 || t"
            ],
            "body": [
                "",
                "",
                "The least significant bit in each byte of (RS)0:31 is examined.",
                "If there is an odd number of one bits the value 1 is placed into",
                "RA0:31; otherwise the",
                "value 0 is placed into RA0:31.",
                "The least significant bit in each byte of (RS)32:63 is examined.",
                "If there is an odd number of one bits the value 1 is placed into",
                "RA32:63; otherwise the",
                "value 0 is placed into RA32:63.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Extend Sign Word",
                    "form": "X",
                    "mnemonic": "extsw",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Extend Sign Word",
                    "form": "X",
                    "mnemonic": "extsw.",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "986",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "s := (RS)<sub>32</sub>",
                "RA<sub>32:63</sub> := (RS)<sub>32:63</sub>",
                "RA<sub>0:31</sub> := <sup>32</sup>s"
            ],
            "body": [
                "",
                "",
                "(RS)32:63 are placed",
                "into RA32:63.",
                "RA0:31 are filled with",
                "a copy of (RS)32.",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract"
            ]
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Population Count Doubleword",
                    "form": "X",
                    "mnemonic": "popcntd",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "506",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "n := 0",
                "do i = 0 to 63",
                "  if (RS)<sub>i</sub> = 1 then",
                "  n := n+1",
                "RA := n"
            ],
            "body": [
                "",
                "",
                "A count of the number of one bits in register RS is",
                "placed into register RA.",
                "This number ranges from 0 to 64, inclusive.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Parity Doubleword",
                    "form": "X",
                    "mnemonic": "prtyd",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "186",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "s := 0",
                "do i = 0 to 7",
                "  s := s ^ (RS)<sub>i8+7</sub>",
                "RA := <sup>63</sup>0 || s"
            ],
            "body": [
                "",
                "",
                "The least significant bit in each byte of the contents of register",
                "RS is examined.",
                "If there is an odd number of one bits the value 1 is placed into",
                "register RA; otherwise the value 0 is placed into",
                "register RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Count Leading Zeros Doubleword",
                    "form": "X",
                    "mnemonic": "cntlzd",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Count Leading Zeros Doubleword",
                    "form": "X",
                    "mnemonic": "cntlzd.",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "58",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := 0",
                "do while n < 64",
                " if (RS)<sub>n</sub> = 1 then leave",
                " n := n + 1",
                "RA := n"
            ],
            "body": [
                "",
                "",
                "A count of the number of consecutive zero bits starting at bit 0 of",
                "register RS is placed into register RA.",
                "This number ranges from 0 to 64, inclusive.",
                "",
                "If Rc=1, CR Field 0 is set to reflect the result.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Count Trailing Zeros Doubleword",
                    "form": "X",
                    "mnemonic": "cnttzd",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "Count Trailing Zeros Doubleword",
                    "form": "X",
                    "mnemonic": "cnttzd.",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "570",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n  := 0",
                "do while n < 64",
                "  if (RS)<sub>63-n</sub> = 0b1 then leave",
                "  n  := n + 1",
                "RA := EXTZ64(n)"
            ],
            "body": [
                "",
                "",
                "A count of the number of consecutive zero bits starting at bit 63 of",
                "register RS is placed into register RA.",
                "This number ranges from 0 to 64, inclusive.",
                "",
                "If Rc is equal to 1, CR field 0 is set to",
                "reflect the result.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Count Leading Zeros Doubleword under bit Mask",
                    "form": "X",
                    "mnemonic": "cntlzdm",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "59",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "count = 0",
                "do i = 0 to 63",
                "  if((RB)<sub>i</sub>=1) then do",
                "     if((RS)<sub>i</sub>=1) then break",
                "     count := count + 1",
                "  end",
                "end",
                "RA := EXTZ64(count)"
            ],
            "body": [
                "",
                "",
                "Let n be the number of bits in register RB",
                "having the value 1.",
                "",
                "Extract and pack together the contents of the bits in register",
                "RS corresponding to a mask specified in register",
                "RB, creating an n-bit value.",
                "",
                "Count the number of contiguous leftmost 0 bits in the n-bit extracted value and place the result into register RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Count Trailing Zeros Doubleword under bit Mask",
                    "form": "X",
                    "mnemonic": "cnttzdm",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "571",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "count := 0",
                "do i = 0 to 63",
                "  if((RB)<sub>63-i</sub>=1) then do",
                "     if((RS)<sub>63-i</sub>=1) then break",
                "     count := count + 1",
                "  end",
                "end",
                "RA := EXTZ64(count)"
            ],
            "body": [
                "",
                "",
                "Let n be the number of bits in register RB",
                "having the value 1.",
                "",
                "Extract and pack together the contents of bits in register RS corresponding to a mask specified in register RB,",
                "creating an n-bit value.",
                "",
                "Count the number of contiguous rightmost 0 bits in the n-bit extracted value and place the result into register RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Bit Permute Doubleword",
                    "form": "X",
                    "mnemonic": "bpermd",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "252",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "do i = 0 to 7",
                "  index := (RS)<sub>8i:8i+7</sub>",
                "  If index < 64",
                "     then perm<sub>i</sub> := (RB)<sub>index</sub>",
                "     else perm<sub>i</sub> := 0",
                "RA := <sup>56</sup>0 || perm<sub>0:7</sub>"
            ],
            "body": [
                "",
                "",
                "Eight permuted bits are produced.",
                "For each permuted bit i where i ranges from 0 to 7 and",
                "for each byte i of RS, do the following.",
                "",
                "",
                "",
                "If byte i of RS is less than 64, permuted bit",
                "i is set to the bit of RB specified by byte i",
                "of RS; otherwise permuted bit i is set to 0.",
                "",
                "",
                "The permuted bits are placed in the least-significant byte of",
                "RA, and the remaining bits are filled with 0s.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Centrifuge Doubleword",
                    "form": "X",
                    "mnemonic": "cfuged",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "220",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "ptr0 := 0",
                "ptr1 := 0",
                "do i = 0 to 63",
                "  if((RB)<sub>i</sub>=0) then do",
                "     result<sub>ptr0</sub> := (RS)<sub>i</sub>",
                "     ptr0 := ptr0 + 1",
                "  end",
                "  if((RB)<sub>63-i</sub>==1) then do",
                "     result<sub>63-ptr1</sub> := (RS)<sub>63-i</sub>",
                "     ptr1 := ptr1 + 1",
                "  end",
                "end",
                "RA := result"
            ],
            "body": [
                "",
                "",
                "The bits in GPR[RS] whose corresponding bits in the mask",
                "in GPR[RB] equal 1 are placed in the rightmost bits in",
                "GPR[RA] maintaining their relative original order.",
                "The other bits in GPR[RS] are placed in the leftmost bits",
                "in GPR[RA] maintaining their relative original order.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Parallel Bits Extract Doubleword",
                    "form": "X",
                    "mnemonic": "pextd",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "188",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "result := 0",
                "mask := (RB)",
                "m := 0",
                "k := 0",
                "do while (m < 64)",
                "  if ((RB)<sub>63-m</sub> == 1) then do",
                "     result<sub>63-k</sub> := (RS)<sub>63-m</sub>",
                "     k := k + 1",
                "  end",
                "  m := m + 1",
                "end",
                "RA := result"
            ],
            "body": [
                "",
                "",
                "Let mask be the contents of register RB.",
                "",
                "The contents of the bits in register RS corresponding to",
                "bits in mask containing a 1 are packed into an n-bit value.",
                "The extracted value is placed into register RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Parallel Bits Deposit Doubleword",
                    "form": "X",
                    "mnemonic": "pdepd",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "156",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "result := 0",
                "mask := (RB)",
                "m := 0",
                "k := 0",
                "do while (m < 64)",
                "  if (mask<sub>63-m</sub> == 1) then do",
                "     result<sub>63-m</sub> := (RS)<sub>63-k</sub>",
                "     k := k + 1",
                "  end",
                "  m := m + 1",
                "end",
                "RA := result"
            ],
            "body": [
                "",
                "",
                "Let mask be the contents of register RB.",
                "",
                "Let n be the number of bits in mask having",
                "the value 1.",
                "",
                "The contents of the rightmost n bits of register RS are",
                "placed into register RA under control of mask",
                "as follows.",
                "",
                "",
                "",
                "The contents of bits in register RA corresponding to bits",
                "in mask that contain a 0 are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Rotate Left Word Immediate then AND with Mask",
                    "form": "M",
                    "mnemonic": "rlwinm",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Rotate Left Word Immediate then AND with Mask",
                    "form": "M",
                    "mnemonic": "rlwinm.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "21",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SH",
                    "size": "5"
                },
                {
                    "name": "MB",
                    "size": "5"
                },
                {
                    "name": "ME",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := SH",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, n)",
                "m := MASK(MB+32, ME+32)",
                "RA := r & m"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are rotated32",
                "left SH bits.",
                "A mask is generated having 1-bits from bit MB+32 through",
                "bit ME+32 and 0-bits elsewhere.",
                "The rotated data are ANDed with the generated mask and the result is",
                "placed into register RA.",
                "",
                ""
            ],
            "intrinsics": [
                "vec_all_eq",
                "vec_all_ge",
                "vec_all_gt",
                "vec_all_in",
                "vec_all_le",
                "vec_all_lt",
                "vec_all_nan",
                "vec_all_ne",
                "vec_all_nge",
                "vec_all_ngt",
                "vec_all_nle",
                "vec_all_nlt",
                "vec_all_numeric",
                "vec_any_eq",
                "vec_any_ge",
                "vec_any_gt",
                "vec_any_le",
                "vec_any_lt",
                "vec_any_nan",
                "vec_any_ne",
                "vec_any_nge",
                "vec_any_ngt",
                "vec_any_nle",
                "vec_any_nlt",
                "vec_any_numeric",
                "vec_any_out",
                "vec_splats"
            ]
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Rotate Left Word then AND with Mask",
                    "form": "M",
                    "mnemonic": "rlwnm",
                    "operands": [
                        "RA",
                        "RS",
                        "RB",
                        "MB",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Rotate Left Word then AND with Mask",
                    "form": "M",
                    "mnemonic": "rlwnm.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB",
                        "MB",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "23",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "MB",
                    "size": "5"
                },
                {
                    "name": "ME",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>59:63</sub>",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, n)",
                "m := MASK(MB+32, ME+32)",
                "RA := r & m"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are rotated32",
                "left the number of bits specified by (RB)59:63.",
                "A mask is generated having 1-bits from bit MB+32 through",
                "bit ME+32 and 0-bits elsewhere.",
                "The rotated data are ANDed with the generated mask and the result is",
                "placed into register RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Rotate Left Word Immediate then Mask Insert",
                    "form": "M",
                    "mnemonic": "rlwimi",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Rotate Left Word Immediate then Mask Insert",
                    "form": "M",
                    "mnemonic": "rlwimi.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "20",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SH",
                    "size": "5"
                },
                {
                    "name": "MB",
                    "size": "5"
                },
                {
                    "name": "ME",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := SH",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, n)",
                "m := MASK(MB+32, ME+32)",
                "RA := r&m | (RA) & ~m"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are rotated32",
                "left SH bits.",
                "A mask is generated having 1-bits from bit MB+32 through",
                "bit ME+32 and 0-bits elsewhere.",
                "The rotated data are inserted into register RA under",
                "control of the generated mask.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Rotate Left Doubleword Immediate then Clear Left",
                    "form": "MD",
                    "mnemonic": "rldicl",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Rotate Left Doubleword Immediate then Clear Left",
                    "form": "MD",
                    "mnemonic": "rldicl.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "30",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "sh1",
                    "size": "5"
                },
                {
                    "name": "mb1",
                    "size": "5"
                },
                {
                    "name": "mb0",
                    "size": "1"
                },
                {
                    "name": "0",
                    "size": "3"
                },
                {
                    "name": "sh0",
                    "size": "1"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "b := mb<sub>5</sub> || mb<sub>0:4</sub>",
                "m := MASK(b, 63)",
                "RA := r & m"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are rotated64",
                "left SH bits.",
                "A mask is generated having 1-bits from bit MB through bit",
                "63 and 0-bits elsewhere.",
                "The rotated data are ANDed with the generated mask and the result is",
                "placed into register RA.",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract",
                "vec_first_match_index",
                "vec_first_match_or_eos_index",
                "vec_first_mismatch_index",
                "vec_first_mismatch_or_eos_index"
            ]
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Rotate Left Doubleword Immediate then Clear Right",
                    "form": "MD",
                    "mnemonic": "rldicr",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Rotate Left Doubleword Immediate then Clear Right",
                    "form": "MD",
                    "mnemonic": "rldicr.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "30",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "sh1",
                    "size": "5"
                },
                {
                    "name": "me1",
                    "size": "5"
                },
                {
                    "name": "mb0",
                    "size": "1"
                },
                {
                    "name": "1",
                    "size": "3"
                },
                {
                    "name": "sh0",
                    "size": "1"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "e := me<sub>5</sub> || me<sub>0:4</sub>",
                "m := MASK(0, e)",
                "RA := r & m"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are rotated64",
                "left SH bits.",
                "A mask is generated having 1-bits from bit 0 through bit ME and 0-bits elsewhere.",
                "The rotated data are ANDed with the generated mask and the result is",
                "placed into register RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Rotate Left Doubleword Immediate then Clear",
                    "form": "MD",
                    "mnemonic": "rldic",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Rotate Left Doubleword Immediate then Clear",
                    "form": "MD",
                    "mnemonic": "rldic.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "30",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "sh1",
                    "size": "5"
                },
                {
                    "name": "mb1",
                    "size": "5"
                },
                {
                    "name": "mb0",
                    "size": "1"
                },
                {
                    "name": "2",
                    "size": "3"
                },
                {
                    "name": "sh0",
                    "size": "1"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "b := mb<sub>5</sub> || mb<sub>0:4</sub>",
                "m := MASK(b, ~n)",
                "RA := r & m"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are rotated64",
                "left SH bits.",
                "A mask is generated having 1-bits from bit MB through bit",
                "63-SH and 0-bits elsewhere.",
                "The rotated data are ANDed with the generated mask and the result is",
                "placed into register RA.",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract"
            ]
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Rotate Left Doubleword then Clear Left",
                    "form": "MDS",
                    "mnemonic": "rldcl",
                    "operands": [
                        "RA",
                        "RS",
                        "RB",
                        "MB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Rotate Left Doubleword then Clear Left",
                    "form": "MDS",
                    "mnemonic": "rldcl.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB",
                        "MB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "30",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "mb1",
                    "size": "5"
                },
                {
                    "name": "mb0",
                    "size": "1"
                },
                {
                    "name": "8",
                    "size": "4"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>58:63</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "b := mb<sub>5</sub> || mb<sub>0:4</sub>",
                "m := MASK(b, 63)",
                "RA := r & m"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are rotated64",
                "left the number of bits specified by (RB)58:63.",
                "A mask is generated having 1-bits from bit MB through bit",
                "63 and 0-bits elsewhere.",
                "The rotated data are ANDed with the generated mask and the result is",
                "placed into register RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Rotate Left Doubleword then Clear Right",
                    "form": "MDS",
                    "mnemonic": "rldcr",
                    "operands": [
                        "RA",
                        "RS",
                        "RB",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Rotate Left Doubleword then Clear Right",
                    "form": "MDS",
                    "mnemonic": "rldcr.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB",
                        "ME"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "30",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "me1",
                    "size": "5"
                },
                {
                    "name": "me0",
                    "size": "1"
                },
                {
                    "name": "9",
                    "size": "4"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>58:63</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "e := me<sub>5</sub> || me<sub>0:4</sub>",
                "m := MASK(0, e)",
                "RA := r & m"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are rotated64",
                "left the number of bits specified by (RB)58:63.",
                "A mask is generated having 1-bits from bit 0 through bit ME and 0-bits elsewhere.",
                "The rotated data are ANDed with the generated mask and the result is",
                "placed into register RA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Rotate Left Doubleword Immediate then Mask Insert",
                    "form": "MD",
                    "mnemonic": "rldimi",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Rotate Left Doubleword Immediate then Mask Insert",
                    "form": "MD",
                    "mnemonic": "rldimi.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH",
                        "MB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "30",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "sh1",
                    "size": "5"
                },
                {
                    "name": "mb1",
                    "size": "5"
                },
                {
                    "name": "mb0",
                    "size": "1"
                },
                {
                    "name": "3",
                    "size": "3"
                },
                {
                    "name": "sh0",
                    "size": "1"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "b := mb<sub>5</sub> || mb<sub>0:4</sub>",
                "m := MASK(b, ~n)",
                "RA := r&m | (RA) & ~m"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are rotated64",
                "left SH bits.",
                "A mask is generated having 1-bits from bit MB through bit",
                "63-SH and 0-bits elsewhere.",
                "The rotated data are inserted into register RA under",
                "control of the generated mask.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Shift Left Word",
                    "form": "X",
                    "mnemonic": "slw",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Shift Left Word",
                    "form": "X",
                    "mnemonic": "slw.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "24",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>59:63</sub>",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, n)",
                "if (RB)<sub>58</sub> = 0 then",
                "    m := MASK(32, 63-n)",
                "else m := <sup>64</sup>0",
                "RA := r & m"
            ],
            "body": [
                "",
                "",
                "The contents of the low-order 32 bits of register RS are",
                "shifted left the number of bits specified by (RB)58:63.",
                "Bits shifted out of position 32 are lost.",
                "Zeros are supplied to the vacated positions on the right.",
                "The 32-bit result is placed into RA32:63.",
                "RA0:31 are set to zero.",
                "Shift amounts from 32 to 63 give a zero result.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Shift Right Word",
                    "form": "X",
                    "mnemonic": "srw",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Shift Right Word",
                    "form": "X",
                    "mnemonic": "srw.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "536",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>59:63</sub>",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, 64-n)",
                "if (RB)<sub>58</sub> = 0 then",
                "   m := MASK(n+32, 63)",
                "else m := <sup>64</sup>0",
                "RA := r & m"
            ],
            "body": [
                "",
                "",
                "The contents of the low-order 32 bits of register RS are",
                "shifted right the number of bits specified by (RB)58:63.",
                "Bits shifted out of position 63 are lost.",
                "Zeros are supplied to the vacated positions on the left.",
                "The 32-bit result is placed into RA32:63.",
                "RA0:31 are set to zero.",
                "Shift amounts from 32 to 63 give a zero result.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Shift Right Algebraic Word Immediate",
                    "form": "X",
                    "mnemonic": "srawi",
                    "operands": [
                        "RA",
                        "RS",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Shift Right Algebraic Word Immediate",
                    "form": "X",
                    "mnemonic": "srawi.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "SH",
                    "size": "5"
                },
                {
                    "name": "824",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := SH",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, 64-n)",
                "m := MASK(n+32, 63)",
                "s := (RS)<sub>32</sub>",
                "RA := r&m | (<sup>64</sup>s) & ~m",
                "carry := s & ((r & ~m)<sub>32:63</sub> != 0 )",
                "CA    := carry",
                "CA32  := carry"
            ],
            "body": [
                "",
                "",
                "The contents of the low-order 32 bits of register RS are",
                "shifted right SH bits.",
                "Bits shifted out of position 63 are lost.",
                "Bit 32 of RS is replicated to fill the vacated positions",
                "on the left.",
                "The 32-bit result is placed into RA32:63.",
                "Bit 32 of RS is replicated to fill RA0:31.",
                "CA and CA32 are set to 1 if the low-order 32",
                "bits of (RS) contain a negative number and any 1-bits are",
                "shifted out of position 63; otherwise CA and CA32 are set to 0.",
                "A shift amount of zero causes RA to receive EXTS((RS)32:63), and",
                "CA and CA32 to be set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Shift Right Algebraic Word",
                    "form": "X",
                    "mnemonic": "sraw",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Shift Right Algebraic Word",
                    "form": "X",
                    "mnemonic": "sraw.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "792",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>59:63</sub>",
                "r := ROTL<sub>32</sub>((RS)<sub>32:63</sub>, 64-n)",
                "if (RB)<sub>58</sub> = 0 then",
                "   m := MASK(n+32, 63)",
                "else m := <sup>64</sup>0",
                "s := (RS)<sub>32</sub>",
                "RA := r&m | (<sup>64</sup>s) & ~m",
                "carry := s & ((r & ~m)<sub>32:63</sub> != 0)",
                "CA    := carry",
                "CA32  := carry"
            ],
            "body": [
                "",
                "",
                "The contents of the low-order 32 bits of register RS are",
                "shifted right the number of bits specified by (RB)58:63.",
                "Bits shifted out of position 63 are lost.",
                "Bit 32 of RS is replicated to fill the vacated positions",
                "on the left.",
                "The 32-bit result is placed into RA32:63.",
                "Bit 32 of RS is replicated to fill RA0:31.",
                "CA and CA32 are set to 1 if the low-order 32",
                "bits of (RS) contain a negative number and any 1-bits are",
                "shifted out of position 63; otherwise CA and CA32 are set to 0.",
                "A shift amount of zero causes RA to receive EXTS((RS)32:63), and",
                "CA and CA32 to be set to 0.",
                "Shift amounts from 32 to 63 give a result of 64 sign bits, and cause",
                "CA and CA32 to receive the sign bit of",
                "(RS)32:63.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Shift Left Doubleword",
                    "form": "X",
                    "mnemonic": "sld",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Shift Left Doubleword",
                    "form": "X",
                    "mnemonic": "sld.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "27",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>58:63</sub>",
                "r := ROTL<sub>64</sub>((RS), n)",
                "if (RB)<sub>57</sub> = 0 then",
                "    m := MASK(0, 63-n)",
                "else m := <sup>64</sup>0",
                "RA := r & m"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are shifted left the number",
                "of bits specified by (RB)57:63. Bits shifted out of position 0 are lost.",
                "Zeros are supplied to the vacated positions on the right.",
                "The result is placed into register RA.",
                "Shift amounts from 64 to 127 give a zero result.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Shift Right Algebraic Doubleword Immediate",
                    "form": "XS",
                    "mnemonic": "sradi",
                    "operands": [
                        "RA",
                        "RS",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Shift Right Algebraic Doubleword Immediate",
                    "form": "XS",
                    "mnemonic": "sradi.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "sh1",
                    "size": "5"
                },
                {
                    "name": "413",
                    "size": "9"
                },
                {
                    "name": "sh0",
                    "size": "1"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r := ROTL<sub>64</sub>((RS), 64-n)",
                "m := MASK(n, 63)",
                "s := (RS)<sub>0</sub>",
                "RA := r&m | (<sup>64</sup>s) & ~m",
                "carry := s & ((r & ~m) != 0)",
                "CA    := carry",
                "CA32  := carry"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are shifted right SH bits. Bits shifted out of position 63 are lost.",
                "Bit 0 of RS is replicated to fill the vacated positions",
                "on the left. The result is placed into register RA.",
                "CA and CA32 are set to 1 if (RS)",
                "is negative and any 1-bits are shifted out of position 63; otherwise",
                "CA and CA32 are set to 0.",
                "A shift amount of zero causes RA to be set equal to",
                "(RS), and CA and CA32 to be set",
                "to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Shift Right Doubleword",
                    "form": "X",
                    "mnemonic": "srd",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Shift Right Doubleword",
                    "form": "X",
                    "mnemonic": "srd.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "539",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>58:63</sub>",
                "r := ROTL<sub>64</sub>((RS), 64-n)",
                "if (RB)<sub>57</sub> = 0 then",
                "   m := MASK(n, 63)",
                "else m := <sup>64</sup>0",
                "RA := r & m"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are shifted right the number",
                "of bits specified by (RB)57:63. Bits shifted out of position 63 are lost.",
                "Zeros are supplied to the vacated positions on the left.",
                "The result is placed into register RA.",
                "Shift amounts from 64 to 127 give a zero result.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Shift Right Algebraic Doubleword",
                    "form": "X",
                    "mnemonic": "srad",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Shift Right Algebraic Doubleword",
                    "form": "X",
                    "mnemonic": "srad.",
                    "operands": [
                        "RA",
                        "RS",
                        "RB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "794",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n := (RB)<sub>58:63</sub>",
                "r := ROTL<sub>64</sub>((RS), 64-n)",
                "if (RB)<sub>57</sub> = 0 then",
                "   m := MASK(n, 63)",
                "else m := <sup>64</sup>0",
                "s := (RS)<sub>0</sub>",
                "RA := r&m | (<sup>64</sup>s) & ~m",
                "carry := s & ((r & ~m) != 0)",
                "CA    := carry",
                "CA32  := carry"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are shifted right the number",
                "of bits specified by (RB)57:63. Bits shifted out of position 63 are lost.",
                "Bit 0 of RS is replicated to fill the vacated positions",
                "on the left. The result is placed into register RA.",
                "CA and CA32 are set to 1 if (RS)",
                "is negative and any 1-bits are shifted out of position 63; otherwise",
                "CA and CA32 are set to 0.",
                "A shift amount of zero causes RA to be set equal to",
                "(RS), and CA and CA32 to be set",
                "to 0.",
                "Shift amounts from 64 to 127 give a result of 64 sign bits in",
                "RA, and cause CA and CA32 to",
                "receive the sign bit of (RS).",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Extend Sign Word and Shift Left Immediate",
                    "form": "XS",
                    "mnemonic": "extswsli",
                    "operands": [
                        "RA",
                        "RS",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "Extend Sign Word and Shift Left Immediate",
                    "form": "XS",
                    "mnemonic": "extswsli.",
                    "operands": [
                        "RA",
                        "RS",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "sh1",
                    "size": "5"
                },
                {
                    "name": "445",
                    "size": "9"
                },
                {
                    "name": "sh0",
                    "size": "1"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "n  := sh<sub>5</sub> || sh<sub>0:4</sub>",
                "r  := ROTL64(EXTS64(RS<sub>32:63</sub>), n)",
                "m  := MASK(0, 63-n)",
                "RA := r & m"
            ],
            "body": [
                "",
                "",
                "The contents of the low order 32 bits of RS are",
                "sign-extended to 64 bits and then shifted left SH bits.",
                "Bits shifted out of bit 0 are lost.",
                "Zeros are supplied to vacated bits on the right.",
                "The result is placed in register RA.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Convert Declets To Binary Coded Decimal",
                    "form": "X",
                    "mnemonic": "cdtbcd",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "282",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "do i = 0 to 1",
                "  n := i * 32",
                "     RA<sub>n+0:n+7  </sub> := 0",
                "     RA<sub>n+8:n+19 </sub> := DPD_TO_BCD((RS)<sub>n+12:n+21</sub>)",
                "     RA<sub>n+20:n+31</sub> := DPD_TO_BCD((RS)<sub>n+22:n+31</sub>)"
            ],
            "body": [
                "",
                "",
                "The low-order 20 bits of each word of register RS contain",
                "two declets which are converted to six, 4-bit BCD fields; each set of",
                "six, 4-bit BCD fields is placed into the low-order 24 bits of the",
                "corresponding word in RA.",
                "The high-order 8 bits in each word of RA are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Convert Binary Coded Decimal To Declets",
                    "form": "X",
                    "mnemonic": "cbcdtd",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "314",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "do i = 0 to 1",
                "  n := i * 32",
                "     RA<sub>n+0:n+11 </sub> := 0",
                "     RA<sub>n+12:n+21</sub> := BCD_TO_DPD((RS)<sub>n+8:n+19</sub>)",
                "     RA<sub>n+22:n+31</sub> := BCD_TO_DPD((RS)<sub>n+20:n+31</sub>)"
            ],
            "body": [
                "",
                "",
                "The low-order 24 bits of each word of register RS contain",
                "six, 4-bit BCD fields which are converted to two declets; each set of",
                "two declets is placed into the low-order 20 bits of the corresponding",
                "word in RA.",
                "The high-order 12 bits in each word of RA are set to 0.",
                "",
                "If a 4-bit BCD field has a value greater than 9 the results are",
                "undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Add and Generate Sixes",
                    "form": "XO",
                    "mnemonic": "addg6s",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "74",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "do i = 0 to 15",
                "  dc<sub>i</sub> := carry_out(RA<sub>4i:63</sub> + RB<sub>4i:63</sub>)",
                "c := <sup>4</sup>(dc<sub>0</sub>) || <sup>4</sup>(dc<sub>1</sub>) || ... || <sup>4</sup>(dc<sub>15</sub>)",
                "RT := (~c) & 0x6666_6666_6666_6666"
            ],
            "body": [
                "",
                "",
                "The contents of register RA are added to the contents of",
                "register RB.",
                "Sixteen carry bits are produced, one for each carry out of decimal",
                "position n (bit position 4n).",
                "",
                "A doubleword is composed from the 16 carry bits, and placed into",
                "RT.",
                "The doubleword consists of a decimal six (0b0110) in",
                "every decimal digit position for which the corresponding carry bit is",
                "0, and a zero (0b0000) in every position for which the",
                "corresponding carry bit is 1.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Byte-Reverse Halfword",
                    "form": "X",
                    "mnemonic": "brh",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "219",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS)<sub>8:15 </sub> || (RS)<sub>0:7  </sub> ||",
                "     (RS)<sub>24:31</sub> || (RS)<sub>16:23</sub> ||",
                "     (RS)<sub>40:47</sub> || (RS)<sub>32:39</sub> ||",
                "     (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub>"
            ],
            "body": [
                "",
                "",
                "The contents of bits 0:15 of register RS are placed into",
                "bits 0:15 of register RA in byte-reversed order.",
                "",
                "The contents of bits 16:31 of register RS are placed into",
                "bits 16:31 of register RA in byte-reversed order.",
                "",
                "The contents of bits 32:47 of register RS are placed into",
                "bits 32:47 of register RA in byte-reversed order.",
                "",
                "The contents of bits 48:63 of register RS are placed into",
                "bits 48:63 of register RA in byte-reversed order.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Byte-Reverse Word",
                    "form": "X",
                    "mnemonic": "brw",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "155",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS)<sub>24:31</sub> || (RS)<sub>16:23</sub> || (RS)<sub>8:15 </sub> || (RS)<sub>0:7  </sub> ||",
                "     (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub> || (RS)<sub>40:47</sub> || (RS)<sub>32:39</sub>"
            ],
            "body": [
                "",
                "",
                "The contents of bits 0:31 of register RS are placed into",
                "bits 0:31 of register RA in byte-reversed order.",
                "",
                "The contents of bits 32:63 of register RS are placed into",
                "bits 32:63 of register RA in byte-reversed order.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Byte-Reverse Doubleword",
                    "form": "X",
                    "mnemonic": "brd",
                    "operands": [
                        "RA",
                        "RS"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "187",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RA := (RS)<sub>56:63</sub> || (RS)<sub>48:55</sub> || (RS)<sub>40:47</sub> || (RS)<sub>32:39 </sub>||",
                "     (RS)<sub>24:31</sub> || (RS)<sub>16:23</sub> || (RS)<sub>8:15 </sub> || (RS)<sub>0:7</sub>"
            ],
            "body": [
                "",
                "",
                "The contents of register RS are placed into register",
                "RA in byte-reversed order.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Hash Store",
                    "form": "X",
                    "mnemonic": "hashst",
                    "operands": [
                        "RB",
                        "offset(RA)"
                    ],
                    "conditions": [],
                    "release": "v3.1B"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "D",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "722",
                    "size": "10"
                },
                {
                    "name": "DX",
                    "size": "1"
                }
            ],
            "code": [
                "DW := 32*DX + D",
                "d := EXTS(0b111_1111 || DW || 0b000)",
                "EA := (RA) + d",
                "temp := HashDigest((RA), (RB), HASHKEYR)",
                "MEM(EA, 8) := temp",
                ""
            ],
            "body": [
                "",
                "Let DW be the value 32DX + D.",
                "The offset is  (0b1111111 || DW || 0b000) sign extended to 64 bits.",
                "Let the effective address (EA) be the sum (RA) + offset.",
                "The doubleword hash value computed from the contents of RA, RB, and",
                "the privileged SPR HASHKEYR, as specified by the HashDigest function",
                "described in",
                "Section of Book I,",
                "is stored into the doubleword in storage addressed by EA.",
                "",
                "EA must be a multiple of 8.",
                "If it is not, either the system alignment error handler is invoked or",
                "the results are boundedly undefined.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Hash Check",
                    "form": "X",
                    "mnemonic": "hashchk",
                    "operands": [
                        "RB",
                        "offset(RA)"
                    ],
                    "conditions": [],
                    "release": "v3.1B"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "D",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "754",
                    "size": "10"
                },
                {
                    "name": "DX",
                    "size": "1"
                }
            ],
            "code": [
                "DW := 32*DX + D",
                "d := EXTS(0b111_1111 || DW || 0b000)",
                "EA := (RA) + d",
                "temp := HashDigest((RA), (RB), HASHKEYR)",
                "temp1 := MEM(EA, 8)",
                "if (temp != temp1) then TRAP"
            ],
            "body": [
                "",
                "Let DW be the value 32DX + D.",
                "The offset is (0b1111111 || DW || 0b000) sign extended to 64 bits.",
                "Let the effective address (EA) be the sum (RA) + offset.",
                "The doubleword in storage addressed by EA is read and compared with",
                "the doubleword hash value computed from the contents of RA, RB, and",
                "the privileged SPR HASHKEYR, as specified by the HashDigest function",
                "described in",
                "Section of Book I.",
                "If the values are unequal, the system trap handler is invoked.",
                "",
                "This instruction is treated as a Load; see",
                "Section",
                "of Book II.",
                "",
                "If the values are unequal, this instruction is context synchronizing",
                "(see Book III).",
                "",
                "EA must be a multiple of 8.",
                "If it is not, either the system alignment error handler is invoked or",
                "the results are boundedly undefined.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move From VSR Doubleword",
                    "form": "X",
                    "mnemonic": "mfvsrd",
                    "operands": [
                        "RA",
                        "XS"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "51",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 & MSR.FP=0 then FP_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "GPR[RA] := VSR[32*SX+S].dword[0]"
            ],
            "body": [
                "",
                "",
                "Let XS be the value 32SX + S.",
                "",
                "The contents of doubleword element 0 of VSR[XS] are",
                "placed into GPR[RA].",
                "",
                "For SX=0, mfvsrd is treated as a",
                "Floating-Point instruction in terms of resource",
                "availability.",
                "",
                "For SX=1, mfvsrd is treated as a",
                "Vector instruction in terms of resource availability.",
                "",
                "Extended Mnemonics:",
                "",
                "Extended mnemonics for Move From VSR Doubleword:",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_div",
                "vec_extract"
            ]
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move From VSR Lower Doubleword",
                    "form": "X",
                    "mnemonic": "mfvsrld",
                    "operands": [
                        "RA",
                        "XS"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "307",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "GPR[RA] := VSR[32*SX+S].dword[1]"
            ],
            "body": [
                "",
                "",
                "Let XS be the value 32SX + S.",
                "",
                "The contents of doubleword 1 of VSR[XS] are placed into",
                "GPR[RA].",
                "",
                "For SX=0, mfvsrld is treated as a",
                "VSX instruction in terms of resource availability.",
                "",
                "For SX=1, mfvsrld is treated as a",
                "Vector instruction in terms of resource availability.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move From VSR Word and Zero",
                    "form": "X",
                    "mnemonic": "mfvsrwz",
                    "operands": [
                        "RA",
                        "XS"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "115",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 & MSR.FP=0 then FP_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "GPR[RA] := EXTZ64(VSR[32*SX+S].word[1])"
            ],
            "body": [
                "",
                "",
                "Let XS be the value 32SX + S.",
                "",
                "The contents of word element 1 of VSR[XS] are placed into",
                "bits 32:63 of GPR[RA].",
                "The contents of bits 0:31 of GPR[RA] are set to 0.",
                "",
                "For SX=0, mfvsrwz is treated as a",
                "Floating-Point instruction in terms of resource",
                "availability.",
                "",
                "For SX=1, mfvsrwz is treated as a",
                "Vector instruction in terms of resource availability.",
                "",
                "Extended Mnemonics:",
                "",
                "Extended mnemonics for Move To VSR Word and Zero:",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move To VSR Doubleword",
                    "form": "X",
                    "mnemonic": "mtvsrd",
                    "operands": [
                        "XT",
                        "RA"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "179",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 & MSR.FP=0 then FP_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[32*TX+T].dword[0] := GPR[RA]",
                "VSR[32*TX+T].dword[1] := 0xUUUU_UUUU_UUUU_UUUU"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "The contents of GPR[RA] are placed into doubleword",
                "element 0 of VSR[XT].",
                "",
                "The contents of doubleword element 1 of VSR[XT] are",
                "undefined.",
                "",
                "For TX=0, mtvsrd is treated as a",
                "Floating-Point instruction in terms of resource",
                "availability.",
                "",
                "For TX=1, mtvsrd is treated as a",
                "Vector instruction in terms of resource availability.",
                "",
                "Extended Mnemonics:",
                "",
                "Extended mnemonics for Move To VSR Doubleword:",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_div",
                "vec_insert",
                "vec_splats"
            ]
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move To VSR Word Algebraic",
                    "form": "X",
                    "mnemonic": "mtvsrwa",
                    "operands": [
                        "XT",
                        "RA"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "211",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 & MSR.FP=0 then FP_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[32*TX+T].dword[0] := EXTS64(GPR[RA].bit[32:63])",
                "VSR[32*TX+T].dword[1] := 0xUUUU_UUUU_UUUU_UUUU"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "The two\u00e2\u20ac\u2122s-complement integer in bits 32:63 of GPR[RA] is",
                "sign-extended to 64 bits and placed into doubleword element 0 of",
                "VSR[XT].",
                "",
                "The contents of doubleword element 1 of VSR[XT] are",
                "undefined.",
                "",
                "For TX=0, mtvsrwa is treated as a",
                "Floating-Point instruction in terms of resource",
                "availability.",
                "",
                "For TX=1, mtvsrwa is treated as a",
                "Vector instruction in terms of resource availability.",
                "",
                "Extended Mnemonics:",
                "",
                "Extended mnemonics for Move To VSR Word Algebraic:",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move To VSR Word and Zero",
                    "form": "X",
                    "mnemonic": "mtvsrwz",
                    "operands": [
                        "XT",
                        "RA"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "243",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 & MSR.FP=0 then FP_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[32*TX+T].dword[0] := EXTZ64(GPR[RA].word[1])",
                "VSR[32*TX+T].dword[1] := 0xUUUU_UUUU_UUUU_UUUU"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "The contents of bits 32:63 of GPR[RA] are placed into",
                "word element 1 of VSR[XT].",
                "The contents of word element 0 of VSR[XT] are set to 0.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are",
                "undefined.",
                "",
                "For TX=0, mtvsrwz is treated as a",
                "Floating-Point instruction in terms of resource",
                "availability.",
                "",
                "For TX=1, mtvsrwz is treated as a",
                "Vector instruction in terms of resource availability.",
                "",
                "Extended Mnemonics:",
                "",
                "Extended mnemonics for Move To VSR Word and Zero:",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_insert",
                "vec_splats"
            ]
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move To VSR Double Doubleword",
                    "form": "X",
                    "mnemonic": "mtvsrdd",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "435",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if RA=0 then",
                "  VSR[32*TX+T].dword[0] := 0x0000_0000_0000_0000",
                "else",
                "  VSR[32*TX+T].dword[0] := GPR[RA]",
                "",
                "VSR[32*TX+T].dword[1] := GPR[RB]"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "The contents of GPR[RA], or the value 0 if RA=0, are placed into doubleword 0 of  VSR[XT].",
                "",
                "The contents of GPR[RB] are placed into doubleword 1 of",
                "VSR[XT].",
                "",
                "For TX=0, mtvsrdd is treated as a",
                "VSX instruction in terms of resource availability.",
                "",
                "For TX=1, mtvsrdd is treated as a",
                "Vector instruction in terms of resource availability.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract"
            ]
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move To VSR Word  Splat",
                    "form": "X",
                    "mnemonic": "mtvsrws",
                    "operands": [
                        "XT",
                        "RA"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "403",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[32*TX+T].word[0] := GPR[RA].bit[32:63]",
                "VSR[32*TX+T].word[1] := GPR[RA].bit[32:63]",
                "VSR[32*TX+T].word[2] := GPR[RA].bit[32:63]",
                "VSR[32*TX+T].word[3] := GPR[RA].bit[32:63]"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "The contents of bits 32:63 of GPR[RA] are placed into",
                "each word element of  VSR[XT].",
                "",
                "For TX=0, mtvsrws is treated as a",
                "VSX instruction in terms of resource availability.",
                "",
                "For TX=1, mtvsrws is treated as a",
                "Vector instruction in terms of resource availability.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move To Special Purpose Register",
                    "form": "XFX",
                    "mnemonic": "mtspr",
                    "operands": [
                        "SPR",
                        "RS"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "spr1",
                    "size": "5"
                },
                {
                    "name": "spr0",
                    "size": "5"
                },
                {
                    "name": "467",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "n := spr<sub>5:9</sub> || spr<sub>0:4</sub>",
                "switch (n)",
                "  case(13): see Book III",
                "  case(808, 809, 810, 811):",
                "  default:",
                "     if length(SPR(n)) = 64 then",
                "        SPR(n) := (RS)",
                "     else",
                "        SPR(n) := (RS)<sub>32:63</sub>"
            ],
            "body": [
                "",
                "",
                "The SPR field denotes a Special Purpose Register, encoded as shown in",
                "the table below.",
                "If the SPR field contains a value from 808 through 811, the",
                "instruction specifies a reserved SPR, and is treated as a no-op;  see",
                "Section, Reserved",
                "Fields, Reserved Values, and Reserved SPRs.",
                "Otherwise, unless the SPR field contains 13 (denoting the AMR), the contents of register RS are placed into the",
                "designated Special Purpose Register.",
                "For Special Purpose Registers that are 32 bits long, the low-order 32",
                "bits of RS are placed into the SPR.",
                "",
                "The AMR (Authority Mask Register) is used for storage protection.",
                "This use, and operation of mtspr for the AMR, are",
                "described in Book III.",
                "",
                "",
                "",
                "",
                "If execution of this instruction is attempted specifying an SPR",
                "number that is not shown above, one of the following occurs.",
                "",
                "",
                "",
                "A complete description of this instruction can be found in Book III.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move From Special Purpose Register",
                    "form": "XFX",
                    "mnemonic": "mfspr",
                    "operands": [
                        "RT",
                        "SPR"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "spr1",
                    "size": "5"
                },
                {
                    "name": "spr0",
                    "size": "5"
                },
                {
                    "name": "339",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "n := spr<sub>5:9</sub> || spr<sub>0:4</sub>",
                "switch (n)",
                "  case(808, 809, 810, 811):",
                "  default:",
                "     if length(SPR(n)) = 64 then",
                "        RT := SPR(n)",
                "     else",
                "        RT := <sup>32</sup>0 || SPR(n)"
            ],
            "body": [
                "",
                "",
                "The SPR field denotes a Special Purpose Register, encoded as shown in",
                "the table below.",
                "If the SPR field contains a value from 808 through 811, the",
                "instruction specifies a reserved SPR, and is treated as a no-op; see",
                "Section, Reserved",
                "Fields, Reserved Values, and Reserved SPRs.",
                "Otherwise, the contents of the designated Special Purpose Register",
                "are placed into register RT.",
                "For Special Purpose Registers that are 32 bits long, the low-order 32",
                "bits of RT receive the contents of the Special Purpose",
                "Register and the high-order 32 bits of RT are set to zero.",
                "",
                "",
                "",
                "",
                "If execution of this instruction is attempted specifying an SPR",
                "number that is not shown above, one of the following occurs.",
                "",
                "",
                "",
                "A complete description of this instruction can be found in Book III.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move to CR from XER Extended",
                    "form": "X",
                    "mnemonic": "mcrxrx",
                    "operands": [
                        "BF"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "12"
                },
                {
                    "name": "576",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "CR<sub>4BF+32:4BF+35</sub> := XER<sub>OV OV32 CA CA32</sub>"
            ],
            "body": [
                "",
                "",
                "The contents of the OV, OV32, CA,",
                "and CA32 are copied to Condition Register field",
                "BF.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move To One Condition Register Field",
                    "form": "XFX",
                    "mnemonic": "mtocrf",
                    "operands": [
                        "FXM",
                        "RS"
                    ],
                    "conditions": [],
                    "release": "v2.01"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "1"
                },
                {
                    "name": "FXM",
                    "size": "8"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "144",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "count := 0",
                "do i = 0 to 7",
                "  if FXM<sub>i</sub> = 1 then",
                "     n := i",
                "  count := count + 1",
                "if count = 1 then",
                "  CR<sub>4n+32:4n+35</sub> := (RS)<sub>4n+32:4n+35</sub>",
                "else",
                "  CR := undefined"
            ],
            "body": [
                "",
                "",
                "If exactly one bit of the FXM field is set to 1, let",
                "n be the position of that bit in the field (0 ",
                "n  7).",
                "The contents of bits 4n+32:4n+35 of register RS are",
                "placed into CR field n (CR bits 4n+32:4n+35).",
                "Otherwise, the contents of the Condition Register are undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move To Condition Register Fields",
                    "form": "XFX",
                    "mnemonic": "mtcrf",
                    "operands": [
                        "FXM",
                        "RS"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "1"
                },
                {
                    "name": "FXM",
                    "size": "8"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "144",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "mask := <sup>4</sup>(FXM<sub>0</sub>) || <sup>4</sup>(FXM<sub>1</sub>) || ... <sup>4</sup>(FXM<sub>7</sub>)",
                "CR := ((RS)<sub>32:63</sub> & mask) | (CR & ~mask)"
            ],
            "body": [
                "",
                "",
                "The contents of bits 32:63 of register RS are placed into",
                "the Condition Register under control of the field mask specified by",
                "FXM. The field mask identifies the 4-bit fields affected.",
                "Let i be an integer in the range 0-7.",
                "If FXMi=1",
                "then CR field i (CR bits 4i+32:4i+35) is set to",
                "the contents of the corresponding field of the low-order 32 bits of",
                "RS.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move From One Condition Register Field",
                    "form": "XFX",
                    "mnemonic": "mfocrf",
                    "operands": [
                        "RT",
                        "FXM"
                    ],
                    "conditions": [],
                    "release": "v2.01"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "1"
                },
                {
                    "name": "FXM",
                    "size": "8"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "19",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RT := undefined",
                "count := 0",
                "do i = 0 to 7",
                "  if FXM<sub>i</sub> = 1 then",
                "     n := i",
                "     count := count + 1",
                "if count = 1 then",
                "  RT := <sup>64</sup>0",
                "  RT<sub>4n+32:4n+35</sub> := CR<sub>4n+32:4n+35</sub>"
            ],
            "body": [
                "",
                "",
                "If exactly one bit of the FXM field is set to 1, let n be",
                "the position of that bit in the field (0  n  7).",
                "The contents of CR field n (CR bits 4*n+32:4*n+35) are placed into bits 4n+32:4n+35",
                "of register RT, and the contents of the remaining bits of",
                "register RT are undefined.",
                "Otherwise, the contents of register RT are undefined.",
                "",
                "If exactly one bit of the FXM field is set to 1, the",
                "contents of the remaining bits of register RT are set to",
                "0's instead of being undefined as specified above.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_all_eq",
                "vec_all_ge",
                "vec_all_gt",
                "vec_all_in",
                "vec_all_le",
                "vec_all_lt",
                "vec_all_nan",
                "vec_all_ne",
                "vec_all_nge",
                "vec_all_ngt",
                "vec_all_nle",
                "vec_all_nlt",
                "vec_all_numeric",
                "vec_any_eq",
                "vec_any_ge",
                "vec_any_gt",
                "vec_any_le",
                "vec_any_lt",
                "vec_any_nan",
                "vec_any_ne",
                "vec_any_nge",
                "vec_any_ngt",
                "vec_any_nle",
                "vec_any_nlt",
                "vec_any_numeric",
                "vec_any_out"
            ]
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move From Condition Register",
                    "form": "XFX",
                    "mnemonic": "mfcr",
                    "operands": [
                        "RT"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "9"
                },
                {
                    "name": "19",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "  RT := <sup>32</sup>0 || CR"
            ],
            "body": [
                "",
                "",
                "The contents of the Condition Register are placed into RT32:63.",
                "RT0:31 are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Set Boolean",
                    "form": "X",
                    "mnemonic": "setb",
                    "operands": [
                        "RT",
                        "BFA"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "BFA",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "7"
                },
                {
                    "name": "128",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if CR<sub>4BFA+32</sub>=1 then",
                "  RT := 0xFFFF_FFFF_FFFF_FFFF",
                "",
                "else if CR<sub>4BFA+33</sub>=1 then",
                "  RT := 0x0000_0000_0000_0001",
                "",
                "else",
                "  RT := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "If the contents of bit 0 of CR field BFA are",
                "equal to 0b1, the contents of register RT are",
                "set to 0xFFFF_FFFF_FFFF_FFFF.",
                "",
                "Otherwise, if the contents of bit 1 of CR field",
                "BFA are equal to 0b1, the contents of",
                "register RT are set to 0x0000_0000_0000_0001.",
                "",
                "Otherwise, the contents of register RT are set to",
                "0x0000_0000_0000_0000.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Set Boolean Condition",
                    "form": "X",
                    "mnemonic": "setbc",
                    "operands": [
                        "RT",
                        "BI"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "BI",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "384",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RT = (CR<sub>BI</sub>=1) ?  1 :  0"
            ],
            "body": [
                "",
                "",
                "If bit BI of the CR contains a 1, register RT",
                "is set to 1. Otherwise, register RT is set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Set Boolean Condition Reverse",
                    "form": "X",
                    "mnemonic": "setbcr",
                    "operands": [
                        "RT",
                        "BI"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "BI",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "416",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RT = (CR<sub>BI</sub>=1) ?  0 :  1"
            ],
            "body": [
                "",
                "",
                "If bit BI of the CR contains a 1, register RT",
                "is set to 0. Otherwise, register RT is set to 1.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Set Negative Boolean Condition",
                    "form": "X",
                    "mnemonic": "setnbc",
                    "operands": [
                        "RT",
                        "BI"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "BI",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "448",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RT = (CR<sub>BI</sub>=1) ? -1 :  0"
            ],
            "body": [
                "",
                "",
                "If bit BI of the CR contains a 1, register RT",
                "is set to -1. Otherwise, register RT is set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Set Negative Boolean Condition Reverse",
                    "form": "X",
                    "mnemonic": "setnbcr",
                    "operands": [
                        "RT",
                        "BI"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "BI",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "480",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RT = (CR<sub>BI</sub>=1) ?  0 : -1"
            ],
            "body": [
                "",
                "",
                "If bit BI of the CR contains a 1, register RT",
                "is set to 0. Otherwise, register RT is set to -1.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Prefixed Nop",
                    "form": "MRR:*",
                    "mnemonic": "pnop",
                    "operands": [],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "112",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "0",
                    "size": "18"
                },
                {
                    "name": "?",
                    "size": "32"
                }
            ],
            "code": [],
            "body": [
                "",
                "No operation is performed.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Floating-Point Single",
                    "form": "D",
                    "mnemonic": "lfs",
                    "operands": [
                        "FRT",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                },
                {
                    "name": "Prefixed Load Floating-Point Single",
                    "form": "MLS:D",
                    "mnemonic": "plfs",
                    "operands": [
                        "FRT",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "12",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "48",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"lfs\"  then",
                "  EA := (RA|0) + EXTS64(D)",
                "if \"plfs\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"plfs\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "FRT := DOUBLE(MEM(EA, 4))"
            ],
            "body": [
                "",
                "",
                "For lfs, let the effective address (EA) be the sum of the contents of register RA, or the",
                "value 0 if RA=0, and the value D,",
                "sign-extended to 64 bits.",
                "",
                "For plfs with R=0, let the effective",
                "address (EA) be the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For plfs with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "The word in storage addressed by EA is interpreted as a",
                "floating-point single-precision operand.",
                "This word is converted to floating-point double format (see",
                "pagePPC1ChFloatPt-ldsgl) and placed into register",
                "FRT.",
                "",
                "For plfs, if R is equal to 1 and RA is not equal to 0, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Floating-Point Single Indexed",
                    "form": "X",
                    "mnemonic": "lfsx",
                    "operands": [
                        "FRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "535",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "FRT := DOUBLE(MEM(EA, 4))"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "The word in storage addressed by EA is interpreted as a",
                "floating-point single-precision operand.",
                "This word is converted to floating-point double format (see",
                "pagePPC1ChFloatPt-ldsgl) and placed into register",
                "FRT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Floating-Point Single with Update",
                    "form": "D",
                    "mnemonic": "lfsu",
                    "operands": [
                        "FRT",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "49",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "FRT := DOUBLE(MEM(EA, 4))",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+D.",
                "",
                "The word in storage addressed by EA is interpreted as a",
                "floating-point single-precision operand.",
                "This word is converted to floating-point double format (see",
                "pagePPC1ChFloatPt-ldsgl) and placed into register",
                "FRT.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Floating-Point Single with Update Indexed",
                    "form": "X",
                    "mnemonic": "lfsux",
                    "operands": [
                        "FRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "567",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "FRT := DOUBLE(MEM(EA, 4))",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+(RB).",
                "",
                "The word in storage addressed by EA is interpreted as a",
                "floating-point single-precision operand.",
                "This word is converted to floating-point double format (see",
                "pagePPC1ChFloatPt-ldsgl) and placed into register",
                "FRT.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Floating-Point Double",
                    "form": "D",
                    "mnemonic": "lfd",
                    "operands": [
                        "FRT",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                },
                {
                    "name": "Prefixed Load Floating-Point Double",
                    "form": "MLS:D",
                    "mnemonic": "plfd",
                    "operands": [
                        "FRT",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "12",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "50",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"lfd\"  then",
                "  EA := (RA|0) + EXTS64(D)",
                "if \"plfd\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"plfd\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "FRT := MEM(EA, 8)"
            ],
            "body": [
                "",
                "",
                "For lfd, let the effective address (EA) be the sum of the contents of register RA, or the",
                "value 0 if RA=0, and the value D,",
                "sign-extended to 64 bits.",
                "",
                "For plfd with R=0, let the effective",
                "address (EA) be the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For plfd with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "The doubleword in storage addressed by EA is",
                "loaded into register FRT.",
                "",
                "For plfd, if R is equal to 1 and RA is not equal to 0, the instruction form is",
                "invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Floating-Point Double Indexed",
                    "form": "X",
                    "mnemonic": "lfdx",
                    "operands": [
                        "FRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "599",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "FRT := MEM(EA, 8)"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "The doubleword in storage addressed by EA is loaded into register",
                "FRT.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Floating-Point Double with Update",
                    "form": "D",
                    "mnemonic": "lfdu",
                    "operands": [
                        "FRT",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "51",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "FRT := MEM(EA, 8)",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+D.",
                "",
                "The doubleword in storage addressed by EA is loaded into",
                "register FRT.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Floating-Point Double with Update Indexed",
                    "form": "X",
                    "mnemonic": "lfdux",
                    "operands": [
                        "FRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "631",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "FRT := MEM(EA, 8)",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+(RB).",
                "",
                "The doubleword in storage addressed by EA is loaded into",
                "register FRT.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Floating-Point as Integer Word Algebraic Indexed",
                    "form": "X",
                    "mnemonic": "lfiwax",
                    "operands": [
                        "FRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "855",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "FRT := EXTS(MEM(EA, 4))"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "The word in storage addressed by EA is loaded into",
                "FRT.",
                "FRT are filled with",
                "a copy of bit 0 of the loaded word.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Floating-Point as Integer Word  Zero Indexed",
                    "form": "X",
                    "mnemonic": "lfiwzx",
                    "operands": [
                        "FRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "887",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "FRT := <sup>32</sup>0 || MEM(EA, 4)"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "The word in storage addressed by EA is loaded into",
                "FRT.",
                "FRT are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Floating-Point Single",
                    "form": "D",
                    "mnemonic": "stfs",
                    "operands": [
                        "FRS",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                },
                {
                    "name": "Prefixed Store Floating-Point Single",
                    "form": "MLS:D",
                    "mnemonic": "pstfs",
                    "operands": [
                        "FRS",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "12",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "52",
                    "size": "6"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"stfs\"  then",
                "  EA := (RA|0) + EXTS64(D)",
                "if \"pstfs\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"pstfs\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 4) := SINGLE((FRS))"
            ],
            "body": [
                "",
                "",
                "For stfs, let the effective address (EA) be the sum of the contents of register RA, or the",
                "value 0 if RA=0, and the value D,",
                "sign-extended to 64 bits.",
                "",
                "For pstfs with R=0, let the effective",
                "address (EA) be the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For pstfs with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "The contents of register FRS are converted to single",
                "format (see pagePPC1ChFloatPt-stsgl) and stored into the",
                "word in storage addressed by EA.",
                "",
                "For pstfs, if R is equal to",
                "1 and RA is not equal to 0, the instruction",
                "form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Floating-Point Single Indexed",
                    "form": "X",
                    "mnemonic": "stfsx",
                    "operands": [
                        "FRS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "663",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 4) := SINGLE((FRS))"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "The contents of register FRS are converted to single",
                "format (see pagePPC1ChFloatPt-stsgl) and stored into the",
                "word in storage addressed by EA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Floating-Point Single with Update",
                    "form": "D",
                    "mnemonic": "stfsu",
                    "operands": [
                        "FRS",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "53",
                    "size": "6"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 4) := SINGLE((FRS))",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+D.",
                "",
                "The contents of register FRS are converted to single",
                "format (see pagePPC1ChFloatPt-stsgl) and stored into the",
                "word in storage addressed by EA.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Floating-Point Single with Update Indexed",
                    "form": "X",
                    "mnemonic": "stfsux",
                    "operands": [
                        "FRS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "695",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 4) := SINGLE((FRS))",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+(RB).",
                "",
                "The contents of register FRS are converted to single",
                "format (see pagePPC1ChFloatPt-stsgl) and stored into the",
                "word in storage addressed by EA.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Floating-Point Double",
                    "form": "D",
                    "mnemonic": "stfd",
                    "operands": [
                        "FRS",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                },
                {
                    "name": "Prefixed Store Floating-Point Double",
                    "form": "MLS:D",
                    "mnemonic": "pstfd",
                    "operands": [
                        "FRS",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "12",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "54",
                    "size": "6"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"stfd\"  then",
                "  EA := (RA|0) + EXTS64(D)",
                "if \"pstfd\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"pstfd\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA, 8) := (FRS)"
            ],
            "body": [
                "",
                "",
                "For stfd, let the effective address (EA) be the sum of the contents of register RA, or the",
                "value 0 if RA=0, and the value D,",
                "sign-extended to 64 bits.",
                "",
                "For pstfd with R=0, let the effective",
                "address (EA) be the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For pstfd with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "The contents of register FRS are stored into the",
                "doubleword in storage addressed by EA.",
                "",
                "For pstfd, if R is equal to",
                "1 and RA is not equal to 0, the instruction",
                "form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Floating-Point Double Indexed",
                    "form": "X",
                    "mnemonic": "stfdx",
                    "operands": [
                        "FRS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "727",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 8) := (FRS)"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "The contents of register FRS are stored into the",
                "doubleword in storage addressed by EA.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Floating-Point Double with Update",
                    "form": "D",
                    "mnemonic": "stfdu",
                    "operands": [
                        "FRS",
                        "D(RA)"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "55",
                    "size": "6"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "D",
                    "size": "16"
                }
            ],
            "code": [
                "EA := (RA) + EXTS(D)",
                "MEM(EA, 8) := (FRS)",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+D.",
                "",
                "The contents of register FRS are stored into the",
                "doubleword in storage addressed by EA.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Floating-Point Double with Update Indexed",
                    "form": "X",
                    "mnemonic": "stfdux",
                    "operands": [
                        "FRS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "759",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "EA := (RA) + (RB)",
                "MEM(EA, 8) := (FRS)",
                "RA := EA"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA)+(RB).",
                "",
                "The contents of register FRS are stored into the",
                "doubleword in storage addressed by EA.",
                "",
                "EA is placed into register RA.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Floating-Point as Integer Word Indexed",
                    "form": "X",
                    "mnemonic": "stfiwx",
                    "operands": [
                        "FRS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "FRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "983",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 4) := (FRS)<sub>32:63</sub>"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "(FRS) are stored,",
                "without conversion, into the word in storage addressed by EA.",
                "",
                "If the contents of register FRS were produced, either",
                "directly or indirectly, by a Load Floating-Point Single",
                "instruction, a single-precision Arithmetic instruction, or",
                "frsp, then the value stored is undefined.",
                "(The contents of register FRS are produced directly by",
                "such an instruction if FRS is the target register for the",
                "instruction.",
                "The contents of register FRS are produced indirectly by",
                "such an instruction if FRS is the final target register",
                "of a sequence of one or more Floating-Point Move",
                "instructions, with the input to the sequence having been produced",
                "directly by such an instruction.)",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Floating-Point Double Pair",
                    "form": "DS",
                    "mnemonic": "lfdp",
                    "operands": [
                        "FRTp",
                        "DS(RA)"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "57",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DS",
                    "size": "14"
                },
                {
                    "name": "0",
                    "size": "2"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b :=(RA)",
                "EA := b + EXTS(DS||0b00)",
                "FRTp<sub>even</sub> := MEM(EA,8)",
                "FRTp<sub>odd </sub> := MEM(EA+8, 8)"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(DS||0b00).",
                "",
                "The doubleword in storage addressed by EA is placed into",
                "the even-numbered register of FRTp.",
                "",
                "The doubleword in storage addressed by EA+8 is placed",
                "into the odd-numbered register of FRTp.",
                "",
                "If FRTp is odd, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Floating-Point Double Pair Indexed",
                    "form": "X",
                    "mnemonic": "lfdpx",
                    "operands": [
                        "FRTp",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "791",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "FRTp<sub>even</sub> := MEM(EA,8)",
                "FRTp<sub>odd </sub> := MEM(EA+8, 8)"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "The doubleword in storage addressed by EA is placed into",
                "the even-numbered register of FRTp.",
                "",
                "The doubleword in storage addressed by EA+8 is placed",
                "into the odd-numbered register of FRTp.",
                "",
                "If FRTp is odd, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Floating-Point Double Pair",
                    "form": "DS",
                    "mnemonic": "stfdp",
                    "operands": [
                        "FRSp",
                        "DS(RA)"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "61",
                    "size": "6"
                },
                {
                    "name": "FRSp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "DS",
                    "size": "14"
                },
                {
                    "name": "0",
                    "size": "2"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + EXTS(DS||0b00)",
                "MEM(EA, 8)   := FRSp<sub>even</sub>",
                "MEM(EA+8, 8) := FRSp<sub>odd</sub>"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(DS||0b00).",
                "",
                "The contents of the even-numbered register of FRSp are",
                "stored into the doubleword in storage addressed by EA.",
                "",
                "The contents of the odd-numbered register of FRSp are",
                "stored into the doubleword in storage addressed by EA+8.",
                "",
                "If FRSp is odd, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Floating-Point Double Pair Indexed",
                    "form": "X",
                    "mnemonic": "stfdpx",
                    "operands": [
                        "FRSp",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "FRSp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "919",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 8)   := FRSp<sub>even</sub>",
                "MEM(EA+8, 8) := FRSp<sub>odd</sub>"
            ],
            "body": [
                "",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(DS||0b00).",
                "",
                "The contents of the even-numbered register of FRSp are",
                "stored into the doubleword in storage addressed by EA.",
                "",
                "The contents of the odd-numbered register of FRSp are",
                "stored into the doubleword in storage addressed by EA+8.",
                "",
                "If FRSp is odd, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Move Register",
                    "form": "X",
                    "mnemonic": "fmr",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Move Register",
                    "form": "X",
                    "mnemonic": "fmr.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "72",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The contents of register FRB are placed into register",
                "FRT.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Negate",
                    "form": "X",
                    "mnemonic": "fneg",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Negate",
                    "form": "X",
                    "mnemonic": "fneg.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "40",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The contents of register FRB with bit 0 inverted are",
                "placed into register FRT.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Absolute Value",
                    "form": "X",
                    "mnemonic": "fabs",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Absolute Value",
                    "form": "X",
                    "mnemonic": "fabs.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "264",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The contents of register FRB with bit 0 set to zero are",
                "placed into register FRT.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Negative Absolute Value",
                    "form": "X",
                    "mnemonic": "fnabs",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Negative Absolute Value",
                    "form": "X",
                    "mnemonic": "fnabs.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "136",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The contents of register FRB with bit 0 set to one are",
                "placed into register FRT.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Copy Sign",
                    "form": "X",
                    "mnemonic": "fcpsgn",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "Floating Copy Sign",
                    "form": "X",
                    "mnemonic": "fcpsgn.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "8",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The contents of register FRB with bit 0 set to the value",
                "of bit 0 of register FRA are placed into register",
                "FRT.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Merge Even Word",
                    "form": "X",
                    "mnemonic": "fmrgew",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "966",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.FP=0 then FP_Unavailable()",
                "FPR[FRT].word[0] := FPR[FRA].word[0]",
                "FPR[FRT].word[1] := FPR[FRB].word[0]"
            ],
            "body": [
                "",
                "",
                "The contents of word element 0 of FPR[FRA] are placed",
                "into word element 0 of FPR[FRT].",
                "",
                "The contents of word element 0 of FPR[FRB] are placed",
                "into word element 1 of FPR[FRT].",
                "",
                "fmrgew is treated as a Floating-Point",
                "instruction in terms of resource availability.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Merge Odd Word",
                    "form": "X",
                    "mnemonic": "fmrgow",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "838",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.FP=0 then FP_Unavailable()",
                "FPR[FRT].word[0] := FPR[FRA].word[1]",
                "FPR[FRT].word[1] := FPR[FRB].word[1]"
            ],
            "body": [
                "",
                "",
                "The contents of word element 1 of FPR[FRA] are placed",
                "into word element 0 of FPR[FRT].",
                "",
                "The contents of word element 1 of FPR[FRB] are placed",
                "into word element 1 of FPR[FRT].",
                "",
                "fmrgow is treated as a Floating-Point",
                "instruction in terms of resource availability.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Add",
                    "form": "A",
                    "mnemonic": "fadd",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Add",
                    "form": "A",
                    "mnemonic": "fadd.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Add Single",
                    "form": "A",
                    "mnemonic": "fadds",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Floating Add Single",
                    "form": "A",
                    "mnemonic": "fadds.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "21",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The floating-point operand in register FRA is added to",
                "the floating-point operand in register FRB.",
                "",
                "If the most significant bit of the resultant significand is not 1,",
                "the result is normalized.",
                "The result is rounded to the target precision under control of",
                "RN and placed into register FRT.",
                "",
                "Floating-point addition is based on exponent comparison and addition",
                "of the two significands.",
                "The exponents of the two operands are compared, and the significand",
                "accompanying the smaller exponent is shifted right, with its exponent",
                "increased by one for each bit shifted, until the two exponents are",
                "equal.",
                "The two significands are then added or subtracted as appropriate,",
                "depending on the signs of the operands, to form an intermediate sum.",
                "All 53 bits of the significand as well as all three guard bits",
                "(G, R, and X) enter into the",
                "computation.",
                "",
                "If a carry occurs, the sum\u00e2\u20ac\u2122s significand is shifted right one bit",
                "position and the exponent is increased by one.",
                "",
                "FPRF is set to the class and sign of the result, except",
                "for Invalid Operation Exceptions when VE=1.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Subtract",
                    "form": "A",
                    "mnemonic": "fsub",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Subtract",
                    "form": "A",
                    "mnemonic": "fsub.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Subtract Single",
                    "form": "A",
                    "mnemonic": "fsubs",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Floating Subtract Single",
                    "form": "A",
                    "mnemonic": "fsubs.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "20",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The floating-point operand in register FRB is subtracted",
                "from the floating-point operand in register FRA.",
                "",
                "If the most significant bit of the resultant significand is not 1,",
                "the result is normalized.",
                "The result is rounded to the target precision under control of",
                "RN and placed into register FRT.",
                "",
                "The execution of the Floating Subtract instruction is identical to",
                "that of Floating Add, except that the contents of FRB",
                "participate in the operation with the sign bit (bit 0) inverted.",
                "",
                "FPRF is set to the class and sign of the result, except",
                "for Invalid Operation Exceptions when VE=1.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Multiply",
                    "form": "A",
                    "mnemonic": "fmul",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Multiply",
                    "form": "A",
                    "mnemonic": "fmul.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Multiply Single",
                    "form": "A",
                    "mnemonic": "fmuls",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Floating Multiply Single",
                    "form": "A",
                    "mnemonic": "fmuls.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRC",
                    "size": "5"
                },
                {
                    "name": "25",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The floating-point operand in register FRA is multiplied",
                "by the floating-point operand in register FRC.",
                "",
                "If the most significant bit of the resultant significand is not 1,",
                "the result is normalized.",
                "The result is rounded to the target precision under control of",
                "RN and placed into register FRT.",
                "",
                "Floating-point multiplication is based on exponent addition and",
                "multiplication of the significands.",
                "",
                "FPRF is set to the class and sign of the result, except",
                "for Invalid Operation Exceptions when VE=1.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Divide",
                    "form": "A",
                    "mnemonic": "fdiv",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Divide",
                    "form": "A",
                    "mnemonic": "fdiv.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Divide Single",
                    "form": "A",
                    "mnemonic": "fdivs",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Floating Divide Single",
                    "form": "A",
                    "mnemonic": "fdivs.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "18",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The floating-point operand in register FRA is divided by",
                "the floating-point operand in register FRB.",
                "The remainder is not supplied as a result.",
                "",
                "If the most significant bit of the resultant significand is not 1,",
                "the result is normalized.",
                "The result is rounded to the target precision under control of",
                "RN and placed into register FRT.",
                "",
                "Floating-point division is based on exponent subtraction and division",
                "of the significands.",
                "",
                "FPRF is set to the class and sign of the result, except",
                "for Invalid Operation Exceptions when VE=1 and Zero",
                "Divide Exceptions when ZE=1.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Square Root",
                    "form": "A",
                    "mnemonic": "fsqrt",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P2"
                },
                {
                    "name": "Floating Square Root",
                    "form": "A",
                    "mnemonic": "fsqrt.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P2"
                },
                {
                    "name": "Floating Square Root Single",
                    "form": "A",
                    "mnemonic": "fsqrts",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Floating Square Root Single",
                    "form": "A",
                    "mnemonic": "fsqrts.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "22",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The square root of the floating-point operand in register FRB is placed into register FRT.",
                "",
                "If the most significant bit of the resultant significand is not 1,",
                "the result is normalized.",
                "The result is rounded to the target precision under control of",
                "RN and placed into register FRT.",
                "",
                "Operation with various special values of the operand is summarized",
                "below.",
                "",
                "",
                "",
                "",
                "FPSCR is set to the",
                "class and sign of the result, except for Invalid Operation Exceptions",
                "when FPSCR=1.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Reciprocal Estimate",
                    "form": "A",
                    "mnemonic": "fre",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.02"
                },
                {
                    "name": "Floating Reciprocal Estimate",
                    "form": "A",
                    "mnemonic": "fre.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.02"
                },
                {
                    "name": "Floating Reciprocal Estimate Single",
                    "form": "A",
                    "mnemonic": "fres",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Floating Reciprocal Estimate Single",
                    "form": "A",
                    "mnemonic": "fres.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "24",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "An estimate of the reciprocal of the floating-point operand in",
                "register FRB is placed into register FRT.",
                "Unless the reciprocal would be a zero, an infinity, the result of a",
                "trap-disabled Overflow exception, or a QNaN, the estimate is correct",
                "to a precision of one part in 256 of the reciprocal of (FRB), i.e.,",
                "",
                "where x is the initial value in FRB.",
                "",
                "Operation with various special values of the operand is summarized",
                "below.",
                "",
                "",
                "",
                "",
                "FPRF is set to the class and sign of the result, except",
                "for Invalid Operation Exceptions when VE=1 and Zero",
                "Divide Exceptions when ZE=1.",
                "",
                "The results of executing this instruction may vary between",
                "implementations, and between different executions on the same",
                "implementation.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Reciprocal Square Root Estimate",
                    "form": "A",
                    "mnemonic": "frsqrte",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Floating Reciprocal Square Root Estimate",
                    "form": "A",
                    "mnemonic": "frsqrte.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Floating Reciprocal Square Root Estimate Single",
                    "form": "A",
                    "mnemonic": "frsqrtes",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.02"
                },
                {
                    "name": "Floating Reciprocal Square Root Estimate Single",
                    "form": "A",
                    "mnemonic": "frsqrtes.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "26",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "A estimate of the reciprocal of the square root of the floating-point",
                "operand in register FRB is placed into register",
                "FRT.",
                "The estimate placed into register FRT is correct to a",
                "precision of one part in 32 of the reciprocal of the square root of",
                "(FRB), i.e.,",
                "",
                "where x is the initial value in FRB.",
                "",
                "Operation with various special values of the operand is summarized",
                "below.",
                "",
                "",
                "",
                "",
                "FPRF is set to the class and sign of the result, except",
                "for Invalid Operation Exceptions when VE=1 and Zero",
                "Divide Exceptions when ZE=1.",
                "",
                "The results of executing this instruction may vary between",
                "implementations, and between different executions on the same",
                "implementation.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Test for software Divide",
                    "form": "X",
                    "mnemonic": "ftdiv",
                    "operands": [
                        "BF",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "128",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let e_a be the unbiased exponent of the double-precision",
                "floating-point operand in register FRA.",
                "",
                "Let e_b be the unbiased exponent of the double-precision",
                "floating-point operand in register FRB.",
                "",
                "fe_flag is set to 1 if any of the following conditions",
                "occurs.",
                "",
                "",
                "",
                "Otherwise fe_flag is set to 0.",
                "",
                "fg_flag is set to 1 if either of the following",
                "conditions occurs.",
                "",
                "",
                "",
                "Otherwise fg_flag is set to 0.",
                "",
                "If the implementation guarantees a relative error of",
                "fre[s][.] of less",
                "than or equal to 2, then",
                "fl_flag is set to 1.",
                "Otherwise fl_flag is set to 0.",
                "",
                "CR field BF is set to the value fl_flag||fg_flag||fe_flag||0b0.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Test for software Square Root",
                    "form": "X",
                    "mnemonic": "ftsqrt",
                    "operands": [
                        "BF",
                        "FRB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "7"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "160",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let e_b be the unbiased exponent of the double-precision",
                "floating-point operand in register FRB.",
                "",
                "fe_flag is set to 1 if either of the following",
                "conditions occurs.",
                "",
                "",
                "",
                "Otherwise fe_flag is set to 0.",
                "",
                "fg_flag is set to 1 if the following condition occurs.",
                "",
                "",
                "",
                "Otherwise fg_flag is set to 0.",
                "",
                "If the implementation guarantees a relative error of",
                "frsqrte[s][.] of",
                "less than or equal to 2,",
                "then fl_flag is set to 1.",
                "Otherwise fl_flag is set to 0.",
                "",
                "CR field BF is set to the value fl_flag||fg_flag||fe_flag||0b0.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Multiply-Add",
                    "form": "A",
                    "mnemonic": "fmadd",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Multiply-Add",
                    "form": "A",
                    "mnemonic": "fmadd.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Multiply-Add Single",
                    "form": "A",
                    "mnemonic": "fmadds",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Floating Multiply-Add Single",
                    "form": "A",
                    "mnemonic": "fmadds.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "FRC",
                    "size": "5"
                },
                {
                    "name": "29",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The operation",
                "",
                "",
                "",
                "FRT  [(FRA)(FRC)] + (FRB)",
                "",
                "",
                "",
                "is performed.",
                "",
                "The floating-point operand in register FRA is multiplied",
                "by the floating-point operand in register FRC.",
                "The floating-point operand in register FRB is added to",
                "this intermediate result.",
                "",
                "If the most significant bit of the resultant significand is not 1,",
                "the result is normalized.",
                "The result is rounded to the target precision under control of",
                "RN and placed into register FRT.",
                "",
                "FPRF is set to the class and sign of the result, except",
                "for Invalid Operation Exceptions when VE=1.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Multiply-Subtract",
                    "form": "A",
                    "mnemonic": "fmsub",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Multiply-Subtract",
                    "form": "A",
                    "mnemonic": "fmsub.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Multiply-Subtract Single",
                    "form": "A",
                    "mnemonic": "fmsubs",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Floating Multiply-Subtract Single",
                    "form": "A",
                    "mnemonic": "fmsubs.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "FRC",
                    "size": "5"
                },
                {
                    "name": "28",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The operation",
                "",
                "",
                "",
                "FRT  [(FRA)(FRC)] - (FRB)",
                "",
                "",
                "",
                "is performed.",
                "",
                "The floating-point operand in register FRA is multiplied",
                "by the floating-point operand in register FRC.",
                "The floating-point operand in register FRB is subtracted",
                "from this intermediate result.",
                "",
                "If the most significant bit of the resultant significand is not 1,",
                "the result is normalized.",
                "The result is rounded to the target precision under control of",
                "RN and placed into register FRT.",
                "",
                "FPRF is set to the class and sign of the result, except",
                "for Invalid Operation Exceptions when VE=1.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Negative Multiply-Add",
                    "form": "A",
                    "mnemonic": "fnmadd",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Negative Multiply-Add",
                    "form": "A",
                    "mnemonic": "fnmadd.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Negative Multiply-Add Single",
                    "form": "A",
                    "mnemonic": "fnmadds",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Floating Negative Multiply-Add Single",
                    "form": "A",
                    "mnemonic": "fnmadds.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "FRC",
                    "size": "5"
                },
                {
                    "name": "31",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The operation",
                "",
                "",
                "",
                "FRT  - ( [(FRA)(FRC)] + (FRB) )",
                "",
                "",
                "",
                "is performed.",
                "",
                "The floating-point operand in register FRA is multiplied",
                "by the floating-point operand in register FRC.",
                "The floating-point operand in register FRB is added to",
                "this intermediate result.",
                "",
                "If the most significant bit of the resultant significand is not 1,",
                "the result is normalized.",
                "The result is rounded to the target precision under control of",
                "RN, then negated and placed into register FRT.",
                "",
                "This instruction produces the same result as would be obtained by",
                "using the Floating Multiply-Add instruction and then",
                "negating the result, with the following exceptions.",
                "",
                "",
                "",
                "FPRF is set to the class and sign of the result, except",
                "for Invalid Operation Exceptions when VE=1.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Negative Multiply-Subtract",
                    "form": "A",
                    "mnemonic": "fnmsub",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Negative Multiply-Subtract",
                    "form": "A",
                    "mnemonic": "fnmsub.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Negative Multiply-Subtract Single",
                    "form": "A",
                    "mnemonic": "fnmsubs",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Floating Negative Multiply-Subtract Single",
                    "form": "A",
                    "mnemonic": "fnmsubs.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "FRC",
                    "size": "5"
                },
                {
                    "name": "30",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The operation",
                "",
                "",
                "",
                "FRT  - ( [(FRA)(FRC)] - (FRB) )",
                "",
                "",
                "",
                "is performed.",
                "",
                "The floating-point operand in register FRA is multiplied",
                "by the floating-point operand in register FRC.",
                "The floating-point operand in register FRB is subtracted",
                "from this intermediate result.",
                "",
                "If the most significant bit of the resultant significand is not 1,",
                "the result is normalized.",
                "The result is rounded to the target precision under control of",
                "RN, then negated and placed into register FRT.",
                "",
                "This instruction produces the same result as would be obtained by",
                "using the Floating Multiply-Subtract instruction and then",
                "negating the result, with the following exceptions.",
                "",
                "",
                "",
                "FPRF is set to the class and sign of the result, except",
                "for Invalid Operation Exceptions when VE=1.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Round to Single-Precision",
                    "form": "X",
                    "mnemonic": "frsp",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Floating Round to Single-Precision",
                    "form": "X",
                    "mnemonic": "frsp.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "12",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The floating-point operand in register FRB is rounded to",
                "single-precision, using the rounding mode specified by RN, and placed into register FRT.",
                "",
                "The rounding is described fully in",
                "Section,",
                "Floating-Point Round to Single-Precision Model on",
                "pagesec:PPC1ApFPmodel-A-1-Floating-Point-Round-to-Single-Precision-Model.",
                "",
                "FPRF is set to the class and sign of the result, except",
                "for Invalid Operation Exceptions when VE=1.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Convert with round Double-Precision To Signed Doubleword format",
                    "form": "X",
                    "mnemonic": "fctid",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Floating Convert with round Double-Precision To Signed Doubleword format",
                    "form": "X",
                    "mnemonic": "fctid.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "814",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let src be the double-precision floating-point value in",
                "FRB.",
                "",
                "If src is a NaN, then the result is 0x8000_0000_0000_0000, VXCVI is set to 1, and, if",
                "src is an SNaN, VXSNAN is set to 1.",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode specified by RN.",
                "",
                "If the rounded value is greater than 2-1, then the result is",
                "0x7FFF_FFFF_FFFF_FFFF and VXCVI is set to",
                "1.",
                "",
                "Otherwise, if the rounded value is less than -2, then the result is 0x8000_0000_0000_0000 and VXCVI is set to 1.",
                "",
                "Otherwise, the result is the rounded value converted to 64-bit",
                "signed-integer format, and XX is set to 1 if the result",
                "is inexact.",
                "",
                "If an enabled Invalid Operation Exception does not occur, then the",
                "result is placed into FRT.",
                "",
                "The conversion is described fully in",
                "Section,",
                "Floating-Point Convert to Integer Model on",
                "pagesec:PPC1ApFPmodel-A-2-Floating-Point-Convert-to-Integer-Model.",
                "",
                "Except for enabled Invalid Operation Exceptions, FPRF is",
                "undefined.",
                "FR is set if the result is incremented when rounded.",
                "FI is set if the result is inexact.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Convert with truncate Double-Precision To Signed Doubleword format",
                    "form": "X",
                    "mnemonic": "fctidz",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Floating Convert with truncate Double-Precision To Signed Doubleword format",
                    "form": "X",
                    "mnemonic": "fctidz.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "815",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let src be the double-precision floating-point value in",
                "FRB.",
                "",
                "If src is a NaN, then the result is 0x8000_0000_0000_0000, VXCVI is set to 1, and, if",
                "src is an SNaN, VXSNAN is set to 1.",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode Round toward Zero.",
                "",
                "If the rounded value is greater than 2-1, then the result is",
                "0x7FFF_FFFF_FFFF_FFFF and VXCVI is set to",
                "1.",
                "",
                "Otherwise, if the rounded value is less than -2, then the result is 0x8000_0000_0000_0000 and VXCVI is set to 1.",
                "",
                "Otherwise, the result is the rounded value converted to 64-bit",
                "signed-integer format, and XX is set to 1 if the result",
                "is inexact.",
                "",
                "If an enabled Invalid Operation Exception does not occur, then the",
                "result is placed into FRT.",
                "",
                "The conversion is described fully in",
                "Section,",
                "Floating-Point Convert to Integer Model on",
                "pagesec:PPC1ApFPmodel-A-2-Floating-Point-Convert-to-Integer-Model.",
                "",
                "Except for enabled Invalid Operation Exceptions, FPRF is",
                "undefined.",
                "FR is set if the result is incremented when rounded.",
                "FI is set if the result is inexact.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Convert with round Double-Precision To Unsigned Doubleword format",
                    "form": "X",
                    "mnemonic": "fctidu",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Floating Convert with round Double-Precision To Unsigned Doubleword format",
                    "form": "X",
                    "mnemonic": "fctidu.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "942",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let src be the double-precision floating-point value in",
                "FRB.",
                "",
                "If src is a NaN, then the result is 0x0000_0000_0000_0000, VXCVI is set to 1, and, if",
                "src is an SNaN, VXSNAN is set to 1.",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode specified by RN.",
                "",
                "If the rounded value is greater than 2-1, then the result is",
                "0xFFFF_FFFF_FFFF_FFFF, and VXCVI is set to",
                "1.",
                "",
                "Otherwise, if the rounded value is less than 0, then the result is",
                "0x0000_0000_0000_0000, and VXCVI is set to",
                "1.",
                "",
                "Otherwise, the result is the rounded value converted to 64-bit",
                "unsigned-integer format, and XX is set to 1 if the result",
                "is inexact.",
                "",
                "If an enabled Invalid Operation Exception does not occur, then the",
                "result is placed into FRT.",
                "",
                "The conversion is described fully in",
                "Section,",
                "Floating-Point Convert to Integer Model on",
                "pagesec:PPC1ApFPmodel-A-2-Floating-Point-Convert-to-Integer-Model.",
                "",
                "Except for enabled Invalid Operation Exceptions, FPRF is",
                "undefined.",
                "FR is set if the result is incremented when rounded.",
                "FI is set if the result is inexact.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Convert with truncate Double-Precision To Unsigned Doubleword format",
                    "form": "X",
                    "mnemonic": "fctiduz",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Floating Convert with truncate Double-Precision To Unsigned Doubleword format",
                    "form": "X",
                    "mnemonic": "fctiduz.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "943",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let src be the double-precision floating-point value in",
                "FRB.",
                "",
                "If src is a NaN, then the result is 0x0000_0000_0000_0000, VXCVI is set to 1, and, if",
                "src is an SNaN, VXSNAN is set to 1.",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode Round toward Zero.",
                "",
                "If the rounded value is greater than 2-1, then the result is",
                "0xFFFF_FFFF_FFFF_FFFF, and VXCVI is set to",
                "1.",
                "",
                "Otherwise, if the rounded value is less than 0, then the result is",
                "0x0000_0000_0000_0000, and VXCVI is set to",
                "1.",
                "",
                "Otherwise, the result is the rounded value converted to 64-bit",
                "unsigned-integer format, and XX is set to 1 if the result",
                "is inexact.",
                "",
                "If an enabled Invalid Operation Exception does not occur, then the",
                "result is placed into FRT.",
                "",
                "The conversion is described fully in",
                "Section,",
                "Floating-Point Convert to Integer Model on",
                "pagesec:PPC1ApFPmodel-A-2-Floating-Point-Convert-to-Integer-Model.",
                "",
                "Except for enabled Invalid Operation Exceptions, FPRF is",
                "undefined.",
                "FR is set if the result is incremented when rounded.",
                "FI is set if the result is inexact.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Convert with round Double-Precision To Signed Word format",
                    "form": "X",
                    "mnemonic": "fctiw",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P2"
                },
                {
                    "name": "Floating Convert with round Double-Precision To Signed Word format",
                    "form": "X",
                    "mnemonic": "fctiw.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P2"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "14",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let src be the double-precision floating-point value in",
                "FRB.",
                "",
                "If src is a NaN, then the result is 0x8000_0000, VXCVI is set to 1, and, if src",
                "is an SNaN, VXSNAN is set to 1.",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode specified by RN.",
                "",
                "If the rounded value is greater than 2-1, then the result is",
                "0x7FFF_FFFF, and VXCVI is set to 1.",
                "",
                "Otherwise, if the rounded value is less than -2, then the result is 0x8000_0000, and VXCVI is set to 1.",
                "",
                "Otherwise, the result is the rounded value converted to 32-bit",
                "signed-integer format, and XX is set to 1 if the result",
                "is inexact.",
                "",
                "If an enabled Invalid Operation Exception does not occur, then the",
                "result is placed into FRT32:63 and",
                "FRT0:31 is undefined,",
                "",
                "The conversion is described fully in",
                "Section,",
                "Floating-Point Convert to Integer Model on",
                "pagesec:PPC1ApFPmodel-A-2-Floating-Point-Convert-to-Integer-Model.",
                "",
                "Except for enabled Invalid Operation Exceptions, FPRF is",
                "undefined.",
                "FR is set if the result is incremented when rounded.",
                "FI is set if the result is inexact.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Convert with truncate Double-Precision To Signed Word fomat",
                    "form": "X",
                    "mnemonic": "fctiwz",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P2"
                },
                {
                    "name": "Floating Convert with truncate Double-Precision To Signed Word fomat",
                    "form": "X",
                    "mnemonic": "fctiwz.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P2"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "15",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let src be the double-precision floating-point value in",
                "FRB.",
                "",
                "If src is a NaN, then the result is 0x8000_0000, VXCVI is set to 1, and, if src",
                "is an SNaN, VXSNAN is set to 1.",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode Round toward Zero.",
                "",
                "If the rounded value is greater than 2-1, then the result is",
                "0x7FFF_FFFF, and VXCVI is set to 1.",
                "",
                "Otherwise, if the rounded value is less than -2, then the result is 0x8000_0000, and VXCVI is set to 1.",
                "",
                "Otherwise, the result is the rounded value converted to 32-bit",
                "signed-integer format, and XX is set to 1 if the result",
                "is inexact.",
                "",
                "If an enabled Invalid Operation Exception does not occur, then the",
                "result is placed into FRT and FRT is",
                "undefined,",
                "",
                "The conversion is described fully in",
                "Section,",
                "Floating-Point Convert to Integer Model on",
                "pagesec:PPC1ApFPmodel-A-2-Floating-Point-Convert-to-Integer-Model.",
                "",
                "Except for enabled Invalid Operation Exceptions, FPRF is",
                "undefined.",
                "FR is set if the result is incremented when rounded.",
                "FI is set if the result is inexact.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Convert with round Double-Precision To Unsigned Word format",
                    "form": "X",
                    "mnemonic": "fctiwu",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Floating Convert with round Double-Precision To Unsigned Word format",
                    "form": "X",
                    "mnemonic": "fctiwu.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "142",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let src be the double-precision floating-point value in",
                "FRB.",
                "",
                "If src is a NaN, then the result is 0x0000_0000, VXCVI is set to 1, and, if src",
                "is an SNaN, VXSNAN is set to 1.",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode specified by RN.",
                "",
                "If the rounded value is greater than 2-1, then the result is",
                "0xFFFF_FFFF and VXCVI is set to 1.",
                "",
                "Otherwise, if the rounded value is less than 0,  then the",
                "result is 0x0000_0000 and VXCVI is set to 1.",
                "",
                "Otherwise, the result is the rounded value converted to 32-bit",
                "unsigned-integer format, and XX is set to 1 if the result",
                "is inexact.",
                "",
                "If an enabled Invalid Operation Exception does not occur, then the",
                "result is placed into FRT and FRT is",
                "undefined,",
                "",
                "The conversion is described fully in",
                "Section,",
                "Floating-Point Convert to Integer Model on",
                "pagesec:PPC1ApFPmodel-A-2-Floating-Point-Convert-to-Integer-Model.",
                "",
                "Except for enabled Invalid Operation Exceptions, FPRF is",
                "undefined.",
                "FR is set if the result is incremented when rounded.",
                "FI is set if the result is inexact.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Convert with truncate Double-Precision To Unsigned Word format",
                    "form": "X",
                    "mnemonic": "fctiwuz",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Floating Convert with truncate Double-Precision To Unsigned Word format",
                    "form": "X",
                    "mnemonic": "fctiwuz.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "143",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let src be the double-precision floating-point value in",
                "FRB.",
                "",
                "If src is a NaN, then the result is 0x0000_0000, VXCVI is set to 1, and, if src",
                "is an SNaN, VXSNAN is set to 1.",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode Round toward Zero.",
                "",
                "If the rounded value is greater than 2-1, then the result is",
                "0xFFFF_FFFF and VXCVI is set to 1.",
                "",
                "Otherwise, if the rounded value is less than 0.0,  then the result is",
                "0x0000_0000 and VXCVI is set to 1.",
                "",
                "Otherwise, the result is the rounded value converted to 32-bit",
                "unsigned-integer format, and XX is set to 1 if the result",
                "is inexact.",
                "",
                "If an enabled Invalid Operation Exception does not occur, then the",
                "result is placed into FRT and FRT is",
                "undefined,",
                "",
                "The conversion is described fully in",
                "Section,",
                "Floating-Point Convert to Integer Model on",
                "pagesec:PPC1ApFPmodel-A-2-Floating-Point-Convert-to-Integer-Model.",
                "",
                "Except for enabled Invalid Operation Exceptions, FPRF is",
                "undefined.",
                "FR is set if the result is incremented when rounded.",
                "FI is set if the result is inexact.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Convert with round Signed Doubleword to Double-Precision format",
                    "form": "X",
                    "mnemonic": "fcfid",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Floating Convert with round Signed Doubleword to Double-Precision format",
                    "form": "X",
                    "mnemonic": "fcfid.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "846",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The 64-bit signed fixed-point operand in register FRB is",
                "converted to an infinitely precise floating-point integer.",
                "The result of the conversion is rounded to double-precision, using",
                "the rounding mode specified by RN, and placed into",
                "register FRT.",
                "",
                "The conversion is described fully in",
                "Section,",
                "Floating-Point Convert from Integer Model.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set if the result is incremented when rounded.",
                "FI is set if the result is inexact.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Convert with round Unsigned Doubleword to Double-Precision format",
                    "form": "X",
                    "mnemonic": "fcfidu",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Floating Convert with round Unsigned Doubleword to Double-Precision format",
                    "form": "X",
                    "mnemonic": "fcfidu.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "974",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The 64-bit unsigned fixed-point operand in register FRB",
                "is converted to an infinitely precise floating-point integer.",
                "The result of the conversion is rounded to double-precision, using",
                "the rounding mode specified by RN, and placed into",
                "register FRT.",
                "",
                "The conversion is described fully in",
                "Section,",
                "Floating-Point Convert from Integer Model.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set if the result is incremented when rounded.",
                "FI is set if the result is inexact.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Convert with round Signed Doubleword to Single-Precision format",
                    "form": "X",
                    "mnemonic": "fcfids",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Floating Convert with round Signed Doubleword to Single-Precision format",
                    "form": "X",
                    "mnemonic": "fcfids.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "846",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The 64-bit signed fixed-point operand in register FRB is",
                "converted to an infinitely precise floating-point integer.",
                "The result of the conversion is rounded to single-precision, using",
                "the rounding mode specified by RN, and placed into",
                "register FRT.",
                "",
                "The conversion is described fully in",
                "Section,",
                "Floating-Point Convert from Integer Model.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set if the result is incremented when rounded.",
                "FI is set if the result is inexact.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Convert with round Unsigned Doubleword to Single-Precision format",
                    "form": "X",
                    "mnemonic": "fcfidus",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "Floating Convert with round Unsigned Doubleword to Single-Precision format",
                    "form": "X",
                    "mnemonic": "fcfidus.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "974",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The 64-bit unsigned fixed-point operand in register FRB",
                "is converted to an infinitely precise floating-point integer.",
                "The result of the conversion is rounded to single-precision, using",
                "the rounding mode specified by RN, and placed into",
                "register FRT.",
                "",
                "The conversion is described fully in",
                "Section,",
                "Floating-Point Convert from Integer Model.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set if the result is incremented when rounded.",
                "FI is set if the result is inexact.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Round to Integer Nearest",
                    "form": "X",
                    "mnemonic": "frin",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.02"
                },
                {
                    "name": "Floating Round to Integer Nearest",
                    "form": "X",
                    "mnemonic": "frin.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "392",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The floating-point operand in register FRB is rounded to",
                "an integral value as follows, with the result placed into register",
                "FRT.",
                "If the sign of the operand is positive, (FRB)+0.5 is",
                "truncated to an integral value, otherwise (FRB)-0.5 is",
                "truncated to an integral value.",
                "",
                "FPRF is set to the class and sign of the result, except",
                "for Invalid Operation Exceptions when VE=1.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Round to Integer Toward Zero",
                    "form": "X",
                    "mnemonic": "friz",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.02"
                },
                {
                    "name": "Floating Round to Integer Toward Zero",
                    "form": "X",
                    "mnemonic": "friz.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "424",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The floating-point operand in register FRB is rounded to",
                "an integral value using the rounding mode round toward zero, and the",
                "result is placed into register FRT.",
                "",
                "FPRF is set to the class and sign of the result, except",
                "for Invalid Operation Exceptions when VE = 1.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Round to Integer Plus",
                    "form": "X",
                    "mnemonic": "frip",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.02"
                },
                {
                    "name": "Floating Round to Integer Plus",
                    "form": "X",
                    "mnemonic": "frip.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "456",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The floating-point operand in register FRB is rounded to",
                "an integral value using the rounding mode round toward +infinity, and",
                "the result is placed into register FRT.",
                "",
                "FPRF is set to the class and sign of the result, except",
                "for Invalid Operation Exceptions when VE=1.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Round to Integer Minus",
                    "form": "X",
                    "mnemonic": "frim",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.02"
                },
                {
                    "name": "Floating Round to Integer Minus",
                    "form": "X",
                    "mnemonic": "frim.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.02"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "488",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The floating-point operand in register FRB is rounded to",
                "an integral value using the rounding mode round toward -infinity, and",
                "the result is placed into register FRT.",
                "",
                "FPRF is set to the class and sign of the result, except",
                "for Invalid Operation Exceptions when VE=1.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Compare Unordered",
                    "form": "X",
                    "mnemonic": "fcmpu",
                    "operands": [
                        "BF",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if (FRA) is a NaN or",
                "  (FRB) is a NaN then c := 0b0001",
                "else if (FRA) < (FRB) then c := 0b1000",
                "else if (FRA) > (FRB) then c := 0b0100",
                "else                       c := 0b0010",
                "FPCC := c",
                "CR<sub>4BF:4BF+3</sub> := c",
                "if (FRA) is an SNaN or",
                "  (FRB) is an SNaN then",
                "    VXSNAN := 1"
            ],
            "body": [
                "",
                "",
                "The floating-point operand in register FRA is compared to",
                "the floating-point operand in register FRB.",
                "The result of the compare is placed into CR field BF and",
                "the FPCC.",
                "",
                "If either of the operands is a NaN, either quiet or signaling, then",
                "CR field BF and the FPCC are set to reflect",
                "unordered.",
                "If either of the operands is a Signaling NaN, then VXSNAN",
                "is set.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Compare Ordered",
                    "form": "X",
                    "mnemonic": "fcmpo",
                    "operands": [
                        "BF",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "32",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if (FRA) is a NaN or",
                "  (FRB) is a NaN then c := 0b0001",
                "else if (FRA) < (FRB) then c := 0b1000",
                "else if (FRA) > (FRB) then c := 0b0100",
                "else                       c := 0b0010",
                "FPCC := c",
                "CR<sub>4BF:4BF+3</sub> := c",
                "if (FRA) is an SNaN or",
                "  (FRB) is an SNaN then",
                "    VXSNAN := 1",
                "    if VE = 0 then VXVC := 1",
                "else if (FRA) is a QNaN or",
                "  (FRB) is a QNaN then VXVC := 1"
            ],
            "body": [
                "",
                "",
                "The floating-point operand in register FRA is compared to",
                "the floating-point operand in register FRB.",
                "The result of the compare is placed into CR field BF and",
                "the FPCC.",
                "",
                "If either of the operands is a NaN, either quiet or signaling, then",
                "CR field BF and the FPCC are set to reflect",
                "unordered.",
                "If either of the operands is a Signaling NaN, then VXSNAN",
                "is set and, if Invalid Operation is disabled (VE=0),",
                "VXVC is set.",
                "If neither operand is a Signaling NaN but at least one operand is a",
                "Quiet NaN, then VXVC is set.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Floating Select",
                    "form": "A",
                    "mnemonic": "fsel",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "PPC"
                },
                {
                    "name": "Floating Select",
                    "form": "A",
                    "mnemonic": "fsel.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRC",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "FRC",
                    "size": "5"
                },
                {
                    "name": "23",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "if (FRA) >= 0.0 then FRT := (FRC)",
                "else FRT := (FRB)"
            ],
            "body": [
                "",
                "",
                "The floating-point operand in register FRA is compared to",
                "the value zero.",
                "If the operand is greater than or equal to zero, register FRT is set to the contents of register FRC.",
                "If the operand is less than zero or is a NaN, register FRT is set to the contents of register FRB.",
                "The comparison ignores the sign of zero (i.e., regards +0",
                "as equal to -0).",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move From FPSCR",
                    "form": "X",
                    "mnemonic": "mffs",
                    "operands": [
                        "FRT"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Move From FPSCR",
                    "form": "X",
                    "mnemonic": "mffs.",
                    "operands": [
                        "FRT"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "583",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The contents of the FPSCR are placed into register FRT.",
                "",
                "If Rc=1, CR field 1 is set to the value FX||FEX||VX||OX.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move From FPSCR  Clear Enables",
                    "form": "X",
                    "mnemonic": "mffsce",
                    "operands": [
                        "FRT"
                    ],
                    "conditions": [],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "583",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The contents of the FPSCR are placed into register FRT.",
                "",
                "The contents of bits 56:60 (VE, OE,",
                "UE, ZE, XE) of the FPSCR are set",
                "to 0.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move From FPSCR Control  Set DRN",
                    "form": "X",
                    "mnemonic": "mffscdrn",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "20",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "583",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let new_DRN be the contents of bits 29:31 of register",
                "FRB.",
                "",
                "The contents of the control bits in the FPSCR, that is, bits 29:31",
                "(DRN) and bits 56:63 (VE, OE,",
                "UE, ZE, XE, NI,",
                "RN), are placed into the corresponding bits in register",
                "FRT.",
                "All other bits in register FRT are set to 0.",
                "",
                "new_DRN is placed into bits 62:64 of the FPSCR",
                "(DRN).",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move From FPSCR Control  Set DRN Immediate",
                    "form": "X",
                    "mnemonic": "mffscdrni",
                    "operands": [
                        "FRT",
                        "DRM"
                    ],
                    "conditions": [],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "21",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "DRM",
                    "size": "3"
                },
                {
                    "name": "583",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The contents of the control bits in the FPSCR, that is, bits 29:31",
                "(DRN) and bits 56:63 (VE, OE,",
                "UE, ZE, XE, NI,",
                "RN), are placed into the corresponding bits in register",
                "FRT.",
                "All other bits in register FRT are set to 0.",
                "",
                "The contents of bits 29:31 of the FPSCR (DRN) are set to",
                "the value of DRM.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move From FPSCR Control  Set RN",
                    "form": "X",
                    "mnemonic": "mffscrn",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "22",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "583",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let new_RN be the contents of bits 62:63 of register FRB.",
                "",
                "The contents of the control bits in the FPSCR, that is, bits 29:31",
                "(DRN) and bits 56:63 (VE, OE, UE,",
                "ZE, XE, NI, RN), are",
                "placed into the corresponding bits in register FRT.",
                "All other bits in register FRT are set to 0.",
                "",
                "new_RN is placed into bits 62:63 of the FPSCR (RN).",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move From FPSCR Control  Set RN Immediate",
                    "form": "X",
                    "mnemonic": "mffscrni",
                    "operands": [
                        "FRT",
                        "RM"
                    ],
                    "conditions": [],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "23",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "RM",
                    "size": "2"
                },
                {
                    "name": "583",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The contents of the control bits in the FPSCR, that is, bits 29:31",
                "(DRN) and bits 56:63 (VE, OE,",
                "UE, ZE, XE, NI,",
                "RN), are placed into the corresponding bits in register",
                "FRT.",
                "All other bits in register FRT are set to 0.",
                "",
                "The contents of bits 62:63 of the FPSCR (RN) are set to",
                "the value of RM.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move From FPSCR Lightweight",
                    "form": "X",
                    "mnemonic": "mffsl",
                    "operands": [
                        "FRT"
                    ],
                    "conditions": [],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "24",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "583",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The contents of the control bits in the FPSCR, that is, bits 29:31",
                "(DRN) and bits 56:63 (VE, OE,",
                "UE, ZE, XE, NI,",
                "RN), and the non-sticky status bits in the FPSCR, that",
                "is, bits 45:51 (FR, FI, C,",
                "FL, FG, FE, FU), are placed into",
                "the corresponding bits in register FRT.",
                "All other bits in register FRT are set to 0.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move to Condition Register from FPSCR",
                    "form": "X",
                    "mnemonic": "mcrfs",
                    "operands": [
                        "BF",
                        "BFA"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "BFA",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "7"
                },
                {
                    "name": "64",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The contents of FPSCR field BFA are copied to Condition Register field",
                "BF. All exception bits copied are set to 0 in the FPSCR.",
                "If the FX bit is copied, it is set to 0 in the FPSCR.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move To FPSCR Field Immediate",
                    "form": "X",
                    "mnemonic": "mtfsfi",
                    "operands": [
                        "BF",
                        "U",
                        "W"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Move To FPSCR Field Immediate",
                    "form": "X",
                    "mnemonic": "mtfsfi.",
                    "operands": [
                        "BF",
                        "U",
                        "W"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "W",
                    "size": "1"
                },
                {
                    "name": "U",
                    "size": "4"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "134",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The value of the U field is placed into FPSCR field",
                "BF+8*(1-W).",
                "",
                "FX is altered only if BF=0 and W=0.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move To FPSCR Fields",
                    "form": "XFL",
                    "mnemonic": "mtfsf",
                    "operands": [
                        "FLM",
                        "FRB",
                        "L",
                        "W"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Move To FPSCR Fields",
                    "form": "XFL",
                    "mnemonic": "mtfsf.",
                    "operands": [
                        "FLM",
                        "FRB",
                        "L",
                        "W"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "FLM",
                    "size": "8"
                },
                {
                    "name": "W",
                    "size": "1"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "711",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The FPSCR is modified as specified by the FLM, L, and W fields.",
                "",
                "L=0",
                "",
                "",
                "",
                "The contents of register FRB are placed into the FPSCR",
                "under control of the W field and the field mask specified",
                "by FLM.",
                "W and the field mask identify the 4-bit fields affected.",
                "Let i be an integer in the range 0-7.",
                "If FLM=1",
                "then FPSCR field k is set to the contents of the",
                "corresponding field of register FRB, where k=i+8*(1-W).",
                "",
                "",
                "L=1",
                "",
                "",
                "",
                "The contents of register FRB are placed into the FPSCR.",
                "",
                "",
                "FX is not altered implicitly by this instruction.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move To FPSCR Bit 0",
                    "form": "X",
                    "mnemonic": "mtfsb0",
                    "operands": [
                        "BT"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Move To FPSCR Bit 0",
                    "form": "X",
                    "mnemonic": "mtfsb0.",
                    "operands": [
                        "BT"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "10"
                },
                {
                    "name": "70",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Bit BT+32 of the FPSCR is set to 0.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Floating-Point Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move To FPSCR Bit 1",
                    "form": "X",
                    "mnemonic": "mtfsb1",
                    "operands": [
                        "BT"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "P1"
                },
                {
                    "name": "Move To FPSCR Bit 1",
                    "form": "X",
                    "mnemonic": "mtfsb1.",
                    "operands": [
                        "BT"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "10"
                },
                {
                    "name": "38",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Bit BT+32 of the FPSCR is set to 1.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Add",
                    "form": "X",
                    "mnemonic": "dadd",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Add",
                    "form": "X",
                    "mnemonic": "dadd.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Add Quad",
                    "form": "X",
                    "mnemonic": "daddq",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Add Quad",
                    "form": "X",
                    "mnemonic": "daddq.",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "2",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The DFP operand in FRA[p] is added to the DFP operand in",
                "FRB[p].",
                "",
                "The result is rounded to the target-format precision under control of",
                "DRN (bits 29:31 of the FPSCR).",
                "An appropriate form of the rounded result is selected based on the",
                "ideal exponent and is placed in FRT[p].",
                "The ideal exponent is the smaller exponent of the two source operands.",
                "",
                "Figure summarizes the actions for Add.",
                "Figure does not include the setting of",
                "FPRF.",
                "FPRF is always set to the class and sign of the result,",
                "except for an enabled invalid-operation exception, in which case the",
                "field remains unchanged.",
                "",
                "dadd[q][.] are treated as Floating-Point instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Subtract",
                    "form": "X",
                    "mnemonic": "dsub",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Subtract",
                    "form": "X",
                    "mnemonic": "dsub.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Subtract Quad",
                    "form": "X",
                    "mnemonic": "dsubq",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Subtract Quad",
                    "form": "X",
                    "mnemonic": "dsubq.",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "514",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The DFP operand in FRB[p] is subtracted from the DFP",
                "operand in FRA[p].",
                "",
                "The result is rounded to the target-format precision under control of",
                "DRN (bits 29:31 of the FPSCR).",
                "An appropriate form of the rounded result is selected based on the",
                "ideal exponent and is placed in FRT[p].",
                "The ideal exponent is the smaller exponent of the two source operands.",
                "",
                "The execution of Subtract is identical to that of Add, except that",
                "the operand in FRB participates in the operation with its",
                "sign bit inverted.  See Figure.",
                "The table does not include the setting of FPRF.",
                "FPRF is always set to the class and sign of the result,",
                "except for an enabled invalid-operation exception, in which case the",
                "field remains unchanged.",
                "",
                "dsub[q][.] are treated as Floating-Point instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Multiply",
                    "form": "X",
                    "mnemonic": "dmul",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Multiply",
                    "form": "X",
                    "mnemonic": "dmul.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Multiply Quad",
                    "form": "X",
                    "mnemonic": "dmulq",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Multiply Quad",
                    "form": "X",
                    "mnemonic": "dmulq.",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "34",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The DFP operand in FRA[p] is multiplied by the DFP",
                "operand in FRB[p].",
                "",
                "The result is rounded to the target-format precision under control of",
                "DRN (bits 29:31 of the FPSCR).",
                "An appropriate form of the rounded result is selected based on the",
                "ideal exponent and is placed in FRT[p].",
                "The ideal exponent is the sum of the two exponents of the source",
                "operands.",
                "",
                "Figure summarizes the actions for",
                "Multiply.",
                "Figure does not include the setting of",
                "FPRF.",
                "FPRF is always set to the class and sign of the result,",
                "except for an enabled invalid-operation exception, in which case the",
                "field remains unchanged.",
                "",
                "dmul[q][.] are treated as Floating-Point instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Divide",
                    "form": "X",
                    "mnemonic": "ddiv",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Divide",
                    "form": "X",
                    "mnemonic": "ddiv.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Divide Quad",
                    "form": "X",
                    "mnemonic": "ddivq",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Divide Quad",
                    "form": "X",
                    "mnemonic": "ddivq.",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "546",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The DFP operand in FRA[p] is divided by the DFP operand",
                "in FRB[p].",
                "",
                "The result is rounded to the target-format precision under control of",
                "the DRN (bits 29:31 of the FPSCR).",
                "An appropriate form of the rounded result is selected based on the",
                "ideal exponent and is placed in FRT[p].",
                "The ideal exponent is the difference of subtracting the exponent of",
                "the divisor from the exponent of the dividend.",
                "",
                "Figure summarizes the actions for Divide.",
                "Figure does not include the setting of",
                "FPRF.",
                "FPRF is always set to the class and sign of the result,",
                "except for an enabled invalid-operation and enabled zero-divide",
                "exceptions, in which cases the field remains unchanged.",
                "",
                "ddiv[q][.] are treated as Floating-Point instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Compare Unordered",
                    "form": "X",
                    "mnemonic": "dcmpu",
                    "operands": [
                        "BF",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Compare Unordered Quad",
                    "form": "X",
                    "mnemonic": "dcmpuq",
                    "operands": [
                        "BF",
                        "FRAp",
                        "FRBp"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "642",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The DFP operand in FRA[p] is compared to the DFP operand",
                "in FRB[p].",
                "The result of the compare is placed into CR field BF and",
                "the FPCC.",
                "",
                "dcmpu[q] are treated as Floating-Point instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Compare Ordered",
                    "form": "X",
                    "mnemonic": "dcmpo",
                    "operands": [
                        "BF",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Compare Ordered Quad",
                    "form": "X",
                    "mnemonic": "dcmpoq",
                    "operands": [
                        "BF",
                        "FRAp",
                        "FRBp"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "130",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The DFP operand in FRA[p] is compared to the DFP operand",
                "in FRB[p].",
                "The result of the compare is placed into CR field BF and",
                "the FPCC.",
                "",
                "dcmpo[q] are treated as Floating-Point instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Test Data Class",
                    "form": "Z22",
                    "mnemonic": "dtstdc",
                    "operands": [
                        "BF",
                        "FRA",
                        "DCM"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Test Data Class Quad",
                    "form": "Z22",
                    "mnemonic": "dtstdcq",
                    "operands": [
                        "BF",
                        "FRAp",
                        "DCM"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "DCM",
                    "size": "6"
                },
                {
                    "name": "194",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let the DCM (Data Class Mask) field specify one or more",
                "of the 6 possible data classes, where each bit corresponds to a",
                "specific data class.",
                "",
                "",
                "",
                "",
                "CR field BF and FPCC are set to indicate the",
                "sign of the DFP operand in FRA[p] and whether the data",
                "class of the DFP operand in FRA[p] matches any of the",
                "data classes specified by DCM.",
                "",
                "",
                "",
                "",
                "dtstdc[q] are treated as Floating-Point instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Test Data Group",
                    "form": "Z22",
                    "mnemonic": "dtstdg",
                    "operands": [
                        "BF",
                        "FRA",
                        "DGM"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Test Data Group Quad",
                    "form": "Z22",
                    "mnemonic": "dtstdgq",
                    "operands": [
                        "BF",
                        "FRAp",
                        "DGM"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "DGM",
                    "size": "6"
                },
                {
                    "name": "226",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let the DGM (Data Group Mask) field specify one or more",
                "of the 6 possible data groups, where each bit corresponds to a",
                "specific data group.",
                "",
                "The term extreme exponent means either the maximum exponent,",
                "X, or the minimum",
                "exponent, X.",
                "",
                "",
                "",
                "",
                "CR field BF and FPCC are set to indicate the",
                "sign of the DFP operand in FRA[p] and whether the data",
                "group of the DFP operand in FRA[p] matches any of the",
                "data groups specified by DGM.",
                "",
                "",
                "",
                "",
                "dtstdg[q] are treated as Floating-Point instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Test Exponent",
                    "form": "X",
                    "mnemonic": "dtstex",
                    "operands": [
                        "BF",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Test Exponent Quad",
                    "form": "X",
                    "mnemonic": "dtstexq",
                    "operands": [
                        "BF",
                        "FRAp",
                        "FRBp"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "162",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The exponent value (Ea) of the DFP operand in FRA[p] is compared to the exponent value (Eb) of the DFP",
                "operand in FRB[p].",
                "The result of the compare is placed into CR field BF and",
                "the FPCC.",
                "",
                "The codes in the CR field BF and FPCC are",
                "defined for the DFP Test Exponent operations as follows.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Test Significance",
                    "form": "X",
                    "mnemonic": "dtstsf",
                    "operands": [
                        "BF",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Test Significance Quad",
                    "form": "X",
                    "mnemonic": "dtstsfq",
                    "operands": [
                        "BF",
                        "FRA",
                        "FRBp"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "674",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let k be the contents of bits 58:63 of FPR[FRA] that specifies the reference significance.",
                "",
                "For dtstsf, let the value NSDb be the number",
                "of significant digits of the DFP value in FPR[FRB].",
                "",
                "For dtstsfq, let the value NSDb be the number",
                "of significant digits of the DFP value in FPR[FRBp:FRBp+1].",
                "",
                "For this instruction, the number of significant digits of the value 0",
                "is considered to be zero.",
                "",
                "NSDb is compared to k.",
                "The result of the compare is placed into CR field BF and",
                "the FPCC as follows.",
                "",
                "",
                "",
                "",
                "dtstsf[q] are treated as Floating-Point instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Test Significance Immediate",
                    "form": "X",
                    "mnemonic": "dtstsfi",
                    "operands": [
                        "BF",
                        "UIM",
                        "FRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                },
                {
                    "name": "DFP Test Significance Immediate Quad",
                    "form": "X",
                    "mnemonic": "dtstsfiq",
                    "operands": [
                        "BF",
                        "UIM",
                        "FRBp"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "UIM",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "675",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let the value UIM specify the reference significance.",
                "",
                "For dtstsfi, let the value NSDb be the number",
                "of significant digits of the DFP value in FPR[FRB].",
                "",
                "For dtstsfiq, let the value NSDb be the number",
                "of significant digits of the DFP value in FPR[FRBp:FRBp+1].",
                "",
                "For this instruction, the number of significant digits of the value",
                "0 is considered to be zero.",
                "",
                "NSDb is compared to UIM.",
                "The result of the compare is placed into CR field BF and",
                "the FPCC as follows.",
                "",
                "",
                "",
                "",
                "dtstsfi[q] are treated as Floating-Point instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Quantize Immediate",
                    "form": "Z23",
                    "mnemonic": "dquai",
                    "operands": [
                        "TE",
                        "FRT",
                        "FRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Quantize Immediate",
                    "form": "Z23",
                    "mnemonic": "dquai.",
                    "operands": [
                        "TE",
                        "FRT",
                        "FRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Quantize Immediate Quad",
                    "form": "Z23",
                    "mnemonic": "dquaiq",
                    "operands": [
                        "TE",
                        "FRTp",
                        "FRBp",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Quantize Immediate Quad",
                    "form": "Z23",
                    "mnemonic": "dquaiq.",
                    "operands": [
                        "TE",
                        "FRTp",
                        "FRBp",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "TE",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "67",
                    "size": "8"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The DFP operand in FRB[p] is converted and rounded to the",
                "form with the exponent specified by TE based on the",
                "rounding mode specified in the RMC field.",
                "TE is a 5-bit signed binary integer.",
                "The result of that form is placed in FRT[p].",
                "The sign of the result is the same as the sign of the operand in",
                "FRB[p].",
                "The ideal exponent is the exponent specified by TE.",
                "",
                "When the value of the operand in FRB[p] is greater than",
                "(10-1) ",
                "10, where p is the",
                "format precision, an invalid operation exception is recognized.",
                "",
                "When the delivered result differs in value from the operand in",
                "FRB[p], an inexact exception is recognized.",
                "No underflow exception is recognized by this operation, regardless of",
                "the value of the operand in FRB[p].",
                "",
                "FPRF is always set to the class and sign of the result,",
                "except for an enabled invalid-operation exception, in which case the",
                "field remains unchanged.",
                "",
                "dquai[q][.] are treated as Floating-Point instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Quantize",
                    "form": "Z23",
                    "mnemonic": "dqua",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Quantize",
                    "form": "Z23",
                    "mnemonic": "dqua.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Quantize Quad",
                    "form": "Z23",
                    "mnemonic": "dquaq",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "FRBp",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Quantize Quad",
                    "form": "Z23",
                    "mnemonic": "dquaq.",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "FRBp",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "3",
                    "size": "8"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The DFP operand in register FRB[p] is converted and",
                "rounded to the form with the same exponent as that of the DFP operand",
                "in FRA[p] based on the rounding mode specified by",
                "RMC.",
                "The result of that form is placed in FRT[p].",
                "The sign of the result is the same as the sign of the operand in",
                "FRB[p].",
                "The ideal exponent is the exponent specified in FRA[p].",
                "",
                "When the value of the operand in FRB[p] is greater than",
                "(10-1) x",
                "10, where p is the format precision",
                "and Ea is the exponent of the operand in FRA[p], an invalid operation exception is recognized.",
                "",
                "When the delivered result differs in value from the operand in",
                "FRB[p], an inexact exception is recognized.",
                "No underflow exception is recognized by this operation, regardless of",
                "the value of the operand in FRB[p].",
                "",
                "Figure and",
                "Figure summarize the",
                "actions.  The tables do not include the setting of FPRF.",
                "FPRF is always set to the class and sign of the result,",
                "except for an enabled invalid-operation exception, in which case the",
                "field remains unchanged.",
                "",
                "dqua[q][.] are treated as Floating-Point instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Reround",
                    "form": "Z23",
                    "mnemonic": "drrnd",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Reround",
                    "form": "Z23",
                    "mnemonic": "drrnd.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Reround Quad",
                    "form": "Z23",
                    "mnemonic": "drrndq",
                    "operands": [
                        "FRTp",
                        "FRA",
                        "FRBp",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Reround Quad",
                    "form": "Z23",
                    "mnemonic": "drrndq.",
                    "operands": [
                        "FRTp",
                        "FRA",
                        "FRBp",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "35",
                    "size": "8"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let k be the contents of bits 58:63 of FRA",
                "that specifies the reference significance.",
                "",
                "When the DFP operand in FRB[p] is a finite number, and if",
                "the reference significance is zero, or if the reference significance",
                "is nonzero and the number of significant digits of the source operand",
                "is less than or equal to the reference significance, then the value",
                "and the form of the source operand is placed in FRT[p].",
                "If the reference significance is nonzero and the number of",
                "significant digits of the source operand is greater than the",
                "reference significance, then the source operand is converted and",
                "rounded to the number of significant digits specified in the",
                "reference significance based on the rounding mode specified in the",
                "RMC field.",
                "The result of the form with the specified number of significant",
                "digits is placed in FRT[p].",
                "The sign of the result is the same as the sign of the operand in",
                "FRB[p].",
                "",
                "For this instruction, the number of significant digits of the value 0",
                "is considered to be zero.",
                "The ideal exponent is the greater value of the exponent of the",
                "operand in FRB[p] and the referenced exponent.",
                "The referenced exponent is the resultant exponent if the operand in",
                "FRB[p] would have been converted and rounded to the",
                "number of significant digits specified in the reference significance",
                "based on the rounding mode specified by RMC.",
                "",
                "If the exponent of the rounded result of the form that has the",
                "specified number of significant digits would be greater than",
                "X, an",
                "invalid operation exception (VXCVI) occurs.",
                "When the invalid-operation exception occurs, and if the exception is",
                "disabled, a default QNaN is returned.",
                "When an invalid-operation exception occurs, no inexact exception is",
                "recognized.",
                "",
                "In the absence of an invalid-operation exception, if the result",
                "differs in value from the operand in FRB[p], an inexact",
                "exception is recognized.",
                "",
                "This operation causes neither an overflow nor an underflow exception.",
                "",
                "Figure summarizes the actions for",
                "Reround.",
                "The table does not include the setting of FPRF.",
                "FPRF is always set to the class and sign of the result,",
                "except for an enabled invalid-operation exception, in which case the",
                "field remains unchanged.",
                "",
                "drrnd[q][.] are treated as Floating-Point instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Round To FP Integer With Inexact",
                    "form": "Z23",
                    "mnemonic": "drintx",
                    "operands": [
                        "R",
                        "FRT",
                        "FRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Round To FP Integer With Inexact",
                    "form": "Z23",
                    "mnemonic": "drintx.",
                    "operands": [
                        "R",
                        "FRT",
                        "FRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Round To FP Integer With Inexact Quad",
                    "form": "Z23",
                    "mnemonic": "drintxq",
                    "operands": [
                        "R",
                        "FRTp",
                        "FRBp",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Round To FP Integer With Inexact Quad",
                    "form": "Z23",
                    "mnemonic": "drintxq.",
                    "operands": [
                        "R",
                        "FRTp",
                        "FRBp",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "99",
                    "size": "8"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The DFP operand in FRB[p] is rounded to a floating-point",
                "integer and placed into FRT[p].",
                "The sign of the result is the same as the sign of the operand in",
                "FRB[p].",
                "The ideal exponent is the larger value of zero and the exponent of",
                "the operand in FRB[p].",
                "",
                "The rounding mode used is specified by RMC.",
                "When the RMC-encoding-selection (R) bit is",
                "zero, RMC field contains the primary encoding; when the",
                "bit is one, the field contains the secondary encoding.",
                "",
                "In addition to coercion of the converted value to fit the target",
                "format, the special rounding used by Round To FP Integer",
                "also coerces the target exponent to the ideal exponent.",
                "",
                "When the operand in FRB[p] is a finite number and the",
                "exponent is less than zero, the operand is rounded to the result with",
                "an exponent of zero.",
                "When the exponent is greater than or equal to zero, the result is set",
                "to the numerical value and the form of the operand in FRB[p].",
                "",
                "When the result differs in value from the operand in FRB[p], an inexact exception is recognized.",
                "No underflow exception is recognized by this operation, regardless of",
                "the value of the operand in FRB[p].",
                "",
                "Figure",
                "summarizes the actions for Round To FP Integer With",
                "Inexact.",
                "The table does not include the setting of FPRF.",
                "FPRF is always set to the class and sign of the result,",
                "except for an enabled invalid-operation, in which case the field",
                "remains unchanged.",
                "",
                "drintx[q][.] are treated as Floating-Point instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Round To FP Integer Without Inexact",
                    "form": "Z23",
                    "mnemonic": "drintn",
                    "operands": [
                        "R",
                        "FRT",
                        "FRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Round To FP Integer Without Inexact",
                    "form": "Z23",
                    "mnemonic": "drintn.",
                    "operands": [
                        "R",
                        "FRT",
                        "FRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Round To FP Integer Without Inexact Quad",
                    "form": "Z23",
                    "mnemonic": "drintnq",
                    "operands": [
                        "R",
                        "FRTp",
                        "FRBp",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Round To FP Integer Without Inexact Quad",
                    "form": "Z23",
                    "mnemonic": "drintnq.",
                    "operands": [
                        "R",
                        "FRTp",
                        "FRBp",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "227",
                    "size": "8"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "This operation is the same as the Round To FP Integer With",
                "Inexact operation, except that this operation does not recognize an",
                "inexact exception.",
                "",
                "Figure",
                "summarizes the actions for Round To FP Integer Without",
                "Inexact.",
                "The table does not include the setting of FPRF.",
                "FPRF is always set to the class and sign of the result,",
                "except for an enabled invalid-operation, in which case the field",
                "remains unchanged.",
                "",
                "drintn[q][.] are treated as Floating-Point instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Convert To DFP Long",
                    "form": "X",
                    "mnemonic": "dctdp",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Convert To DFP Long",
                    "form": "X",
                    "mnemonic": "dctdp.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "258",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The DFP short operand in bits 32:63 of FRB is converted",
                "to DFP long format and the converted result is placed into FRT.",
                "The sign of the result is the same as the sign of the source operand.",
                "The ideal exponent is the exponent of the source operand.",
                "",
                "If the operand in FRB is an SNaN, it is converted to an",
                "SNaN in DFP long format and does not cause an invalid-operation",
                "exception.",
                "",
                "dctdp[.] are treated as Floating-Point",
                "instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Convert To DFP Extended",
                    "form": "X",
                    "mnemonic": "dctqpq",
                    "operands": [
                        "FRTp",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Convert To DFP Extended",
                    "form": "X",
                    "mnemonic": "dctqpq.",
                    "operands": [
                        "FRTp",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "258",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The DFP long operand in the FRB is converted to DFP",
                "extended format and placed into FRTp.",
                "The sign of the result is the same as the sign of the operand in FRB.",
                "The ideal exponent is the exponent of the operand in FRB.",
                "",
                "If the operand in FRB is an SNaN, an invalid-operation",
                "exception is recognized.",
                "If the exception is disabled, the SNaN is converted to the",
                "corresponding QNaN in DFP extended format.",
                "",
                "dctqpq[.] are treated as Floating-Point",
                "instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Round To DFP Short",
                    "form": "X",
                    "mnemonic": "drsp",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Round To DFP Short",
                    "form": "X",
                    "mnemonic": "drsp.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "770",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The DFP long operand in FRB is converted and rounded to",
                "DFP short format.",
                "The DFP short value is extended on the left with zeros to form a",
                "64-bit entity and placed into FRT.",
                "The sign of the result is the same as the sign of the source operand.",
                "The ideal exponent is the exponent of the source operand.",
                "",
                "If the operand in FRB is an SNaN, it is converted to an",
                "SNaN in DFP short format and does not cause an invalid-operation",
                "exception.",
                "",
                "Normally, the result is in the format and length of the target.",
                "However, when an overflow or underflow exception occurs and if the",
                "exception is enabled, the operation is completed by producing a",
                "wrapped rounded result in the same format and length as the source",
                "but rounded to the target-format precision.",
                "",
                "drsp[.] are treated as Floating-Point",
                "instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Round To DFP Long",
                    "form": "X",
                    "mnemonic": "drdpq",
                    "operands": [
                        "FRTp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Round To DFP Long",
                    "form": "X",
                    "mnemonic": "drdpq.",
                    "operands": [
                        "FRTp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "770",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The DFP extended operand in FRBp is converted and rounded",
                "to DFP long format.",
                "The result concatenated with 64 0s is placed in FRTp.",
                "The sign of the result is the same as the sign of the source operand.",
                "The ideal exponent is the exponent of the operand in FRBp.",
                "",
                "If the operand in FRBp is an SNaN, an invalid-operation",
                "exception is recognized.",
                "If the exception is disabled, the SNaN is converted to the",
                "corresponding QNaN in DFP long format.",
                "",
                "Normally, the result is in the format and length of the target.",
                "However, when an overflow or underflow exception occurs and if the",
                "exception is enabled, the operation is completed by producing a",
                "wrapped rounded result in the same format and length as the source",
                "but rounded to the target-format precision.",
                "",
                "drdpq[.] are treated as Floating-Point",
                "instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Convert From Fixed",
                    "form": "X",
                    "mnemonic": "dcffix",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "DFP Convert From Fixed",
                    "form": "X",
                    "mnemonic": "dcffix.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "802",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The 64-bit signed binary integer in FRB is converted and",
                "rounded to a DFP Long value and placed into FRT.",
                "The sign of the result is the same as the sign of the source operand.",
                "The ideal exponent is zero.",
                "",
                "If the source operand is a zero, then a plus zero with a zero",
                "exponent is returned.",
                "",
                "FPRF is set to the class and sign of the result.",
                "",
                "dcffix[.] are treated as Floating-Point",
                "instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Convert From Fixed Quad",
                    "form": "X",
                    "mnemonic": "dcffixq",
                    "operands": [
                        "FRTp",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Convert From Fixed Quad",
                    "form": "X",
                    "mnemonic": "dcffixq.",
                    "operands": [
                        "FRTp",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRB",
                    "size": "5"
                },
                {
                    "name": "802",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The 64-bit signed binary integer in FRB is converted and",
                "rounded to a DFP Extended value and placed into FRTp.",
                "The sign of the result is the same as the sign of the source operand.",
                "The ideal exponent is zero.",
                "",
                "If the source operand is a zero, then a plus zero with a zero",
                "exponent is returned.",
                "",
                "FPRF is set to the class and sign of the result.",
                "",
                "dcffixq[.] are treated as Floating-Point",
                "instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Convert From Fixed Quadword Quad",
                    "form": "X",
                    "mnemonic": "dcffixqq",
                    "operands": [
                        "FRTp",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "994",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The 128-bit signed binary integer in VRB is converted and",
                "rounded to a DFP Extended value and placed into FRTp.",
                "The sign of the result is the same as the sign of the source operand.",
                "The ideal exponent is zero.",
                "",
                "If the source operand is a zero, then a plus zero with a zero",
                "exponent is returned.",
                "",
                "FPRF is set to the class and sign of the result.",
                "",
                "dcffixqq is treated as a Floating-Point and a",
                "Vector instruction in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Convert To Fixed",
                    "form": "X",
                    "mnemonic": "dctfix",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Convert To Fixed",
                    "form": "X",
                    "mnemonic": "dctfix.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Convert To Fixed Quad",
                    "form": "X",
                    "mnemonic": "dctfixq",
                    "operands": [
                        "FRT",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Convert To Fixed Quad",
                    "form": "X",
                    "mnemonic": "dctfixq.",
                    "operands": [
                        "FRT",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "290",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The DFP operand in FRB[p] is rounded to an integer value",
                "and is placed into FRT in the 64-bit signed binary",
                "integer format.",
                "The sign of the result is the same as the sign of the source operand,",
                "except when the source operand is a NaN or a zero.",
                "",
                "Figure summarizes the actions",
                "for Convert To Fixed.",
                "",
                "dctfix[q][.] are treated as Floating-Point",
                "instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Convert To Fixed Quadword Quad",
                    "form": "X",
                    "mnemonic": "dctfixqq",
                    "operands": [
                        "VRT",
                        "FRBp"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "994",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The DFP operand in FRBp is rounded to an integer value",
                "and is placed into VRT in the 128-bit signed binary",
                "integer format.",
                "The sign of the result is the same as the sign of the source operand,",
                "except when the source operand is a NaN or a zero.",
                "",
                "Figure 96 summarizes the actions for Convert To Fixed.",
                "",
                "dctfixqq is treated as a Floating-Point and a Vector",
                "instruction in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Decode DPD To BCD",
                    "form": "X",
                    "mnemonic": "ddedpd",
                    "operands": [
                        "SP",
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Decode DPD To BCD",
                    "form": "X",
                    "mnemonic": "ddedpd.",
                    "operands": [
                        "SP",
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Decode DPD To BCD Quad",
                    "form": "X",
                    "mnemonic": "ddedpdq",
                    "operands": [
                        "SP",
                        "FRTp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Decode DPD To BCD Quad",
                    "form": "X",
                    "mnemonic": "ddedpdq.",
                    "operands": [
                        "SP",
                        "FRTp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "SP",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "322",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "A portion of the significand of the DFP operand in FRB[p]",
                "is converted to a signed or unsigned BCD number depending on the",
                "SP field.",
                "For infinity and NaN, the significand is considered to be the",
                "contents in the trailing significand field padded on the left by a",
                "zero digit.",
                "",
                "SP0 = 0 (unsigned conversion)",
                "",
                "",
                "",
                "The rightmost 16 digits of the significand (32 digits for",
                "ddedpdq) is converted to an unsigned BCD number",
                "and the result is placed into FRT[p].",
                "",
                "",
                "SP0 = 1 (signed conversion)",
                "",
                "",
                "",
                "The rightmost 15 digits of the significand (31 digits for",
                "ddedpdq) is converted to a signed BCD number with",
                "the same sign as the DFP operand, and the result is placed into",
                "FRT[p].",
                "If the DFP operand is negative, the sign is encoded as 0b1101.",
                "If the DFP operand is positive, SP indicates which preferred plus sign",
                "encoding is used.",
                "If SP = 0, the",
                "plus sign is encoded as 0b1100 (the option-1 preferred",
                "sign code), otherwise the plus sign is encoded as 0b1111",
                "(the option-2 preferred sign code).",
                "",
                "",
                "ddedpd[q][.] are treated as Floating-Point",
                "instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Encode BCD To DPD",
                    "form": "X",
                    "mnemonic": "denbcd",
                    "operands": [
                        "S",
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Encode BCD To DPD",
                    "form": "X",
                    "mnemonic": "denbcd.",
                    "operands": [
                        "S",
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Encode BCD To DPD Quad",
                    "form": "X",
                    "mnemonic": "denbcdq",
                    "operands": [
                        "S",
                        "FRTp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Encode BCD To DPD Quad",
                    "form": "X",
                    "mnemonic": "denbcdq.",
                    "operands": [
                        "S",
                        "FRTp",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "S",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "834",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The signed or unsigned BCD operand, depending on the S field, in",
                "FRB[p] is converted to a DFP number.",
                "The ideal exponent is zero.",
                "",
                "S = 0 (unsigned BCD operand)",
                "",
                "",
                "",
                "The unsigned BCD operand in FRB[p] is converted to a",
                "positive DFP number of the same magnitude and the result is placed",
                "into FRT[p].",
                "",
                "",
                "S = 1 (signed BCD operand)",
                "",
                "",
                "",
                "The signed BCD operand in FRB[p] is converted to the",
                "corresponding DFP number and the result is placed into FRT[p].",
                "",
                "",
                "If an invalid BCD digit or sign code is detected in the source",
                "operand, an invalid-operation exception (VXCVI) occurs.",
                "",
                "FPRF is set to the class and sign of the result, except",
                "for Invalid Operation Exception when VE=1.",
                "",
                "denbcd[q][.] are treated as Floating-Point",
                "instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Extract Biased Exponent",
                    "form": "X",
                    "mnemonic": "dxex",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Extract Biased Exponent",
                    "form": "X",
                    "mnemonic": "dxex.",
                    "operands": [
                        "FRT",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Extract Biased Exponent Quad",
                    "form": "X",
                    "mnemonic": "dxexq",
                    "operands": [
                        "FRT",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Extract Biased Exponent Quad",
                    "form": "X",
                    "mnemonic": "dxexq.",
                    "operands": [
                        "FRT",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "354",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The biased exponent of the operand in FRB[p] is extracted",
                "and placed into FRT in the 64-bit signed binary integer",
                "format.",
                "When the operand in FRB is an infinity, QNaN, or SNaN, a",
                "special code is returned.",
                "",
                "",
                "",
                "",
                "dxex[q][.] are treated as Floating-Point",
                "instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Insert Biased Exponent",
                    "form": "X",
                    "mnemonic": "diex",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Insert Biased Exponent",
                    "form": "X",
                    "mnemonic": "diex.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "FRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Insert Biased Exponent Quad",
                    "form": "X",
                    "mnemonic": "diexq",
                    "operands": [
                        "FRTp",
                        "FRA",
                        "FRBp"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Insert Biased Exponent Quad",
                    "form": "X",
                    "mnemonic": "diexq.",
                    "operands": [
                        "FRTp",
                        "FRA",
                        "FRBp"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRA",
                    "size": "5"
                },
                {
                    "name": "FRBp",
                    "size": "5"
                },
                {
                    "name": "866",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let a be the value of the 64-bit signed binary integer in",
                "FRA.",
                "",
                "",
                "",
                "",
                "When 0  a  MBE,",
                "a is the biased target exponent that is combined with the",
                "sign bit and the significand value of the DFP operand in FRB[p] to form the DFP result in FRT[p].",
                "The ideal exponent is the specified target exponent.",
                "",
                "When a specifies a special code (a  0 or",
                "a  MBE), an infinity, QNaN, or SNaN is formed in",
                "FRT[p] with the trailing significand field containing the",
                "value from the trailing significand field of the source operand in",
                "FRB[p], and with an N-bit combination field set as",
                "follows.",
                "",
                "",
                "",
                "diex[q][.] are treated as Floating-Point",
                "instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Shift Significand Left Immediate",
                    "form": "Z22",
                    "mnemonic": "dscli",
                    "operands": [
                        "FRT",
                        "FRA",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Shift Significand Left Immediate",
                    "form": "Z22",
                    "mnemonic": "dscli.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Shift Significand Left Immediate Quad",
                    "form": "Z22",
                    "mnemonic": "dscliq",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Shift Significand Left Immediate Quad",
                    "form": "Z22",
                    "mnemonic": "dscliq.",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "SH",
                    "size": "6"
                },
                {
                    "name": "66",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The significand of the DFP operand in FRA[p] is shifted",
                "left SH digits.",
                "For a NaN or infinity, all significand digits are in the trailing",
                "significand field. SH is a 6-bit unsigned binary integer.",
                "Digits shifted out of the leftmost digit are lost.",
                "Zeros are supplied to the vacated positions on the right.",
                "The result is placed into FRT[p].",
                "The sign of the result is the same as the sign of the source operand",
                "in FRA[p].",
                "",
                "If the source operand in FRA[p] is a finite number, the",
                "exponent of the result is the same as the exponent of the source",
                "operand.",
                "",
                "For an Infinity, QNaN or SNaN result, the target format\u00e2\u20ac\u2122s N-bit",
                "combination field is set as follows.",
                "",
                "",
                "",
                "dscli[q][.] are treated as Floating-Point",
                "instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Decimal Floating-Point",
            "book": "I",
            "mnemonics": [
                {
                    "name": "DFP Shift Significand Right Immediate",
                    "form": "Z22",
                    "mnemonic": "dscri",
                    "operands": [
                        "FRT",
                        "FRA",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Shift Significand Right Immediate",
                    "form": "Z22",
                    "mnemonic": "dscri.",
                    "operands": [
                        "FRT",
                        "FRA",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Shift Significand Right Immediate Quad",
                    "form": "Z22",
                    "mnemonic": "dscriq",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.05"
                },
                {
                    "name": "DFP Shift Significand Right Immediate Quad",
                    "form": "Z22",
                    "mnemonic": "dscriq.",
                    "operands": [
                        "FRTp",
                        "FRAp",
                        "SH"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "FRTp",
                    "size": "5"
                },
                {
                    "name": "FRAp",
                    "size": "5"
                },
                {
                    "name": "SH",
                    "size": "6"
                },
                {
                    "name": "98",
                    "size": "9"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The significand of the DFP operand in FRA[p] is shifted",
                "right SH digits.",
                "For a NaN or infinity, all significand digits are in the trailing",
                "significand field. SH is a 6-bit unsigned binary integer.",
                "Digits shifted out of the units digit are lost.",
                "Zeros are supplied to the vacated positions on the left.",
                "The result is placed into FRT[p].",
                "The sign of the result is the same as the sign of the source operand",
                "in FRA[p].",
                "",
                "If the source operand in FRA[p] is a finite number, the",
                "exponent of the result is the same as the exponent of the source",
                "operand.",
                "",
                "For an Infinity, QNaN or SNaN result, the target format\u00e2\u20ac\u2122s N-bit",
                "combination field is set as follows.",
                "",
                "",
                "",
                "dscri[q][.] are treated as Floating-Point",
                "instructions in terms of resource availability.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Vector Element Byte Indexed",
                    "form": "X",
                    "mnemonic": "lvebx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "7",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "eb := EA.bit[60:63]",
                "",
                "VSR[VRT+32] := undefined",
                "if Big-Endian byte ordering then",
                "VSR[VRT+32].byte[eb] := MEM(EA,1)",
                "else",
                "VSR[VRT+32].byte[15-eb] := MEM(EA,1)"
            ],
            "body": [
                "",
                "",
                "Let EA be the sum (RA|0)+(RB).",
                "",
                "Let eb be bits 60:63 of EA.",
                "",
                "If Big-Endian byte ordering is used for the storage access, the",
                "contents of the byte in storage at address EA are placed",
                "into byte eb of VSR[VRT+32].",
                "The remaining bytes of VSR[VRT+32] are set to undefined",
                "values.",
                "",
                "If Little-Endian byte ordering is used for the storage access, the",
                "contents of the byte in storage at address EA are placed",
                "into byte 15-eb of VSR[VRT+32].",
                "The remaining bytes of VSR[VRT+32] are set to undefined",
                "values.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_lde"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Vector Element Halfword Indexed",
                    "form": "X",
                    "mnemonic": "lvehx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "39",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "EA := EA & 0xFFFF_FFFF_FFFF_FFFE",
                "eb := EA.bit[60:63]",
                "",
                "VSR[VRT+32] := undefined",
                "if Big-Endian byte ordering then",
                "  VSR[VRT+32].byte[eb:eb+1] := MEM(EA,2)",
                "else",
                "  VSR[VRT+32].byte[14-eb:15-eb] := MEM(EA,2)"
            ],
            "body": [
                "",
                "",
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFFE with the sum (RA|0)+(RB).",
                "",
                "Let eb be bits 60:63 of EA.",
                "",
                "If Big-Endian byte ordering is used for the storage access,",
                "",
                "",
                "",
                "If Little-Endian byte ordering is used for the storage access,",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_lde"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Vector Element Word Indexed",
                    "form": "X",
                    "mnemonic": "lvewx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "71",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "EA := EA & 0xFFFF_FFFF_FFFF_FFFC",
                "eb := EA.bit[60:63]",
                "",
                "VSR[VRT+32] := undefined",
                "if Big-Endian byte ordering then",
                "  VSR[VRT+32].byte[eb:eb+3] := MEM(EA,4)",
                "else",
                "  VSR[VRT+32].byte[12-eb:15-eb] := MEM(EA,4)"
            ],
            "body": [
                "",
                "",
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFFC with the sum (RA|0)+(RB).",
                "",
                "Let eb be bits 60:63 of EA.",
                "",
                "If Big-Endian byte ordering is used for the storage access,",
                "",
                "",
                "",
                "If if Little-Endian byte ordering is used for the storage access,",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_lde"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Vector Indexed",
                    "form": "X",
                    "mnemonic": "lvx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "103",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "EA := EA & 0xFFFF_FFFF_FFFF_FFF0",
                "",
                "VSR[VRT+32] := MEM(EA, 16)"
            ],
            "body": [
                "",
                "",
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFF0 with the sum (RA|0)+(RB).",
                "",
                "The contents of the quadword in storage at address EA are",
                "placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_ld"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Vector Indexed Last",
                    "form": "X",
                    "mnemonic": "lvxl",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "359",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "EA := EA & 0xFFFF_FFFF_FFFF_FFF0",
                "",
                "VSR[VRT+32] := MEM(EA, 16)",
                "",
                "mark_as_not_likely_to_be_needed_again_anytime_soon(EA)"
            ],
            "body": [
                "",
                "",
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFF0 with the sum (RA|0)+(RB).",
                "",
                "The contents of the quadword in storage at address EA are",
                "placed into VSR[VRT+32].",
                "",
                "lvxl provides a hint that the quadword in storage",
                "addressed by EA will probably not be needed again by the",
                "program in the near future.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_ldl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Vector Element Byte Indexed",
                    "form": "X",
                    "mnemonic": "stvebx",
                    "operands": [
                        "VRS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "VRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "135",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "eb := EA.bit[60:63]",
                "",
                "if Big-Endian byte ordering then",
                "  MEM(EA,1) := VSR[VRS+32].byte[eb]",
                "else",
                "  MEM(EA,1) := VSR[VRS+32].byte[15-eb]"
            ],
            "body": [
                "",
                "",
                "Let EA be the sum (RA|0)+(RB).",
                "",
                "Let eb be bits 60:63 of EA.",
                "",
                "If Big-Endian byte ordering is used for the storage access, the",
                "contents of byte eb of VSR[VRS+32] are placed",
                "in the byte in storage at address EA.",
                "",
                "If Little-Endian byte ordering is used for the storage access, the",
                "contents of byte 15-eb of VSR[VRS+32] are",
                "placed in the byte in storage at address EA.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_ste"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Vector Element Halfword Indexed",
                    "form": "X",
                    "mnemonic": "stvehx",
                    "operands": [
                        "VRS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "VRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "167",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "EA := EA & 0xFFFF_FFFF_FFFF_FFFE",
                "eb := EA.bit[60:63]",
                "",
                "if Big-Endian byte ordering then",
                "  MEM(EA,2) := VSR[VRS+32].byte[eb:eb+1]",
                "else",
                "  MEM(EA,2) := VSR[VRS+32][14-eb:15-eb]"
            ],
            "body": [
                "",
                "",
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFFE with the sum (RA|0)+(RB).",
                "",
                "Let eb be bits 60:63 of EA.",
                "",
                "If Big-Endian byte ordering is used for the storage access,",
                "",
                "",
                "",
                "If Little-Endian byte ordering is used for the storage access,",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_ste"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Vector Element Word Indexed",
                    "form": "X",
                    "mnemonic": "stvewx",
                    "operands": [
                        "VRS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "VRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "199",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "EA := EA & 0xFFFF_FFFF_FFFF_FFFC",
                "eb := EA.bit[60:63]",
                "",
                "if Big-Endian byte ordering then",
                "  MEM(EA,4) := VSR[VRS+32].byte[eb:eb+3]",
                "else",
                "  MEM(EA,4) := VSR[VRS+32].byte[12-eb:15-eb]"
            ],
            "body": [
                "",
                "",
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFFC with the sum (RA|0)+(RB).",
                "",
                "Let eb be bits 60:63 of EA.",
                "",
                "If Big-Endian byte ordering is used for the storage access,",
                "",
                "",
                "",
                "If Little-Endian byte ordering is used for the storage access,",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_ste"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Vector Indexed",
                    "form": "X",
                    "mnemonic": "stvx",
                    "operands": [
                        "VRS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "VRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "231",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "EA := EA & 0xFFFF_FFFF_FFFF_FFF0",
                "",
                "MEM(EA, 16) := VSR[VRS+32]"
            ],
            "body": [
                "",
                "",
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFF0 with the sum (RA|0)+(RB).",
                "",
                "The contents of VSR[VRS+32] are placed into the quadword",
                "in storage at address EA.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_st"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store Vector Indexed Last",
                    "form": "X",
                    "mnemonic": "stvxl",
                    "operands": [
                        "VRS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "VRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "487",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "EA := EA & 0xFFFF_FFFF_FFFF_FFF0",
                "",
                "MEM(EA, 16) := VSR[VRS+32]",
                "",
                "mark_as_not_likely_to_be_needed_again_anytime_soon(EA)"
            ],
            "body": [
                "",
                "",
                "Let EA be the result of ANDing 0xFFFF_FFFF_FFFF_FFF0 with the sum (RA|0)+(RB).",
                "",
                "The contents of VSR[VRS+32] are placed into the quadword",
                "in storage at address EA.",
                "",
                "stvxl provides a hint that the quadword in",
                "storage addressed by EA will probably not be needed again",
                "by the program in the near future.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_stl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Vector for Shift Left Indexed",
                    "form": "X",
                    "mnemonic": "lvsl",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "6",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "sh := (((RA=0) ? 0 : GPR[RA]) + GPR[RB]).bit[60:63]",
                "",
                "switch(sh)",
                "  case(0x0): VSR[VRT+32]:=0x000102030405060708090A0B0C0D0E0F",
                "  case(0x1): VSR[VRT+32]:=0x0102030405060708090A0B0C0D0E0F10",
                "  case(0x2): VSR[VRT+32]:=0x02030405060708090A0B0C0D0E0F1011",
                "  case(0x3): VSR[VRT+32]:=0x030405060708090A0B0C0D0E0F101112",
                "  case(0x4): VSR[VRT+32]:=0x0405060708090A0B0C0D0E0F10111213",
                "  case(0x5): VSR[VRT+32]:=0x05060708090A0B0C0D0E0F1011121314",
                "  case(0x6): VSR[VRT+32]:=0x060708090A0B0C0D0E0F101112131415",
                "  case(0x7): VSR[VRT+32]:=0x0708090A0B0C0D0E0F10111213141516",
                "  case(0x8): VSR[VRT+32]:=0x08090A0B0C0D0E0F1011121314151617",
                "  case(0x9): VSR[VRT+32]:=0x090A0B0C0D0E0F101112131415161718",
                "  case(0xA): VSR[VRT+32]:=0x0A0B0C0D0E0F10111213141516171819",
                "  case(0xB): VSR[VRT+32]:=0x0B0C0D0E0F101112131415161718191A",
                "  case(0xC): VSR[VRT+32]:=0x0C0D0E0F101112131415161718191A1B",
                "  case(0xD): VSR[VRT+32]:=0x0D0E0F101112131415161718191A1B1C",
                "  case(0xE): VSR[VRT+32]:=0x0E0F101112131415161718191A1B1C1D",
                "  case(0xF): VSR[VRT+32]:=0x0F101112131415161718191A1B1C1D1E"
            ],
            "body": [
                "",
                "",
                "Let sh be bits 60:63 of the sum of the contents of",
                "GPR[RA], or 0 if RA=0, and the contents of",
                "GPR[RB].",
                "",
                "Let X be the 32-byte value 0x00 || 0x01 || 0x02 || \u00e2\u20ac\u00a6 || 0x1D ||",
                "0x1E || 0x1F.",
                "",
                "Bytes sh to sh+15 of X are placed",
                "into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_xl_len_r"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load Vector for Shift Right Indexed",
                    "form": "X",
                    "mnemonic": "lvsr",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "38",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "sh := (((RA=0) ? 0 : GPR[RA]) + GPR[RB]).bit[60:63]",
                "",
                "switch(sh)",
                "  case(0x0): VSR[VRT+32]:=0x101112131415161718191A1B1C1D1E1F",
                "  case(0x1): VSR[VRT+32]:=0x0F101112131415161718191A1B1C1D1E",
                "  case(0x2): VSR[VRT+32]:=0x0E0F101112131415161718191A1B1C1D",
                "  case(0x3): VSR[VRT+32]:=0x0D0E0F101112131415161718191A1B1C",
                "  case(0x4): VSR[VRT+32]:=0x0C0D0E0F101112131415161718191A1B",
                "  case(0x5): VSR[VRT+32]:=0x0B0C0D0E0F101112131415161718191A",
                "  case(0x6): VSR[VRT+32]:=0x0A0B0C0D0E0F10111213141516171819",
                "  case(0x7): VSR[VRT+32]:=0x090A0B0C0D0E0F101112131415161718",
                "  case(0x8): VSR[VRT+32]:=0x08090A0B0C0D0E0F1011121314151617",
                "  case(0x9): VSR[VRT+32]:=0x0708090A0B0C0D0E0F10111213141516",
                "  case(0xA): VSR[VRT+32]:=0x060708090A0B0C0D0E0F101112131415",
                "  case(0xB): VSR[VRT+32]:=0x05060708090A0B0C0D0E0F1011121314",
                "  case(0xC): VSR[VRT+32]:=0x0405060708090A0B0C0D0E0F10111213",
                "  case(0xD): VSR[VRT+32]:=0x030405060708090A0B0C0D0E0F101112",
                "  case(0xE): VSR[VRT+32]:=0x02030405060708090A0B0C0D0E0F1011",
                "  case(0xF): VSR[VRT+32]:=0x0102030405060708090A0B0C0D0E0F10"
            ],
            "body": [
                "",
                "",
                "Let sh be bits 60:63 of the sum of the contents of",
                "GPR[RA], or 0 if RA=0, and the contents of",
                "GPR[RB].",
                "",
                "Let X be the 32-byte value 0x00 || 0x01 || 0x02 || \u00e2\u20ac\u00a6 || 0x1D ||",
                "0x1E || 0x1F.",
                "",
                "Bytes 16-sh to 31-sh of X are",
                "placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_xst_len_r"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Pack Pixel",
                    "form": "VX",
                    "mnemonic": "vpkpx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "782",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 7",
                "  VSR[VRT+32].hword[i].bit[0]     := vsrc.word[i].bit[7]",
                "  VSR[VRT+32].hword[i].bit[1:5]   := vsrc.word[i].bit[8:12]",
                "  VSR[VRT+32].hword[i].bit[6:10]  := vsrc.word[i].bit[16:20]",
                "  VSR[VRT+32].hword[i].bit[11:15] := vsrc.word[i].bit[24:28]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The contents of word element i of vsrc are",
                "packed to produce a 16-bit value as described below.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into halfword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_packpx"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Pack Signed Halfword Signed Saturate",
                    "form": "VX",
                    "mnemonic": "vpkshss",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "398",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "  VSR[VRT+32].byte[i] := si8_CLAMP(EXTS(vsrc.hword[i]))",
                "end"
            ],
            "body": [
                "",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "The signed integer value in halfword element i of",
                "vsrc is placed into byte element i of",
                "VSR[VRT+32] in signed integer format.",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_packs"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Pack Signed Halfword Unsigned Saturate",
                    "form": "VX",
                    "mnemonic": "vpkshus",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "270",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "  VSR[VRT+32].byte[i] := ui8_CLAMP(EXTS(vsrc.hword[i]))",
                "end"
            ],
            "body": [
                "",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "The signed integer value in halfword element i of",
                "vsrc is placed into byte element i of",
                "VSR[VRT+32] in unsigned integer format.",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_packsu"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Pack Signed Word Signed Saturate",
                    "form": "VX",
                    "mnemonic": "vpkswss",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "462",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 7",
                "  VSR[VRT+32].hword[i] := si16_CLAMP(EXTS(vsrc.word[i]))",
                "end"
            ],
            "body": [
                "",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The signed integer value in word element i of vsrc is placed into halfword element i of VSR[VRT+32] in signed integer format.",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_pack_to_short_fp32",
                "vec_packs"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Pack Signed Word Unsigned Saturate",
                    "form": "VX",
                    "mnemonic": "vpkswus",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "334",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 7",
                "  VSR[VRT+32].hword[i] := ui16_CLAMP(EXTS(vsrc.word[i]))",
                "end"
            ],
            "body": [
                "",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The signed integer value in word element i of vsrc is placed into halfword element i of VSR[VRT+32] in unsigned integer format.",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_packsu"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Pack Signed Doubleword Signed Saturate",
                    "form": "VX",
                    "mnemonic": "vpksdss",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1486",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := si32_CLAMP(EXTS(VSR[VRA+32].dword[0]))",
                "VSR[VRT+32].word[1] := si32_CLAMP(EXTS(VSR[VRA+32].dword[1]))",
                "VSR[VRT+32].word[2] := si32_CLAMP(EXTS(VSR[VRB+32].dword[0]))",
                "VSR[VRT+32].word[3] := si32_CLAMP(EXTS(VSR[VRB+32].dword[1]))"
            ],
            "body": [
                "",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The signed integer value in doubleword element i of",
                "vsrc is placed into word element i of",
                "VSR[VRT+32] in signed integer format.",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_packs"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Pack Signed Doubleword Unsigned Saturate",
                    "form": "VX",
                    "mnemonic": "vpksdus",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1358",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := ui32_CLAMP(EXTS(VSR[VRA+32].dword[0]))",
                "VSR[VRT+32].word[1] := ui32_CLAMP(EXTS(VSR[VRA+32].dword[1]))",
                "VSR[VRT+32].word[2] := ui32_CLAMP(EXTS(VSR[VRB+32].dword[0]))",
                "VSR[VRT+32].word[3] := ui32_CLAMP(EXTS(VSR[VRB+32].dword[1]))"
            ],
            "body": [
                "",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The signed integer value in doubleword element i of",
                "vsrc is placed into word element i of",
                "VSR[VRT+32] in unsigned integer format.",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_packsu"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Pack Unsigned Halfword Unsigned Modulo",
                    "form": "VX",
                    "mnemonic": "vpkuhum",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "14",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "  VSR[VRT+32].byte[i] := vsrc.hword[i].bit[8:15]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "The contents of bits 8:15 of halfword element i of",
                "vsrc are placed into byte element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_pack"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Pack Unsigned Halfword Unsigned Saturate",
                    "form": "VX",
                    "mnemonic": "vpkuhus",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "142",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC then Vector_Unavailable()",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "  VSR[VRT+32].byte[i] := ui8_CLAMP(EXTZ(vsrc.hword[i]))",
                "end"
            ],
            "body": [
                "",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in halfword element i of",
                "vsrc are placed into byte element i of",
                "VSR[VRT+32] in unsigned integer format.",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_packs",
                "vec_packsu"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Pack Unsigned Word Unsigned Modulo",
                    "form": "VX",
                    "mnemonic": "vpkuwum",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "78",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 7",
                "  VSR[VRT+32].hword[i] := vsrc.word[i].bit[16:31]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The contents of bits 16:31 of word element i of",
                "vsrc are placed into halfword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_pack"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Pack Unsigned Word Unsigned Saturate",
                    "form": "VX",
                    "mnemonic": "vpkuwus",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "206",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 7",
                "  VSR[VRT+32].hword[i] := ui16_CLAMP(EXTZ(vsrc.word[i]))",
                "end"
            ],
            "body": [
                "",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in word element i of",
                "vsrc is placed into halfword element i of",
                "VSR[VRT+32] in unsigned integer format.",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_packs",
                "vec_packsu"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Pack Unsigned Doubleword Unsigned Modulo",
                    "form": "VX",
                    "mnemonic": "vpkudum",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1102",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := VSR[VRA+32].dword[0].bit[32:63]",
                "VSR[VRT+32].word[1] := VSR[VRA+32].dword[1].bit[32:63]",
                "VSR[VRT+32].word[2] := VSR[VRB+32].dword[0].bit[32:63]",
                "VSR[VRT+32].word[3] := VSR[VRB+32].dword[1].bit[32:63]"
            ],
            "body": [
                "",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The contents of bits 32:63 of doubleword element i of",
                "vsrc are placed into word element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_pack"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Pack Unsigned Doubleword Unsigned Saturate",
                    "form": "VX",
                    "mnemonic": "vpkudus",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1230",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := ui32_CLAMP(EXTZ(VSR[VRA+32].dword[0]))",
                "VSR[VRT+32].word[1] := ui32_CLAMP(EXTZ(VSR[VRA+32].dword[1]))",
                "VSR[VRT+32].word[2] := ui32_CLAMP(EXTZ(VSR[VRB+32].dword[0]))",
                "VSR[VRT+32].word[3] := ui32_CLAMP(EXTZ(VSR[VRB+32].dword[1]))"
            ],
            "body": [
                "",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in doubleword element i of",
                "vsrc are placed into halfword element i of",
                "VSR[VRT+32] in unsigned integer format.",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_packs",
                "vec_packsu"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Unpack High Signed Byte",
                    "form": "VX",
                    "mnemonic": "vupkhsb",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "526",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  VSR[VRT+32].hword[i] := EXTS16(VSR[VRB+32].byte[i])",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The signed integer value in byte element i of VSR[VRB+32] is sign-extended and placed into halfword element",
                "i in VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_unpackh",
                "vec_unpackl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Unpack Low Signed Byte",
                    "form": "VX",
                    "mnemonic": "vupklsb",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "654",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  VSR[VRT+32].hword[i] := EXTS16(VSR[VRB+32].byte[i+8])",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The signed integer value in byte element i+8 of",
                "VSR[VRB+32] is sign-extended and placed into halfword",
                "element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_unpackh",
                "vec_unpackl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Unpack High Signed Halfword",
                    "form": "VX",
                    "mnemonic": "vupkhsh",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "590",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := EXTS32(VSR[VRB+32].hword[0])",
                "VSR[VRT+32].word[1] := EXTS32(VSR[VRB+32].hword[1])",
                "VSR[VRT+32].word[2] := EXTS32(VSR[VRB+32].hword[2])",
                "VSR[VRT+32].word[3] := EXTS32(VSR[VRB+32].hword[3])"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The signed integer value in halfword element i of",
                "VSR[VRB+32] is sign-extended and placed into word element",
                "i in VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_unpackh",
                "vec_unpackl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Unpack Low Signed Halfword",
                    "form": "VX",
                    "mnemonic": "vupklsh",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "718",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := EXTS32(VSR[VRB+32].hword[4])",
                "VSR[VRT+32].word[1] := EXTS32(VSR[VRB+32].hword[5])",
                "VSR[VRT+32].word[2] := EXTS32(VSR[VRB+32].hword[6])",
                "VSR[VRT+32].word[3] := EXTS32(VSR[VRB+32].hword[7])"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The signed integer value in halfword element i+4 of",
                "VSR[VRB+32] is sign-extended to produce a signed-integer",
                "word and placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_unpackh",
                "vec_unpackl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Unpack High Signed Word",
                    "form": "VX",
                    "mnemonic": "vupkhsw",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1614",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].dword[0] := EXTS64(VSR[VRB+32].word[0])",
                "VSR[VRT+32].dword[1] := EXTS64(VSR[VRB+32].word[1])"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The signed integer value in word element i of VSR[VRB+32] is sign-extended and placed into doubleword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_unpackh",
                "vec_unpackl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Unpack Low Signed Word",
                    "form": "VX",
                    "mnemonic": "vupklsw",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1742",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].dword[0] := EXTS64(VSR[VRB+32].word[2])",
                "VSR[VRT+32].dword[1] := EXTS64(VSR[VRB+32].word[3])"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The signed integer value in word element i+2 of",
                "VSR[VRB+32] is sign-extended and placed into doubleword",
                "element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_unpackh",
                "vec_unpackl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Unpack High Pixel",
                    "form": "VX",
                    "mnemonic": "vupkhpx",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "846",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src := VSR[VRB+32].hword[i]",
                "",
                "  VSR[VRT+32].word[i].byte[0] := EXTS8(src.bit[0])",
                "  VSR[VRT+32].word[i].byte[1] := EXTZ8(src.bit[1:5])",
                "  VSR[VRT+32].word[i].byte[2] := EXTZ8(src.bit[6:10])",
                "  VSR[VRT+32].word[i].byte[3] := EXTZ8(src.bit[11:15])",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The contents of halfword element i of VSR[VRB+32] are unpacked as follows.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed in word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_unpackh",
                "vec_unpackl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Unpack Low Pixel",
                    "form": "VX",
                    "mnemonic": "vupklpx",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "974",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src := VSR[VRB+32].hword[i+4]",
                "",
                "  VSR[VRT+32].word[i].byte[0] := EXTS8(src.bit[0])",
                "  VSR[VRT+32].word[i].byte[1] := EXTZ8(src.bit[1:5])",
                "  VSR[VRT+32].word[i].byte[2] := EXTZ8(src.bit[6:10])",
                "  VSR[VRT+32].word[i].byte[3] := EXTZ8(src.bit[11:15])",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The contents of halfword element i+4 of VSR[VRB+32] are unpacked as follows.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed in word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_unpackh",
                "vec_unpackl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Merge High Byte",
                    "form": "VX",
                    "mnemonic": "vmrghb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "12",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  VSR[VRT+32].hword[i].byte[0] := VSR[VRA+32].byte[i]",
                "  VSR[VRT+32].hword[i].byte[1] := VSR[VRB+32].byte[i]",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The contents of byte element i of VSR[VRA+32]",
                "are placed into byte element 2i of VSR[VRT+32].",
                "",
                "",
                "The contents of byte element i of VSR[VRB+32]",
                "are placed into byte element 2i+1 of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mergeh",
                "vec_mergel"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Merge Low Byte",
                    "form": "VX",
                    "mnemonic": "vmrglb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "268",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  VSR[VRT+32].hword[i].byte[0] := VSR[VRA+32].byte[i+8]",
                "  VSR[VRT+32].hword[i].byte[1] := VSR[VRB+32].byte[i+8]",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The contents of byte element i+8 of VSR[VRA+32] are",
                "placed into byte element 2i of VSR[VRT+32].",
                "",
                "",
                "The contents of byte element i+8 of VSR[VRB+32] are",
                "placed into byte element 2i+1 of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mergeh",
                "vec_mergel"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Merge High Halfword",
                    "form": "VX",
                    "mnemonic": "vmrghh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "76",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  VSR[VRT+32].word[i].hword[0] := VSR[VRA+32].hword[i]",
                "  VSR[VRT+32].word[i].hword[1] := VSR[VRB+32].hword[i]",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The contents of halfword element i of VSR[VRA+32] are placed into halfword element 2i of VSR[VRT+32].",
                "",
                "",
                "The contents of halfword element i of VSR[VRB+32] are placed into halfword element 2i+1 of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mergeh",
                "vec_mergel"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Merge Low Halfword",
                    "form": "VX",
                    "mnemonic": "vmrglh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "332",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  VSR[VRT+32].word[i].hword[0] := VSR[VRA+32].hword[i+4]",
                "  VSR[VRT+32].word[i].hword[1] := VSR[VRB+32].hword[i+4]",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The contents of halfword element i+4 of VSR[VRA+32] are placed into halfword element 2i of VSR[VRT+32].",
                "",
                "",
                "The contents of halfword element i+4 of VSR[VRB+32] are placed into halfword element 2i+1 of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mergeh",
                "vec_mergel"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Merge High Word",
                    "form": "VX",
                    "mnemonic": "vmrghw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "140",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := VSR[VRA+32].word[0]",
                "VSR[VRT+32].word[1] := VSR[VRB+32].word[0]",
                "VSR[VRT+32].word[2] := VSR[VRA+32].word[1]",
                "VSR[VRT+32].word[3] := VSR[VRB+32].word[1]"
            ],
            "body": [
                "",
                "",
                "The contents of word element 0 of VSR[VRA+32] are placed",
                "into word element 0 of VSR[VRT+32].",
                "",
                "The contents of word element 0 of VSR[VRB+32] are placed",
                "into word element 1 of VSR[VRT+32].",
                "",
                "The contents of word element 1 of VSR[VRA+32] are placed",
                "into word element 2 of VSR[VRT+32].",
                "",
                "The contents of word element 1 of VSR[VRB+32] are placed",
                "into word element 3 of VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mergeh",
                "vec_mergel"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Merge Low Word",
                    "form": "VX",
                    "mnemonic": "vmrglw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "396",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := VSR[VRA+32].word[2]",
                "VSR[VRT+32].word[1] := VSR[VRB+32].word[2]",
                "VSR[VRT+32].word[2] := VSR[VRA+32].word[3]",
                "VSR[VRT+32].word[3] := VSR[VRB+32].word[3]"
            ],
            "body": [
                "",
                "",
                "The contents of word element 2 of VSR[VRA+32] are placed",
                "into word element 0 of VSR[VRT+32].",
                "",
                "The contents of word element 2 of VSR[VRB+32] are placed",
                "into word element 1 of VSR[VRT+32].",
                "",
                "The contents of word element 3 of VSR[VRA+32] are placed",
                "into word element 2 of VSR[VRT+32].",
                "",
                "The contents of word element 3 of VSR[VRB+32] are placed",
                "into word element 3 of VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mergeh",
                "vec_mergel"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Merge Even Word",
                    "form": "VX",
                    "mnemonic": "vmrgew",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1932",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := VSR[VRA+32].word[0]",
                "VSR[VRT+32].word[1] := VSR[VRB+32].word[0]",
                "VSR[VRT+32].word[2] := VSR[VRA+32].word[2]",
                "VSR[VRT+32].word[3] := VSR[VRB+32].word[2]"
            ],
            "body": [
                "",
                "",
                "The contents of word element 0 of VSR[VRA+32] are placed",
                "into word element 0 of VSR[VRT+32].",
                "",
                "The contents of word element 0 of VSR[VRB+32] are placed",
                "into word element 1 of VSR[VRT+32].",
                "",
                "The contents of word element 2 of VSR[VRA+32] are placed",
                "into word element 2 of VSR[VRT+32].",
                "",
                "The contents of word element 2 of VSR[VRB+32] are placed",
                "into word element 3 of VSR[VRT+32].",
                "",
                "vmrgew is treated as a Vector",
                "instruction in terms of resource availability.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_float2",
                "vec_mergee",
                "vec_mergeo",
                "vec_pack",
                "vec_signed2",
                "vec_unsigned2"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Merge Odd Word",
                    "form": "VX",
                    "mnemonic": "vmrgow",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1676",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].word[0] := VSR[VRA+32].word[1]",
                "VSR[VRT+32].word[1] := VSR[VRB+32].word[1]",
                "VSR[VRT+32].word[2] := VSR[VRA+32].word[3]",
                "VSR[VRT+32].word[3] := VSR[VRB+32].word[3]"
            ],
            "body": [
                "",
                "",
                "The contents of word element 1 of VSR[VRA+32] are placed",
                "into word element 0 of VSR[VRT+32].",
                "",
                "The contents of word element 1 of VSR[VRB+32] are placed",
                "into word element 1 of VSR[VRT+32].",
                "",
                "The contents of word element 3 of VSR[VRA+32] are placed",
                "into word element 2 of VSR[VRT+32].",
                "",
                "The contents of word element 3 of VSR[VRB+32] are placed",
                "into word element 3 of VSR[VRT+32].",
                "",
                "vmrgow is treated as a Vector",
                "instruction in terms of resource availability.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_float2",
                "vec_mergee",
                "vec_mergeo",
                "vec_pack",
                "vec_signed2",
                "vec_unsigned2"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Splat Byte",
                    "form": "VX",
                    "mnemonic": "vspltb",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "524",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "b := UIM || 0b000",
                "do i = 0 to 15",
                "  VSR[VRT+32].byte[i] := VSR[VRB+32].bit[b:b+7]",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "The contents of byte element UIM in VSR[VRB+32] are placed into byte element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_splat",
                "vec_splats"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Splat Halfword",
                    "form": "VX",
                    "mnemonic": "vsplth",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "UIM",
                    "size": "3"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "588",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "b := UIM || 0b0000",
                "do i = 0 to 7",
                "  VSR[VRT+32].hword[i] := VSR[VRB+32].bit[b:b+15]",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The contents of halfword element UIM in VSR[VRB+32] are placed into halfword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_splat",
                "vec_splats"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Splat Word",
                    "form": "VX",
                    "mnemonic": "vspltw",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "UIM",
                    "size": "2"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "652",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "b := UIM || 0b00000",
                "do i = 0 to 3",
                "  VSR[VRT+32].word[i] := VSR[VRB+32].bit[b:b+31]",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The contents of word element UIM in VSR[VRB+32] are placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sums"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Splat Immediate Signed Byte",
                    "form": "VX",
                    "mnemonic": "vspltisb",
                    "operands": [
                        "VRT",
                        "SIM"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "SIM",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "780",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  VSR[VRT+32].byte[i] := EXTS8(SIM, 8)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "The value of the SIM field, sign-extended to 8 bits, is",
                "placed into byte element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_abss",
                "vec_splat_s8",
                "vec_splat_u8"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Splat Immediate Signed Halfword",
                    "form": "VX",
                    "mnemonic": "vspltish",
                    "operands": [
                        "VRT",
                        "SIM"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "SIM",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "844",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  VSR[VRT+32].hword[i] := EXTS16(SIM, 16)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The value of the SIM field, sign-extended to 16 bits, is",
                "placed into halfword element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_abss",
                "vec_splat_s16",
                "vec_splat_u16"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Splat Immediate Signed Word",
                    "form": "VX",
                    "mnemonic": "vspltisw",
                    "operands": [
                        "VRT",
                        "SIM"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "SIM",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "908",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  VSR[VRT+32].word[i] := EXTS32(SIM, 32)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The value of the SIM field, sign-extended to 32 bits, is",
                "placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_abs",
                "vec_abss",
                "vec_adde",
                "vec_addec",
                "vec_nabs",
                "vec_neg",
                "vec_rlnm",
                "vec_splat_s32",
                "vec_splat_u32",
                "vec_sube",
                "vec_subec"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Permute",
                    "form": "VA",
                    "mnemonic": "vperm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "43",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "  index := VSR[VRC+32].byte[i].bit[3:7]",
                "  VSR[VRT+32].byte[i] := src.byte[index]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let the source vector be the concatenation of the contents of",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let index be the value specified by bits 3:7 of byte",
                "element i of VSR[VRC+32].",
                "",
                "",
                "The contents of byte element index of src are",
                "placed into byte element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract_fp32_from_shorth",
                "vec_extract_fp32_from_shortl",
                "vec_mul",
                "vec_perm",
                "vec_reve",
                "vec_xl_len_r",
                "vec_xst_len_r"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Permute Right-indexed",
                    "form": "VA",
                    "mnemonic": "vpermr",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "59",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "do i = 0 to 15",
                "  index := VSR[VRC+32].byte[i].bit[3:7]",
                "  VSR[VRT+32].byte[i] := src.byte[31-index]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let the source vector be the concatenation of the contents of",
                "VSR[VRA+32] followed by the contents of VSR[VRB+32].",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let index be the value specified by bits 3:7 of byte",
                "element i of VSR[VRC+32].",
                "",
                "",
                "The contents of byte element 31-index of src",
                "are placed into byte element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract_fp32_from_shorth",
                "vec_extract_fp32_from_shortl",
                "vec_perm",
                "vec_reve"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Select",
                    "form": "VA",
                    "mnemonic": "vsel",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "42",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := VSR[VRA+32]",
                "src2 := VSR[VRB+32]",
                "mask := VSR[VRC+32]",
                "",
                "VSR[VRT+32] := (src1 & ~mask) | (src2 & mask)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the contents of VSR[VRA+32].",
                "",
                "Let src2 be the contents of VSR[VRB+32].",
                "",
                "Let mask be the contents of VSR[VRC+32].",
                "",
                "The value, (src1mask)|(src2mask), is",
                "placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Left Double by Bit Immediate",
                    "form": "VN",
                    "mnemonic": "vsldbi",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "SH"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "2"
                },
                {
                    "name": "SH",
                    "size": "3"
                },
                {
                    "name": "22",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32]   := vsrc.bit[SH:SH+127]"
            ],
            "body": [
                "",
                "",
                "Let vsrc be the contents of VSR[VRA+32]",
                "concatenated with the contents of VSR[VRB+32].",
                "",
                "The contents of bits SH:SH+127 of vsrc are",
                "placed into VSR[VRT+32].",
                "",
                "SH can be any integer value between 0 and 7.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Left Double by Octet Immediate",
                    "form": "VA",
                    "mnemonic": "vsldoi",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "SHB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "SHB",
                    "size": "4"
                },
                {
                    "name": "44",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32] := src.byte[SHB:SHB+15]"
            ],
            "body": [
                "",
                "",
                "Let vsrc be the contents of VSR[VRA+32]",
                "concatenated with the contents of VSR[VRB+32].",
                "",
                "Bytes SHB:SHB+15 of vsrc are placed into",
                "VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_floate",
                "vec_floato",
                "vec_signede",
                "vec_signedo",
                "vec_sld",
                "vec_sum2s",
                "vec_sums",
                "vec_unsignede",
                "vec_unsignedo"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Right Double by Bit Immediate",
                    "form": "VN",
                    "mnemonic": "vsrdbi",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "SH"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "2"
                },
                {
                    "name": "SH",
                    "size": "3"
                },
                {
                    "name": "22",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32]   := vsrc.bit[128-SH:255-SH]"
            ],
            "body": [
                "",
                "",
                "Let vsrc be the contents of VSR[VRA+32]",
                "concatenated with the contents of VSR[VRB+32].",
                "",
                "The contents of bits 128-SH:255-SH of vsrc",
                "are placed into VSR[VRT+32].",
                "",
                "SH can be any integer value between 0 and 7.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Left",
                    "form": "VX",
                    "mnemonic": "vsl",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "452",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "shb := VSR[VRB+32].bit[125:127]",
                "",
                "t := 1",
                "do i = 0 to 14",
                "  t := t & (VSR[VRB+32].byte[i].bit[5:7] = sh)",
                "end",
                "if t=1 then",
                "  VSR[VRT+32] := VSR[VRA+32] << sh",
                "else",
                "  VSR[VRT+32] := UNDEFINED"
            ],
            "body": [
                "",
                "",
                "The contents of VSR[VRA+32] are shifted left by the",
                "number of bits specified in bits 125:127 of VSR[VRB+32].",
                "",
                "",
                "",
                "The result is place into VSR[VRT+32], except if, for any",
                "byte element in VSR[VRB+32], the low-order 3 bits are not",
                "equal to the shift amount, then VSR[VRT+32] is undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sll"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Right",
                    "form": "VX",
                    "mnemonic": "vsr",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "708",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "sh := VSR[VRB+32].bit[125:127]",
                "",
                "t := 1",
                "do i = 0 to 14",
                "  t := t & (VSR[VRB+32].byte[i].bit[5:7]=sh)",
                "end",
                "if t=1 then",
                "  VSR[VRT+32] := CHOP128(EXTZ(VSR[VRA+32]) >> sh)",
                "else",
                "  VSR[VRT+32] := UNDEFINED"
            ],
            "body": [
                "",
                "",
                "The contents of VSR[VRA+32] are shifted right by the",
                "number of bits specified in bits 125:127 of VSR[VRB+32].",
                "",
                "",
                "",
                "The result is place into VSR[VRT+32], except if, for any",
                "byte element in VSR[VRB+32], the low-order 3 bits are not",
                "equal to the shift amount, then VSR[VRT+32] is undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_srl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Left by Octet",
                    "form": "VX",
                    "mnemonic": "vslo",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1036",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "shb := VSR[VRB+32].bit[121:124] << 3",
                "",
                "VSR[VRT+32] := VSR[VRA+32] << shb"
            ],
            "body": [
                "",
                "",
                "The contents of VSR[VRA+32] are shifted left by the",
                "number of bytes specified in bits 121:124 of VSR[VRB+32].",
                "",
                "",
                "",
                "The result is placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract",
                "vec_slo"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Right by Octet",
                    "form": "VX",
                    "mnemonic": "vsro",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1100",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "shb := VSR[VRB+32].bit[121:124] << 3",
                "",
                "VSR[VRT+32] := VSR[VRA+32] >> shb"
            ],
            "body": [
                "",
                "",
                "The contents of VSR[VRA+32] are shifted right by the",
                "number of bytes specified in bits 121:124 of VSR[VRB+32].",
                "",
                "",
                "",
                "The result is placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sro"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Left Variable",
                    "form": "VX",
                    "mnemonic": "vslv",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1860",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable_Interrupt()",
                "",
                "vsrc.byte[0:15] := VSR[VRA+32]",
                "vsrc.byte[16]   := 0x00",
                "",
                "do i = 0 to 15",
                "  sh := VSR[VRB+32].byte[i].bit[5:7]",
                "  VSR[VRT+32].byte[i] := src.byte[i:i+1].bit[sh:sh+7]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let bytes 0:15 of vsrc be the contents of VSR[VRA+32].",
                "",
                "Let byte 16 of vsrc be the value 0x00.",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let sh be the value in bits 5:7 of byte element",
                "i of VSR[VRB+32].",
                "",
                "",
                "The contents of bits sh:sh+7 of the halfword in byte",
                "elements i:i+1 of vsrc are placed into byte",
                "element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_slv"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Right Variable",
                    "form": "VX",
                    "mnemonic": "vsrv",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1796",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable_Interrupt()",
                "",
                "vsrc.byte[0]   := 0x00",
                "vsrc.byte[1:16] := VSR[VRA+32]",
                "",
                "do i = 0 to 15",
                "  sh := VSR[VRB+32].byte[i].bit[5:7]",
                "  VSR[VRT+32].byte[i] := src.byte[i:i+1].bit[8-sh:15-sh]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let bytes 1:16 of vsrc be the contents of VSR[VRA+32].",
                "",
                "Let byte 0 of vsrc be the value 0x00.",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let sh be the value in bits 5:7 of byte element",
                "i of VSR[VRB+32].",
                "",
                "",
                "The contents of bits 8-sh:15-sh of the halfword in byte",
                "elements i:i+1 of vsrc are placed into byte",
                "element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_srv"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Unsigned Byte to VSR using immediate-specified index",
                    "form": "VX",
                    "mnemonic": "vextractub",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "525",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src := VSR[VRB+32].byte[UIM]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(src)",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "The contents of byte element UIM of VSR[VRB+32] are placed into bits 56:63 of VSR[VRT+32].",
                "The contents of the remaining byte elements of VSR[VRT+32] are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Unsigned Halfword to VSR using immediate-specified index",
                    "form": "VX",
                    "mnemonic": "vextractuh",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "589",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src := VSR[VRB+32].byte[UIM:UIM+1]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(src)",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "The contents of byte elements UIM:UIM+1 of VSR[VRB+32] are placed into halfword element 3 of VSR[VRT+32].",
                "The contents of the remaining halfword elements of VSR[VRT+32] are set to 0.",
                "",
                "If the value of UIM is greater than 14, the results are",
                "undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Unsigned Word to VSR using immediate-specified index",
                    "form": "VX",
                    "mnemonic": "vextractuw",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "653",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src := VSR[VRB+32].byte[UIM:UIM+3]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(src)",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "The contents of byte elements UIM:UIM+3 of VSR[VRB+32] are placed into word element 1 of VSR[VRT+32].",
                "The contents of the remaining word elements of VSR[VRT+32] are set to 0.",
                "",
                "If the value of UIM is greater than 12, the results are",
                "undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Doubleword to VSR using immediate-specified index",
                    "form": "VX",
                    "mnemonic": "vextractd",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "717",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src := VSR[VRB+32].byte[UIM:UIM+7]",
                "",
                "VSR[VRT+32].dword[0] := src",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "The contents of byte elements UIM:UIM+7 of VSR[VRB+32]  are placed into VSR[VRT+32].",
                "The contents of doubleword element 1 of VSR[VRT+32] are",
                "set to 0.",
                "",
                "If the value of UIM is greater than 8, the results are",
                "undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Unsigned Byte to GPR using GPR-specified Left-Index",
                    "form": "VX",
                    "mnemonic": "vextublx",
                    "operands": [
                        "RT",
                        "RA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1549",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[index])"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of byte element index of VSR[VRB+32] are placed into bits 56:63 of GPR[RT].",
                "",
                "The contents of bits 0:55 of GPR[RT] are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Unsigned Byte to GPR using GPR-specified Right-Index",
                    "form": "VX",
                    "mnemonic": "vextubrx",
                    "operands": [
                        "RT",
                        "RA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1805",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[15-index])"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of byte element 15-index of VSR[VRB+32] are placed into bits 56:63 of GPR[RT].",
                "",
                "The contents of bits 0:55 of GPR[RT] are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Unsigned Halfword to GPR using GPR-specified Left-Index",
                    "form": "VX",
                    "mnemonic": "vextuhlx",
                    "operands": [
                        "RT",
                        "RA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1613",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[index:index+1])"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of byte elements index:index+1 of VSR[VRB+32] are placed into bits 48:63 of GPR[RT].",
                "",
                "The contents of bits 0:47 of GPR[RT] are set to 0.",
                "",
                "If the value of index is greater than 14, the results are",
                "undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Unsigned Halfword to GPR using GPR-specified Right-Index",
                    "form": "VX",
                    "mnemonic": "vextuhrx",
                    "operands": [
                        "RT",
                        "RA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1869",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[14-index:15-index])"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of byte elements 14-index:15-index of",
                "VSR[VRB+32] are placed into bits 48:63 of GPR[RT].",
                "",
                "The contents of bits 0:47 of GPR[RT] are set to 0.",
                "",
                "If the value of index is greater than 14, the results are",
                "undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Unsigned Word to GPR using GPR-specified Left-Index",
                    "form": "VX",
                    "mnemonic": "vextuwlx",
                    "operands": [
                        "RT",
                        "RA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1677",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[index:index+3])"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of byte elements index:index+3 of VSR[VRB+32] are placed into bits 32:63 of GPR[RT].",
                "",
                "The contents of bits 0:31 of GPR[RT] are set to 0.",
                "",
                "If the value of index is greater than 12, the results are",
                "undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Unsigned Word to GPR using GPR-specified Right-Index",
                    "form": "VX",
                    "mnemonic": "vextuwrx",
                    "operands": [
                        "RT",
                        "RA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1933",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "index := GPR[RA].bit[60:63]",
                "GPR[RT] := EXTZ64(VSR[VRB+32].byte[12-index:15-index])"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of byte elements index:index+3 of VSR[VRB+32] are placed into bits 32:63 of GPR[RT].",
                "",
                "The contents of bits 0:31 of GPR[RT] are set to 0.",
                "",
                "If the value of index is greater than 12, the results are",
                "undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Double Unsigned Byte to VSR using GPR-specified Left-Index",
                    "form": "VA",
                    "mnemonic": "vextdubvlx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "RC"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "24",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(vsrc.byte[index])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[VRA+32] and VSR[VRB+32].",
                "",
                "The contents of byte element index of vsrc",
                "are zero-extended and placed into doubleword 0 of VSR[VRT+32].",
                "",
                "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Double Unsigned Byte to VSR using GPR-specified Right-Index",
                    "form": "VA",
                    "mnemonic": "vextdubvrx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "RC"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "25",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(vsrc.byte[31-index])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[VRA+32] and VSR[VRB+32].",
                "",
                "The contents of byte element 31-index of vsrc",
                "are zero-extended and placed into doubleword 0 of VSR[VRT+32].",
                "",
                "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Double Unsigned Halfword to VSR using GPR-specified Left-Index",
                    "form": "VA",
                    "mnemonic": "vextduhvlx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "RC"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "26",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(vsrc.byte[index:index+1])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[VRA+32] and VSR[VRB+32].",
                "",
                "The contents of byte elements index:index+1 of vsrc are zero-extended and placed into doubleword 0 of VSR[VRT+32].",
                "",
                "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
                "",
                "If index is greater than 30, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Double Unsigned Halfword to VSR using GPR-specified Right-Index",
                    "form": "VA",
                    "mnemonic": "vextduhvrx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "RC"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "27",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "vsrc.qword[0] := VSR[VRA+32]",
                "vsrc.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(vsrc.byte[30-index:31-index])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[VRA+32] and VSR[VRB+32].",
                "",
                "The contents of byte elements 30-index:31-index of",
                "vsrc are zero-extended and placed into doubleword 0 of",
                "VSR[VRT+32].",
                "",
                "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
                "",
                "If index is greater than 30, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Double Unsigned Word to VSR using GPR-specified Left-Index",
                    "form": "VA",
                    "mnemonic": "vextduwvlx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "RC"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "28",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "src.qword[0] := VSR[VRA+32]",
                "src.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(src.byte[index:index+3])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "",
                "Let src be the concatenation of the contents of",
                "VSR[VRA+32] and VSR[VRB+32].",
                "",
                "The contents of byte elements index:index+3 of src are zero-extended and placed into doubleword 0 of VSR[VRT+32].",
                "",
                "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
                "",
                "If index is greater than 28, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Double Unsigned Word to VSR using GPR-specified Right-Index",
                    "form": "VA",
                    "mnemonic": "vextduwvrx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "RC"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "29",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "src.qword[0] := VSR[VRA+32]",
                "src.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := EXTZ64(src.byte[28-index:31-index])",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "",
                "Let src be the concatenation of the contents of",
                "VSR[VRA+32] and VSR[VRB+32].",
                "",
                "The contents of byte elements 28-index:31-index of",
                "src are zero-extended and placed into doubleword 0 of",
                "VSR[VRT+32].",
                "",
                "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
                "",
                "If index is greater than 28, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Double Doubleword to VSR using GPR-specified Left-Index",
                    "form": "VA",
                    "mnemonic": "vextddvlx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "RC"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "30",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "src.qword[0] := VSR[VRA+32]",
                "src.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := src.byte[index:index+7]",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "",
                "Let src be the concatenation of the contents of",
                "VSR[VRA+32] and VSR[VRB+32].",
                "",
                "The contents of byte elements index:index+7 of src are placed into doubleword 0 of VSR[VRT+32].",
                "",
                "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
                "",
                "If index is greater than 24, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Double Doubleword to VSR using GPR-specified Right-Index",
                    "form": "VA",
                    "mnemonic": "vextddvrx",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "RC"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RC",
                    "size": "5"
                },
                {
                    "name": "31",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RC].bit[59:63]",
                "src.qword[0] := VSR[VRA+32]",
                "src.qword[1] := VSR[VRB+32]",
                "",
                "VSR[VRT+32].dword[0] := src.byte[24-index:31-index]",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 59:63 of GPR[RC].",
                "",
                "Let src be the concatenation of the contents of",
                "VSR[VRA+32] and VSR[VRB+32].",
                "",
                "The contents of byte elements 24-index:31-index of src are placed into doubleword 0 of",
                "VSR[VRT+32].",
                "",
                "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
                "",
                "If index is greater than 24, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Byte from VSR using immediate-specified index",
                    "form": "VX",
                    "mnemonic": "vinsertb",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "781",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].byte[UIM] := VSR[VRB+32].byte[7]"
            ],
            "body": [
                "",
                "",
                "The contents of byte element 7 of VSR[VRB+32]",
                "are placed into byte element UIM of VSR[VRT+32].",
                "The contents of the remaining byte elements of VSR[VRT+32] are not modified.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_insert"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Halfword from VSR using immediate-specified index",
                    "form": "VX",
                    "mnemonic": "vinserth",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "845",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].byte[UIM:UIM+1] := VSR[VRB+32].hword[3]"
            ],
            "body": [
                "",
                "",
                "The contents of halfword element 3 of VSR[VRB+32] are placed into byte elements UIM:UIM+1 of",
                "VSR[VRT+32].",
                "The contents of the remaining byte elements of VSR[VRT+32] are not modified.",
                "",
                "If the value of UIM is greater than 14, the results are",
                "undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_insert"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Word from VSR using immediate-specified index",
                    "form": "VX",
                    "mnemonic": "vinsertw",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "909",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].byte[UIM:UIM+3] := VSR[VRB+32].word[1]"
            ],
            "body": [
                "",
                "",
                "The contents of word element 1 of VSR[VRB+32]",
                "are placed into byte elements UIM:UIM+3 of VSR[VRT+32].",
                "The contents of the remaining byte elements of VSR[VRT+32] are not modified.",
                "",
                "If the value of UIM is greater than 12, the results are",
                "undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Doubleword from VSR using immediate-specified index",
                    "form": "VX",
                    "mnemonic": "vinsertd",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "973",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32].byte[UIM:UIM+7] := VSR[VRB+32].dword[0]"
            ],
            "body": [
                "",
                "",
                "The contents of doubleword element 0 of VSR[VRB+32] are placed into byte elements UIM:UIM+7 of",
                "VSR[VRT+32].",
                "The contents of the remaining byte elements of VSR[VRT+32] are not modified.",
                "",
                "If the value of UIM is greater than 8, the results are",
                "undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Byte from GPR using GPR-specified Left-Index",
                    "form": "VX",
                    "mnemonic": "vinsblx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "527",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[index] := GPR[RB].bit[56:63]"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of bits 56:63 of GPR[RB] are placed into",
                "byte element index of VSR[VRT+32].",
                "",
                "All other byte elements of VSR[VRT+32] are not modified.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Byte from GPR using GPR-specified Right-Index",
                    "form": "VX",
                    "mnemonic": "vinsbrx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "783",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[15-index] := GPR[RB].bit[56:63]"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of bits 56:63 of GPR[RB] are placed into",
                "byte element 15-index of VSR[VRT+32].",
                "",
                "All other byte elements of VSR[VRT+32] are not modified.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Halfword from GPR using GPR-specified Left-Index",
                    "form": "VX",
                    "mnemonic": "vinshlx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "591",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[index:index+1] := GPR[RB].bit[48:63]"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of bits 48:63 of GPR[RB] are placed into",
                "byte elements index:index+1 of VSR[VRT+32].",
                "",
                "If index is greater than 14, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Halfword from GPR using GPR-specified Right-Index",
                    "form": "VX",
                    "mnemonic": "vinshrx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "847",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[14-index:15-index] := GPR[RB].bit[48:63]"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of bits 48:63 of GPR[RB] are placed into",
                "byte elements 14-index:15-index of VSR[VRT+32].",
                "",
                "If index is greater than 14, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Word from GPR using GPR-specified Left-Index",
                    "form": "VX",
                    "mnemonic": "vinswlx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "655",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[index:index+3] := GPR[RB].bit[32:63]"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of bits 32:63 of GPR[RB] are placed into",
                "byte elements index:index+3 of VSR[VRT+32].",
                "",
                "All other byte elements of VSR[VRT+32] are not modified.",
                "",
                "If index is greater than 12, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Word from GPR using GPR-specified Right-Index",
                    "form": "VX",
                    "mnemonic": "vinswrx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "911",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[12-index:15-index] := GPR[RB].bit[32:63]"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of bits 32:63 of GPR[RB] are placed into",
                "byte elements 12-index:15-index of VSR[VRT+32].",
                "",
                "All other byte elements of VSR[VRT+32] are not modified.",
                "",
                "If index is greater than 12, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Doubleword from GPR using GPR-specified Left-Index",
                    "form": "VX",
                    "mnemonic": "vinsdlx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "719",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[index:index+7] := GPR[RB]"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of GPR[RB] are placed into byte elements",
                "index:index+7 of VSR[VRT+32].",
                "",
                "All other byte elements of VSR[VRT+32] are not modified.",
                "",
                "If index is greater than 8, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Doubleword from GPR using GPR-specified Right-Index",
                    "form": "VX",
                    "mnemonic": "vinsdrx",
                    "operands": [
                        "VRT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "975",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[8-index:15-index] := GPR[RB]"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of GPR[RB] are placed into byte elements",
                "8-index:15-index of VSR[VRT+32].",
                "",
                "All other byte elements of VSR[VRT+32] are not modified.",
                "",
                "If index is greater than 8, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Word from GPR using immediate-specified index",
                    "form": "VX",
                    "mnemonic": "vinsw",
                    "operands": [
                        "VRT",
                        "RB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "IMM",
                    "size": "4"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "207",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32].byte[UIM:UIM+3] := GPR[RB].bit[32:63]"
            ],
            "body": [
                "",
                "",
                "The contents of bits 32:63 of GPR[RB] are placed into",
                "byte elements UIM:UIM+3 of VSR[VRT+32].",
                "",
                "All other byte elements of VSR[VRT+32] are not modified.",
                "",
                "If UIM is greater than 12, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Doubleword from GPR using immediate-specified index",
                    "form": "VX",
                    "mnemonic": "vinsd",
                    "operands": [
                        "VRT",
                        "RB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "IMM",
                    "size": "4"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "463",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32].byte[UIM:UIM+7] := GPR[RB]"
            ],
            "body": [
                "",
                "",
                "The contents of GPR[RB] are placed into byte elements",
                "UIM:UIM+7 of",
                "VSR[VRT+32].",
                "",
                "All other byte elements of VSR[VRT+32] are not modified.",
                "",
                "If UIM is greater than 8, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Byte from VSR using GPR-specified Left-Index",
                    "form": "VX",
                    "mnemonic": "vinsbvlx",
                    "operands": [
                        "VRT",
                        "RA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "15",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[index] := VSR[VRB+32].bit[56:63]"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of bits 56:63 of VSR[VRB+32] are placed into",
                "byte element index of VSR[VRT+32].",
                "",
                "All other byte elements of VSR[VRT+32] are not modified.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Byte from VSR using GPR-specified Right-Index",
                    "form": "VX",
                    "mnemonic": "vinsbvrx",
                    "operands": [
                        "VRT",
                        "RA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "271",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[15-index] := VSR[VRB+32].bit[56:63]"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of bits 56:63 of VSR[VRB+32] are placed into",
                "byte element 15-index of VSR[VRT+32].",
                "",
                "All other byte elements of VSR[VRT+32] are not modified.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Halfword from VSR using GPR-specified Left-Index",
                    "form": "VX",
                    "mnemonic": "vinshvlx",
                    "operands": [
                        "VRT",
                        "RA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "79",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[index:index+1] := VSR[VRB+32].bit[48:63]"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of bits 48:63 of VSR[VRB+32] are placed into",
                "byte elements index:index+1 of VSR[VRT+32].",
                "",
                "If index is greater than 14, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Halfword from VSR using GPR-specified Right-Index",
                    "form": "VX",
                    "mnemonic": "vinshvrx",
                    "operands": [
                        "VRT",
                        "RA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "335",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "src.byte[0:15] := 0",
                "",
                "VSR[VRT+32].byte[14-index:15-index] := VSR[VRB+32].bit[48:63]"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of bits 48:63 of VSR[VRB+32] are placed into",
                "byte elements 14-index:15-index of VSR[VRT+32].",
                "",
                "If index is greater than 14, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Word from VSR using GPR-specified Left-Index",
                    "form": "VX",
                    "mnemonic": "vinswvlx",
                    "operands": [
                        "VRT",
                        "RA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "143",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[index:index+3] := VSR[VRB+32].bit[32:63]"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of bits 32:63 of VSR[VRB+32] are placed into",
                "byte elements index:index+3 of VSR[VRT+32].",
                "",
                "All other byte elements of VSR[VRT+32] are not modified.",
                "",
                "If index is greater than 12, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Insert Word from VSR using GPR-specified Right-Index",
                    "form": "VX",
                    "mnemonic": "vinswvrx",
                    "operands": [
                        "VRT",
                        "RA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "399",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "index := GPR[RA].bit[60:63]",
                "",
                "VSR[VRT+32].byte[12-index:15-index] := VSR[VRB+32].bit[32:63]"
            ],
            "body": [
                "",
                "",
                "Let index be the contents of bits 60:63 of GPR[RA].",
                "",
                "The contents of bits 32:63 of VSR[VRB+32] are placed into",
                "byte elements 12-index:15-index of VSR[VRT+32].",
                "",
                "All other byte elements of VSR[VRT+32] are not modified.",
                "",
                "If index is greater than 12, the result is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Add  write Carry-out Unsigned Word",
                    "form": "VX",
                    "mnemonic": "vaddcuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "384",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "src1 := EXTZ(VSR[VRA+32].word[i])",
                "src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "VSR[VRT+32].word[i] := CHOP32((src1 + src2) >> 32)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in word element i in",
                "VSR[VRA+32] is added to the unsigned integer value in",
                "word element i in VSR[VRB+32].",
                "The carry out of the 32-bit sum is zero-extended to 32 bits and",
                "placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_addc",
                "vec_addec"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Add Signed Byte Saturate",
                    "form": "VX",
                    "mnemonic": "vaddsbs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "768",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "src1 := EXTS(VSR[VRA+32].byte[i])",
                "src2 := EXTS(VSR[VRB+32].byte[i])",
                "",
                "VSR[VRT+32].byte[i] := si8_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "The signed integer value in byte element i of VSR[VRA+32] is added to the signed integer value in byte element",
                "i of VSR[VRB+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into byte element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_adds"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Add Signed Halfword Saturate",
                    "form": "VX",
                    "mnemonic": "vaddshs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "832",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "src1 := EXTS(VSR[VRA+32].hword[i])",
                "src2 := EXTS(VSR[VRB+32].hword[i])",
                "",
                "VSR[VRT+32].hword[i] := si16_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The signed integer value in halfword element i of",
                "VSR[VRA+32] is added to the signed integer value in",
                "halfword element i of VSR[VRB+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into halfword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_adds"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Add Signed Word Saturate",
                    "form": "VX",
                    "mnemonic": "vaddsws",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "896",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := EXTS(VSR[VRA].word[i])",
                "  src2 := EXTS(VSR[VRB].word[i])",
                "",
                "  VSR[VRT+32].word[i] := si32_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The signed integer value in word element i of VSR[VRA+32] is added to the signed integer value in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_adds"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Add Unsigned Byte Modulo",
                    "form": "VX",
                    "mnemonic": "vaddubm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "src1 := EXTZ(VSR[VRA+32].byte[i])",
                "src2 := EXTZ(VSR[VRB+32].byte[i])",
                "",
                "VSR[VRT+32].byte[i] := CHOP8(src1 + src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "The integer value in byte element i of VSR[VRA+32] is added to the integer value in byte element i of VSR[VRB+32].",
                "",
                "",
                "The low-order 8 bits of the result are placed into byte element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_add"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Add Unsigned Halfword Modulo",
                    "form": "VX",
                    "mnemonic": "vadduhm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "64",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := EXTZ(VSR[VRA+32].hword[i])",
                "  src2 := EXTZ(VSR[VRB+32].hword[i])",
                "",
                "VSR[VRT+32].hword[i] := CHOP16(src1 + src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The integer value in halfword element i of VSR[VRA+32] is added to the integer value in halfword element",
                "i of VSR[VRB+32].",
                "",
                "",
                "The low-order 16 bits of the result are placed into halfword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_add"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Add Unsigned Word Modulo",
                    "form": "VX",
                    "mnemonic": "vadduwm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "128",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := EXTZ(VSR[VRA+32].word[i])",
                "  src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "VSR[VRT+32].word[i] := CHOP32(src1 + src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The integer value in word element i of VSR[VRA+32] is added to the integer value in word element i of VSR[VRB+32].",
                "",
                "",
                "The low-order 32 bits of the result are placed into word element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_add",
                "vec_adde",
                "vec_addec"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Add Unsigned Doubleword Modulo",
                    "form": "VX",
                    "mnemonic": "vaddudm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "192",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src1 := EXTZ(VSR[VRA+32].dword[i])",
                "  src2 := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "VSR[VRT+32].dword[i] := CHOP64(src1 + src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The integer value in doubleword element i of VSR[VRB+32] is added to the integer value in doubleword element",
                "i of VSR[VRA+32].",
                "",
                "",
                "The low-order 64 bits of the result are placed into doubleword el",
                "ement i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_add"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Add Unsigned Byte Saturate",
                    "form": "VX",
                    "mnemonic": "vaddubs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "512",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  src1 := EXTZ(VSR[VRA+32].byte[i])",
                "  src2 := EXTZ(VSR[VRB+32].byte[i])",
                "",
                "VSR[VRT+32].byte[i] := ui8_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in byte element i of",
                "VSR[VRA+32] is added to the unsigned integer value in",
                "byte element i of VSR[VRB+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into byte element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_adds"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Add Unsigned Halfword Saturate",
                    "form": "VX",
                    "mnemonic": "vadduhs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "576",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := EXTZ(VSR[VRA+32].hword[i])",
                "  src2 := EXTZ(VSR[VRB+32].hword[i])",
                "",
                "VSR[VRT+32].hword[i] := ui16_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in halfword element i of",
                "VSR[VRA+32] is added to the unsigned integer value in",
                "halfword element i of VSR[VRB+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into halfword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_adds"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Add Unsigned Word Saturate",
                    "form": "VX",
                    "mnemonic": "vadduws",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "640",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := EXTZ(VSR[VRA+32].word[i])",
                "  src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "VSR[VRT+32].word[i] := ui32_CLAMP(src1 + src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in word element i of",
                "VSR[VRA+32] is added to the unsigned integer value in",
                "word element i of VSR[VRB+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_adds"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Add Unsigned Quadword Modulo",
                    "form": "VX",
                    "mnemonic": "vadduqm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "256",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(src1 + src2)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the integer value in VSR[VRA+32].",
                "",
                "Let src2 be the integer value in VSR[VRB+32].",
                "",
                "src1 and src2 can be signed or unsigned",
                "integers.",
                "",
                "The rightmost 128 bits of the sum of src1 and",
                "src2 are placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_add"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Add Extended Unsigned Quadword Modulo",
                    "form": "VA",
                    "mnemonic": "vaddeuqm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "60",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "cin  := EXTZ(VSR[VRC+32].bit[127])",
                "",
                "VSR[VRT+32] := CHOP128(src1 + src2 + cin)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the integer value in VSR[VRA+32].",
                "",
                "Let src2 be the integer value in VSR[VRB+32].",
                "",
                "Let cin be the integer value in bit 127 of",
                "VSR[VRC+32].",
                "",
                "src1 and src2 can be signed or unsigned",
                "integers.",
                "",
                "The rightmost 128 bits of the sum of src1,",
                "src2, and cin  are placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_adde"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Add  write Carry-out Unsigned Quadword",
                    "form": "VX",
                    "mnemonic": "vaddcuq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "320",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "sum  := EXTZ(src1) + EXTZ(src2)",
                "",
                "VSR[VRT+32] := EXTZ128((src1 + src2) >> 128)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the integer value in VSR[VRA+32].",
                "",
                "Let src2 be the integer value in VSR[VRB+32].",
                "",
                "src1 and src2 can be signed or unsigned",
                "integers.",
                "",
                "The carry out of the sum of src1 and src2 is",
                "placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_addc"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Add Extended  write Carry-out Unsigned Quadword",
                    "form": "VA",
                    "mnemonic": "vaddecuq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "61",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "cin  := EXTZ(VSR[VRC+32].bit[127])",
                "",
                "VSR[VRT+32] := EXTZ128((src1 + src2 + cin) >> 128)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the integer value in VSR[VRA+32].",
                "",
                "Let src2 be the integer value in VSR[VRB+32].",
                "",
                "Let cin be the integer value in bit 127 of",
                "VSR[VRC+32].",
                "",
                "src1 and src2 can be signed or unsigned",
                "integers.",
                "",
                "The carry out of the sum of src1, src2, and",
                "cin  are placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_addec"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Subtract  Write Carry-out Unsigned Word",
                    "form": "VX",
                    "mnemonic": "vsubcuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1408",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := EXTZ(VSR[VRA+32].word[i])",
                "  src2 := EXTZ(~VSR[VRB+32].word[i])",
                "",
                "  VSR[VRT+32].word[i] := EXTZ32((src1+src2+1) >> 32)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in word element i of",
                "VSR[VRB+32] is subtracted from the unsigned integer value",
                "in word element i in VSR[VRA+32].",
                "The complement of the borrow out of bit 0 of the 32-bit difference is",
                "zero-extended to 32 bits and placed into word element i",
                "of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_subc",
                "vec_subec"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Subtract Signed Byte Saturate",
                    "form": "VX",
                    "mnemonic": "vsubsbs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1792",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  src1 := EXTS(VSR[VRA+32].byte[i])",
                "  src2 := EXTS(VSR[VRB+32].byte[i])",
                "",
                "  VSR[VRT+32].byte[i] := si8_CLAMP(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "The signed integer value in byte element i in VSR[VRB+32] is subtracted from the signed integer value in byte",
                "element i in VSR[VRA+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into byte element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_abss",
                "vec_subs"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Subtract Signed Halfword Saturate",
                    "form": "VX",
                    "mnemonic": "vsubshs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1856",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := EXTS(VSR[VRA+32].hword[i])",
                "  src2 := EXTS(VSR[VRB+32].hword[i])",
                "",
                "  VSR[VRT+32].hword[i] := si16_CLAMP(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The signed integer value in halfword element i in",
                "VSR[VRB+32] is subtracted from the signed integer value",
                "in halfword element i in VSR[VRA+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into halfword element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_abss",
                "vec_subs"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Subtract Signed Word Saturate",
                    "form": "VX",
                    "mnemonic": "vsubsws",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1920",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := EXTS(VSR[VRA+32].word[i])",
                "  src2 := EXTS(VSR[VRB+32].word[i])",
                "",
                "  VSR[VRT+32].word[i] := si32_CLAMP(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The signed integer value in word element i in VSR[VRB+32] is subtracted from the signed integer value in word",
                "element i in VSR[VRA+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_abss",
                "vec_subs"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Subtract Unsigned Byte Modulo",
                    "form": "VX",
                    "mnemonic": "vsububm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1024",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  src1 := EXTZ(VSR[VRA+32].byte[i])",
                "  src2 := EXTZ(VSR[VRB+32].byte[i])",
                "  VSR[VRT+32].byte[i] := CHOP8(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in byte element i in",
                "VSR[VRB+32] is subtracted from the unsigned integer value",
                "in byte element i in VSR[VRA+32].",
                "",
                "",
                "The low-order 8 bits of the result are placed into byte element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_abs",
                "vec_nabs",
                "vec_neg",
                "vec_sub"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Subtract Unsigned Halfword Modulo",
                    "form": "VX",
                    "mnemonic": "vsubuhm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1088",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := EXTZ(VSR[VRA+32].hword[i])",
                "  src2 := EXTZ(VSR[VRB+32].hword[i])",
                "  VSR[VRT+32].hword[i] := CHOP16(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in halfword element i in",
                "VSR[VRB+32] is subtracted from the unsigned integer value",
                "in halfword element i in VSR[VRA+32].",
                "",
                "",
                "The low-order 16 bits of the result are placed into halfword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_nabs",
                "vec_neg",
                "vec_sub"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Subtract Unsigned Word Modulo",
                    "form": "VX",
                    "mnemonic": "vsubuwm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1152",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := EXTZ(VSR[VRA+32].word[i])",
                "  src2 := EXTZ(VSR[VRB+32].word[i])",
                "  VSR[VRT+32].word[i] := CHOP32(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in word element i in",
                "VSR[VRB+32] is subtracted from the unsigned integer value",
                "in word element i in VSR[VRA+32].",
                "",
                "",
                "The low-order 16 bits of the result are placed into word element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_abs",
                "vec_nabs",
                "vec_neg",
                "vec_sub",
                "vec_sube",
                "vec_subec"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Subtract Unsigned Doubleword Modulo",
                    "form": "VX",
                    "mnemonic": "vsubudm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1216",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src1 := EXTZ(VSR[VRA+32].dword[i])",
                "  src2 := EXTZ(VSR[VRB+32].dword[i])",
                "  VSR[VRT+32].dword[i] := CHOP64(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The integer value in doubleword element i in VSR[VRB+32] is subtracted from the integer value in doubleword",
                "element i in VSR[VRA+32].",
                "",
                "",
                "The low-order 64 bits of the result are placed into doubleword",
                "element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_abs",
                "vec_nabs",
                "vec_neg",
                "vec_sub"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Subtract Unsigned Byte Saturate",
                    "form": "VX",
                    "mnemonic": "vsububs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1536",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  src1 := EXTZ(VSR[VRA+32].byte[i])",
                "  src2 := EXTZ(VSR[VRB+32].byte[i])",
                "  VSR[VRT+32].byte[i] := ui8_CLAMP(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in byte element i of",
                "VSR[VRB+32] is subtracted from the unsigned integer value",
                "in byte element i of VSR[VRA+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into byte element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_subs"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Subtract Unsigned Halfword Saturate",
                    "form": "VX",
                    "mnemonic": "vsubuhs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1600",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := EXTZ(VSR[VRA+32].hword[i])",
                "  src2 := EXTZ(VSR[VRB+32].hword[i])",
                "  VSR[VRT+32].hword[i] := ui16_CLAMP(src1 + ~src2 + 1)",
                "  VSCR.SAT := VSCR.SAT | sat_flag",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in halfword element i of",
                "VSR[VRB+32] is subtracted from the unsigned integer value",
                "in halfword element i of VSR[VRA+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into halfword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_subs"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Subtract Unsigned Word Saturate",
                    "form": "VX",
                    "mnemonic": "vsubuws",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1664",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := EXTZ(VSR[VRA+32].word[i])",
                "  src2 := EXTZ(VSR[VRB+32].word[i])",
                "  VSR[VRT+32].word[i] := ui32_CLAMP(src1 + ~src2 + 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in word element i of",
                "VSR[VRB+32] is subtracted from the unsigned integer value",
                "in word element i of VSR[VRA+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_subs"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Subtract Unsigned Quadword Modulo",
                    "form": "VX",
                    "mnemonic": "vsubuqm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1280",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(~VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(src1 + src2 + 1)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the integer value in VSR[VRA+32].",
                "",
                "Let src2 be the integer value in VSR[VRB+32].",
                "",
                "src1 and src2 can be signed or unsigned",
                "integers.",
                "",
                "The rightmost 128 bits of the sum of src1,",
                "the one\u00e2\u20ac\u2122s complement of src2, and the value 1",
                "are placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sub"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Subtract Extended Unsigned Quadword Modulo",
                    "form": "VA",
                    "mnemonic": "vsubeuqm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "62",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(~VSR[VRB+32])",
                "cin  := EXTZ(VSR[VRC+32].bit[127])",
                "",
                "VSR[VRT+32] := CHOP128(src1 + src2 + cin)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the integer value in VSR[VRA+32].",
                "",
                "Let src2 be the integer value in VSR[VRB+32].",
                "",
                "Let cin be the integer value in bit 127 of",
                "VSR[VRC+32].",
                "",
                "src1 and src2 can be signed or unsigned",
                "integers.",
                "",
                "The rightmost 128 bits of the sum of src1,",
                "the one\u00e2\u20ac\u2122s complement of src2, and cin are",
                "placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sube"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Subtract  write Carry-out Unsigned Quadword",
                    "form": "VX",
                    "mnemonic": "vsubcuq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1344",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(~VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128((src1 + src2 + 1) >> 128)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the integer value in VSR[VRA+32].",
                "",
                "Let src2 be the integer value in VSR[VRB+32].",
                "",
                "src1 and src2 can be signed or unsigned",
                "integers.",
                "",
                "The carry out of the sum of src1, the one\u00e2\u20ac\u2122s complement of",
                "src2, and the value 1 is placed into",
                "VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_subc"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Subtract Extended  write Carry-out Unsigned Quadword",
                    "form": "VA",
                    "mnemonic": "vsubecuq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "63",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(~VSR[VRB+32])",
                "cin  := EXTZ(VSR[VRC+32].bit[127])",
                "",
                "VSR[VRT+32] := CHOP128((src1 + src2 + cin) >> 128)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the integer value in VSR[VRA+32].",
                "",
                "Let src2 be the integer value in VSR[VRB+32].",
                "",
                "Let cin be the integer value in bit 127 of",
                "VSR[VRC+32].",
                "",
                "src1 and src2 can be signed or unsigned",
                "integers.",
                "",
                "The carry out of the sum of src1, the one\u00e2\u20ac\u2122s complement of",
                "src2, and cin are placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_subec"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Even Signed Byte",
                    "form": "VX",
                    "mnemonic": "vmulesb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "776",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := EXTS(VSR[VRA+32].byte[2*i])",
                "  src2 := EXTS(VSR[VRB+32].byte[2*i])",
                "",
                "  VSR[VRT+32].hword[i] := CHOP16(src1 * src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The signed integer value in byte element i2 of",
                "VSR[VRA+32] is multiplied by the signed integer value in",
                "byte element i2 of VSR[VRB+32].",
                "",
                "",
                "The 16-bit product is placed into halfword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mul",
                "vec_mule",
                "vec_mulo"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Odd Signed Byte",
                    "form": "VX",
                    "mnemonic": "vmulosb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "264",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := EXTS(VSR[VRA+32].byte[2*i+1])",
                "  src2 := EXTS(VSR[VRB+32].byte[2*i+1])",
                "",
                "  VSR[VRT+32].hword[i] := CHOP16(src1 * src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The signed integer value in byte element i2+1",
                "of VSR[VRA+32] is multiplied by the signed integer value",
                "in byte element i2+1 of VSR[VRB+32].",
                "",
                "",
                "The 16-bit product is placed into halfword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mul",
                "vec_mule",
                "vec_mulo"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Even Unsigned Byte",
                    "form": "VX",
                    "mnemonic": "vmuleub",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "520",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := EXTZ(VSR[VRA+32].byte[2*i])",
                "  src2 := EXTZ(VSR[VRB+32].byte[2*i])",
                "",
                "  VSR[VRT+32].hword[i] := CHOP16(src1 * src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in byte element i2",
                "of VSR[VRA+32] is multiplied by the unsigned integer",
                "value in byte element i2 of VSR[VRB+32].",
                "",
                "",
                "The 16-bit product is placed into halfword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mule",
                "vec_mulo"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Odd Unsigned Byte",
                    "form": "VX",
                    "mnemonic": "vmuloub",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "8",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := EXTZ(VSR[VRA+32].byte[2*i+1])",
                "  src2 := EXTZ(VSR[VRB+32].byte[2*i+1])",
                "",
                "  VSR[VRT+32].hword[i] := CHOP16(src1 * src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in byte element i2+1",
                "of VSR[VRA+32] is multiplied by the unsigned integer",
                "value in byte element i2+1 of VSR[VRB+32].",
                "",
                "",
                "The 16-bit product is placed into halfword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mule",
                "vec_mulo"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Even Signed Halfword",
                    "form": "VX",
                    "mnemonic": "vmulesh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "840",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := EXTS(VSR[VRA+32].hword[2*i])",
                "  src2 := EXTS(VSR[VRB+32].hword[2*i])",
                "",
                "  VSR[VRT+32].word[i] := CHOP32(src1 * src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The signed integer value in halfword element i2",
                "of VSR[VRA+32] is multiplied by the signed integer value",
                "in halfword element i2 of VSR[VRB+32].",
                "",
                "",
                "The 32-bit product is placed into word element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mule",
                "vec_mulo"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Odd Signed Halfword",
                    "form": "VX",
                    "mnemonic": "vmulosh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "328",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := EXTS(VSR[VRA+32].hword[2*i+1])",
                "  src2 := EXTS(VSR[VRB+32].hword[2*i+1])",
                "",
                "  VSR[VRT+32].word[i] := CHOP32(src1 * src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The signed integer value in halfword element i2+1 of VSR[VRA+32] is multiplied by the",
                "signed integer value in halfword element i2+1",
                "of VSR[VRB+32].",
                "",
                "",
                "The 32-bit product is placed into word element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mule",
                "vec_mulo"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Even Unsigned Halfword",
                    "form": "VX",
                    "mnemonic": "vmuleuh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "584",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := EXTZ(VSR[VRA+32].hword[2*i])",
                "  src2 := EXTZ(VSR[VRB+32].hword[2*i])",
                "",
                "  VSR[VRT+32].word[i] := CHOP32(src1 * src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in halfword element i2 of VSR[VRA+32] is multiplied by the",
                "unsigned integer value in halfword element i2",
                "of VSR[VRB+32].",
                "",
                "",
                "The 32-bit product is placed into word element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mule",
                "vec_mulo"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Odd Unsigned Halfword",
                    "form": "VX",
                    "mnemonic": "vmulouh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "72",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := EXTZ(VSR[VRA+32].hword[2*i+1])",
                "  src2 := EXTZ(VSR[VRB+32].hword[2*i+1])",
                "",
                "  VSR[VRT+32].word[i] := CHOP32(src1 * src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in halfword element i2+1 of VSR[VRA+32] is multiplied by the",
                "unsigned integer value in halfword element  i2+1 of VSR[VRB+32].",
                "",
                "",
                "The 32-bit product is placed into word element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mule",
                "vec_mulo"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Even Signed Word",
                    "form": "VX",
                    "mnemonic": "vmulesw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "904",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src1 := EXTS(VSR[VRA+32].word[2*i])",
                "  src2 := EXTS(VSR[VRB+32].word[2*i])",
                "",
                "  VSR[VRT+32].dword[i] := CHOP64(src1 * src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The signed integer in word element 2i of VSR[VRA+32] is multiplied by the signed integer in",
                "word element 2i of VSR[VRB+32].",
                "",
                "",
                "The 64-bit product is placed into doubleword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mule",
                "vec_mulo"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Odd Signed Word",
                    "form": "VX",
                    "mnemonic": "vmulosw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "392",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src1 := EXTS(VSR[VRA+32].word[2*i+1])",
                "  src2 := EXTS(VSR[VRB+32].word[2*i+1])",
                "",
                "  VSR[VRT+32].dword[i] := CHOP64(src1 * src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The signed integer in word element 2i+1 of VSR[VRA+32] is multiplied by the signed integer",
                "in word element 2i+1 of VSR[VRB+32].",
                "",
                "",
                "The 64-bit product is placed into doubleword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mule",
                "vec_mulo"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Even Unsigned Word",
                    "form": "VX",
                    "mnemonic": "vmuleuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "648",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src1 := EXTZ(VSR[VRA+32].word[2*i])",
                "  src2 := EXTZ(VSR[VRB+32].word[2*i])",
                "",
                "  VSR[VRT+32].dword[i] := CHOP64(src1 * src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The unsigned integer in word element 2i of VSR[VRA+32] is multiplied by",
                "the unsigned integer in word element 2i of VSR[VRB+32].",
                "",
                "",
                "The 64-bit product is placed into doubleword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mule",
                "vec_mulo"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Odd Unsigned Word",
                    "form": "VX",
                    "mnemonic": "vmulouw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "136",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src1 := EXTZ(VSR[VRA+32].word[2*i+1])",
                "  src2 := EXTZ(VSR[VRB+32].word[2*i+1])",
                "",
                "  VSR[VRT+32].dword[i] := CHOP64(src1 * src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The unsigned integer in word element 2i+1 of VSR[VRA+32] is multiplied",
                "by the unsigned integer in word element 2i+1 of VSR[VRB+32].",
                "",
                "",
                "The 64-bit product is placed into doubleword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mule",
                "vec_mulo"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Even Unsigned Doubleword",
                    "form": "VX",
                    "mnemonic": "vmuleud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "712",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32].dword[0])",
                "src2 := EXTZ(VSR[VRB+32].dword[0])",
                "",
                "VSR[VRT+32] := CHOP128(src1 * src2)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the unsigned integer value in doubleword",
                "element 0 of VSR[VRA+32].",
                "",
                "Let src2 be the unsigned integer value in doubleword",
                "element 0 of VSR[VRB+32].",
                "",
                "The 128-bit product of src1 multiplied by src2 is placed into VSR[VRT+32].",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Odd Unsigned Doubleword",
                    "form": "VX",
                    "mnemonic": "vmuloud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "200",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "src1 := EXTZ(VSR[VRA+32].dword[1])",
                "src2 := EXTZ(VSR[VRB+32].dword[1])",
                "",
                "VSR[VRT+32] := CHOP128(src1 * src2)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the unsigned integer value in doubleword",
                "element 1 of VSR[VRA+32].",
                "",
                "Let src2 be the unsigned integer value in doubleword",
                "element 1 of VSR[VRB+32].",
                "",
                "The 128-bit product of src1 multiplied by src2 is placed into VSR[VRT+32].",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Even Signed Doubleword",
                    "form": "VX",
                    "mnemonic": "vmulesd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "968",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "src1 := EXTS(VSR[VRA+32].dword[0])",
                "src2 := EXTS(VSR[VRB+32].dword[0])",
                "",
                "VSR[VRT+32] := CHOP128(src1 * src2)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the signed integer value in doubleword",
                "element 0 of VSR[VRA+32].",
                "",
                "Let src2 be the signed integer value in doubleword",
                "element 0 of VSR[VRB+32].",
                "",
                "The 128-bit product of src1 multiplied by src2 is placed into VSR[VRT+32].",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Odd Signed Doubleword",
                    "form": "VX",
                    "mnemonic": "vmulosd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "456",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTS(VSR[VRA+32].dword[1])",
                "src2 := EXTS(VSR[VRB+32].dword[1])",
                "",
                "VSR[VRT+32] := CHOP128(src1 * src2)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the signed integer value in doubleword",
                "element 1 of VSR[VRA+32].",
                "",
                "Let src2 be the signed integer value in doubleword",
                "element 1 of VSR[VRB+32].",
                "",
                "The 128-bit product of src1 multiplied by src2 is placed into VSR[VRT+32].",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Unsigned Word Modulo",
                    "form": "VX",
                    "mnemonic": "vmuluwm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "137",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := EXTZ(VSR[VRA+32].word[i])",
                "  src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "  VSR[VRT+32].word[i] := CHOP32(src1 * src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The integer in word element i of VSR[VRA+32]",
                "is multiplied by the integer in word element i of",
                "VSR[VRB+32].",
                "",
                "",
                "The low-order 32 bits of the product are placed into word element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mul"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply High Signed Word",
                    "form": "VX",
                    "mnemonic": "vmulhsw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "905",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := EXTS(VSR[VRA+32].word[i])",
                "  src2 := EXTS(VSR[VRB+32].word[i])",
                "",
                "  VSR[VRT+32].word[i] := CHOP32((src1 * src2) >> 32)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The signed integer value in word element i of VSR[VRA+32] is multiplied by the signed integer value in word",
                "element i of VSR[VRB+32].",
                "",
                "",
                "The high-order 32 bits of the 64-bit product are placed into word",
                "element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply High Unsigned Word",
                    "form": "VX",
                    "mnemonic": "vmulhuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "649",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := EXTZ(VSR[VRA+32].word[i])",
                "  src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "  VSR[VRT+32].word[i] := CHOP32((src1 * src2) >> 32)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in word element i of",
                "VSR[VRA+32] is multiplied by the unsigned integer value",
                "in word element i of VSR[VRB+32].",
                "",
                "",
                "The high-order 32 bits of the 64-bit product are placed into word",
                "element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply High Signed Doubleword",
                    "form": "VX",
                    "mnemonic": "vmulhsd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "969",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src1 := EXTS(VSR[VRA+32].dword[i])",
                "  src2 := EXTS(VSR[VRB+32].dword[i])",
                "",
                "  VSR[VRT+32].dword[i] := CHOP64((src1 * src2) >> 64)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The signed integer value in doubleword element i of",
                "VSR[VRA+32] is multiplied by the signed integer value in",
                "doubleword element i of VSR[VRB+32].",
                "",
                "",
                "The high-order 64 bits of the 128-bit product are placed into",
                "doubleword element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply High Unsigned Doubleword",
                    "form": "VX",
                    "mnemonic": "vmulhud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "713",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src1 := EXTZ(VSR[VRA+32].dword[i])",
                "  src2 := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "  VSR[VRT+32].dword[i] := CHOP64((src1 * src2) >> 64)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in doubleword element i of",
                "VSR[VRA+32] is multiplied by the unsigned integer value",
                "in doubleword element i of VSR[VRB+32].",
                "",
                "",
                "The high-order 64 bits of the 128-bit product are placed into",
                "doubleword element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply Low Doubleword",
                    "form": "VX",
                    "mnemonic": "vmulld",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "457",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src1 := EXTS(VSR[VRA+32].dword[i])",
                "  src2 := EXTS(VSR[VRB+32].dword[i])",
                "",
                "  VSR[VRT+32].dword[i] := CHOP64(src1 * src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The integer value in doubleword element i of VSR[VRA+32] is mutiplied by the integer value in doubleword element",
                "i of VSR[VRB+32].",
                "",
                "",
                "The low-order 64 bits of the product are placed into doubleword",
                "element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply-High-Add Signed Halfword Saturate",
                    "form": "VA",
                    "mnemonic": "vmhaddshs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "32",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := EXTS(VSR[VRA+32].hword[i])",
                "  src2 := EXTS(VSR[VRB+32].hword[i])",
                "  src3 := EXTS(VSR[VRC+32].hword[i])",
                "",
                "  result := ((src1 * src2)) >> 15) + src3",
                "  VSR[VRT+32].hword[i] := si16_CLAMP(result)",
                "VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The signed integer value in halfword element i of",
                "VSR[VRA+32] is multiplied by the signed integer value in",
                "halfword element i of VSR[VRB+32], producing",
                "a 32-bit signed integer product.",
                "",
                "",
                "Bits 0:16 of the product are added to the signed integer value in",
                "halfword element i of VSR[VRC+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The low-order 16 bits of the result are placed into halfword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_madds"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply-High-Round-Add Signed Halfword Saturate",
                    "form": "VA",
                    "mnemonic": "vmhraddshs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "33",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := EXTS(VSR[VRA+32].hword[i])",
                "  src2 := EXTS(VSR[VRB+32].hword[i])",
                "  src3 := EXTS(VSR[VRC+32].hword[i])",
                "",
                "result := (((src1 * src2) + 0x0000_4000) >> 15) + src3",
                "  VSR[VRT+32].hword[i] := si16_CLAMP(result)",
                "VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The signed integer value in halfword element i of",
                "VSR[VRA+32] is multiplied by the signed integer value in",
                "halfword element i of VSR[VRB+32], producing",
                "a 32-bit signed integer product.",
                "",
                "",
                "The value 0x0000_4000 is added to the product.",
                "",
                "",
                "Bits 0:16 of the 32-bit sum are added to the signed integer value in",
                "halfword element i of VSR[VRC+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The low-order 16 bits of the result are placed into halfword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mradds"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply-Low-Add Unsigned Halfword Modulo",
                    "form": "VA",
                    "mnemonic": "vmladduhm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "34",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := EXTZ(VSR[VRA+32].hword[i])",
                "  src2 := EXTZ(VSR[VRB+32].hword[i])",
                "  src3 := EXTZ(VSR[VRC+32].hword[i])",
                "",
                "VSR[VRT+32].hword[i] := CHOP16((src1 * src2) + src3)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in halfword element i of",
                "VSR[VRA+32] is multiplied by the unsigned integer value",
                "in halfword element i in VSR[VRB+32].",
                "",
                "",
                "The product is added to the unsigned integer value in halfword",
                "element i of VSR[VRC+32].",
                "",
                "",
                "The low-order 16 bits of the sum of the product and the unsigned",
                "integer value in word element i of VSR[VRC+32] are placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_madd",
                "vec_mul"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply-Sum Unsigned Byte Modulo",
                    "form": "VA",
                    "mnemonic": "vmsumubm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "36",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  temp := EXTZ(VSR[VRC+32].word[i])",
                "  do j = 0 to 3",
                "     src1 := EXTZ(VSR[VRA+32].word[i].byte[j])",
                "     src2 := EXTZ(VSR[VRB+32].word[i].byte[j])",
                "     temp := temp + (src1 * src2)",
                "  end",
                "  VSR[VRT+32].word[i] := CHOP32(temp)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "For each integer value j from 0 to 3, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in byte element j of word",
                "element i of VSR[VRA+32] is multiplied by the",
                "unsigned integer value in byte element j of word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "",
                "The sum of the four products is added to the unsigned integer value",
                "in word element i of VSR[VRC+32].",
                "",
                "",
                "The low-order 32 bits of the result are placed into word element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_msum"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply-Sum Mixed Byte Modulo",
                    "form": "VA",
                    "mnemonic": "vmsummbm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "37",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  temp := EXTS(VSR[VRC+32].word[i])",
                "  do j = 0 to 3",
                "     src1 := EXTS(VSR[VRA+32].word[i].byte[j])",
                "     src2 := EXTZ(VSR[VRB+32].word[i].byte[j])",
                "     temp := temp + (src1 * src2)",
                "  end",
                "  VSR[VRT+32].word[i] := CHOP32(temp)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "For each integer value j from 0 to 3, do the following.",
                "",
                "",
                "",
                "The signed integer value in byte element j of word",
                "element i of VSR[VRA+32] is multiplied by the",
                "unsigned integer value in byte element j of word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "",
                "The sum of the four products is added to the signed integer value in",
                "word element i of VSR[VRC+32].",
                "",
                "",
                "The low-order 32 bits of the result are placed into word element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_msum"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply-Sum Signed Halfword Modulo",
                    "form": "VA",
                    "mnemonic": "vmsumshm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "40",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  temp := EXTS(VSR[VRC+32].word[i])",
                "  do j = 0 to 1",
                "     src1 := EXTS(VSR[VRA+32].word[i].hword[j])",
                "     src2 := EXTS(VSR[VRB+32].word[i].hword[j])",
                "     temp := temp + (src1 * src2)",
                "  end",
                "  VSR[VRT+32].word[i] := CHOP32(temp)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "For each integer value j from 0 to 1, do the following.",
                "",
                "",
                "",
                "The signed integer value in halfword element j of word",
                "element i of VSR[VRA+32] is multiplied by the",
                "signed integer value in halfword element j of word",
                "element i of VSR[VRB+32].",
                "",
                "",
                "",
                "The sum of the two products is added to the signed integer value in",
                "word element i of VSR[VRC+32].",
                "",
                "",
                "The low-order 32 bits of the result are placed into word element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_msum"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply-Sum Signed Halfword Saturate",
                    "form": "VA",
                    "mnemonic": "vmsumshs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "41",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  temp := EXTS(VSR[VRC+32].word[i])",
                "  do j = 0 to 1",
                "     src1 := EXTS(VSR[VRA+32].word[i].hword[j])",
                "     src2 := EXTS(VSR[VRB+32].word[i].hword[j])",
                "     temp := temp + (src1 * src2)",
                "  end",
                "  VSR[VRT+32].word[i] := si32_CLAMP(temp)",
                "VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "For each integer value j from 0 to 1, do the following.",
                "",
                "",
                "",
                "The signed integer value in halfword element j of word",
                "element i of VSR[VRA+32] is multiplied by the",
                "signed integer value in halfword element j of word",
                "element i of VSR[VRB+32].",
                "",
                "",
                "",
                "The sum of the two products is added to the signed integer value in",
                "word element i of VSR[VRC+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The low-order 32 bits of the result are placed into word element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_msums"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply-Sum Unsigned Halfword Modulo",
                    "form": "VA",
                    "mnemonic": "vmsumuhm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "38",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  temp := EXTZ(VSR[VRC+32].word[i])",
                "  do j = 0 to 1",
                "     src1 := EXTZ(VSR[VRA+32].word[i].hword[j])",
                "     src2 := EXTZ(VSR[VRB+32].word[i].hword[j])",
                "     temp := temp + (src1 * src2)",
                "  end",
                "  VSR[VRT+32].word[i] := CHOP32(temp)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "For each integer value j from 0 to 1, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in halfword element j of word",
                "element i of VSR[VRA+32] is multiplied by the",
                "unsigned integer value in halfword element j of word",
                "element i of VSR[VRB+32].",
                "",
                "",
                "",
                "The sum of the two products is added to the signed integer value in",
                "word element i of VSR[VRC+32].",
                "",
                "",
                "The low-order 32 bits of the result are placed into word element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_msum"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply-Sum Unsigned Halfword Saturate",
                    "form": "VA",
                    "mnemonic": "vmsumuhs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "39",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  temp := EXTZ(VSR[VRC+32].word[i])",
                "  do j = 0 to 1",
                "     src1 := EXTZ(VSR[VRA+32].word[i].hword[j])",
                "     src2 := EXTZ(VSR[VRB+32].word[i].hword[j])",
                "     temp := temp + src1 * src2",
                "  end",
                "  VSR[VRT+32].word[i] := ui32_CLAMP(temp)",
                "VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "For each integer value j from 0 to 1, do the following.",
                "",
                "",
                "",
                "The unsigned integer value in halfword element j of word",
                "element i of VSR[VRA+32] is multiplied by the",
                "unsigned integer value in halfword element j of word",
                "element i of VSR[VRB+32].",
                "",
                "",
                "",
                "The sum of the two products is added to the signed integer value in",
                "word element i of VSR[VRC+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The low-order 32 bits of the result are placed into word element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_msums"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply-Sum Unsigned Doubleword Modulo",
                    "form": "VA",
                    "mnemonic": "vmsumudm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "35",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "temp := EXTZ(VSR[VRC+32])",
                "do i = 0 to 1",
                "  src1  := EXTZ(VSR[VRA+32].dword[i])",
                "  src2  := EXTZ(VSR[VRB+32].dword[i])",
                "  temp := temp + (src1 * src2)",
                "end",
                "VSR[VRT+32] := CHOP128(temp)"
            ],
            "body": [
                "",
                "",
                "Let prod0 be the product of the unsigned integer values",
                "in doubleword element 0 of VSR[VRA+32] and doubleword",
                "element 0 of VSR[VRB+32].",
                "",
                "Let prod1 be the product of the unsigned integer values",
                "in doubleword element 1 of VSR[VRA+32] and doubleword",
                "element 1 of VSR[VRB+32].",
                "",
                "The low-order 128 bits of the sum of prod0, prod1, and the unsigned integer value in VSR[VRC+32] are",
                "placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply-Sum  write Carry-out Unsigned Doubleword",
                    "form": "VA",
                    "mnemonic": "vmsumcud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "23",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "temp := EXTZ(VSR[VRC+32])",
                "do i = 0 to 1",
                "  src1  := EXTZ(VSR[VRA+32].dword[i])",
                "  src2  := EXTZ(VSR[VRB+32].dword[i])",
                "  temp := temp + (src1 * src2)",
                "end",
                "",
                "VSR[VRT+32] := CHOP128(temp >> 128)"
            ],
            "body": [
                "",
                "",
                "Let prod0 be the quadword product of the unsigned integer",
                "values in doubleword element 0 of VSR[VRA+32] and",
                "doubleword element 0 of VSR[VRB+32].",
                "",
                "Let prod1 be the quadword product of the unsigned integer",
                "values in doubleword element 1 of VSR[VRA+32] and",
                "doubleword element 1 of VSR[VRB+32].",
                "",
                "The carry out of the low-order 128 bits of the sum of prod0, prod1, and the unsigned integer value in",
                "VSR[VRC+32] is placed into VSR[VRT+32].",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Divide Signed Word",
                    "form": "VX",
                    "mnemonic": "vdivsw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "395",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  dividend := EXTS(VSR[VRA+32].word[i])",
                "  divisor  := EXTS(VSR[VRB+32].word[i])",
                "",
                "  VSR[VRT+32].word[i] := CHOP32(dividend / divisor)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the",
                "following.",
                "",
                "",
                "",
                "The signed integer in word element i of VSR[VRA+32] is divided by the signed integer in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "The quotient is the unique signed integer that satisfies",
                "",
                "",
                "",
                "dividend = (quotient  divisor) + remainder",
                "",
                "",
                "",
                "where 0 = r  |divisor| if the dividend is",
                "nonnegative, and -|divisor|  r = 0 if the",
                "dividend is negative.",
                "",
                "",
                "If an attempt is made to perform any of the divisions",
                "",
                "",
                "",
                "0x80000000  -1",
                "",
                "",
                "anything  0",
                "",
                "",
                "",
                "then the quotient is undefined.",
                "",
                "",
                "The quotient is placed into word element i of VSR[VRT+32]",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Divide Unsigned Word",
                    "form": "VX",
                    "mnemonic": "vdivuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "139",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  dividend := EXTZ(VSR[VRA+32].word[i])",
                "  divisor  := EXTZ(VSR[VRB+32].word[i])",
                "",
                "  VSR[VRT+32].word[i] := CHOP32(dividend / divisor)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the",
                "following.",
                "",
                "",
                "",
                "The unsigned integer in word element i of VSR[VRA+32] is divided by the unsigned integer in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "The quotient is the unique unsigned integer that satisfies",
                "",
                "",
                "",
                "dividend = (quotient  divisor) + remainder",
                "",
                "",
                "",
                "where 0 = r  |divisor|.",
                "",
                "",
                "If an attempt is made to perform the division",
                "",
                "",
                "",
                "anything  0",
                "",
                "",
                "",
                "then the quotient is undefined.",
                "",
                "",
                "The quotient is placed into word element i of VSR[VRT+32]",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Divide Extended Signed Word",
                    "form": "VX",
                    "mnemonic": "vdivesw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "907",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  dividend := EXTS(VSR[VRA+32].word[i]) << 32",
                "  divisor  := EXTS(VSR[VRB+32].word[i])",
                "",
                "  VSR[VRT+32].word[i] := CHOP32(dividend / divisor)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let dividend be the signed integer value in word element",
                "i of VSR[VRA+32], shifted left by 32 bits.",
                "",
                "",
                "Let divisor be the signed integer value in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "dividend is divided by divisor.",
                "",
                "",
                "The quotient is the unique signed integer that satisfies",
                "",
                "",
                "",
                "dividend = (quotient  divisor) + remainder",
                "",
                "",
                "",
                "where 0 = r  |divisor| if the dividend is",
                "nonnegative, and -|divisor|  r = 0 if the",
                "dividend is negative.",
                "",
                "",
                "If the quotient cannot be represented in 32 bits, or if an attempt is",
                "made to perform the division,",
                "",
                "",
                "",
                "anything  0",
                "",
                "",
                "",
                "the quotient is undefined.",
                "",
                "",
                "The quotient is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Divide Extended Unsigned Word",
                    "form": "VX",
                    "mnemonic": "vdiveuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "651",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  dividend := EXTZ(VSR[VRA+32].word[i]) << 32",
                "  divisor  := EXTZ(VSR[VRB+32].word[i])",
                "",
                "  VSR[VRT+32].word[i] := CHOP32(dividend / divisor)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let dividend be the unsigned integer value in word",
                "element i of VSR[VRA+32], shifted left by 32",
                "bits.",
                "",
                "",
                "Let divisor be the unsigned integer value in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "The quotient is the unique unsigned integer that satisfies",
                "",
                "",
                "",
                "dividend = (quotient  divisor) + remainder",
                "",
                "",
                "",
                "where 0 = r  |divisor|.",
                "",
                "",
                "If the quotient cannot be represented in 32 bits, or if an attempt is",
                "made to perform the division,",
                "",
                "",
                "",
                "anything  0",
                "",
                "",
                "",
                "the quotient is undefined.",
                "",
                "",
                "The quotient is placed into word element i of VSR[VRT+32]",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Divide Signed Doubleword",
                    "form": "VX",
                    "mnemonic": "vdivsd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "459",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  dividend := EXTS(VSR[VRA+32].dword[i])",
                "  divisor  := EXTS(VSR[VRB+32].dword[i])",
                "",
                "  VSR[VRT+32].dword[i] := CHOP64(dividend / divisor)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the",
                "following.",
                "",
                "",
                "",
                "The signed integer in doubleword element i of VSR[VRA+32] is divided by the signed integer in doubleword element",
                "i of VSR[VRB+32].",
                "",
                "",
                "The quotient is the unique signed integer that satisfies",
                "",
                "",
                "",
                "dividend = (quotient  divisor) + remainder",
                "",
                "",
                "",
                "where 0 = remainder  |divisor| if the dividend",
                "is nonnegative, and -|divisor|  remainder = 0",
                "if the dividend is negative.",
                "",
                "",
                "If an attempt is made to perform any of the divisions",
                "",
                "",
                "",
                "0x8000000000000000  -1",
                "",
                "",
                "anything  0",
                "",
                "",
                "",
                "then the quotient is undefined.",
                "",
                "",
                "The quotient is placed into word element i of VSR[VRT+32]",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Divide Unsigned Doubleword",
                    "form": "VX",
                    "mnemonic": "vdivud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "203",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  dividend := EXTZ(VSR[VRA+32].dword[i])",
                "  divisor  := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "  VSR[VRT+32].dword[i] := CHOP64(dividend / divisor)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the",
                "following.",
                "",
                "",
                "",
                "The unsigned integer in doubleword element i of",
                "VSR[VRA+32] is divided by the unsigned integer in",
                "doubleword element i of VSR[VRB+32].",
                "",
                "",
                "The quotient is the unique unsigned integer that satisfies",
                "",
                "",
                "",
                "dividend = (quotient  divisor) + remainder",
                "",
                "",
                "",
                "where 0 = remainder  divisor.",
                "",
                "",
                "If an attempt is made to perform the division",
                "",
                "",
                "",
                "anything  0",
                "",
                "",
                "",
                "then the quotient is undefined.",
                "",
                "",
                "The quotient is placed into doubleword element i of",
                "VSR[VRT+32]",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Divide Extended Signed Doubleword",
                    "form": "VX",
                    "mnemonic": "vdivesd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "971",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  dividend := EXTS(VSR[VRA+32].dword[i]) << 64",
                "  divisor  := EXTS(VSR[VRB+32].dword[i])",
                "",
                "  VSR[VRT+32].dword[i] := CHOP64(dividend / divisor)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let dividend be the signed integer value in doubleword",
                "element i of VSR[VRA+32], shifted left by 64",
                "bits.",
                "",
                "",
                "Let divisor be the signed integer value in doubleword",
                "element i of VSR[VRB+32].",
                "",
                "",
                "dividend is divided by divisor.",
                "",
                "",
                "The quotient is the unique signed integer that satisfies",
                "",
                "",
                "",
                "dividend = (quotient  divisor) + remainder",
                "",
                "",
                "",
                "where 0 = r  |divisor| if the dividend is",
                "nonnegative, and -|divisor|  r = 0 if the",
                "dividend is negative.",
                "",
                "",
                "If the quotient cannot be represented in 64 bits, or if an attempt is",
                "made to perform the division, anything ",
                "0, the quotient is undefined.",
                "",
                "",
                "The quotient is placed into doubleword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Divide Extended Unsigned Doubleword",
                    "form": "VX",
                    "mnemonic": "vdiveud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "715",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  dividend := EXTZ(VSR[VRA+32].dword[i]) << 64",
                "  divisor  := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "  VSR[VRT+32].dword[i] := CHOP64(dividend / divisor)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let dividend be the unsigned integer value in doubleword",
                "element i of VSR[VRA+32], shifted left by 64",
                "bits.",
                "",
                "",
                "Let divisor be the unsigned integer value in doubleword",
                "element i of VSR[VRB+32].",
                "",
                "",
                "The quotient is the unique unsigned integer that satisfies",
                "",
                "",
                "",
                "dividend = (quotient  divisor) + remainder",
                "",
                "",
                "",
                "where 0 = r  |divisor|.",
                "",
                "",
                "If the quotient cannot be represented in 64 bits, or if an attempt is",
                "made to perform the division,",
                "",
                "",
                "",
                "anything  0",
                "",
                "",
                "",
                "the quotient is undefined.",
                "",
                "",
                "The quotient is placed into doubleword element i of",
                "VSR[VRT+32]",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Divide Signed Quadword",
                    "form": "VX",
                    "mnemonic": "vdivsq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "267",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTS(VSR[VRA+32])",
                "divisor     := EXTS(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend / divisor)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the signed integer value in VSR[VRA+32].",
                "",
                "Let src2 be the signed integer value in VSR[VRB+32].",
                "",
                "The quotient of src1 divided by src2 is",
                "placed into VSR[VRT+32].",
                "",
                "The quotient is the unique signed integer that satisfies",
                "",
                "",
                "",
                "dividend = (quotient  divisor) + r",
                "",
                "",
                "where 0r|divisor| if the",
                "dividend is nonnegative, and -|divisor|r0 if the dividend is negative.",
                "",
                "If an attempt is made to perform any of the divisions",
                "",
                "",
                "",
                "0x8000000000000000  -1",
                "",
                "",
                "anything  0",
                "",
                "",
                "then the contents of VSR[VRT+32] are undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Divide Unsigned Quadword",
                    "form": "VX",
                    "mnemonic": "vdivuq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "11",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTZ(VSR[VRA+32])",
                "divisor     := EXTZ(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend / divisor)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the unsigned integer value in VSR[VRA+32].",
                "",
                "Let src2 be the unsigned integer value in VSR[VRB+32].",
                "",
                "The quotient of src1 divided by src2 is",
                "placed into VSR[VRT+32].",
                "",
                "The quotient is the unique unsigned integer that satisfies",
                "",
                "",
                "",
                "dividend = (quotient  divisor) + r",
                "",
                "",
                "where 0rdivisor.",
                "",
                "If an attempt is made to perform the division",
                "",
                "",
                "",
                "anything  0",
                "",
                "",
                "then the contents of VSR[VRT+32] are undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Divide Extended Signed Quadword",
                    "form": "VX",
                    "mnemonic": "vdivesq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "779",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTS(VSR[VRA+32]) << 128",
                "divisor     := EXTS(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend / divisor)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the signed integer value in VSR[VRA+32] concatenated with 128 0s.",
                "",
                "Let src2 be the signed integer value in VSR[VRB+32].",
                "",
                "The quotient of src1 divided by src2 is",
                "placed into VSR[VRT+32].",
                "",
                "The quotient is the unique signed integer that satisfies",
                "",
                "",
                "",
                "dividend = (quotient  divisor) + r",
                "",
                "",
                "where 0  r  |divisor| if",
                "dividend is nonnegative, and -|divisor|  r  0 if dividend is negative.",
                "",
                "If the quotient cannot be represented in 128 bits, or if an attempt",
                "is made to perform the division",
                "",
                "",
                "",
                "anything  0",
                "",
                "",
                "then the contents of VSR[VRT+32] are undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Divide Extended Unsigned Quadword",
                    "form": "VX",
                    "mnemonic": "vdiveuq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "523",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTZ(VSR[VRA+32]) << 128",
                "divisor     := EXTZ(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend / divisor)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the unsigned integer value in VSR[VRA+32] concatenated with 128 0s.",
                "",
                "Let src2 be the unsigned integer value in VSR[VRB+32].",
                "",
                "The quotient of src1 divided by src2 is",
                "placed into VSR[VRT+32].",
                "",
                "The quotient is the unique unsigned integer that satisfies",
                "",
                "",
                "",
                "dividend = (quotient  divisor) + r",
                "",
                "",
                "where 0  r  divisor.",
                "",
                "If the quotient cannot be represented in 128 bits, or if an attempt",
                "is made to perform the division",
                "",
                "",
                "",
                "anything  0",
                "",
                "",
                "then the contents of VSR[VRT+32] are undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Modulo Signed Word",
                    "form": "VX",
                    "mnemonic": "vmodsw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1931",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  dividend := EXTS(VSR[VRA+32].word[i])",
                "  divisor  := EXTS(VSR[VRB+32].word[i])",
                "",
                "  VSR[VRT+32].word[i] := CHOP32(dividend % divisor)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the",
                "following.",
                "",
                "",
                "",
                "The signed integer in word element i of VSR[VRA+32] is divided by the signed integer in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "The remainder is the unique signed integer that satisfies",
                "",
                "",
                "",
                "quotient  = dividend  divisor",
                "",
                "",
                "remainder = dividend - (quotient  divisor)",
                "",
                "",
                "",
                "where 0 = remainder  |divisor| if the dividend",
                "is nonnegative, and -|divisor|  remainder = 0",
                "if the dividend is negative.",
                "",
                "",
                "If an attempt is made to perform any of the modulo operations",
                "",
                "",
                "",
                "0x80000000  -1",
                "",
                "",
                "anything  0",
                "",
                "",
                "",
                "then the remainder is undefined.",
                "",
                "",
                "The remainder is placed into word element i of VSR[VRT+32]",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Modulo Unsigned Word",
                    "form": "VX",
                    "mnemonic": "vmoduw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1675",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  dividend := EXTZ(VSR[VRA+32].word[i])",
                "  divisor  := EXTZ(VSR[VRB+32].word[i])",
                "",
                "  VSR[VRT+32].word[i] := CHOP32(dividend % divisor)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the",
                "following.",
                "",
                "",
                "",
                "The unsigned integer in word element i of VSR[VRA+32] is divided by the unsigned integer in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "The remainder is the unique unsigned integer that satisfies",
                "",
                "",
                "",
                "quotient  = dividend  divisor",
                "",
                "",
                "remainder = dividend - (quotient  divisor)",
                "",
                "",
                "",
                "where 0 = remainder  divisor.",
                "",
                "",
                "If an attempt is made to perform the modulo operation",
                "",
                "",
                "",
                "anything  0",
                "",
                "",
                "",
                "then the remainder is undefined.",
                "",
                "",
                "The remainder is placed into word element i of VSR[VRT+32]",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Modulo Signed Doubleword",
                    "form": "VX",
                    "mnemonic": "vmodsd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1995",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  dividend := EXTS(VSR[VRA+32].dword[i])",
                "  divisor  := EXTS(VSR[VRB+32].dword[i])",
                "",
                "  VSR[VRT+32].dword[i] := CHOP64(dividend % divisor)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the",
                "following.",
                "",
                "",
                "",
                "The signed integer in doubleword element i of VSR[VRA+32] is divided by the signed integer in doubleword element",
                "i of VSR[VRB+32].",
                "",
                "",
                "The remainder is the unique signed integer that satisfies",
                "",
                "",
                "",
                "quotient  = dividend  divisor",
                "",
                "",
                "remainder = dividend - (quotient  divisor)",
                "",
                "",
                "",
                "where 0 = remainder  |divisor| if the dividend",
                "is nonnegative, and -|divisor|  remainder = 0",
                "if the dividend is negative.",
                "",
                "",
                "If an attempt is made to perform any of the modulo operations",
                "",
                "",
                "",
                "0x80000000  -1",
                "",
                "",
                "anything  0",
                "",
                "",
                "",
                "the remainder is undefined.",
                "",
                "",
                "The remainder is placed into doubleword element i of",
                "VSR[VRT+32]",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Modulo Unsigned Doubleword",
                    "form": "VX",
                    "mnemonic": "vmodud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1739",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  dividend := EXTZ(VSR[VRA+32].dword[i])",
                "  divisor  := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "  VSR[VRT+32].dword[i] := CHOP64(dividend % divisor)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the",
                "following.",
                "",
                "",
                "",
                "The unsigned integer in doubleword element i of",
                "VSR[VRA+32] is divided by the unsigned integer in",
                "doubleword element i of VSR[VRB+32].",
                "",
                "",
                "The remainder is the unique unsigned integer that satisfies",
                "",
                "",
                "",
                "quotient  = dividend  divisor",
                "",
                "",
                "remainder = dividend - (quotient  divisor)",
                "",
                "",
                "",
                "where 0 = remainder  divisor.",
                "",
                "",
                "If an attempt is made to perform the modulo operation",
                "",
                "",
                "",
                "anything  0",
                "",
                "",
                "",
                "the remainder is undefined.",
                "",
                "",
                "The remainder is placed into doubleword element i of",
                "VSR[VRT+32]",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Modulo Signed Quadword",
                    "form": "VX",
                    "mnemonic": "vmodsq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1803",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTS(VSR[VRA+32])",
                "divisor     := EXTS(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend % divisor)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the signed integer value in VSR[VRA+32].",
                "",
                "Let src2 be the signed integer value in VSR[VRB+32].",
                "",
                "The remainder of src1 divided by src2 is",
                "placed into VSR[VRT+32].",
                "",
                "The remainder is the unique signed integer that satisfies",
                "",
                "remainder = dividend - (quotient  divisor)",
                "",
                "where 0remainder|divisor| if",
                "the dividend is nonnegative, and -|divisor|remainder0 if the dividend is",
                "negative.",
                "",
                "If an attempt is made to perform any of the divisions",
                "",
                "anything  0",
                "",
                "0x8000000000000000  -1",
                "",
                "then the contents of VSR[VRT+32] are undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Modulo Unsigned Quadword",
                    "form": "VX",
                    "mnemonic": "vmoduq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1547",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "dividend    := EXTZ(VSR[VRA+32])",
                "divisor     := EXTZ(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := CHOP128(dividend % divisor)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the signed integer value in VSR[VRA+32].",
                "",
                "Let src2 be the signed integer value in VSR[VRB+32].",
                "",
                "The remainder of src1 divided by src2 is",
                "placed into VSR[VRT+32].",
                "",
                "The remainder is the unique signed integer that satisfies",
                "",
                "remainder = dividend - (quotient  divisor)",
                "",
                "where 0  remainder  divisor.",
                "",
                "If an attempt is made to perform any of the divisions",
                "",
                "anything  0",
                "",
                "then the contents of VSR[VRT+32] are undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Sum across Signed Word Saturate",
                    "form": "VX",
                    "mnemonic": "vsumsws",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1928",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "temp := EXTS(VSR[VRB+32].word[3])",
                "do i = 0 to 3",
                "  temp := temp + EXTS(VSR[VRA+32].word[i])",
                "end",
                "VSR[VRT+32].word[0] := 0x0000_0000",
                "VSR[VRT+32].word[1] := 0x0000_0000",
                "VSR[VRT+32].word[2] := 0x0000_0000",
                "VSR[VRT+32].word[3] := si32_CLAMP(temp)",
                "VSCR.SAT := sat_flag"
            ],
            "body": [
                "",
                "",
                "The sum of the signed integer values in the four word elements of",
                "VSR[VRA+32] is added to the signed integer value in the",
                "word element 3 of VSR[VRB+32].",
                "",
                "",
                "",
                "The low-order 32 bits of the result are placed into word element 3 of",
                "VSR[VRT+32].",
                "",
                "Word elements 0 to 2 of VSR[VRT+32] are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sums"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Sum across Half Signed Word Saturate",
                    "form": "VX",
                    "mnemonic": "vsum2sws",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1672",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  temp := EXTS(VSR[VRB+32].dword[i].word[1])",
                "  do j = 0 to 1",
                "     temp := temp + EXTS(VSR[VRA+32].dword[i].word[j])",
                "  end",
                "  VSR[VRT+32].dword[i].word[0] := 0x0000_0000",
                "  VSR[VRT+32].dword[i].word[1] := si32_CLAMP(temp)",
                "  VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "",
                "",
                "Word elements 0 and 2 of VSR[VRT+32] are set to 0.",
                "",
                "The sum of the signed integer values in word elements 0 and 1 in",
                "VSR[VRA+32] is added to the signed integer value in word",
                "element 1 of VSR[VRB+32].",
                "",
                "",
                "",
                "The low-order 32 bits of the result are placed into word element 1 of",
                "VSR[VRT+32].",
                "",
                "The sum of the signed integer values in word elements 2 and 3 in",
                "VSR[VRA+32] is added to the signed integer value in word",
                "element 3 of VSR[VRB+32].",
                "",
                "",
                "",
                "The low-order 32 bits of the result are placed into word element 3 of",
                "VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sum2s"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Sum across Quarter Signed Byte Saturate",
                    "form": "VX",
                    "mnemonic": "vsum4sbs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1800",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  temp := EXTS(VSR[VRB+32].word[i])",
                "  do j = 0 to 3",
                "     temp := temp + EXTS(VSR[VRA+32].word[i].byte[j])",
                "  end",
                "  VSR[VRT+32].word[i] := si32_CLAMP(temp)",
                "VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The sum of the signed integer values in the four byte elements",
                "contained in word element i of VSR[VRA+32] is",
                "added to the signed integer value in word element i of",
                "VSR[VRB+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sum4s"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Sum across Quarter Signed Halfword Saturate",
                    "form": "VX",
                    "mnemonic": "vsum4shs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1608",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  temp := EXTS(VSR[VRB+32].word[i])",
                "  do j = 0 to 1",
                "     temp := temp + EXTS(VSR[VRA+32].word[i].hword[j])",
                "  end",
                "  VSR[VRT+32].word[i] := si32_CLAMP(temp)",
                "VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The sum of the signed integer values in the two halfword elements",
                "contained in word element i of VSR[VRA+32] is",
                "added to the signed integer value in word element i of",
                "VSR[VRB+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into the corresponding word element of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sum4s"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Sum across Quarter Unsigned Byte Saturate",
                    "form": "VX",
                    "mnemonic": "vsum4ubs",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1544",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  temp := EXTZ(VSR[VRB+32].word[i])",
                "  do j = 0 to 3",
                "     temp := temp + EXTZ(VSR[VRA+32].word[i].byte[j])",
                "  end",
                "  VSR[VRT+32].word[i] := ui32_CLAMP(temp)",
                "VSCR.SAT := sat_flag",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The sum of the unsigned integer values in the four byte elements",
                "contained in word element i of VSR[VRA+32] is",
                "added to the unsigned integer value in word element i of",
                "VSR[VRB+32].",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sum4s"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Negate Word",
                    "form": "VX",
                    "mnemonic": "vnegw",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "6",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1538",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src := EXTS(VSR[VRB+32].word[i])",
                "",
                "  VSR[VRT+32].word[i] := CHOP32(~src + 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the",
                "following.",
                "",
                "",
                "",
                "The sum of the one\u00e2\u20ac\u2122s-complement of the signed integer in word element",
                "i of VSR[VRB+32] and 1 is placed into word",
                "element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Negate Doubleword",
                    "form": "VX",
                    "mnemonic": "vnegd",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "7",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1538",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src := EXTS(VSR[VRB+32].dword[i])",
                "",
                "  VSR[VRT+32]dword[i] := CHOP64(~src + 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the",
                "following.",
                "",
                "",
                "",
                "The sum of the one\u00e2\u20ac\u2122s-complement of the signed integer in doubleword",
                "element i of VSR[VRB+32] and 1 is placed into",
                "doubleword element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extend Sign Byte To Word",
                    "form": "VX",
                    "mnemonic": "vextsb2w",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "16",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1538",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src := VSR[VRB+32].word[i].bit[24:31]",
                "",
                "  VSR[VRT+32].word[i] := EXTS32(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The signed integer in bits 24:31 of word element i of",
                "VSR[VRB+32] is sign-extended and placed into word element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extend Sign Halfword To Word",
                    "form": "VX",
                    "mnemonic": "vextsh2w",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "17",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1538",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src := VSR[VRB+32].word[i].bit[16:31]",
                "",
                "  VSR[VRT+32].word[i] := EXTS32(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The signed integer in bits 16:31 of word element i of",
                "VSR[VRB+32] is sign-extended and placed into word element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extend Sign Byte To Doubleword",
                    "form": "VX",
                    "mnemonic": "vextsb2d",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "24",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1538",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src := VSR[VRB+32].dword[i].bit[56:63]",
                "",
                "  VSR[VRT+32].dword[i] := EXTS64(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The signed integer in bits 56:63 of doubleword element i",
                "of VSR[VRB+32] is sign-extended and placed into",
                "doubleword element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_rlnm"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extend Sign Halfword To Doubleword",
                    "form": "VX",
                    "mnemonic": "vextsh2d",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "25",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1538",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src := VSR[VRB+32].dword[i].bit[48:63]",
                "",
                "  VSR[VRT+32].dword[i] := EXTS64(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The signed integer in bits 48:63 of doubleword element i",
                "of VSR[VRB+32] is sign-extended and placed into",
                "doubleword element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extend Sign Word To Doubleword",
                    "form": "VX",
                    "mnemonic": "vextsw2d",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "26",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1538",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src := VSR[VRB+32].dword[i].bit[32:63]",
                "",
                "  VSR[VRT+32].dword[i] := EXTS64(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The signed integer in bits 32:63 of doubleword element i",
                "of VSR[VRB+32] is sign-extended and placed into",
                "doubleword element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extend Sign Doubleword to Quadword",
                    "form": "VX",
                    "mnemonic": "vextsd2q",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "27",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1538",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := EXTS128(VSR[VRB+32].bit[64:127])"
            ],
            "body": [
                "",
                "",
                "The signed integer in bits 64:127 of VSR[VRB+32] is",
                "signed extended to 128 bits and placed into VSR[VRT+32].",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Average Signed Byte",
                    "form": "VX",
                    "mnemonic": "vavgsb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1282",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  src1 := EXTS(VSR[VRA+32].byte[i])",
                "  src2 := EXTS(VSR[VRB+32].byte[i])",
                "",
                "  VSR[VRT+32].byte[i] := CHOP8((src1 + src2 + 1) >> 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let src1 be the signed integer value in byte element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the signed integer value in byte element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is added to src2.",
                "",
                "",
                "The sum is incremented by 1 and then shifted right 1 bit.",
                "",
                "",
                "The low-order 8 bits of the result are placed into byte element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_avg"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Average Unsigned Byte",
                    "form": "VX",
                    "mnemonic": "vavgub",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1026",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  src1 := EXTZ(VSR[VRA+32].byte[i])",
                "  src2 := EXTZ(VSR[VRB+32].byte[i])",
                "",
                "  VSR[VRT+32].byte[i] := CHOP8((src1 + src2 + 1) >> 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in byte element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in byte element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is added to src2.",
                "",
                "",
                "The sum is incremented by 1 and then shifted right 1 bit.",
                "",
                "",
                "The low-order 8 bits of the result are placed into byte element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_avg"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Average Signed Halfword",
                    "form": "VX",
                    "mnemonic": "vavgsh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1346",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := EXTS(VSR[VRA+32].hword[i])",
                "  src2 := EXTS(VSR[VRB+32].hword[i])",
                "",
                "  VSR[VRT+32].hword[i] := CHOP16((src1 + src2 + 1) >> 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let src1 be the signed integer value in halfword element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the signed integer value in halfword element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is added to src2.",
                "",
                "",
                "The sum is incremented by 1 and then shifted right 1 bit.",
                "",
                "",
                "The low-order 16 bits of the result are placed into halfword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_avg"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Average Unsigned Halfword",
                    "form": "VX",
                    "mnemonic": "vavguh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1090",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := EXTZ(VSR[VRA+32].hword[i])",
                "  src2 := EXTZ(VSR[VRB+32].hword[i])",
                "",
                "  VSR[VRT+32].hword[i] := CHOP16((src1 + src2 + 1) >> 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in halfword",
                "element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in halfword",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src1 is added to src2.",
                "",
                "",
                "The sum is incremented by 1 and then shifted right 1 bit.",
                "",
                "",
                "The low-order 16 bits of the result are placed into halfword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_avg"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Average Signed Word",
                    "form": "VX",
                    "mnemonic": "vavgsw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1410",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := EXTS(VSR[VRA+32].word[i])",
                "  src2 := EXTS(VSR[VRB+32].word[i])",
                "",
                "  VSR[VRT+32].word[i] := Chop32((src1 + src2 + 1) >> 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the signed integer value in word element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the signed integer value in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is added to src2.",
                "",
                "",
                "The sum is incremented by 1 and then shifted right 1 bit.",
                "",
                "",
                "The low-order 32 bits of the result are placed into word element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_avg"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Average Unsigned Word",
                    "form": "VX",
                    "mnemonic": "vavguw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1154",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := EXTZ(VSR[VRA+32].word[i])",
                "  src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "  VSR[VRT+32].word[i] := Chop32((src1 + src2 + 1) >> 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in word element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is added to src2.",
                "",
                "",
                "The sum is incremented by 1 and then shifted right 1 bit.",
                "",
                "",
                "The low-order 32 bits of the result are placed into word element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_avg"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Absolute Difference Unsigned Byte",
                    "form": "VX",
                    "mnemonic": "vabsdub",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1027",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  src1 := EXTZ(VSR[VRA+32].byte[i])",
                "  src2 := EXTZ(VSR[VRB+32].byte[i])",
                "",
                "  if src1 > src2 then",
                "     VSR[VRT+32].byte[i] := CHOP8(src1 + ~src2 + 1)",
                "  else",
                "     VSR[VRT+32].byte[i] := CHOP8(src2 + ~src1 + 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in byte element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in byte element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is subtracted by src2.",
                "",
                "",
                "The absolute value of the difference is placed into byte element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_absd"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Absolute Difference Unsigned Halfword",
                    "form": "VX",
                    "mnemonic": "vabsduh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1091",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := EXTZ(VSR[VRA+32].hword[i])",
                "  src2 := EXTZ(VSR[VRB+32].hword[i])",
                "",
                "  if src1 > src2 then",
                "     VSR[VRT+32].hword[i] := CHOP16(src1 + ~src2 + 1)",
                "  else",
                "     VSR[VRT+32].hword[i] := CHOP16(src2 + ~src1 + 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in halfword",
                "element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in halfword",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src1 is subtracted by src2.",
                "",
                "",
                "The absolute value of the difference is placed into halfword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_absd"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Absolute Difference Unsigned Word",
                    "form": "VX",
                    "mnemonic": "vabsduw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1155",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := EXTZ(VSR[VRA+32].word[i])",
                "  src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "  if src1 > src2 then",
                "     VSR[VRT+32].word[i] := CHOP32(src1 + ~src2 + 1)",
                "  else",
                "     VSR[VRT+32].word[i] := CHOP32(src2 + ~src1 + 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in word element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is subtracted by src2.",
                "",
                "",
                "The absolute value of the difference is placed into word element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_absd"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Maximum Signed Byte",
                    "form": "VX",
                    "mnemonic": "vmaxsb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "258",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  src1 := VSR[VRA+32].byte[i]",
                "  src2 := VSR[VRB+32].byte[i]",
                "",
                "  gt_flag := EXTS(src1) > EXTS(src2)",
                "  VSR[VRT+32].byte[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let src1 be the signed integer value in byte element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the signed integer value in byte element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "The larger of the two values is placed into byte element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_abs",
                "vec_abss",
                "vec_max"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Maximum Unsigned Byte",
                    "form": "VX",
                    "mnemonic": "vmaxub",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "2",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  src1 := VSR[VRA+32].byte[i]",
                "  src2 := VSR[VRB+32].byte[i]",
                "",
                "  gt_flag := EXTZ(src1) > EXTZ(src2)",
                "  VSR[VRT+32].byte[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let src1 be the signed integer value in byte element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the signed integer value in byte element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "The larger of the two values is placed into byte element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_max"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Maximum Signed Halfword",
                    "form": "VX",
                    "mnemonic": "vmaxsh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "322",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := VSR[VRA+32].hword[i]",
                "  src2 := VSR[VRB+32].hword[i]",
                "",
                "  gt_flag := EXTS(src1) > EXTS(src2)",
                "  VSR[VRT+32].hword[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let src1 be the signed integer value in halfword element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the signed integer value in halfword element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "The larger of the two values is placed into halfword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_abss",
                "vec_max"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Maximum Unsigned Halfword",
                    "form": "VX",
                    "mnemonic": "vmaxuh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "66",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := VSR[VRA+32].hword[i]",
                "  src2 := VSR[VRB+32].hword[i]",
                "",
                "  gt_flag := EXTZ(src1) > EXTZ(src2)",
                "  VSR[VRT+32].hword[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in halfword",
                "element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in halfword",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "The larger of the two values is placed into halfword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_max"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Maximum Signed Word",
                    "form": "VX",
                    "mnemonic": "vmaxsw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "386",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "",
                "  gt_flag := EXTS(src1) > EXTS(src2)",
                "  VSR[VRT+32].word[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the signed integer value in word element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the signed integer value in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "The larger of the two values is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_abs",
                "vec_abss",
                "vec_max"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Maximum Unsigned Word",
                    "form": "VX",
                    "mnemonic": "vmaxuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "130",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "",
                "  gt_flag := EXTZ(src1) > EXTZ(src2)",
                "  VSR[VRT+32].word[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in word element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "The larger of the two values is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_max"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Maximum Signed Doubleword",
                    "form": "VX",
                    "mnemonic": "vmaxsd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "450",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src1 := VSR[VRA+32].dword[i]",
                "  src2 := VSR[VRB+32].dword[i]",
                "",
                "  gt_flag := EXTS(src1) > EXTS(src2)",
                "  VSR[VRT+32].dword[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the signed integer value in doubleword",
                "element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the signed integer value in doubleword",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "The larger of the two values is placed into doubleword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_abs",
                "vec_max"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Maximum Unsigned Doubleword",
                    "form": "VX",
                    "mnemonic": "vmaxud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "194",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src1 := VSR[VRA+32].dword[i]",
                "  src2 := VSR[VRB+32].dword[i]",
                "",
                "  gt_flag := EXTZ(src1) > EXTZ(src2)",
                "  VSR[VRT+32].dword[i] := gt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in doubleword",
                "element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in doubleword",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "The larger of the two values is placed into doubleword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_max"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Minimum Signed Byte",
                    "form": "VX",
                    "mnemonic": "vminsb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "770",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  src1 := VSR[VRA+32].byte[i]",
                "  src2 := VSR[VRB+32].byte[i]",
                "",
                "  lt_flag := EXTS(src1) < EXTS(src2)",
                "  VSR[VRT+32].byte[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let src1 be the signed integer value in byte element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the signed integer value in byte element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "The smaller of the two values is placed into byte element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_min",
                "vec_nabs"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Minimum Unsigned Byte",
                    "form": "VX",
                    "mnemonic": "vminub",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "514",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  src1 := VSR[VRA+32].byte[i]",
                "  src2 := VSR[VRB+32].byte[i]",
                "",
                "  lt_flag := EXTZ(src1) < EXTZ(src2)",
                "  VSR[VRT+32].byte[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in byte element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in byte element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "The smaller of the two values is placed into byte element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_min"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Minimum Signed Halfword",
                    "form": "VX",
                    "mnemonic": "vminsh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "834",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := VSR[VRA+32].hword[i]",
                "  src2 := VSR[VRB+32].hword[i]",
                "",
                "  lt_flag := EXTS(src1) < EXTS(src2)",
                "  VSR[VRT+32].hword[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let src1 be the signed integer value in halfword element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the signed integer value in halfword element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "The smaller of the two values is placed into halfword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_min",
                "vec_nabs"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Minimum Unsigned Halfword",
                    "form": "VX",
                    "mnemonic": "vminuh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "578",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  src1 := VSR[VRA+32].hword[i]",
                "  src2 := VSR[VRB+32].hword[i]",
                "",
                "  lt_flag := EXTZ(src1) < EXTZ(src2)",
                "  VSR[VRT+32].hword[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in halfword",
                "element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in halfword",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "The smaller of the two values is placed into halfword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_min"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Minimum Signed Word",
                    "form": "VX",
                    "mnemonic": "vminsw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "898",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "",
                "  lt_flag := EXTS(src1) < EXTS(src2)",
                "  VSR[VRT+32].word[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the signed integer value in word element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the signed integer value in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "The smaller of the two values is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_min",
                "vec_nabs"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Minimum Unsigned Word",
                    "form": "VX",
                    "mnemonic": "vminuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "642",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "",
                "  lt_flag := EXTZ(src1) < EXTZ(src2)",
                "  VSR[VRT+32].word[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in word element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "The smaller of the two values is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_min"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Minimum Signed Doubleword",
                    "form": "VX",
                    "mnemonic": "vminsd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "962",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src1 := VSR[VRA+32].dword[i]",
                "  src2 := VSR[VRB+32].dword[i]",
                "",
                "  lt_flag := EXTS(src1) < EXTS(src2)",
                "  VSR[VRT+32].dword[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the signed integer value in doubleword",
                "element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the signed integer value in doubleword",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "The smaller of the two values is placed into doubleword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_min",
                "vec_nabs"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Minimum Unsigned Doubleword",
                    "form": "VX",
                    "mnemonic": "vminud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "706",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src1 := VSR[VRA+32].dword[i]",
                "  src2 := VSR[VRB+32].dword[i]",
                "",
                "  lt_flag := EXTZ(src1) < EXTZ(src2)",
                "  VSR[VRT+32].dword[i] := lt_flag=1 ? src1 : src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in doubleword",
                "element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in doubleword",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "The smaller of the two values is placed into doubleword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_min"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Equal Unsigned Byte",
                    "form": "VC",
                    "mnemonic": "vcmpequb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "name": "Vector Compare Equal Unsigned Byte",
                    "form": "VC",
                    "mnemonic": "vcmpequb.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "6",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 15",
                "  src1 := VSR[VRA+32].byte[i]",
                "  src2 := VSR[VRB+32].byte[i]",
                "  if src1 = src2 then do",
                "     VSR[VRT+32].byte[i] := 0xFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].byte[i] := 0x00",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in byte element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in byte element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of byte element i of VSR[VRT+32]",
                "are set to all 1s if src1 is equal to src2,",
                "and is set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpeq",
                "vec_all_eq",
                "vec_any_ne"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Equal Unsigned Halfword",
                    "form": "VC",
                    "mnemonic": "vcmpequh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "name": "Vector Compare Equal Unsigned Halfword",
                    "form": "VC",
                    "mnemonic": "vcmpequh.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "70",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 7",
                "  src1 := VSR[VRA+32].hword[i]",
                "  src2 := VSR[VRB+32].hword[i]",
                "  if src1 = src2 then do",
                "     VSR[VRT+32].hword[i] := 0xFFFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].hword[i] := 0x0000",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in halfword",
                "element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in halfword",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of halfword element i of VSR[VRT+32] are set to all 1s if src1 is equal to",
                "src2, and is set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpeq",
                "vec_all_eq",
                "vec_any_ne"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Equal Unsigned Word",
                    "form": "VC",
                    "mnemonic": "vcmpequw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "name": "Vector Compare Equal Unsigned Word",
                    "form": "VC",
                    "mnemonic": "vcmpequw.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "134",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "  if src1 = src2 then do",
                "     VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].word[i] := 0x0000_0000",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in word element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of word element i of VSR[VRT+32]",
                "are set to all 1s if src1 is equal to src2,",
                "and is set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpeq",
                "vec_all_eq",
                "vec_any_ne"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Equal Unsigned Doubleword",
                    "form": "VC",
                    "mnemonic": "vcmpequd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.07"
                },
                {
                    "name": "Vector Compare Equal Unsigned Doubleword",
                    "form": "VC",
                    "mnemonic": "vcmpequd.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "199",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 1",
                "  src1 := VSR[VRA+32].dword[i]",
                "  src2 := VSR[VRB+32].dword[i]",
                "  if src1 = src2 then do",
                "     VSR[VRT+32].dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].dword[i] := 0x0000_0000_0000_0000",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in doubleword",
                "element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in doubleword",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of doubleword element i of VSR[VRT+32] are set to all 1s if src1 is equal to",
                "src2, and is set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpeq",
                "vec_cmpne",
                "vec_all_eq",
                "vec_all_ne",
                "vec_any_eq",
                "vec_any_ne"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Equal Quadword",
                    "form": "VC",
                    "mnemonic": "vcmpequq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.1"
                },
                {
                    "name": "Vector Compare Equal Quadword",
                    "form": "VC",
                    "mnemonic": "vcmpequq.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "455",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "src1 := VSR[VRA+32]",
                "src2 := VSR[VRB+32]",
                "",
                "if src1 = src2 then do",
                "  VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "  all_false := 0",
                "end",
                "else do",
                "  VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "  all_true := 0",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the unsigned integer value in VSR[VRA+32].",
                "",
                "Let src2 be the unsigned integer value in VSR[VRB+32].",
                "",
                "If src1 is equal to src2, set VSR[VRT+32] to all 1s.",
                "Otherwise, set VSR[VRT+32] to all 0s.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Greater Than Signed Byte",
                    "form": "VC",
                    "mnemonic": "vcmpgtsb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "name": "Vector Compare Greater Than Signed Byte",
                    "form": "VC",
                    "mnemonic": "vcmpgtsb.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "774",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 15",
                "  src1 := EXTS(VSR[VRA+32].byte[i])",
                "  src2 := EXTS(VSR[VRB+32].byte[i])",
                "",
                "  if src1 > src2 then do",
                "     VSR[VRT+32].byte[i] := 0xFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].byte[i] := 0x00",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in byte element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in byte element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of byte element i of VSR[VRT+32]",
                "are set to all 1s if src1 is equal to src2,",
                "and is set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpge",
                "vec_cmpgt",
                "vec_cmple",
                "vec_cmplt",
                "vec_all_ge",
                "vec_all_gt",
                "vec_all_le",
                "vec_all_lt",
                "vec_any_ge",
                "vec_any_gt",
                "vec_any_le",
                "vec_any_lt"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Greater Than Unsigned Byte",
                    "form": "VC",
                    "mnemonic": "vcmpgtub",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "name": "Vector Compare Greater Than Unsigned Byte",
                    "form": "VC",
                    "mnemonic": "vcmpgtub.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "518",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 15",
                "  src1 := EXTZ(VSR[VRA+32].byte[i])",
                "  src2 := EXTZ(VSR[VRB+32].byte[i])",
                "",
                "  if src1 > src2 then do",
                "     VSR[VRT+32].byte[i] := 0xFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].byte[i] := 0x00",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in byte element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in byte element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of byte element i of VSR[VRT+32]",
                "are set to all 1s if src1 is greater than src2, and is set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpge",
                "vec_cmpgt",
                "vec_cmple",
                "vec_cmplt",
                "vec_all_ge",
                "vec_all_gt",
                "vec_all_le",
                "vec_all_lt",
                "vec_any_ge",
                "vec_any_gt",
                "vec_any_le",
                "vec_any_lt"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Greater Than Signed Halfword",
                    "form": "VC",
                    "mnemonic": "vcmpgtsh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "name": "Vector Compare Greater Than Signed Halfword",
                    "form": "VC",
                    "mnemonic": "vcmpgtsh.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "838",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 7",
                "  src1 := EXTS(VSR[VRA+32].hword[i])",
                "  src2 := EXTS(VSR[VRB+32].hword[i])",
                "",
                "  if src1 > src2 then do",
                "     VSR[VRT+32].hword[i] := 0xFFFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].hword[i] := 0x0000",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let src1 be the signed integer value in halfword element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the signed integer value in halfword element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of halfword element i of VSR[VRT+32] are set to all 1s if src1 is greater than",
                "src2, and is set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpge",
                "vec_cmpgt",
                "vec_cmple",
                "vec_cmplt",
                "vec_all_ge",
                "vec_all_gt",
                "vec_all_le",
                "vec_all_lt",
                "vec_any_ge",
                "vec_any_gt",
                "vec_any_le",
                "vec_any_lt"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Greater Than Unsigned Halfword",
                    "form": "VC",
                    "mnemonic": "vcmpgtuh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "name": "Vector Compare Greater Than Unsigned Halfword",
                    "form": "VC",
                    "mnemonic": "vcmpgtuh.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "582",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 7",
                "  src1 := EXTZ(VSR[VRA+32].hword[i])",
                "  src2 := EXTZ(VSR[VRB+32].hword[i])",
                "",
                "  if src1 > src2 then do",
                "     VSR[VRT+32].hword[i] := 0xFFFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].hword[i] := 0x0000",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in halfword",
                "element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in halfword",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of halfword element i of VSR[VRT+32] are set to all 1s if src1 is greater than",
                "src2, and is set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpge",
                "vec_cmpgt",
                "vec_cmple",
                "vec_cmplt",
                "vec_all_ge",
                "vec_all_gt",
                "vec_all_le",
                "vec_all_lt",
                "vec_any_ge",
                "vec_any_gt",
                "vec_any_le",
                "vec_any_lt"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Greater Than Signed Word",
                    "form": "VC",
                    "mnemonic": "vcmpgtsw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "name": "Vector Compare Greater Than Signed Word",
                    "form": "VC",
                    "mnemonic": "vcmpgtsw.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "902",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "  src1 := EXTS(VSR[VRA+32].word[i])",
                "  src2 := EXTS(VSR[VRB+32].word[i])",
                "",
                "  if src1 > src2 then do",
                "     VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].word[i] := 0x0000_0000",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the signed integer value in word element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the signed integer value in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of word element i of VSR[VRT+32]",
                "are set to all 1s if src1 is greater than src2, and is set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpge",
                "vec_cmpgt",
                "vec_cmple",
                "vec_cmplt",
                "vec_all_ge",
                "vec_all_gt",
                "vec_all_le",
                "vec_all_lt",
                "vec_any_ge",
                "vec_any_gt",
                "vec_any_le",
                "vec_any_lt"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Greater Than Unsigned Word",
                    "form": "VC",
                    "mnemonic": "vcmpgtuw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "name": "Vector Compare Greater Than Unsigned Word",
                    "form": "VC",
                    "mnemonic": "vcmpgtuw.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "646",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "  src1 := EXTZ(VSR[VRA+32].word[i])",
                "  src2 := EXTZ(VSR[VRB+32].word[i])",
                "",
                "  if src1 > src2 then do",
                "     VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].word[i] := 0x0000_0000",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in word element",
                "i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of word element i of VSR[VRT+32]",
                "are set to all 1s if src1 is greater than src2, and is set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpge",
                "vec_cmpgt",
                "vec_cmple",
                "vec_cmplt",
                "vec_all_ge",
                "vec_all_gt",
                "vec_all_le",
                "vec_all_lt",
                "vec_any_ge",
                "vec_any_gt",
                "vec_any_le",
                "vec_any_lt"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Greater Than Signed Doubleword",
                    "form": "VC",
                    "mnemonic": "vcmpgtsd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.07"
                },
                {
                    "name": "Vector Compare Greater Than Signed Doubleword",
                    "form": "VC",
                    "mnemonic": "vcmpgtsd.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "967",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 1",
                "  src1 := EXTS(VSR[VRA+32].dword[i])",
                "  src2 := EXTS(VSR[VRB+32].dword[i])",
                "",
                "  if src1 > src2 then do",
                "     VSR[VRT+32].dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].dword[i] := 0x0000_0000_0000_0000",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the signed integer value in doubleword",
                "element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the signed integer value in doubleword",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of doubleword element i of VSR[VRT+32] are set to all 1s if src1 is greater than",
                "src2, and is set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpge",
                "vec_cmpgt",
                "vec_cmple",
                "vec_cmplt",
                "vec_all_ge",
                "vec_all_gt",
                "vec_all_le",
                "vec_all_lt",
                "vec_any_ge",
                "vec_any_gt",
                "vec_any_le",
                "vec_any_lt"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Greater Than Unsigned Doubleword",
                    "form": "VC",
                    "mnemonic": "vcmpgtud",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.07"
                },
                {
                    "name": "Vector Compare Greater Than Unsigned Doubleword",
                    "form": "VC",
                    "mnemonic": "vcmpgtud.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "711",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 1",
                "  src1 := EXTZ(VSR[VRA+32].dword[i])",
                "  src2 := EXTZ(VSR[VRB+32].dword[i])",
                "",
                "  if src1 > src2 then do",
                "     VSR[VRT+32].dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].dword[i] := 0x0000_0000_0000_0000",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in doubleword",
                "element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the unsigned integer value in doubleword",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of doubleword element i of VSR[VRT+32] are set to all 1s if src1 is greater than",
                "src2, and is set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpge",
                "vec_cmpgt",
                "vec_cmple",
                "vec_cmplt",
                "vec_all_ge",
                "vec_all_gt",
                "vec_all_le",
                "vec_all_lt",
                "vec_any_ge",
                "vec_any_gt",
                "vec_any_le",
                "vec_any_lt"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Greater Than Signed Quadword",
                    "form": "VC",
                    "mnemonic": "vcmpgtsq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.1"
                },
                {
                    "name": "Vector Compare Greater Than Signed Quadword",
                    "form": "VC",
                    "mnemonic": "vcmpgtsq.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "903",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "src1 := EXTS(VSR[VRA+32])",
                "src2 := EXTS(VSR[VRB+32])",
                "",
                "if src1 > src2 then do",
                "  VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "  all_false := 0",
                "end",
                "else do",
                "  VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "  all_true := 0",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the signed integer value in VSR[VRA+32].",
                "",
                "Let src2 be the signed integer value in VSR[VRB+32].",
                "",
                "src1 is compared to src2.",
                "",
                "The contents of VSR[VRT+32] are set to all 1s if",
                "src1 is greater than src2, and are set to all",
                "0s otherwise.",
                "",
                "If Rc=1, CR field 6 is set to indicate if src1 is greater than src2 or if src1 is not",
                "greater than src2.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Greater Than Unsigned Quadword",
                    "form": "VC",
                    "mnemonic": "vcmpgtuq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.1"
                },
                {
                    "name": "Vector Compare Greater Than Unsigned Quadword",
                    "form": "VC",
                    "mnemonic": "vcmpgtuq.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "647",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "",
                "if src1 > src2 then do",
                "  VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "  all_false := 0",
                "end",
                "else do",
                "  VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "  all_true := 0",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the unsigned integer value in VSR[VRA+32].",
                "",
                "Let src2 be the unsigned integer value in VSR[VRB+32].",
                "",
                "src1 is compared to src2.",
                "",
                "The contents of VSR[VRT+32] are set to all 1s if",
                "src1 is greater than src2, and are set to all",
                "0s otherwise.",
                "",
                "If Rc=1, CR field 6 is set to indicate if src1 is greater than src2 or if src1 is not",
                "greater than src2.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Not Equal Byte",
                    "form": "VC",
                    "mnemonic": "vcmpneb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "Vector Compare Not Equal Byte",
                    "form": "VC",
                    "mnemonic": "vcmpneb.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "7",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 15",
                "  src1 := VSR[VRA+32].byte[i]",
                "  src2 := VSR[VRB+32].byte[i]",
                "",
                "  if src1 != src2 then do",
                "     VSR[VRT+32].byte[i] := 0xFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].byte[i] := 0x00",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of byte element i of",
                "VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of byte element i of",
                "VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of byte element i of VSR[VRT+32]",
                "are set to all 1s if src1 is not equal to src2, and are set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpne",
                "vec_first_match_index",
                "vec_first_match_or_eos_index",
                "vec_first_mismatch_index",
                "vec_first_mismatch_or_eos_index",
                "vec_all_ne",
                "vec_any_eq"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Not Equal or Zero Byte",
                    "form": "VC",
                    "mnemonic": "vcmpnezb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "Vector Compare Not Equal or Zero Byte",
                    "form": "VC",
                    "mnemonic": "vcmpnezb.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "263",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 15",
                "  src1 := VSR[VRA+32].byte[i]",
                "  src2 := VSR[VRB+32].byte[i]",
                "",
                "  if src1 = 0 | src2 = 0 | src1 != src2 then do",
                "     VSR[VRT+32].byte[i] := 0xFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].byte[i] := 0x00",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of byte element i of",
                "VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of byte element i of",
                "VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of byte element i of VSR[VRT+32]",
                "are set to all 1s if src1 is not equal to src2 or either src1 or src2 is equal to",
                "0x00, and are set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpnez",
                "vec_first_match_or_eos_index",
                "vec_first_mismatch_or_eos_index"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Not Equal Halfword",
                    "form": "VC",
                    "mnemonic": "vcmpneh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "Vector Compare Not Equal Halfword",
                    "form": "VC",
                    "mnemonic": "vcmpneh.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "71",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 7",
                "  src1 := VSR[VRA+32].hword[i]",
                "  src2 := VSR[VRB+32].hword[i]",
                "",
                "  if src1 != src2 then do",
                "     VSR[VRT+32].hword[i] := 0xFFFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].hword[i] := 0x0000",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of halfword element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of halfword element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of halfword element i of VSR[VRT+32] are set to all 1s if src1 is not equal to",
                "src2, and is set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpne",
                "vec_first_match_index",
                "vec_first_match_or_eos_index",
                "vec_first_mismatch_index",
                "vec_first_mismatch_or_eos_index",
                "vec_all_ne",
                "vec_any_eq"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Not Equal or Zero Halfword",
                    "form": "VC",
                    "mnemonic": "vcmpnezh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "Vector Compare Not Equal or Zero Halfword",
                    "form": "VC",
                    "mnemonic": "vcmpnezh.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "327",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 7",
                "  src1 := VSR[VRA+32].hword[i]",
                "  src2 := VSR[VRB+32].hword[i]",
                "",
                "  if src1 = 0 | src2 = 0 | src1 != src2 then do",
                "     VSR[VRT+32].hword[i] := 0xFFFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].hword[i] := 0x0000",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of halfword element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of halfword element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of halfword element i of VSR[VRT+32] are set to all 1s if src1 is not equal to",
                "src2 or either src1 or src2 is",
                "equal to 0x00, and is set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpnez",
                "vec_first_match_or_eos_index",
                "vec_first_mismatch_or_eos_index"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Not Equal Word",
                    "form": "VC",
                    "mnemonic": "vcmpnew",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "Vector Compare Not Equal Word",
                    "form": "VC",
                    "mnemonic": "vcmpnew.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "135",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "",
                "  if src1 != src2 then do",
                "     VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].word[i] := 0x0000_0000",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of word element i of",
                "VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of word element i of",
                "VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of word element i of VSR[VRT+32]",
                "are set to all 1s if src1 is not equal to src2, and is set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpne",
                "vec_first_match_index",
                "vec_first_match_or_eos_index",
                "vec_first_mismatch_index",
                "vec_first_mismatch_or_eos_index",
                "vec_all_ne",
                "vec_any_eq"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Not Equal or Zero Word",
                    "form": "VC",
                    "mnemonic": "vcmpnezw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "Vector Compare Not Equal or Zero Word",
                    "form": "VC",
                    "mnemonic": "vcmpnezw.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "391",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "",
                "  if src1 = 0 | src2 = 0 | src1 != src2 then do",
                "     VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "     all_false := 0",
                "  end",
                "  else do",
                "     VSR[VRT+32].word[i] := 0x0000_0000",
                "     all_true := 0",
                "  end",
                "end",
                "",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of word element i of",
                "VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of word element i of",
                "VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of word element i of VSR[VRT+32]",
                "are set to all 1s if src1 is not equal to src2 or either src1 or src2 is equal to",
                "0x00, and is set to all 0s otherwise.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpnez",
                "vec_first_match_or_eos_index",
                "vec_first_mismatch_or_eos_index"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Signed Quadword",
                    "form": "VX",
                    "mnemonic": "vcmpsq",
                    "operands": [
                        "BF",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "321",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTS(VSR[VRA+32])",
                "src2 := EXTS(VSR[VRB+32])",
                "",
                "lt_flag := src1 < src2",
                "gt_flag := src1 > src2",
                "eq_flag := src1 = src2",
                "",
                "CR.field[BF] := lt_flag<<3 | gt_flag<<2 | eq_flag<<1"
            ],
            "body": [
                "",
                "",
                "Let src1 be the signed integer value in VSR[VRA+32].",
                "",
                "Let src2 be the signed integer value in VSR[VRB+32].",
                "",
                "Compare src1 with src2, place the comparison",
                "flags into CR field BF.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Unsigned Quadword",
                    "form": "VX",
                    "mnemonic": "vcmpuq",
                    "operands": [
                        "BF",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "257",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src1 := EXTZ(VSR[VRA+32])",
                "src2 := EXTZ(VSR[VRB+32])",
                "",
                "lt_flag := src1 < src2",
                "gt_flag := src1 > src2",
                "eq_flag := src1 = src2",
                "",
                "CR.field[BF] := lt_flag<<3 | gt_flag<<2 | eq_flag<<1"
            ],
            "body": [
                "",
                "",
                "Let src1 be the unsigned integer value in VSR[VRA+32].",
                "",
                "Let src2 be the unsigned integer value in VSR[VRB+32].",
                "",
                "Compare src1 with src2, place the comparison",
                "flags into CR field BF.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Logical AND",
                    "form": "VX",
                    "mnemonic": "vand",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1028",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] & VSR[VRB+32]"
            ],
            "body": [
                "",
                "",
                "The contents of VSR[VRA+32] are ANDed with the contents",
                "of VSR[VRB+32] and the result is placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Logical AND with Complement",
                    "form": "VX",
                    "mnemonic": "vandc",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1092",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] & ~VSR[VRB+32]"
            ],
            "body": [
                "",
                "",
                "The contents of VSR[VRA+32] are ANDed with the complement",
                "of the contents of VSR[VRB+32] and the result is placed",
                "into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Logical Equivalence",
                    "form": "VX",
                    "mnemonic": "veqv",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1668",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] == VSR[VRB+32]"
            ],
            "body": [
                "",
                "",
                "The contents of VSR[VRA+32] are XORed with the contents",
                "of VSR[VRB+32] and the complemented result is placed into",
                "VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Logical NAND",
                    "form": "VX",
                    "mnemonic": "vnand",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1412",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := ~( VSR[VRA+32] & VSR[VRB+32] )"
            ],
            "body": [
                "",
                "",
                "The contents of VSR[VRA+32] are ANDed with the contents",
                "of VSR[VRB+32] and the complemented result is placed into",
                "VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Logical OR",
                    "form": "VX",
                    "mnemonic": "vor",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1156",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] | VSR[VRB+32]"
            ],
            "body": [
                "",
                "",
                "The contents of VSR[VRA+32] are ORed with the contents of",
                "VSR[VRB+32] and the result is placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Logical OR with Complement",
                    "form": "VX",
                    "mnemonic": "vorc",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1348",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] | ~VSR[VRB+32]"
            ],
            "body": [
                "",
                "",
                "The contents of VSR[VRA+32] are ORed with the complement",
                "of the contents of VSR[VRB+32] and the result is placed",
                "into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Logical NOR",
                    "form": "VX",
                    "mnemonic": "vnor",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1284",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := ~( VSR[VRA+32] | VSR[VRB+32] )"
            ],
            "body": [
                "",
                "",
                "The contents of VSR[VRA+32] are ORed with the contents of",
                "VSR[VRB+32] and the complemented result is placed into",
                "VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Logical XOR",
                    "form": "VX",
                    "mnemonic": "vxor",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1220",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "VSR[VRT+32] := VSR[VRA+32] ^ VSR[VRB+32]"
            ],
            "body": [
                "",
                "",
                "The contents of VSR[VRA+32] are XORed with the contents",
                "of VSR[VRB+32] and the result is placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Rotate Left Byte",
                    "form": "VX",
                    "mnemonic": "vrlb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "4",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "  src := VSR[VRA+32].byte[i]",
                "  sh  := VSR[VRB+32].byte[i].bit[5:7]",
                "",
                "  VSR[VRT+32].byte[i] := src <<< sh",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of byte element i of",
                "VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of byte element i of",
                "VSR[VRB+32].",
                "",
                "",
                "src1 is rotated left by the number of bits specified in",
                "the low-order 3 bits of src2.",
                "",
                "",
                "The result is placed into byte element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_rl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Rotate Left Halfword",
                    "form": "VX",
                    "mnemonic": "vrlh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "68",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "  src := VSR[VRA+32].hword[i]",
                "  sh  := VSR[VRB+32].hword[i].bit[12:15]",
                "",
                "  VSR[VRT+32].hword[i] := src <<< sh",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of halfword element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of halfword element i of VSR[VRB+32].",
                "",
                "",
                "src1 is rotated left by the number of bits specified in",
                "the low-order 4 bits of src2.",
                "",
                "",
                "The result is placed into halfword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_rl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Rotate Left Word",
                    "form": "VX",
                    "mnemonic": "vrlw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "132",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src := VSR[VRA+32].word[i]",
                "  sh  := VSR[VRB+32].word[i].bit[27:31]",
                "",
                "  VSR[VRT+32].word[i] := src <<< sh",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of word element i of",
                "VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of word element i of",
                "VSR[VRB+32].",
                "",
                "",
                "src1 is rotated left by the number of bits specified in",
                "the low-order 5 bits of src2.",
                "",
                "",
                "The result is placed into word element i in VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_rl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Rotate Left Doubleword",
                    "form": "VX",
                    "mnemonic": "vrld",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "196",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "  src := VSR[VRA+32].dword[i]",
                "  sh  := VSR[VRB+32].dword[i].bit[58:63]",
                "",
                "  VSR[VRT+32].dword[i] := src <<< sh",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of doubleword element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of doubleword element i of VSR[VRB+32].",
                "",
                "",
                "src1 is rotated left by the number of bits specified in",
                "the low-order 6 bits of src2.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_rl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Rotate Left Quadword",
                    "form": "VX",
                    "mnemonic": "vrlq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "5",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "n := VSR[VRB+32].bit[57:63]",
                "VSR[VRT+32] := ROTL128(VSR[VRA+32], n)"
            ],
            "body": [
                "",
                "",
                "Let SH be the contents of bits 57:63 of VSR[VRB+32].",
                "",
                "Let src1 be the contents of VSR[VRA+32].",
                "",
                "src1 is rotated left by SH bits.",
                "Bits shifted out on the left are shifted in on the right to replace",
                "vacated bits.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Rotate Left Word then AND with Mask",
                    "form": "VX",
                    "mnemonic": "vrlwnm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "389",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src1.word[0] := VSR[VRA+32].word[i]",
                "  src1.word[1] := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "  b := src2.bit[11:15]",
                "  e := src2.bit[19:23]",
                "  n := src2.bit[27:31]",
                "  r := src1.bit[n:n+31]",
                "  m := MASK(b, e)",
                "  VSR[VRT+32].word[i] := r & m"
            ],
            "body": [
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of word element i of",
                "VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of word element i of",
                "VSR[VRB+32].",
                "",
                "",
                "Let mb be the contents of bits 11:15 of",
                "src2.",
                "",
                "",
                "Let me be the contents of bits 19:23 of",
                "src2.",
                "",
                "",
                "Let sh be the contents of bits 27:31 of",
                "src2.",
                "",
                "",
                "src1 is rotated left sh bits.",
                "",
                "",
                "A mask is generated having 1-bits from bit mb through bit",
                "me and 0-bits elsewhere.",
                "",
                "",
                "The rotated data are ANDed with the generated mask.",
                "",
                "",
                "The result is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_rlnm"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Rotate Left Doubleword then AND with Mask",
                    "form": "VX",
                    "mnemonic": "vrldnm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "453",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "  src1.dword[0] := VSR[VRA+32].dword[i]",
                "  src1.dword[1] := VSR[VRA+32].dword[i]",
                "  src2 := VSR[VRB+32].dword[i]",
                "  b := src2.bit[42:47]",
                "  e := src2.bit[50:55]",
                "  n := src2.bit[58:63]",
                "  r := src1.bit[n:n+63]",
                "  m := MASK(b, e)",
                "  VSR[VRT+32].dword[i] := r & m"
            ],
            "body": [
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of doubleword element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of doubleword element i of VSR[VRB+32].",
                "",
                "",
                "Let mb be the contents of bits 42:47 of",
                "src2.",
                "",
                "",
                "Let me be the contents of bits 50:55 of",
                "src2.",
                "",
                "",
                "Let sh be the contents of bits 58:63 of",
                "src2.",
                "",
                "",
                "src1 is rotated left sh bits.",
                "",
                "",
                "A mask is generated having 1-bits from bit mb through bit",
                "me and 0-bits elsewhere.",
                "",
                "",
                "The rotated data are ANDed with the generated mask.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_rlnm"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Rotate Left Quadword then AND with Mask",
                    "form": "VX",
                    "mnemonic": "vrlqnm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "325",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "b := VSR[VRB+32].bit[41:47]",
                "e := VSR[VRB+32].bit[49:55]",
                "n := VSR[VRB+32].bit[57:63]",
                "r := ROTL128(VSR[VRA+32],n)",
                "m := MASK128(b, e)",
                "VSR[VRT+32] := r & m"
            ],
            "body": [
                "",
                "",
                "Let src1 be the contents of VSR[VRA+32].",
                "",
                "Let src2 be the contents of VSR[VRB+32].",
                "",
                "Let mb be the contents of bits 41:47 of src2.",
                "",
                "Let me be the contents of bits 49:55 of src2.",
                "",
                "Let sh be the contents of bits 57:63 of src2.",
                "",
                "src1 is rotated left sh bits.",
                "",
                "A mask is generated having 1-bits from bit mb through bit",
                "me and 0-bits elsewhere.",
                "",
                "The rotated data are ANDed with the generated mask.",
                "",
                "The result is placed into VSR[VRT+32].",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Rotate Left Word then Mask Insert",
                    "form": "VX",
                    "mnemonic": "vrlwmi",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "133",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src1.word[0] := VSR[VRA+32].word[i]",
                "  src1.word[1] := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "  src3 := VSR[VRT+32].word[i]",
                "  b := src2.bit[11:15]",
                "  e := src2.bit[19:23]",
                "  n := src2.bit[27:31]",
                "  r := src1.bit[n:n+31]",
                "  m := MASK(b, e)",
                "  VSR[VRT+32].word[i] := (r & m) | (src3 & ~m)"
            ],
            "body": [
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of word element i of",
                "VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of word element i of",
                "VSR[VRB+32].",
                "",
                "",
                "Let src3 be the contents of word element i of",
                "VSR[VRT+32].",
                "",
                "",
                "Let mb be the contents of bits 11:15 of",
                "src2.",
                "",
                "",
                "Let me be the contents of bits 19:23 of",
                "src2.",
                "",
                "",
                "Let sh be the contents of bits 27:31 of",
                "src2.",
                "",
                "",
                "src1 is rotated left sh bits.",
                "",
                "",
                "A mask is generated having 1-bits from bit mb through bit",
                "me and 0-bits elsewhere.",
                "",
                "",
                "The rotated data are inserted into src3 under control of",
                "the generated mask.",
                "",
                "",
                "The result is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_rlmi"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Rotate Left Doubleword then Mask Insert",
                    "form": "VX",
                    "mnemonic": "vrldmi",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "197",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "  src1.dword[0] := VSR[VRA+32].dword[i]",
                "  src1.dword[1] := VSR[VRA+32].dword[i]",
                "  src2 := VSR[VRB+32].dword[i]",
                "  src3 := VSR[VRT+32].dword[i]",
                "  b := src2.bit[42:47]",
                "  e := src2.bit[50:55]",
                "  n := src2.bit[58:63]",
                "  r := src1.bit[n:n+63]",
                "  m := MASK(b, e)",
                "  VSR[VRT+32].dword[i] := (r & m) | (src3 & ~m)"
            ],
            "body": [
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of doubleword element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of doubleword element i of VSR[VRB+32].",
                "",
                "",
                "Let src3 be the contents of doubleword element i of VSR[VRT+32].",
                "",
                "",
                "Let mb be the contents of bits 42:47 of",
                "src2.",
                "",
                "",
                "Let me be the contents of bits 50:55 of",
                "src2.",
                "",
                "",
                "Let sh be the contents of bits 58:63 of",
                "src2.",
                "",
                "",
                "src1 is rotated left sh bits.",
                "",
                "",
                "A mask is generated having 1-bits from bit mb through bit",
                "me and 0-bits elsewhere.",
                "",
                "",
                "The rotated data are inserted into src3 under control of",
                "the generated mask.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_rlmi"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Rotate Left Quadword then Mask Insert",
                    "form": "VX",
                    "mnemonic": "vrlqmi",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "69",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "b := VSR[VRB+32].bit[41:47]",
                "e := VSR[VRB+32].bit[49:55]",
                "n := VSR[VRB+32].bit[57:63]",
                "r := ROTL128(VSR[VRA+32],n)",
                "m := MASK128(b, e)",
                "VSR[VRT+32] := (r & m) | (VSR[VRT+32] & ~m)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the contents of VSR[VRA+32].",
                "",
                "Let src2 be the contents of VSR[VRB+32].",
                "",
                "Let src3 be the contents of VSR[VRT+32].",
                "",
                "Let mb be the contents of bits 41:47 of src2.",
                "",
                "Let me be the contents of bits 49:55 of src2.",
                "",
                "Let sh be the contents of bits 57:63 of src2.",
                "",
                "src1 is rotated left sh bits.",
                "",
                "A mask is generated having 1-bits from bit mb through bit",
                "me and 0-bits elsewhere.",
                "",
                "The rotated data are inserted into src3 under control of",
                "the generated mask.",
                "",
                "The result is placed into VSR[VRT+32].",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Left Byte",
                    "form": "VX",
                    "mnemonic": "vslb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "260",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 15",
                "  src1 := VSR[VRA+32].byte[i]",
                "  src2 := VSR[VRB+32].byte[i].bit[5:7]",
                "  VSR[VRT+32].byte[i] := src1 << src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of byte element i of",
                "VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of byte element i of",
                "VSR[VRB+32].",
                "",
                "",
                "src1 is shifted left by the number of bits specified in",
                "the low-order 3 bits of src2.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into byte element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Left Halfword",
                    "form": "VX",
                    "mnemonic": "vslh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "324",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "  src1 := VSR[VRA+32].hword[i]",
                "  src2 := VSR[VRB+32].hword[i].bit[12:15]",
                "  VSR[VRT+32].hword[i] := src1 << src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of halfword element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of halfword element i of VSR[VRB+32].",
                "",
                "",
                "src1 is shifted left by the number of bits specified in",
                "the low-order 4 bits of src2.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into halfword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Left Word",
                    "form": "VX",
                    "mnemonic": "vslw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "388",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i].bit[27:31]",
                "",
                "  VSR[VRT+32].word[i] := src1 << src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of word element i of",
                "VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of word element i of",
                "VSR[VRB+32].",
                "",
                "",
                "src1 is shifted left by the number of bits specified in",
                "the low-order 5 bits of src2.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_rlnm",
                "vec_sl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Left Doubleword",
                    "form": "VX",
                    "mnemonic": "vsld",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1476",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "  src1 := VSR[VRA+32].dword[i]",
                "src2 := VSR[VRB+32].dword[i].bit[58:63]",
                "",
                "  VSR[VRT+32].dword[i] := src1 << src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of doubleword element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of doubleword element i of VSR[VRB+32].",
                "",
                "",
                "src1 is shifted left by the number of bits specified in",
                "the low-order 6 bits of src2.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_rlnm",
                "vec_sl"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Left Quadword",
                    "form": "VX",
                    "mnemonic": "vslq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "261",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32] := VSR[VRA+32] << VSR[VRB+32].bit[57:63]"
            ],
            "body": [
                "",
                "",
                "Let n be the contents of bits 57:63 of VSR[VRB+32].",
                "",
                "Let src1 be the contents of VSR[VRA+32].",
                "",
                "Let src2 be the contents of VSR[VRB+32].",
                "",
                "src1 is shifted left by the number of bits specified in",
                "the low-order 7 bits of src2.",
                "",
                "",
                "",
                "The result is placed into VSR[VRT+32].",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Right Byte",
                    "form": "VX",
                    "mnemonic": "vsrb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "516",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 15",
                "  src1 := VSR[VRA+32].byte[i]",
                "  src2 := VSR[VRB+32].byte[i].bit[5:7]",
                "  VSR[VRT+32].byte[i] := CHOP8(EXTZ(src1) >> src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of byte element i of",
                "VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of byte element i of",
                "VSR[VRB+32].",
                "",
                "",
                "src1 is shifted right by the number of bits specified in",
                "the low-order 3 bits of src2.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into byte element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sr"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Right Halfword",
                    "form": "VX",
                    "mnemonic": "vsrh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "580",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "  src := VSR[VRA+32].hword[i]",
                "  src2 := VSR[VRB+32].hword[i].bit[12:15]",
                "  VSR[VRT+32].hword[i] := CHOP16(EXTZ(src1) >> src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of halfword element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of halfword element i of VSR[VRB+32].",
                "",
                "",
                "src1 is shifted right by the number of bits specified in",
                "the low-order 4 bits of src2.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into halfword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sr"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Right Word",
                    "form": "VX",
                    "mnemonic": "vsrw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "644",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i].bit[27:31]",
                "  VSR[VRT+32].word[i] := CHOP32(EXTZ(src1) >> src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of word element i of",
                "VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of word element i of",
                "VSR[VRB+32].",
                "",
                "",
                "src1 is shifted right by the number of bits specified in",
                "the low-order 5 bits of src2.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sr"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Right Doubleword",
                    "form": "VX",
                    "mnemonic": "vsrd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1732",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "  src1 := VSR[VRA+32].dword[i]",
                "src2 := VSR[VRB+32].dword[i].bit[58:63]",
                "  VSR[VRT+32].dword[i] := CHOP64(EXTZ(src1) >> src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of doubleword element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of doubleword element i of VSR[VRB+32].",
                "",
                "",
                "src1 are shifted right by the number of bits specified in",
                "bits 58:63 of src2.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sr"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Right Quadword",
                    "form": "VX",
                    "mnemonic": "vsrq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "517",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "src1 := VSR[VRA+32]",
                "src2 := VSR[VRB+32].bit[57:63]",
                "VSR[VRT+32] := CHOP128(EXTZ(src1) >> src2)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the contents of VSR[VRA+32].",
                "",
                "Let src2 be the contents of VSR[VRB+32].",
                "",
                "src1 is shifted right by the number of bits specified in",
                "the low-order 7 bits of src2.",
                "",
                "",
                "",
                "The result is placed into VSR[VRT+32].",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Right Algebraic Byte",
                    "form": "VX",
                    "mnemonic": "vsrab",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "772",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 15",
                "  src1 := VSR[VRA+32].byte[i]",
                "  src2 := VSR[VRB+32].byte[i].bit[5:7]",
                "  VSR[VRT+32].byte[i] := CHOP8(EXTS(src1) >> src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of byte element i of",
                "VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of byte element i of",
                "VSR[VRB+32].",
                "",
                "",
                "src1 is shifted right by the number of bits specified in",
                "the low-order 3 bits of src2.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into byte element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sra"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Right Algebraic Halfword",
                    "form": "VX",
                    "mnemonic": "vsrah",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "836",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "  src1 := VSR[VRA+32].hword[i]",
                "  src2 := VSR[VRB+32].hword[i].bit[12:15]",
                "  VSR[VRT+32].hword[i] := CHOP16(EXTS(src1) >> src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of halfword element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of halfword element i of VSR[VRB+32].",
                "",
                "",
                "src1 is shifted right by the number of bits specified in",
                "the low-order 4 bits of src2.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into halfword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sra"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Right Algebraic Word",
                    "form": "VX",
                    "mnemonic": "vsraw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "900",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i].bit[27:31]",
                "  VSR[VRT+32].word[i] := CHOP32(EXTS(src1) >> src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of word element i of",
                "VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of word element i of",
                "VSR[VRB+32].",
                "",
                "",
                "src1 is shifted right by the number of bits specified in",
                "the low-order 5 bits of src2.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sra"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Right Algebraic Doubleword",
                    "form": "VX",
                    "mnemonic": "vsrad",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "964",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "  src1 := VSR[VRA+32].dword[i]",
                "src2 := VSR[VRB+32].dword[i].bit[58:63]",
                "  VSR[VRT+32].dword[i] := CHOP64(EXTS(src1) >> src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the contents of doubleword element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the contents of doubleword element i of VSR[VRB+32].",
                "",
                "",
                "src1 is shifted right by the number of bits specified in",
                "the low-order 6 bits of src2.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sra"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Shift Right Algebraic Quadword",
                    "form": "VX",
                    "mnemonic": "vsraq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "773",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "src1 := VSR[VRA+32]",
                "src2 := VSR[VRB+32].bit[57:63]",
                "VSR[VRT+32] := CHOP128(EXTS(src1) >> src2)"
            ],
            "body": [
                "",
                "",
                "Let src1 be the contents of VSR[VRA+32].",
                "",
                "Let src2 be the contents of VSR[VRB+32].",
                "",
                "src1 is shifted right by the number of bits specified in",
                "the low-order 7 bits of src2.",
                "",
                "",
                "",
                "The result is placed into VSR[VRT+32].",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Add Floating-Point",
                    "form": "VX",
                    "mnemonic": "vaddfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "10",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "  VSR[VRT+32].word[i] := bfp32_ADD(src1,src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point value in",
                "word element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the single-precision floating-point value in",
                "word element i of VSR[VRB+32].",
                "",
                "",
                "src1 is added to src2.",
                "",
                "",
                "The intermediate result is rounded to the nearest single-precision",
                "floating-point number and placed into word element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Subtract Floating-Point",
                    "form": "VX",
                    "mnemonic": "vsubfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "74",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "  VSR[VRT+32].word[i] := bfp32_SUBTRACT(src1,src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point value in",
                "word element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the single-precision floating-point value in",
                "word element i of VSR[VRB+32].",
                "",
                "",
                "src2 is subtracted from src1.",
                "",
                "",
                "The intermediate result is rounded to the nearest single-precision",
                "floating-point number and placed into word element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply-Add Floating-Point",
                    "form": "VA",
                    "mnemonic": "vmaddfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRC",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "46",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "  src3 := VSR[VRC+32].word[i]",
                "  result := bfp32_MULTIPLY_ADD(src1,src3,src2)",
                "  VSR[VRT+32].word[i] := result",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point value in",
                "word element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the single-precision floating-point value in",
                "word element i of VSR[VRB+32].",
                "",
                "",
                "Let src3 be the single-precision floating-point value in",
                "word element i of VSR[VRC+32].",
                "",
                "",
                "src1 is multiplied by src3.",
                "",
                "",
                "src2 is added to the infinitely-precise product.",
                "",
                "",
                "The intermediate result is rounded to the nearest single-precision",
                "floating-point number and placed into word element i of",
                "VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Negative Multiply-Subtract Floating-Point",
                    "form": "VA",
                    "mnemonic": "vnmsubfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRC",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "47",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "  src3 := VSR[VRC+32].word[i]",
                "  result := bfp32_NEGATIVE_MULTIPLY_SUBTRACT(src1,src3,src2)",
                "  VSR[VRT+32].word[i] := result",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point value in",
                "word element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the single-precision floating-point value in",
                "word element i of VSR[VRB+32].",
                "",
                "",
                "Let src3 be the single-precision floating-point value in",
                "word element i of VSR[VRC+32].",
                "",
                "",
                "src1 is multiplied by src3.",
                "",
                "",
                "src2 is subtracted from the infinitely-precise product.",
                "",
                "",
                "The intermediate result is rounded to the nearest single-precision",
                "floating-point number, then negated and placed into word element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Maximum Floating-Point",
                    "form": "VX",
                    "mnemonic": "vmaxfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1034",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "  VSR[VRT+32].word[i] := bfp32_MAXIMUM(src1,src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point value in",
                "word element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the single-precision floating-point value in",
                "word element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The larger of the two values is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "The maximum of +0.0 and -0.0 is +0.0. The maximum of any value and a NaN is a QNaN.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Minimum Floating-Point",
                    "form": "VX",
                    "mnemonic": "vminfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1098",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "  VSR[VRT+32].word[i] := bfp32_MINIMUM(src1,src2)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point value in",
                "word element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the single-precision floating-point value in",
                "word element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The smaller of the two values is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "The minimum of +0.0 and -0.0 is -0.0. The minimum of any value and a NaN is a QNaN.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Convert with round to zero from floating-point To Signed Word format Saturate",
                    "form": "VX",
                    "mnemonic": "vctsxs",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "UIM",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "970",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src := VSR[VRB+32].word[i]",
                "  VSR[VRT+32].word[i] := si32_CONVERT_FROM_BFP32(src, UIM)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the signed floating-point value in word",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src is multiplied by 2.",
                "The product is converted to a 32-bit signed fixed-point integer using",
                "the rounding mode Round toward Zero.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cts"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Convert with round to zero from floating-point To Unsigned Word format Saturate",
                    "form": "VX",
                    "mnemonic": "vctuxs",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "UIM",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "906",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src := VSR[VRB+32].word[i]",
                "  VSR[VRT+32].word[i] := ui32_CONVERT_FROM_BFP32(src, UIM)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the signed floating-point value in word",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src is multiplied by 2.",
                "The product is converted to a 32-bit unsigned fixed-point integer",
                "using the rounding mode Round toward Zero.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The result is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_ctu",
                "vec_pack_to_short_fp32"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Convert with round to nearest From Signed Word to floating-point format",
                    "form": "VX",
                    "mnemonic": "vcfsx",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "UIM",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "842",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src := VSR[VRB+32].word[i]",
                "  VSR[VRT+32].word[i] := bfp32_CONVERT_FROM_SI32(src,UIM)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the signed fixed-point value in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src is converted to the nearest single-precision",
                "floating-point value.",
                "Each result is divided by 2 and placed into word",
                "element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_ctf"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Convert with round to nearest From Unsigned Word to floating-point format",
                    "form": "VX",
                    "mnemonic": "vcfux",
                    "operands": [
                        "VRT",
                        "VRB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "UIM",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "778",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src := VSR[VRB+32].word[i]",
                "  VSR[VRT+32].word[i] := bfp32_CONVERT_FROM_UI32(src,UIM)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the unsigned fixed-point value in word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "src is converted to the nearest single-precision",
                "floating-point value.",
                "The result is divided by 2 and placed into word",
                "element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_ctf"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Round to Floating-Point Integer toward -Infinity",
                    "form": "VX",
                    "mnemonic": "vrfim",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "714",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src := VSR[VRB+32].word[i]",
                "  VSR[VRT+32].word[i] := bfp32_ROUND_TO_INTEGER_FLOOR(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point value in",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src is rounded to a single-precision floating-point",
                "integer using the rounding mode Round toward -Infinity.",
                "",
                "",
                "The result is placed into the corresponding word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Round to Floating-Point Integer Nearest",
                    "form": "VX",
                    "mnemonic": "vrfin",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "522",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src := VSR[VRB+32].word[i]",
                "  VSR[VRT+32].word[i] := bfp32_ROUND_TO_INTEGER_NEAR(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point value in",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src is rounded to a single-precision floating-point",
                "integer using the rounding mode Round to Nearest.",
                "",
                "",
                "The result is placed into the corresponding word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_round"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Round to Floating-Point Integer toward +Infinity",
                    "form": "VX",
                    "mnemonic": "vrfip",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "650",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src := VSR[VRB+32].word[i]",
                "  VSR[VRT+32].word[i] := bfp32_ROUND_TO_INTEGER_CEIL(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point value in",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src is rounded to a single-precision floating-point",
                "integer using the rounding mode Round toward +Infinity.",
                "",
                "",
                "The result is placed into the corresponding word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Round to Floating-Point Integer toward Zero",
                    "form": "VX",
                    "mnemonic": "vrfiz",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "586",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src := VSR[VRB+32].word[i]",
                "  VSR[VRT+32].word[i] := bfp32_ROUND_TO_INTEGER_TRUNC(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point value in",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src is rounded to a single-precision floating-point",
                "integer using the rounding mode Round toward Zero.",
                "",
                "",
                "The result is placed into the corresponding word element i  of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Bounds Floating-Point",
                    "form": "VC",
                    "mnemonic": "vcmpbfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "name": "Vector Compare Bounds Floating-Point",
                    "form": "VC",
                    "mnemonic": "vcmpbfp.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "966",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "  le := bool_COMPARE_LE_BFP32(src1,src2)",
                "  ge := bool_COMPARE_GE_BFP32(src1,src2)",
                "  VSR[VRT+32].word[i] := ~le || ~ge || <sup>30</sup>0",
                "end",
                "if Rc=1 then do",
                "  ib := (VSR[VRT+32]=0)",
                "  CR6 := 0b00 || ib || 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point value in",
                "element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the single-precision floating-point value in",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "A 2-bit value is formed that indicates whether src1 is",
                "within the bounds specified by src2, as follows.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The 2-bit value is placed into the high-order two bits of word",
                "element i of VSR[VRT+32] and the remaining",
                "bits of element i are set to 0.",
                "",
                "",
                "If Rc=1, CR field 6 is set as follows.",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpb",
                "vec_all_in",
                "vec_any_out"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Equal Floating-Point",
                    "form": "VC",
                    "mnemonic": "vcmpeqfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "name": "Vector Compare Equal Floating-Point",
                    "form": "VC",
                    "mnemonic": "vcmpeqfp.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "198",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "  if bool_COMPARE_EQ_BFP32(src1,src2)=1 then",
                "     VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "     all_false := 0",
                "  else",
                "     VSR[VRT+32].word[i] := 0x0000_0000",
                "     all_true := 0",
                "end",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point value in",
                "element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the single-precision floating-point value in",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of word element i of VSR[VRT+32]",
                "are set to all 1s if src1 is equal to src2,",
                "and are set to all 0s otherwise.",
                "",
                "",
                "If src1 or src2 is a NaN, the contents of",
                "word element i of VSR[VRT+32] are set to all",
                "0s, indicating not equal to.",
                "If src1 and src2 are both infinity with the",
                "same sign, the contents of word element i of VSR[VRT+32] are set to all 1s, indicating equal to.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Greater Than or Equal Floating-Point",
                    "form": "VC",
                    "mnemonic": "vcmpgefp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "name": "Vector Compare Greater Than or Equal Floating-Point",
                    "form": "VC",
                    "mnemonic": "vcmpgefp.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "454",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "  if bool_COMPARE_GE_BFP32(src1,src2)=1 then",
                "     VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "     all_false := 0",
                "  else",
                "     VSR[VRT+32].word[i] := 0x0000_0000",
                "     all_true := 0",
                "end",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point value in",
                "element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the single-precision floating-point value in",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of word element i of VSR[VRT+32]",
                "are set to all 1s if src1 is greater than or equal to",
                "src2, and are set to all 0s otherwise.",
                "",
                "",
                "If src1 or src2 is a NaN, the contents of",
                "word element i of VSR[VRT+32] are set to all",
                "0s, indicating not greater than or equal to.",
                "If src1 and src2 are both infinity with the",
                "same sign, the contents of word element i of VSR[VRT+32] are set to all 1s, indicating greater than or equal",
                "to.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Compare Greater Than Floating-Point",
                    "form": "VC",
                    "mnemonic": "vcmpgtfp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.03"
                },
                {
                    "name": "Vector Compare Greater Than Floating-Point",
                    "form": "VC",
                    "mnemonic": "vcmpgtfp.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "710",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "all_true  := 1",
                "all_false := 1",
                "",
                "do i = 0 to 3",
                "  src1 := VSR[VRA+32].word[i]",
                "  src2 := VSR[VRB+32].word[i]",
                "  if bool_COMPARE_GT_BFP32(src1,src2)=1 then",
                "VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "     all_false := 0",
                "  else",
                "     all_true := 0",
                "VSR[VRT+32].word[i] := 0x0000_0000",
                "end",
                "if Rc=1 then CR.bit[56:59] := (all_true<<3) + (all_false<<1)"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point value in",
                "element i of VSR[VRA+32].",
                "",
                "",
                "Let src2 be the single-precision floating-point value in",
                "element i of VSR[VRB+32].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of word element i of VSR[VRT+32]",
                "are set to all 1s if src1 is greater than src2, and are set to all 0s otherwise.",
                "",
                "",
                "If src1 or src2 is a NaN, the contents of",
                "word element i of VSR[VRT+32] are set to all",
                "0s, indicating not greater than.",
                "If src1 and src2 are both infinity with the",
                "same sign, the contents of word element i of VSR[VRT+32] are set to all 0s, indicating not greater than.",
                "",
                "",
                "If Rc=1, CR field 6 is set to indicate whether all vector",
                "elements compared true and whether all vector elements compared false.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector 2 Raised to the Exponent Estimate Floating-Point",
                    "form": "VX",
                    "mnemonic": "vexptefp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "394",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src := VSR[VRB+32].word[i]",
                "  VSR[VRT+32].word[i] := bfp32_POWER2_ESTIMATE(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The single-precision floating-point estimate of 2 raised to the power",
                "of single-precision floating-point element i of",
                "VSR[VRB+32] is placed into word element i of",
                "VSR[VRT+32].",
                "",
                "",
                "Let x be any single-precision floating-point input value.",
                "Unless x  -146 or the single-precision",
                "floating-point result of computing 2 raised to the power x would be a zero, an infinity, or a QNaN, the estimate has a",
                "relative error in precision no greater than one part in 16.",
                "The most significant 12 bits of the estimate\u00e2\u20ac\u2122s significand are",
                "monotonic.",
                "An integral input value returns an integral value when the result is",
                "representable.",
                "",
                "The result for various special cases of the source value is given",
                "below.",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_expte"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Log Base 2 Estimate Floating-Point",
                    "form": "VX",
                    "mnemonic": "vlogefp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "458",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src := VSR[VRB+32].word[i]",
                "  VSR[VRT+32].word[i] := bfp32_LOG_BASE2_ESTIMATE(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The single-precision floating-point estimate of the base 2 logarithm",
                "of single-precision floating-point element i of",
                "VSR[VRB+32] is placed into the corresponding word element",
                "i of VSR[VRT+32].",
                "",
                "",
                "Let x be any single-precision floating-point input value.",
                "Unless | x-1 | is less than or equal to 0.125 or the",
                "single-precision floating-point result of computing the base 2",
                "logarithm of x would be an infinity or a QNaN, the",
                "estimate has an absolute error in precision (absolute value of the",
                "difference between the estimate and the infinitely precise value) no",
                "greater than 2.",
                "Under the same conditions, the estimate has a relative error in",
                "precision no greater than one part in 8.",
                "",
                "The most significant 12 bits of the estimate\u00e2\u20ac\u2122s significand are",
                "monotonic.",
                "The estimate is exact if x=2, where y is an integer",
                "between -149 and +127 inclusive.",
                "Otherwise the value placed into the element of VSR[VRT+32] may vary between implementations, and between different",
                "executions on the same implementation.",
                "",
                "The result for various special cases of the source value is given",
                "below.",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_loge"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Reciprocal Estimate Floating-Point",
                    "form": "VX",
                    "mnemonic": "vrefp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "266",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src := VSR[VRB+32].word[i]",
                "  VSR[VRT+32].word[i] := bfp32_RECIPROCAL_ESTIMATE(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The single-precision floating-point estimate of the reciprocal of",
                "single-precision floating-point element  i of VSR[VRB+32] is placed into word element  i of VSR[VRT+32].",
                "",
                "",
                "Unless the single-precision floating-point result of computing the",
                "reciprocal of a value would be a zero, an infinity, or a QNaN, the",
                "estimate has a relative error in precision no greater than one part",
                "in 4096.",
                "",
                "Note that results may vary between implementations, and between",
                "different executions on the same implementation.",
                "",
                "The result for various special cases of the source value is given",
                "below.",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Reciprocal Square Root Estimate Floating-Point",
                    "form": "VX",
                    "mnemonic": "vrsqrtefp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "330",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src := VSR[VRB+32].word[i]",
                "VSR[VRT+32].word[i] := bfp32_RECIPROCAL_SQRT_ESTIMATE(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The single-precision floating-point estimate of the reciprocal of the",
                "square root of single-precision floating-point element i",
                "of VSR[VRB+32] is placed into word element i",
                "of VSR[VRT+32].",
                "",
                "",
                "Let x be any single-precision floating-point value.",
                "Unless the single-precision floating-point result of computing the",
                "reciprocal of the square root of x would be a zero, an",
                "infinity, or a QNaN, the estimate has a relative error in precision",
                "no greater than one part in 4096.",
                "",
                "Note that results may vary between implementations, and between",
                "different executions on the same implementation.",
                "",
                "The result for various special cases of the source value is given",
                "below.",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector AES Cipher",
                    "form": "VX",
                    "mnemonic": "vcipher",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1288",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "State    := VSR[VRA+32]",
                "RoundKey := VSR[VRB+32]",
                "vtemp1   := SubBytes(State)",
                "vtemp2   := ShiftRows(vtemp1)",
                "vtemp3   := MixColumns(vtemp2)",
                "VSR[VRT+32]  := vtemp3 ^ RoundKey"
            ],
            "body": [
                "",
                "",
                "Let State be the contents of VSR[VRA+32],",
                "representing the intermediate state array during AES cipher operation.",
                "",
                "Let RoundKey be the contents of VSR[VRB+32],",
                "representing the round key.",
                "",
                "One round of an AES cipher operation is performed on the intermediate",
                "State array, sequentially applying the transforms,",
                "SubBytes(), ShiftRows(), MixColumns(), and AddRoundKey(), as defined in FIPS-197.",
                "",
                "The result is placed into VSR[VRT+32], representing the",
                "new intermediate state of the cipher operation.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cipher_be"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector AES Cipher Last",
                    "form": "VX",
                    "mnemonic": "vcipherlast",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1289",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "State    := VSR[VRA+32]",
                "RoundKey := VSR[VRB+32]",
                "vtemp1   := SubBytes(State)",
                "vtemp2   := ShiftRows(vtemp1)",
                "VSR[VRT+32]  := vtemp2 ^ RoundKey"
            ],
            "body": [
                "",
                "",
                "Let State be the contents of VSR[VRA+32],",
                "representing the intermediate state array during AES cipher operation.",
                "",
                "Let RoundKey be the contents of VSR[VRB+32],",
                "representing the round key.",
                "",
                "The final round in an AES cipher operation is performed on the",
                "intermediate State array, sequentially applying the",
                "transforms, SubBytes(), ShiftRows(),",
                "AddRoundKey(), as defined in FIPS-197.",
                "",
                "The result is placed into VSR[VRT+32], representing the",
                "final state of the cipher operation.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cipherlast_be"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector AES Inverse Cipher",
                    "form": "VX",
                    "mnemonic": "vncipher",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1352",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "State    := VSR[VRA+32]",
                "RoundKey := VSR[VRB+32]",
                "vtemp1   := InvShiftRows(State)",
                "vtemp2   := InvSubBytes(vtemp1)",
                "vtemp3   := vtemp2 ^ RoundKey",
                "VSR[VRT+32]  := InvMixColumns(vtemp3)"
            ],
            "body": [
                "",
                "",
                "Let State be the contents of VSR[VRA+32],",
                "representing the intermediate state array during AES inverse cipher",
                "operation.",
                "",
                "Let RoundKey be the contents of VSR[VRB+32],",
                "representing the round key.",
                "",
                "One round of an AES inverse cipher operation is performed on the",
                "intermediate State array, sequentially applying the transforms,",
                "InvShiftRows(), InvSubBytes(), AddRoundKey(), and InvMixColumns(), as defined in",
                "FIPS-197.",
                "",
                "The result is placed into VSR[VRT+32], representing the",
                "new intermediate state of the inverse cipher operation.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_ncipher_be"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector AES Inverse Cipher Last",
                    "form": "VX",
                    "mnemonic": "vncipherlast",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1353",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "State    := VSR[VRA+32]",
                "RoundKey := VSR[VRB+32]",
                "vtemp1   := InvShiftRows(State)",
                "vtemp2   := InvSubBytes(vtemp1)",
                "VSR[VRT+32]  := vtemp2 ^ RoundKey"
            ],
            "body": [
                "",
                "",
                "Let State be the contents of VSR[VRA+32],",
                "representing the intermediate state array during AES inverse cipher",
                "operation.",
                "",
                "Let RoundKey be the contents of VSR[VRB+32],",
                "representing the round key.",
                "",
                "The final round in an AES inverse cipher operation is performed on",
                "the intermediate State array, sequentially applying the",
                "transforms, InvShiftRows(), InvSubBytes(),",
                "and AddRoundKey(), as defined in FIPS-197.",
                "",
                "The result is placed into VSR[VRT+32], representing the",
                "final state of the inverse cipher operation.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_ncipherlast_be"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector AES SubBytes",
                    "form": "VX",
                    "mnemonic": "vsbox",
                    "operands": [
                        "VRT",
                        "VRA"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "1480",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "State   := VSR[VRA+32]",
                "VSR[VRT+32] := SubBytes(State)"
            ],
            "body": [
                "",
                "",
                "Let State be the contents of VSR[VRA+32],",
                "representing the intermediate state array during AES cipher operation.",
                "",
                "The result of applying the transform, SubBytes() on",
                "State, as defined in FIPS-197, is placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sbox_be"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector SHA-512 Sigma Doubleword",
                    "form": "VX",
                    "mnemonic": "vshasigmad",
                    "operands": [
                        "VRT",
                        "VRA",
                        "ST",
                        "SIX"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "ST",
                    "size": "1"
                },
                {
                    "name": "SIX",
                    "size": "4"
                },
                {
                    "name": "1730",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "  src := VSR[VRA+32].dword[i]",
                "",
                "  if ST=0 & SIX.bit[2*i]=0 then  // SHA-512 sigma0 function",
                "VSR[VRT+32].dword[i] := (src >>>  1) ^",
                "     VSR[VRT+32].dword[i] := (src >>>  8) ^",
                "     VSR[VRT+32].dword[i] := (src >> 7)",
                "",
                "  if ST=0 & SIX.bit[2*i]=1 then  // SHA-512 sigma1 function",
                "VSR[VRT+32].dword[i] := (src >>> 19) ^",
                "     VSR[VRT+32].dword[i] := (src >>> 61) ^",
                "     VSR[VRT+32].dword[i] := (src >> 6)",
                "",
                "  if ST=1 & SIX.bit[2*i]=0 then  // SHA-512 Sigma0 function",
                "VSR[VRT+32].dword[i] := (src >>> 28) ^",
                "     VSR[VRT+32].dword[i] := (src >>> 34) ^",
                "     VSR[VRT+32].dword[i] := (src >>> 39)",
                "",
                "  if ST=1 & SIX.bit[2*i]=1  then  // SHA-512 Sigma1 function",
                "VSR[VRT+32].dword[i] := (src >>> 14) ^",
                "     VSR[VRT+32].dword[i] := (src >>> 18) ^",
                "     VSR[VRT+32].dword[i] := (src >>> 41)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "When ST=0 and bit 2i of SIX is 0, a SHA-512 0 function is performed on",
                "the contents of doubleword element i of VSR[VRA+32] and the result is placed into doubleword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "When ST=0 and bit 2i of SIX is 1, a SHA-512 1 function is performed on",
                "the contents of doubleword element i of VSR[VRA+32] and the result is placed into doubleword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "When ST=1 and bit 2i of SIX is 0, a SHA-512 0 function is performed on",
                "the contents of doubleword element i of VSR[VRA+32] and the result is placed into doubleword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "When ST=1 and bit 2i of SIX is 1, a SHA-512 1 function is performed on",
                "the contents of doubleword element i of VSR[VRA+32] and the result is placed into doubleword element",
                "i of VSR[VRT+32].",
                "",
                "",
                "Bits 1 and 3 of SIX are reserved.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector SHA-256 Sigma Word",
                    "form": "VX",
                    "mnemonic": "vshasigmaw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "ST",
                        "SIX"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "ST",
                    "size": "1"
                },
                {
                    "name": "SIX",
                    "size": "4"
                },
                {
                    "name": "1666",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  src := VSR[VRA+32].word[i]",
                "",
                "  if ST=0 & SIX.bit[i]=0 then  // SHA-256 sigma0 function",
                "VSR[VRT+32].word[i] := (src >>>  7) ^",
                "     VSR[VRT+32].word[i] := (src >>> 18) ^",
                "     VSR[VRT+32].word[i] := (src >>  3)",
                "",
                "if ST=0 & SIX.bit[i]=1 then  // SHA-256 sigma1 function",
                "VSR[VRT+32].word[i] := (src >>> 17) ^",
                "     VSR[VRT+32].word[i] := (src >>> 19) ^",
                "     VSR[VRT+32].word[i] := (src >> 10)",
                "",
                "if ST=1 & SIX.bit[i]=0 then  // SHA-256 Sigma0 function",
                "VSR[VRT+32].word[i] := (src >>>  2) ^",
                "     VSR[VRT+32].word[i] := (src >>> 13) ^",
                "     VSR[VRT+32].word[i] := (src >>> 22)",
                "",
                "if ST=1 & SIX.bit[i]=1 then  // SHA-256 Sigma1 function",
                "VSR[VRT+32].word[i] := (src >>>  6) ^",
                "     VSR[VRT+32].word[i] := (src >>> 11) ^",
                "     VSR[VRT+32].word[i] := (src >>> 25)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "When ST=0 and bit i of SIX is",
                "0, a SHA-256 0 function is performed on the",
                "contents of word element i of VSR[VRA+32] and",
                "the result is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "When ST=0 and bit i of SIX is",
                "1, a SHA-256 1 function is performed on the",
                "contents of word element i of VSR[VRA+32] and",
                "the result is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "When ST=1 and bit i of SIX is",
                "0, a SHA-256 0 function is performed on the",
                "contents of word element i of VSR[VRA+32] and",
                "the result is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "When ST=1 and bit i of SIX is",
                "1, a SHA-256 1 function is performed on the",
                "contents of word element i of VSR[VRA+32] and",
                "the result is placed into word element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_shasigma_be"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Polynomial Multiply-Sum Byte",
                    "form": "VX",
                    "mnemonic": "vpmsumb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1032",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  prod[i].bit[0:14] := 0",
                "  srcA := VSR[VRA+32].byte[i]",
                "  srcB := VSR[VRB+32].byte[i]",
                "  do j = 0 to 7",
                "     do k = 0 to j",
                "        gbit := srcA.bit[k] & srcB.bit[j-k]",
                "        prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "     end",
                "  end",
                "  do j = 8 to 14",
                "     do k = j-7 to 7",
                "        gbit := (srcA.bit[k] & srcB.bit[j-k])",
                "        prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "     end",
                "  end",
                "end",
                "do i = 0 to 7",
                "VSR[VRT+32].hword[i] := 0b0 || (prod[2*i] ^ prod[2*i+1])",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let prod[i] be the 15-bit result of a binary polynomial",
                "multiplication of the contents of byte element i of",
                "VSR[VRA+32] and the contents of byte element i of VSR[VRB+32].",
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The exclusive-OR of prod[2i] and prod[2i+1] is placed in bits 1:15 of halfword element",
                "i of VSR[VRT+32].",
                "Bit 0 of halfword element i of VSR[VRT+32] is",
                "set to 0.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_pmsum_be"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Polynomial Multiply-Sum Halfword",
                    "form": "VX",
                    "mnemonic": "vpmsumh",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1096",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "  prod.bit[0:30] := 0",
                "  srcA := VSR[VRA+32].halfword[i]",
                "  srcB := VSR[VRB+32].halfword[i]",
                "  do j = 0 to 15",
                "     do k = 0 to j",
                "        gbit := srcA.bit[k] & srcB.bit[j-k]",
                "        prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "     end",
                "  end",
                "  do j = 16 to 30",
                "     do k = j-15 to 15",
                "        gbit := (srcA.bit[k] & srcB.bit[j-k])",
                "        prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "     end",
                "  end",
                "end",
                "VSR[VRT+32].word[0] := 0b0 || (prod[0] ^ prod[1])",
                "VSR[VRT+32].word[1] := 0b0 || (prod[2] ^ prod[3])",
                "VSR[VRT+32].word[2] := 0b0 || (prod[4] ^ prod[5])",
                "VSR[VRT+32].word[3] := 0b0 || (prod[6] ^ prod[7])"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let prod[i] be the 31-bit result of a binary polynomial",
                "multiplication of the contents of halfword element i of",
                "VSR[VRA+32] and the contents of halfword element",
                "i of VSR[VRB+32].",
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The exclusive-OR of prod[2i] and prod[2i+1] is placed in bits 1:31 of word element",
                "i of VSR[VRT+32].",
                "Bit 0 of word element i of VSR[VRT+32] is set",
                "to 0.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_pmsum_be"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Polynomial Multiply-Sum Word",
                    "form": "VX",
                    "mnemonic": "vpmsumw",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1160",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  prod[i].bit[0:62] := 0",
                "  srcA := VSR[VRA+32].word[i]",
                "  srcB := VSR[VRB+32].word[i]",
                "  do j = 0 to 31",
                "     do k = 0 to j",
                "        gbit := srcA.bit[k] & srcB.bit[j-k]",
                "        prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "     end",
                "  end",
                "  do j = 32 to 62",
                "     do k = j-31 to 31",
                "        gbit := (srcA.bit[k] & srcB.bit[j-k])",
                "        prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "     end",
                "  end",
                "end",
                "VSR[VRT+32].dword[0] := 0b0 || (prod[0] ^ prod[1])",
                "VSR[VRT+32].dword[1] := 0b0 || (prod[2] ^ prod[3])"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let prod[i] be the 63-bit result of a binary polynomial",
                "multiplication of the contents of word element i of",
                "VSR[VRA+32] and the contents of word element i of VSR[VRB+32].",
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The exclusive-OR of prod[2i] and prod[2i+1] is placed in bits 1:63 of doubleword element",
                "i of VSR[VRT+32].",
                "Bit 0 of doubleword element i of VSR[VRT+32]",
                "is set to 0.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_pmsum_be"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Polynomial Multiply-Sum Doubleword",
                    "form": "VX",
                    "mnemonic": "vpmsumd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1224",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  prod[i].bit[0:126] := 0",
                "  srcA := VSR[VRA+32].doubleword[i]",
                "  srcB := VSR[VRB+32].doubleword[i]",
                "  do j = 0 to 63",
                "     do k = 0 to j",
                "        gbit := srcA.bit[k] & srcB.bit[j-k]",
                "        prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "     end",
                "  end",
                "  do j = 64 to 126",
                "     do k = j-63 to 63",
                "        gbit := (srcA.bit[k] & srcB.bit[j-k])",
                "        prod[i].bit[j] := prod[i].bit[j] ^ gbit",
                "     end",
                "  end",
                "end",
                "VSR[VRT+32] := 0b0 || (prod[0] ^ prod[1])"
            ],
            "body": [
                "",
                "",
                "Let prod[0] be the 127-bit result of a binary polynomial",
                "multiplication of the contents of doubleword element 0 of VSR[VRA+32] and the contents of doubleword element 0 of VSR[VRB+32].",
                "",
                "Let prod[1] be the 127-bit result of a binary polynomial",
                "multiplication of the contents of doubleword element 1 of VSR[VRA+32] and the contents of doubleword element 1 of VSR[VRB+32].",
                "",
                "The exclusive-OR of prod[0] and prod[1] is",
                "placed in bits 1:127 of VSR[VRT+32].",
                "Bit 0 of VSR[VRT+32] is set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_pmsum_be"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Permute  Exclusive-OR",
                    "form": "VA",
                    "mnemonic": "vpermxor",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "VRC"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "VRC",
                    "size": "5"
                },
                {
                    "name": "45",
                    "size": "6"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 15",
                "  indexA := VSR[VRC+32].byte[i].bit[0:3]",
                "  indexB := VSR[VRC+32].byte[i].bit[4:7]",
                "  src1   := VSR[VRA+32].byte[indexA]",
                "  src2   := VSR[VRB+32].byte[indexB]",
                "VSR[VRT+32].byte[i] := src1 ^ src2",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let indexA be the contents of bits 0:3 of byte element",
                "i of VSR[VRC+32].",
                "",
                "",
                "Let indexB be the contents of bits 4:7 of byte element",
                "i of VSR[VRC+32].",
                "",
                "",
                "The exclusive OR of the contents of byte element indexA",
                "of VSR[VRA+32] and the contents of byte element",
                "indexB of VSR[VRB+32] is placed into byte",
                "element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_permxor"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Gather Bits by Bytes by Doubleword",
                    "form": "VX",
                    "mnemonic": "vgbbd",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1292",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "   do j = 0 to 7",
                "       do k = 0 to 7",
                "           b := VSR[VRB+32].dword[i].byte[k].bit[j]",
                "VSR[VRT+32].dword[i].byte[j].bit[k] := b",
                "       end",
                "   end",
                "end"
            ],
            "body": [
                "",
                "",
                "Let src be the contents of VSR[VRB+32],",
                "composed of two doubleword elements numbered 0 and 1.",
                "",
                "Let each doubleword element be composed of eight bytes  numbered 0",
                "through 7.",
                "",
                "An 8-bit  8-bit bit-matrix transpose is performed on the",
                "contents of each doubleword element of VSR[VRB+32] (see",
                "Figure",
                ").",
                "",
                "For each integer value i from 0 to 1, do the following,",
                "",
                "",
                "",
                "The contents of bit 0 of each byte of doubleword element i of VSR[VRB+32] are concatenated and placed into byte 0",
                "of doubleword element i of VSR[VRT+32].",
                "",
                "",
                "The contents of bit 1 of each byte of doubleword element i of VSR[VRB+32] are concatenated and placed into byte 1",
                "of doubleword element i of VSR[VRT+32].",
                "",
                "",
                "The contents of bit 2 of each byte of doubleword element i of VSR[VRB+32] are concatenated and placed into byte 2",
                "of doubleword element i of VSR[VRT+32].",
                "",
                "",
                "The contents of bit 3 of each byte of doubleword element i of VSR[VRB+32] are concatenated and placed into byte 3",
                "of doubleword element i of VSR[VRT+32].",
                "",
                "",
                "The contents of bit 4 of each byte of doubleword element i of VSR[VRB+32] are concatenated and placed into byte 4",
                "of doubleword element i of VSR[VRT+32].",
                "",
                "",
                "The contents of bit 5 of each byte of doubleword element i of VSR[VRB+32] are concatenated and placed into byte 5",
                "of doubleword element i of VSR[VRT+32].",
                "",
                "",
                "The contents of bit 6 of each byte of doubleword element i of VSR[VRB+32] are concatenated and placed into byte 6",
                "of doubleword element i of VSR[VRT+32].",
                "",
                "",
                "The contents of bit 7 of each byte of doubleword element i of VSR[VRB+32] are concatenated and placed into byte 7",
                "of doubleword element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_gb"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Gather every Nth Bit",
                    "form": "VX",
                    "mnemonic": "vgnb",
                    "operands": [
                        "RT",
                        "VRB",
                        "N"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "N",
                    "size": "3"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1228",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "if N<2 | N>7 then",
                "  result := UNDEFINED",
                "else do",
                "  j := 0",
                "  result := 0x0000_0000_0000_0000",
                "  do i = 0 to 127 by N",
                "     result.bit[j] := VSR[VRB+32].bit[i]",
                "     j := j + 1",
                "  end",
                "end",
                "GPR[RT] := result"
            ],
            "body": [
                "",
                "",
                "Starting with bit 0, the contents of every Nth bit of VSR[VRB+32] are",
                "concatenated and placed into GPR[RT].",
                "",
                "N can be any value between 2 and 7, inclusive.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Count Leading Zeros Byte",
                    "form": "VX",
                    "mnemonic": "vclzb",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1794",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 15",
                "  n := 0",
                "  do while n < 8",
                "     if VSR[VRB+32].byte[i].bit[n] = 0b1 then leave",
                "     n := n + 1",
                "  end",
                "VSR[VRT+32].byte[i] := n",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "A count of the number of consecutive zero bits starting at bit 0 of",
                "byte element i of VSR[VRB+32] is placed into",
                "byte element i of VSR[VRT+32].",
                "This number ranges from 0 to 8, inclusive.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cntlz"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Count Leading Zeros Halfword",
                    "form": "VX",
                    "mnemonic": "vclzh",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1858",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 7",
                "  n  := 0",
                "  do while n < 16",
                "     if VSR[VRB+32].hword[i].bit[n] = 0b1 then leave",
                "     n  := n + 1",
                "  end",
                "VSR[VRT+32].hword[i] := n",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "A count of the number of consecutive zero bits starting at bit 0 of",
                "halfword element i of VSR[VRB+32] is placed",
                "into halfword element i of VSR[VRT+32].",
                "This number ranges from 0 to 16, inclusive.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cntlz"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Count Leading Zeros Word",
                    "form": "VX",
                    "mnemonic": "vclzw",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1922",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 3",
                "  n  := 0",
                "  do while n < 32",
                "     if VSR[VRB+32].word[i].bit[n] = 0b1 then leave",
                "     n  := n + 1",
                "  end",
                "  VSR[VRT+32].word[i] := n",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "A count of the number of consecutive zero bits starting at bit 0 of",
                "word element i of VSR[VRB+32] is placed into",
                "word element i of VSR[VRT+32].",
                "This number ranges from 0 to 32, inclusive.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cntlz"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Count Leading Zeros Doubleword",
                    "form": "VX",
                    "mnemonic": "vclzd",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1986",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "  n := 0",
                "  do while (n<64) & (VSR[VRB+32].dword[i].bit[n]=0b0)",
                "     n := n + 1",
                "  end",
                "VSR[VRT+32].dword[i] := n",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "A count of the number of consecutive zero bits starting at bit 0 of",
                "doubleword element i of VSR[VRB+32] is placed",
                "into doubleword element i of VSR[VRT+32].",
                "This number ranges from 0 to 64, inclusive.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cntlz"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Count Leading Zeros Doubleword under bit Mask",
                    "form": "VX",
                    "mnemonic": "vclzdm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1924",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "  count := 0",
                "  do j = 0 to 63",
                "     if VSR[VRB+32].dword[i].bit[j]=1 then do",
                "        if VSR[VRA+32].dword[i].bit[i]=1 then break",
                "        count := count + 1",
                "     end",
                "  end",
                "  VSR[VRT+32].dword[i] := EXTZ64(count)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, starting on the",
                "left, count the number of consecutive 0 bits in doubleword element",
                "i of VSR[VRA+32] corresponding to 1 bits in",
                "doubleword element i of VSR[VRB+32].",
                "Place count in doubleword element i of VSR[VRT+32].",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Count Trailing Zeros Byte",
                    "form": "VX",
                    "mnemonic": "vctzb",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "28",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1538",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  n := 0",
                "  do while n < 8",
                "     if VSR[VRB+32].byte[i].bit[7-n] = 0b1 then leave",
                "     n := n + 1",
                "  end",
                "VSR[VRT+32].byte[i] := CHOP8(EXTZ(n))",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "A count of the number of consecutive zero bits starting at bit 7 of",
                "byte element i of VSR[VRB+32] is placed into",
                "byte element i of VSR[VRT+32].",
                "This number ranges from 0 to 8, inclusive.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cnttz"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Count Trailing Zeros Halfword",
                    "form": "VX",
                    "mnemonic": "vctzh",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "29",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1538",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  n  := 0",
                "  do while n < 16",
                "     if VSR[VRB+32].hword[i].bit[15-n] = 0b1 then leave",
                "     n  := n + 1",
                "  end",
                "VSR[VRT+32].hword[i] := CHOP16(EXTZ(n))",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "A count of the number of consecutive zero bits starting at bit 15 of",
                "halfword element i of VSR[VRB+32] is placed",
                "into halfword element i of VSR[VRT+32].",
                "This number ranges from 0 to 16, inclusive.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cnttz"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Count Trailing Zeros Word",
                    "form": "VX",
                    "mnemonic": "vctzw",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "30",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1538",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  n  := 0",
                "  do while n < 32",
                "     if VSR[VRB+32].word[i].bit[31-n] = 0b1 then leave",
                "     n  := n + 1",
                "  end",
                "VSR[VRT+32].word[i] := CHOP32(EXTZ(n))",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "A count of the number of consecutive zero bits starting at bit 31 of",
                "word element i of VSR[VRB+32] is placed into",
                "word element i of VSR[VRT+32].",
                "This number ranges from 0 to 32, inclusive.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cnttz"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Count Trailing Zeros Doubleword",
                    "form": "VX",
                    "mnemonic": "vctzd",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "31",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1538",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  n  := 0",
                "  do while n < 64",
                "     if VSR[VRB+32].dword[i].bit[63-n] = 0b1 then leave",
                "     n  := n + 1",
                "  end",
                "VSR[VRT+32].dword[i] := CHOP64(EXTZ(n))",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "A count of the number of consecutive zero bits starting at bit 63 of",
                "doubleword element i of VSR[VRB+32] is placed",
                "into doubleword element i of VSR[VRT+32].",
                "This number ranges from 0 to 64, inclusive.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cnttz"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Count Trailing Zeros Doubleword under bit Mask",
                    "form": "VX",
                    "mnemonic": "vctzdm",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1988",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "  count := 0",
                "  do j = 0 to 63",
                "     if VSR[VRB+32].dword[i].bit[63-j]=1 then do",
                "        if VSR[VRA+32].dword[i].bit[63-i]=1 then break",
                "        count := count + 1",
                "     end",
                "  end",
                "  VSR[VRT+32].dword[i] := EXTZ64(count)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, starting on the",
                "right, count the number of consecutive 0 bits in doubleword element",
                "i of VSR[VRA+32] corresponding to 1 bits in",
                "doubleword element i of VSR[VRB+32].",
                "Place count in doubleword element i of VSR[VRT+32].",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Count Leading Zero Least-Significant Bits Byte",
                    "form": "VX",
                    "mnemonic": "vclzlsbb",
                    "operands": [
                        "RT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1538",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count := 0",
                "do while count < 16",
                "  if VSR[VRB+32].byte[count].bit[7]=1 break",
                "  count := count + 1",
                "end",
                "GPR[RT] := EXTZ64(count)"
            ],
            "body": [
                "",
                "",
                "Let count be the number of contiguous leading byte",
                "elements in VSR[VRB+32] having a zero least-significant",
                "bit.",
                "",
                "count is placed into GPR[RT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cntlz_lsbb",
                "vec_first_match_index",
                "vec_first_match_or_eos_index",
                "vec_first_mismatch_index",
                "vec_first_mismatch_or_eos_index"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Count Trailing Zero Least-Significant Bits Byte",
                    "form": "VX",
                    "mnemonic": "vctzlsbb",
                    "operands": [
                        "RT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1538",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count := 0",
                "do while count < 16",
                "  if VSR[VRB+32].byte[15-count].bit[7]=1 break",
                "  count := count + 1",
                "end",
                "GPR[RT] := EXTZ64(count)"
            ],
            "body": [
                "",
                "",
                "Let count be the number of contiguous trailing byte",
                "elements of VSR[VRB+32] having a zero least-significant",
                "bit.",
                "",
                "count is placed into GPR[RT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cnttz_lsbb",
                "vec_first_match_index",
                "vec_first_match_or_eos_index",
                "vec_first_mismatch_index",
                "vec_first_mismatch_or_eos_index"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Parallel Bits Deposit Doubleword",
                    "form": "VX",
                    "mnemonic": "vpdepd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1485",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "  VSR[VRT+32].dword[i] := 0",
                "  m := 0",
                "  k := 0",
                "  do while(m < 64)",
                "     if VSR[VRB+32].dword[i].bit[63-m]=1 then do",
                "        result := VSR[VRA+32].dword[i].bit[63-k]",
                "        VSR[VRT+32].dword[i].bit[63-m] := result",
                "        k := k + 1",
                "     end",
                "     m := m + 1",
                "  end",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let n be the number of bits in doubleword element",
                "i of VSR[VRB+32] that contain a 1.",
                "",
                "",
                "The contents of the rightmost n bits of doubleword",
                "element i of VSR[VRA+32] are placed into",
                "doubleword element i of VSR[VRT+32] under",
                "control of the mask in doubleword element i of VSR[VRB+32] as follows.",
                "",
                "",
                "",
                "",
                "",
                "",
                "The contents of bits in doubleword element i of",
                "VSR[VRT+32] corresponding to bits in doubleword element",
                "i of VSR[VRB+32] that contain a 0 are set to",
                "0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Parallel Bits Extract Doubleword",
                    "form": "VX",
                    "mnemonic": "vpextd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1421",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "  result := 0",
                "  m := 0",
                "  k := 0",
                "  do while(m < 64)",
                "     if VSR[VRB+32].dword[i].bit[63-m]=1 then do",
                "        result.bit[63-k] := VSR[VRA+32].dword[i].bit[63-m]",
                "        k := k + 1",
                "     end",
                "     m := m + 1",
                "  end",
                "  VSR[VRT+32].dword[i] := result",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Starting from the right, for each bit in doubleword element",
                "i of VSR[VRB+32] that is equal to 1, place",
                "the contents of the corresponding bit in doubleword element",
                "i of VSR[VRA+32] into the rightmost",
                "unoccupied bit of doubleword element i of VSR[VRT+32].",
                "Any bits in doubleword element i of VSR[VRT+32]to the left of the most-significant bit copied are set to",
                "0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Centrifuge Doubleword",
                    "form": "VX",
                    "mnemonic": "vcfuged",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1357",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "do i = 0 to 1",
                "  ptr0 := 0",
                "  ptr1 := 0",
                "  do j = 0 to 63",
                "     if VSR[VRB+32].dword[i].bit[j]=0b0 then do",
                "        result.bit[ptr0] := VSR[VRA+32].dword[i].bit[j]",
                "        ptr0 := ptr0 + 1",
                "     end",
                "     if VSR[VRB+32].dword[i].bit[63-j]=1 then do",
                "        result.bit[63-ptr1] := VSR[VRA+32].dword[i].bit[63-j]",
                "        ptr1 := ptr1 + 1",
                "     end",
                "  end",
                "  VSR[VRT+32].dword[i] := result",
                "end"
            ],
            "body": [
                "",
                "",
                "For each doubleword element i of VSR[VRA+32], the bits whose corresponding bits in the",
                "mask in doubleword element i of VSR[VRB+32]",
                "equal 1 are placed in the rightmost bits in doubleword element",
                "i of VSR[VRT+32], maintaining their original",
                "relative order.",
                "The other bits in doubleword element i of VSR[VRA+32] are placed in the leftmost bits in",
                "doubleword element i of VSR[VRT+32],",
                "maintaining their original relative order.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Population Count Byte",
                    "form": "VX",
                    "mnemonic": "vpopcntb",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1795",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  n := 0",
                "  do j = 0 to 7",
                "     n := n + VSR[VRB+32].byte[i].bit[j]",
                "  end",
                "VSR[VRT+32].byte[i] := n",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "A count of the number of bits set to 1 in byte element i",
                "of VSR[VRB+32] is placed into byte element i",
                "of VSR[VRT+32]. This number ranges from 0 to 8, inclusive.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_popcnt"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Population Count Halfword",
                    "form": "VX",
                    "mnemonic": "vpopcnth",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1859",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  n := 0",
                "  do j = 0 to 15",
                "     n := n + VSR[VRB+32].hword[i].bit[j]",
                "  end",
                "VSR[VRT+32].hword[i] := n",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "A count of the number of bits set to 1 in halfword element i of VSR[VRB+32] is placed into halfword element",
                "i of VSR[VRT+32].",
                "This number ranges from 0 to 16, inclusive.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_popcnt"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Population Count Word",
                    "form": "VX",
                    "mnemonic": "vpopcntw",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1923",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  n := 0",
                "  do j = 0 to 31",
                "     n := n + VSR[VRB+32].word[i].bit[j]",
                "  end",
                "VSR[VRT+32].word[i] := n",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "A count of the number of bits set to 1 in word element",
                "i of VSR[VRB+32] is placed into word element",
                "i of VSR[VRT+32].",
                "This number ranges from 0 to 32, inclusive.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_popcnt"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Population Count Doubleword",
                    "form": "VX",
                    "mnemonic": "vpopcntd",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1987",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  n := 0",
                "  do j = 0 to 63",
                "     n := n + VSR[VRB+32].dword[i].bit[j]",
                "  end",
                "VSR[VRT+32].dword[i] := n",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "A count of the number of bits set to 1 in doubleword element",
                "i of VSR[VRB+32] is placed into doubleword",
                "element i of VSR[VRT+32].",
                "This number ranges from 0 to 64, inclusive.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_popcnt"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Parity Byte Word",
                    "form": "VX",
                    "mnemonic": "vprtybw",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "8",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1538",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  s := 0",
                "  do j = 0 to 3",
                "     s := s ^ VSR[VRB+32].word[i].byte[j].bit[7]",
                "  end",
                "VSR[VRT+32].word[i] := CHOP32(EXTZ(s))",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following",
                "",
                "",
                "",
                "If the sum of the least significant bit in each byte sub-element of",
                "word element i of VSR[VRB+32] is odd, the",
                "value 1 is placed into word element i of VSR[VRT+32]; otherwise the value 0 is placed into word element",
                "i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_parity_lsbb"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Parity Byte Doubleword",
                    "form": "VX",
                    "mnemonic": "vprtybd",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "9",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1538",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  s := 0",
                "  do j = 0 to 7",
                "      s := s ^ VSR[VRB+32].dword[i].byte[j].bit[7]",
                "  end",
                "VSR[VRT+32].dword[i] := CHOP64(EXTZ(s))",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following",
                "",
                "",
                "",
                "If the sum of the least significant bit in each byte sub-element of",
                "doubleword element i of VSR[VRB+32] is odd,",
                "the value 1 is placed into doubleword element i of",
                "VSR[VRT+32]; otherwise the value 0 is placed into",
                "doubleword element i of VSR[VRT+32].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_parity_lsbb"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Parity Byte Quadword",
                    "form": "VX",
                    "mnemonic": "vprtybq",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "10",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1538",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "s := 0",
                "do j = 0 to 15",
                "  s := s ^ VSR[VRB+32].byte[j].bit[7]",
                "end",
                "VSR[VRT+32] := CHOP128(EXTZ(s))"
            ],
            "body": [
                "",
                "",
                "If the sum of the least significant bit in each byte element of",
                "VSR[VRB+32] is odd, the value 1 is placed into VSR[VRT+32]; otherwise the value 0 is placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_parity_lsbb"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Bit Permute Doubleword",
                    "form": "VX",
                    "mnemonic": "vbpermd",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1484",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  do j = 0 to 7",
                "     index := VSR[VRB+32].dword[i].byte[j]",
                "     if index < 64 then",
                "        perm.bit[j] := VSR[VRA+32].dword[i].bit[index]",
                "     else",
                "        perm.bit[j] := 0",
                "  end",
                "VSR[VRT+32].dword[i] := EXTZ64(perm)",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, and for each",
                "integer value j from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let index be the contents of byte sub-element j of doubleword element i of VSR[VRB+32].",
                "",
                "",
                "If index is less than 64, then the contents of bit",
                "index of doubleword i of VSR[VRA+32] are placed into bit 56+j of doubleword",
                "element i of VSR[VRT+32].",
                "Otherwise, bit 56+j of doubleword element i",
                "of VSR[VRT+32] is set to 0.",
                "",
                "",
                "The contents of bits 0:55 of doubleword element i of",
                "VSR[VRT+32] are set to 0.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_bperm"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Bit Permute Quadword",
                    "form": "VX",
                    "mnemonic": "vbpermq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1356",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  index := VSR[VRB+32].byte[i]",
                "  if index < 128 then",
                "     perm.bit[i] := VSR[VRA+32].bit[index]",
                "  else",
                "     perm.bit[i] := 0",
                "end",
                "VSR[VRT+32].dword[0] := CHOP64(EXTZ(perm))",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let index be the contents of byte element i",
                "of VSR[VRB+32].",
                "",
                "",
                "If index is less than 128, then the contents",
                "of bit index of VSR[VRA+32] are placed into",
                "bit 48+i of doubleword element i of",
                "VSR[VRT+32].",
                "Otherwise, bit 48+i of doubleword element i",
                "of VSR[VRT+32] is set to 0.",
                "",
                "",
                "The contents of bits 0:47 of VSR[VRT+32] are",
                "set to 0.",
                "",
                "The contents of bits 64:127 of VSR[VRT+32]",
                "are set to 0.",
                "",
                ""
            ],
            "intrinsics": [
                "vec_bperm"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move to VSR Byte Mask",
                    "form": "VX",
                    "mnemonic": "mtvsrbm",
                    "operands": [
                        "VRT",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "16",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  if GPR[RB].bit[48+i]=0 then",
                "     VSR[VRT+32].byte[i] := 0x00",
                "  else",
                "     VSR[VRT+32].byte[i] := 0xFF",
                "end"
            ],
            "body": [
                "",
                "",
                "Let bm be the contents of bits 48:63 of GPR[RB].",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "The contents of byte element i of VSR[VRT+32]",
                "is set to all 0s if bit i of bm is equal to 0.",
                "",
                "",
                "The contents of byte element i of VSR[VRT+32]",
                "is set to all 1s if bit i of bm is equal to 1.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move to VSR Halfword Mask",
                    "form": "VX",
                    "mnemonic": "mtvsrhm",
                    "operands": [
                        "VRT",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "17",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  if GPR[RB].bit[56+i]=0 then",
                "     VSR[VRT+32].hword[i] := 0x0000",
                "  else",
                "     VSR[VRT+32].hword[i] := 0xFFFF",
                "end"
            ],
            "body": [
                "",
                "",
                "Let bm be the contents of bits 56:63 of GPR[RB].",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The contents of halfword element i of VSR[VRT+32] is set to all 0s if bit i of bm",
                "is equal to 0.",
                "",
                "",
                "The contents of halfword element i of VSR[VRT+32] is set to all 1s if bit i of bm",
                "is equal to 1.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move to VSR Word Mask",
                    "form": "VX",
                    "mnemonic": "mtvsrwm",
                    "operands": [
                        "VRT",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "18",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  if GPR[RB].bit[60+i]=0 then",
                "     VSR[VRT+32].word[i] := 0x0000_0000",
                "  else",
                "     VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "end"
            ],
            "body": [
                "",
                "",
                "Let bm be the contents of bits 60:63 of GPR[RB].",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The contents of word element i of VSR[VRT+32]",
                "is set to all 0s if bit i of bm is equal to 0.",
                "",
                "",
                "The contents of word element i of VSR[VRT+32]",
                "is set to all 1s if bit i of bm is equal to 1.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move to VSR Doubleword Mask",
                    "form": "VX",
                    "mnemonic": "mtvsrdm",
                    "operands": [
                        "VRT",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "19",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  if GPR[RB].bit[62+i]=0 then",
                "     VSR[VRT+32].dword[i] := 0x0000_0000_0000_0000",
                "  else",
                "     VSR[VRT+32].dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "end"
            ],
            "body": [
                "",
                "",
                "Let bm be the contents of bits 62:63 of GPR[RB].",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The contents of doubleword element i of VSR[VRT+32] is set to all 0s if bit i of bm",
                "is equal to 0.",
                "",
                "",
                "The contents of doubleword element i of VSR[VRT+32] is set to all 1s if bit i of bm",
                "is equal to 1.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move to VSR Quadword Mask",
                    "form": "VX",
                    "mnemonic": "mtvsrqm",
                    "operands": [
                        "VRT",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "20",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if GPR[RB].bit[63]=0 then",
                "  VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "else",
                "  VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF"
            ],
            "body": [
                "",
                "",
                "Let bm be the contents of bits 63 of GPR[RB].",
                "",
                "The contents of VSR[VRT+32] is set to all 0s if",
                "bm is equal to 0.",
                "",
                "The contents of VSR[VRT+32] is set to all 1s if",
                "bm is equal to 1.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move To VSR Byte Mask Immediate",
                    "form": "DX",
                    "mnemonic": "mtvsrbmi",
                    "operands": [
                        "VRT",
                        "bm"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "bm1",
                    "size": "5"
                },
                {
                    "name": "bm0",
                    "size": "10"
                },
                {
                    "name": "10",
                    "size": "5"
                },
                {
                    "name": "bm2",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "bm.bit[0:9]   := b0",
                "bm.bit[10:14] := b1",
                "bm.bit[15]    := b2",
                "do i = 0 to 15",
                "  if bm.bit[i]=0 then",
                "     VSR[VRT+32].byte[i] := 0x00",
                "  else",
                "     VSR[VRT+32].byte[i] := 0xFF",
                "end"
            ],
            "body": [
                "",
                "",
                "Let bm be the concatenation of b0, b1 and b2.",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "The contents of byte element i of VSR[VRT+32]",
                "is set to all 0s if bit i of bm is equal to 0.",
                "",
                "",
                "The contents of byte element i of VSR[VRT+32]",
                "is set to all 1s if bit i of bm is equal to 1.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Expand Byte Mask",
                    "form": "VX",
                    "mnemonic": "vexpandbm",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  if VSR[VRB+32].byte[i].bit[0]=1 then",
                "     VSR[VRT+32].byte[i] := 0xFF",
                "  end",
                "     VSR[VRT+32].byte[i] := 0x00",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let bmi be the contents of bit 0 of byte element",
                "i of VSR[VRB+32].",
                "",
                "",
                "The contents of byte element i of VSR[VRT+32]",
                "are set to all 0s if bmi is equal to 0.",
                "",
                "",
                "The contents of byte element i of VSR[VRT+32]",
                "are set to all 1s if bmi is equal to 1.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Expand Halfword Mask",
                    "form": "VX",
                    "mnemonic": "vexpandhm",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  if VSR[VRB+32].hword[i].bit[0]=1 then",
                "     VSR[VRT+32].hword[i] := 0xFFFF",
                "  else",
                "     VSR[VRT+32].hword[i] := 0x0000",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "Let bmi be the contents of bit 0 of halfword element",
                "i of VSR[VRB+32],",
                "",
                "",
                "The contents of halfword element i of VSR[VRT+32] are set to all 0s if bmi is equal to 0.",
                "",
                "",
                "The contents of halfword element i of VSR[VRT+32] are set to all 1s if bmi is equal to 1.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Expand Word Mask",
                    "form": "VX",
                    "mnemonic": "vexpandwm",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "2",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  if VSR[VRB+32].word[i].bit[0]=1 then",
                "     VSR[VRT+32].word[i] := 0xFFFF_FFFF",
                "  else",
                "     VSR[VRT+32].word[i] := 0x0000_0000",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let bmi be the contents of bit 0 of word element",
                "i of VSR[VRB+32].",
                "",
                "",
                "The contents of word element i of VSR[VRT+32]",
                "are set to all 0s if bmi is equal to 0.",
                "",
                "",
                "The contents of word element i of VSR[VRT+32]",
                "are set to all 1s if bmi is equal to 1.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Expand Doubleword Mask",
                    "form": "VX",
                    "mnemonic": "vexpanddm",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "3",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  if VSR[VRB+32].dword[i].bit[0]=1 then",
                "     VSR[VRT+32].dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "  else",
                "     VSR[VRT+32].dword[i] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let bmi be the contents of bit 0 of doubleword element",
                "i of VSR[VRB+32],",
                "",
                "",
                "The contents of doubleword element i of VSR[VRT+32] are set to all 0s if bmi is equal to 0.",
                "",
                "",
                "The contents of doubleword element i of VSR[VRT+32] are set to all 1s if bmi is equal to 1.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Expand Quadword Mask",
                    "form": "VX",
                    "mnemonic": "vexpandqm",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "4",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if VSR[VRB+32].bit[0]=1 then",
                "  VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "else",
                "  VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let bmi be the contents of bit 0 of VSR[VRB+32].",
                "",
                "The contents of VSR[VRT+32] are set to all 0s if",
                "bmi is equal to 0.",
                "",
                "The contents of VSR[VRT+32] are set to all 1s if",
                "bmi is equal to 1.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Count Mask Bits Byte",
                    "form": "VX",
                    "mnemonic": "vcntmbb",
                    "operands": [
                        "RT",
                        "VRB",
                        "MP"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "12",
                    "size": "4"
                },
                {
                    "name": "MP",
                    "size": "1"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count = 0",
                "do i = 0 to 15",
                "  count := count + EXTZ8(VSR[VRB+32].byte[i].bit[0]=MP)",
                "end",
                "",
                "GPR[RT] := count << 56"
            ],
            "body": [
                "",
                "",
                "The number of byte elements having bit 0 set to the value MP in VSR[VRB+32] is placed into bits 0:7 of GPR[RT]. Bits 8:63 of GPR[RT] are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Count Mask Bits Halfword",
                    "form": "VX",
                    "mnemonic": "vcntmbh",
                    "operands": [
                        "RT",
                        "VRB",
                        "MP"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "14",
                    "size": "4"
                },
                {
                    "name": "MP",
                    "size": "1"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count = 0",
                "do i = 0 to 7",
                "  count := count + EXTZ64(VSR[VRB+32].hword[i].bit[0]=MP)",
                "",
                "GPR[RT] := count << 57"
            ],
            "body": [
                "",
                "",
                "The number of halfword elements having bit 0 set to the value",
                "MP in VSR[VRB+32] is placed into bits 0:6 of",
                "GPR[RT]. Bits 7:63 of GPR[RT] are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Count Mask Bits Word",
                    "form": "VX",
                    "mnemonic": "vcntmbw",
                    "operands": [
                        "RT",
                        "VRB",
                        "MP"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "15",
                    "size": "4"
                },
                {
                    "name": "MP",
                    "size": "1"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count = 0",
                "do i = 0 to 3",
                "  count := count + EXTZ64(VSR[VRB+32].word[i].bit[0]=MP)",
                "end",
                "",
                "GPR[RT] := count << 58"
            ],
            "body": [
                "",
                "",
                "The number of word elements having bit 0 set to the value MP in VSR[VRB+32] is placed into bits 0:5 of GPR[RT]. Bits 6:63 of GPR[RT] are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Count Mask Bits Doubleword",
                    "form": "VX",
                    "mnemonic": "vcntmbd",
                    "operands": [
                        "RT",
                        "VRB",
                        "MP"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "13",
                    "size": "4"
                },
                {
                    "name": "MP",
                    "size": "1"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "count = 0",
                "do i = 0 to 1",
                "  count := count + EXTZ64(VSR[VRB+32].dword[i].bit[0]=MP)",
                "end",
                "",
                "GPR[RT] := count << 59"
            ],
            "body": [
                "",
                "",
                "The number of doubleword elements having bit 0 set to the value",
                "MP in VSR[VRB+32] is placed into bits 0:4 of",
                "GPR[RT]. Bits 5:63 of GPR[RT] are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Byte Mask",
                    "form": "VX",
                    "mnemonic": "vextractbm",
                    "operands": [
                        "RT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "8",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  GPR[RT].bit[48+i] := VSR[VRB+32].byte[i].bit[0]",
                "end",
                "",
                "GPR[RT].bit[0:47] := 0"
            ],
            "body": [
                "",
                "",
                "The contents of bit 0 of each byte element of VSR[VRB+32]",
                "are concatenated and placed into bits 48:63 of GPR[RT].",
                "Bits 0:47 of GPR[RT] are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Halfword Mask",
                    "form": "VX",
                    "mnemonic": "vextracthm",
                    "operands": [
                        "RT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "9",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 7",
                "  GPR[RT].bit[56+i] := VSR[VRB+32].hword[i].bit[0]",
                "end",
                "",
                "GPR[RT].bit[0:55] := 0"
            ],
            "body": [
                "",
                "",
                "The contents of bit 0 of each halfword element of VSR[VRB+32] are concatenated and placed into bits 56:63 of",
                "GPR[RT]. Bits 0:55 of GPR[RT] are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Word Mask",
                    "form": "VX",
                    "mnemonic": "vextractwm",
                    "operands": [
                        "RT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "10",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 3",
                "  GPR[RT].bit[60+i] := VSR[VRB+32].word[i].bit[0]",
                "end",
                "",
                "GPR[RT].bit[0:59] := 0"
            ],
            "body": [
                "",
                "",
                "The contents of bit 0 of each word element of VSR[VRB+32]",
                "are concatenated and placed into bits 60:63 of GPR[RT].",
                "Bits 0:59 of GPR[RT] are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Doubleword Mask",
                    "form": "VX",
                    "mnemonic": "vextractdm",
                    "operands": [
                        "RT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "11",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 1",
                "  GPR[RT].bit[62+i] := VSR[VRB+32].dword[i].bit[0]",
                "end",
                "",
                "GPR[RT].bit[0:61] := 0"
            ],
            "body": [
                "",
                "",
                "The contents of bit 0 of each doubleword element of VSR[VRB+32] are concatenated and placed into bits 62:63 of",
                "GPR[RT]. Bits 0:61 of GPR[RT] are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Extract Quadword Mask",
                    "form": "VX",
                    "mnemonic": "vextractqm",
                    "operands": [
                        "RT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "12",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1602",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "GPR[RT] := EXTZ64(VSR[VRB+32].bit[0])"
            ],
            "body": [
                "",
                "",
                "The contents of bit 0 of VSR[VRB+32] are placed into bit",
                "63 of GPR[RT].",
                "Bits 0:62 of GPR[RT] are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector String Isolate Byte Right-justified",
                    "form": "VC",
                    "mnemonic": "vstribr",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.1"
                },
                {
                    "name": "Vector String Isolate Byte Right-justified",
                    "form": "VC",
                    "mnemonic": "vstribr.",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "13",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "null_found := 0",
                "",
                "while(!null_found) do i = 0 to 15",
                "  null_found := (VSR[VRB+32].byte[15-i]=0)",
                "  VSR[VRT+32].byte[15-i] := VSR[VRB+32].byte[15-i]",
                "end",
                "",
                "do j = i to 15",
                "  VSR[VRT+32].byte[15-j] := 0",
                "end",
                "",
                "if Rc=1 then",
                "  CR.field[6] := 0b00 || null_found || 0b0"
            ],
            "body": [
                "",
                "",
                "From right-to-left, the contents of each byte element of VSR[VRB+32] are placed into the corresponding byte element in",
                "VSR[VRT+32].",
                "If a byte element in VSR[VRB+32] is found to contain 0,",
                "the corresponding byte element and all byte elements to the left of",
                "that byte element in VSR[VRT+32] are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector String Isolate Byte Left-justified",
                    "form": "VC",
                    "mnemonic": "vstribl",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.1"
                },
                {
                    "name": "Vector String Isolate Byte Left-justified",
                    "form": "VC",
                    "mnemonic": "vstribl.",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "13",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "null_found := 0",
                "",
                "while(!null_found) do i = 0 to 15",
                "  null_found := (VSR[VRB+32].byte[i]=0)",
                "  VSR[VRT+32].byte[i] := VSR[VRB+32].byte[i]",
                "end",
                "",
                "do j = i to 15",
                "  VSR[VRT+32].byte[j] := 0",
                "end",
                "",
                "if Rc=1 then",
                "  CR.field[6] := 0b00 || null_found || 0b0"
            ],
            "body": [
                "",
                "",
                "From left-to-right, the contents of each byte element of VSR[VRB+32] are placed into the corresponding byte element in",
                "VSR[VRT+32].",
                "If a byte element in VSR[VRB+32] is found to contain 0,",
                "the corresponding byte element and all byte elements to the right of",
                "that byte element in VSR[VRT+32] are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector String Isolate Halfword Right-justified",
                    "form": "VC",
                    "mnemonic": "vstrihr",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.1"
                },
                {
                    "name": "Vector String Isolate Halfword Right-justified",
                    "form": "VC",
                    "mnemonic": "vstrihr.",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "3",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "13",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "null_found := 0",
                "",
                "while(!null_found) do i = 0 to 7",
                "  null_found := (VSR[VRB+32].hword[7-i] = 0)",
                "  VSR[VRT+32].hword[7-i] := VSR[VRB+32].hword[7-i]",
                "end",
                "",
                "do j = i to 7",
                "  VSR[VRT+32].hword[7-j] := 0",
                "end",
                "",
                "if Rc=1 then",
                "  CR.field[6] := 0b00 || null_found || 0b0"
            ],
            "body": [
                "",
                "",
                "From right-to-left, the contents of each halfword element of",
                "VSR[VRB+32] are placed into the corresponding halfword",
                "element in VSR[VRT+32].",
                "If a halfword element in VSR[VRB+32] is found to contain",
                "0, the corresponding halfword element and all halfword elements to",
                "the left of that halfword element in VSR[VRT+32] are set",
                "to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector String Isolate Halfword Left-justified",
                    "form": "VC",
                    "mnemonic": "vstrihl",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v3.1"
                },
                {
                    "name": "Vector String Isolate Halfword Left-justified",
                    "form": "VC",
                    "mnemonic": "vstrihl.",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "2",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "13",
                    "size": "10"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "null_found := 0",
                "",
                "while(!null_found) do i = 0 to 7",
                "  null_found := (VSR[VRB+32].hword[i] = 0)",
                "  VSR[VRT+32].hword[i] := VSR[VRB+32].hword[i]",
                "end",
                "",
                "do j = i to 7",
                "  VSR[VRT+32].hword[j] := 0",
                "end",
                "",
                "if Rc=1 then",
                "  CR.field[6] := 0b00 || null_found || 0b0"
            ],
            "body": [
                "",
                "",
                "From left-to-right, the contents of each halfword element of",
                "VSR[VRB+32] are placed into the corresponding halfword",
                "element in VSR[VRT+32].",
                "If a halfword element in VSR[VRB+32] is found to contain",
                "0, the corresponding halfword element and all halfword elements to",
                "the right of that halfword element in VSR[VRT+32] are set",
                "to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Clear Leftmost Bytes",
                    "form": "VX",
                    "mnemonic": "vclrlb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "397",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "N := (GPR[RB] > 15) ? 16: GPR[RB]",
                "",
                "do i = 0 to N-1",
                "  VSR[VRT+32].byte[15-i] := VSR[VRA+32].byte[15-i]",
                "end",
                "",
                "do i = N to 15",
                "  VSR[VRT+32].byte[15-i] := 0x00",
                "end"
            ],
            "body": [
                "",
                "",
                "Let N be the integer value in GPR[RB], or the",
                "integer value 16 if the integer value in GPR[RB] is",
                "greater than 15.",
                "",
                "The contents of VSR[VRA+32] are placed into VSR[VRT+32] with the leftmost 16-N bytes of VSR[VRT+32] set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Clear Rightmost Bytes",
                    "form": "VX",
                    "mnemonic": "vclrrb",
                    "operands": [
                        "VRT",
                        "VRA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "461",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "N := (GPR[RB] > 15) ? 16: GPR[RB]",
                "do i = 0 to N-1",
                "  VSR[VRT+32].byte[i] := VSR[VRA+32].byte[i]",
                "end",
                "",
                "do i = N to 15",
                "  VSR[VRT+32].byte[i] := 0x00",
                "end"
            ],
            "body": [
                "",
                "",
                "Let N be the integer value in GPR[RB], or the",
                "integer value 16 if the integer value in GPR[RB] is",
                "greater than 15.",
                "",
                "The contents of VSR[VRA+32] are placed into VSR[VRT+32] with the rightmost 16-N bytes of VSR[VRT+32] set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Decimal Add Modulo",
                    "form": "VX",
                    "mnemonic": "bcdadd.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "PS"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "1",
                    "size": "9"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32] := bcd_ADD(VSR[VRA+32],VSR[VRB+32],PS)",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := ox_flag | inv_flag"
            ],
            "body": [
                "",
                "",
                "Let src1 be the decimal integer value in VSR[VRA+32].",
                "",
                "Let src2 be the decimal integer value in VSR[VRB+32].",
                "",
                "src1 is added to src2.",
                "",
                "If the unbounded result is equal to zero, do the following.",
                "",
                "",
                "",
                "If PS=0, the sign code of the result is set to 0b1100.",
                "",
                "",
                "If PS=1, the sign code of the result is set to 0b1111.",
                "",
                "",
                "CR field 6 is set to 0b0010.",
                "",
                "",
                "If the unbounded result is greater than zero, do the following.",
                "",
                "",
                "",
                "If PS=0, the sign code of the result is set to 0b1100.",
                "",
                "",
                "If PS=1, the sign code of the result is set to 0b1111.",
                "",
                "",
                "If the operation overflows, CR field 6 is set",
                "to 0b0101.",
                "Otherwise, CR field 6 is set to 0b0100.",
                "",
                "",
                "If the unbounded result is less than zero, do the following.",
                "",
                "",
                "",
                "The sign code of the result is set to 0b1101.",
                "",
                "",
                "If the operation overflows, CR field 6 is set",
                "to 0b1001.",
                "Otherwise, CR field 6 is set to 0b1000.",
                "",
                "",
                "The low-order 31 digits of the magnitude of the result",
                "are placed in bits 0:123 of VSR[VRT+32].",
                "",
                "The sign code is placed in bits 124:127 of VSR[VRT+32].",
                "",
                "If either src1 or src2 is an invalid encoding of a 31-digit signed decimal value, the",
                "result is undefined and CR field 6 is set to",
                "0b0001.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Decimal Subtract Modulo",
                    "form": "VX",
                    "mnemonic": "bcdsub.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "PS"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "65",
                    "size": "9"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32] := bcd_SUBTRACT(VSR[VRA+32],VSR[VRB+32],PS)",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := ox_flag | inv_flag"
            ],
            "body": [
                "",
                "",
                "Let src1 be the decimal integer value in VSR[VRA+32].",
                "",
                "Let src2 be the decimal integer value in VSR[VRB+32].",
                "",
                "src1 is subtracted by src2.",
                "",
                "If the unbounded result is equal to zero, do the following.",
                "",
                "",
                "",
                "If PS=0, the sign code of the result is set to 0b1100.",
                "",
                "",
                "If PS=1, the sign code of the result is set to 0b1111.",
                "",
                "",
                "CR field 6 is set to 0b0010.",
                "",
                "",
                "If the unbounded result is greater than zero, do the following.",
                "",
                "",
                "",
                "If PS=0, the sign code of the result is set to 0b1100.",
                "",
                "",
                "If PS=1, the sign code of the result is set to 0b1111.",
                "",
                "",
                "If the operation overflows, CR field 6 is set",
                "to 0b0101.",
                "Otherwise, CR field 6 is set to 0b0100.",
                "",
                "",
                "If the unbounded result is less than zero, do the following.",
                "",
                "",
                "",
                "The sign code of the result is set to 0b1101.",
                "",
                "",
                "If the operation overflows, CR field 6 is set",
                "to 0b1001.",
                "Otherwise, CR field 6 is set to 0b1000.",
                "",
                "",
                "The low-order 31 digits of the magnitude of the result",
                "are placed in bits 0:123 of VSR[VRT+32].",
                "",
                "The sign code is placed in bits 124:127 of VSR[VRT+32].",
                "",
                "If either src1 or src2 is an invalid encoding of a 31-digit signed decimal value, the",
                "result is undefined and CR field 6 is set to",
                "0b0001.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Decimal Convert From National",
                    "form": "VX",
                    "mnemonic": "bcdcfn.",
                    "operands": [
                        "VRT",
                        "VRB",
                        "PS"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "7",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "385",
                    "size": "9"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src_sign := (VSR[VRB+32].hword[7] = 0x002D)",
                "eq_flag  := 1",
                "/* check for valid sign */",
                "inv_flag := (VSR[VRB+32].hword[7] != 0x002B) &",
                " (VSR[VRB+32].hword[7] != 0x002D)",
                "",
                "do i = 0 to 6",
                "  eq_flag  := eq_flag  & (VSR[VRB+32].hword[i] = 0x0030)",
                "  /* check for valid digit */",
                "  inv_flag := inv_flag | (VSR[VRB+32].hword[i] < 0x0030)",
                "          | (VSR[VRB+32].hword[i] > 0x0039)",
                "end",
                "",
                "lt_flag := (eq_flag=0) & (src_sign=1)",
                "gt_flag := (eq_flag=0) & (src_sign=0)",
                "",
                "do i = 0 to 23",
                "  result.nibble[i] := 0x0",
                "end",
                "do i = 0 to 6",
                "  result.nibble[i+24] := VSR[VRB+32].hword[i].nibble[3]",
                "end",
                "result.nibble[31] := (src_sign=0) ? ((PS=0) ? 0xC : 0xF) : 0xD",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag"
            ],
            "body": [
                "",
                "",
                "Let src be the national decimal value in VSR[VRB+32].",
                "",
                "src is placed in VSR[VRT+32] in packed",
                "decimal format.",
                "",
                "A valid encoding of a national decimal value requires the following.",
                "",
                "",
                "",
                "National decimal values having a sign code of 0x002B are",
                "interpreted as positive values.",
                "",
                "National decimal values having a sign code of 0x002D are",
                "interpreted as negative values.",
                "",
                "For each integer value i from 0 to 23, do the following.",
                "",
                "",
                "",
                "The contents of nibble element i of VSR[VRT+32] are set to 0x0.",
                "",
                "",
                "For each integer value i from 0 to 6, do the following.",
                "",
                "",
                "",
                "The contents of nibble 3 of halfword element i of",
                "src are placed into nibble element i+24 of",
                "VSR[VRT+32].",
                "",
                "",
                "For PS=0, the contents of nibble element 31 (i.e., sign",
                "code) of VSR[VRT+32] are set to 0xC for",
                "positive values and to 0xD for negative values.",
                "",
                "For PS=1, the contents of nibble element 31 (i.e., sign",
                "code) of VSR[VRT+32] are set to 0xF for",
                "positive values and to 0xD for negative values.",
                "",
                "CR field 6 is set to reflect src compared to zero.",
                "",
                "If src is an invalid encoding of a national",
                "decimal value, the contents of VSR[VRT+32] are undefined",
                "and CR field 6 is set to 0b0001.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Decimal Convert From Zoned",
                    "form": "VX",
                    "mnemonic": "bcdcfz.",
                    "operands": [
                        "VRT",
                        "VRB",
                        "PS"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "6",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "385",
                    "size": "9"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "/* check for valid sign */",
                "inv_flag := ((VSR[VRB+32].byte[15].nibble[0] < 0xA) & (PS=1)) |",
                "   (VSR[VRB+32].byte[15].nibble[1] > 0x9)",
                "",
                "/* check for valid digits */",
                "MIN := (PS=0) ? 0x30 : 0xF0",
                "MAX := (PS=0) ? 0x39 : 0xF9",
                "do i = 0 to 14",
                "  inv_flag := inv_flag | (VSR[VRB+32].byte[i] < MIN)",
                "          | (VSR[VRB+32].byte[i] > MAX)",
                "end",
                "",
                "if PS=0 then",
                "  src_sign :=  VSR[VRB+32].nibble[30].bit[1]",
                "else",
                "  src_sign := (VSR[VRB+32].nibble[30] = 0b1011) |",
                " (VSR[VRB+32].nibble[30] = 0b1101)",
                "",
                "eq_flag  := 1",
                "",
                "do i = 0 to 14",
                "  result.nibble[i] := 0x0",
                "end",
                "do i = 0 to 15",
                "  result.nibble[i+15] := VSR[VRB+32].byte[i].nibble[1]",
                "  eq_flag := eq_flag & (VSR[VRB+32].byte[i].nibble[1]=0x0)",
                "end",
                "",
                "lt_flag := (eq_flag=0) & (src_sign=1)",
                "gt_flag := (eq_flag=0) & (src_sign=0)",
                "",
                "result.nibble[31] := (src_sign=0) ? 0xC : 0xD",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag"
            ],
            "body": [
                "",
                "",
                "Let src be the zoned decimal value in VSR[VRB+32].",
                "",
                "src is placed in VSR[VRT+32] in packed",
                "decimal format.",
                "",
                "When PS=0, do the following.",
                "",
                "",
                "",
                "A valid encoding of a zoned decimal value requires the following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "Zoned decimal values having a sign code of 0x0,",
                "0x1, 0x2, 0x3, 0x8,",
                "0x9, 0xA, or 0xB are interpreted",
                "as positive values.",
                "",
                "",
                "Zoned decimal values having a sign code of 0x4,",
                "0x5, 0x6, 0x7, 0xC,",
                "0xD, 0xE, or 0xF are interpreted",
                "as negative values.",
                "",
                "",
                "When PS=1, do the following.",
                "",
                "",
                "",
                "A valid encoding of a zoned decimal source operand requires the",
                "following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "Zoned decimal source operands having a sign code of 0xA,",
                "0xC, 0xE, or 0xF are interpreted",
                "as positive values.",
                "",
                "",
                "Zoned decimal source operands having a sign code of 0xB",
                "or 0xD are interpreted as negative values.",
                "",
                "",
                "Positive packed decimal results are returned with a sign code of",
                "0xC.",
                "",
                "Negative packed decimal results are returned with a sign code of",
                "0xD.",
                "",
                "For each integer value i from 0 to 14,",
                "",
                "",
                "",
                "The contents of nibble element i of VSR[VRT+32] are set to 0x0.",
                "",
                "",
                "For each integer value i from 0 to 15,",
                "",
                "",
                "",
                "The contents of nibble 1 of byte element i of src are placed into nibble element i+15 of VSR[VRT+32].",
                "",
                "",
                "CR field 6 is set to reflect src compared to zero.",
                "",
                "If src is an invalid encoding of a zoned",
                "decimal value, the contents of VSR[VRT+32] are undefined",
                "and CR field 6 is set to 0b0001.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Decimal Convert To National",
                    "form": "VX",
                    "mnemonic": "bcdctn.",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "5",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "385",
                    "size": "9"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "ox_flag := 0",
                "do i = 0 to 23",
                "  ox_flag := ox_flag | (VSR[VRB+32].nibble[i] != 0x0)",
                "end",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] < 0xA)",
                "do i = 0 to 30",
                "  inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                "src.sign := (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag := (eq_flag=0) & (src_sign=1)",
                "gt_flag := (eq_flag=0) & (src_sign=0)",
                "",
                "do i = 0 to 6",
                "  result.hword[i].nibble[0:2] := 0x003",
                "  result.hword[i].nibble[3]   := VSR[VRB+32].nibble[i+24]",
                "end",
                "",
                "result.hword[7] := (src_sign=1) ? 0x002D : 0x002B",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "",
                "",
                "Let src be the packed decimal value in VSR[VRB+32].",
                "",
                "src is placed into VSR[VRT+32] in national",
                "decimal format.",
                "",
                "A valid encoding of a signed packed decimal value requires the",
                "following.",
                "",
                "",
                "",
                "Packed decimal values with sign codes of 0xA, 0xC, 0xE, or 0xF are interpreted as positive",
                "values.",
                "",
                "Packed decimal values with sign codes of 0xB or",
                "0xD are interpreted as negative values.",
                "",
                "Values greater in magnitude than 107-1 are too",
                "large to be represented in national decimal format.",
                "",
                "For each integer value i from 0 to 6, do the following.",
                "",
                "",
                "",
                "The value 0x003 is placed into nibbles 0:2 of halfword",
                "element i of VSR[VRT+32].",
                "",
                "",
                "The contents of nibble element i+24 of VSR[VRB+32] are placed into nibble 3 of halfword element i of VSR[VRT+32].",
                "",
                "",
                "The contents of halfword element 7 (i.e., sign code) of VSR[VRT+32] are set to 0x002B for positive values and to",
                "0x002D for negative values.",
                "",
                "CR field 6 is set to reflect src compared to zero,",
                "including whether or not src is too large to be",
                "represented in national decimal format.",
                "",
                "If src is an invalid encoding of a packed",
                "decimal value, the contents of VSR[VRT+32] are undefined",
                "and CR field 6 is set to 0b0001.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Decimal Convert To Zoned",
                    "form": "VX",
                    "mnemonic": "bcdctz.",
                    "operands": [
                        "VRT",
                        "VRB",
                        "PS"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "4",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "385",
                    "size": "9"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] < 0xA)",
                "do i = 0 to 30",
                "   inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "ox_flag := 0",
                "do i = 0 to 15",
                "  ox_flag := ox_flag | (VSR[VRB+32].nibble[i] != 0x0)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                " (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag := (eq_flag=0) & (src_sign=1)",
                "gt_flag := (eq_flag=0) & (src_sign=0)",
                "",
                "do i = 0 to 14",
                "  result.byte[i].nibble[0] := (PS=0) ? 0x3 : 0xF",
                "  result.byte[i].nibble[1] := VSR[VRB+32].nibble[i+15]",
                "end",
                "if src.sign=0 then",
                "  result.byte[15].nibble[0] := (PS=0) ? 0x3 : 0xC",
                "else",
                "  result.byte[15].nibble[0] := (PS=0) ? 0x7 : 0xD",
                "",
                "result.byte[15].nibble[1] := VSR[VRB+32].nibble[30]",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "",
                "",
                "Let src be the packed decimal value in VSR[VRB+32].",
                "",
                "src is placed into  VSR[VRT+32] in zoned",
                "decimal format.",
                "",
                "A valid encoding of a signed packed decimal value requires the",
                "following.",
                "",
                "",
                "",
                "Packed decimal values with sign codes of 0xA, 0xC, 0xE, or 0xF are interpreted as positive",
                "values.",
                "",
                "Packed decimal values with sign codes of 0xB or",
                "0xD are interpreted as negative values.",
                "",
                "Values greater in magnitude than 1016-1 are too",
                "large to be represented in zoned decimal format.",
                "",
                "For PS=0, do the following.",
                "",
                "",
                "",
                "The leftmost nibble of each digit 0-14 of the zoned decimal result is",
                "set to 0x3.",
                "",
                "",
                "Positive zoned decimal results are returned with a sign code of",
                "0x3.",
                "",
                "",
                "Negative zoned decimal results are returned with a sign code of",
                "0x7.",
                "",
                "",
                "For PS=1, do the following.",
                "",
                "",
                "",
                "The leftmost nibble of each digit 0-14 of the zoned decimal result is",
                "set to 0xF.",
                "",
                "",
                "Positive zoned decimal results are returned with a sign code of",
                "0xC.",
                "",
                "",
                "Negative zoned decimal results are returned with a sign code of",
                "0xD.",
                "",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "The rightmost nibble of each digit i of the zoned decimal",
                "result is set to the contents of nibble i+15 of",
                "src.",
                "",
                "",
                "The result is placed into VSR[VRT+32].",
                "",
                "CR field 6 is set to reflect src compared to zero,",
                "including whether or not src is too large to be",
                "represented in zoned decimal format.",
                "",
                "If src is an invalid encoding of a packed",
                "decimal value, the contents of VSR[VRT+32] are undefined",
                "and CR field 6 is set to 0b0001.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Decimal Convert From Signed Quadword",
                    "form": "VX",
                    "mnemonic": "bcdcfsq.",
                    "operands": [
                        "VRT",
                        "VRB",
                        "PS"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "2",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "385",
                    "size": "9"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "ox_flag := (EXTS(VSR[VRB+32]) >  10<sup>31</sup>-1) |",
                " (EXTS(VSR[VRB+32]) < -10<sup>31</sup>-1)",
                "lt_flag := (EXTS(VSR[VRB+32]) <  0)",
                "gt_flag := (EXTS(VSR[VRB+32]) >  0)",
                "eq_flag := (EXTS(VSR[VRB+32]) =  0)",
                "",
                "if ox_flag=0 then",
                "  result := bcd_CONVERT_FROM_SI128(EXTS(VSR[VRB+32]),PS)",
                "else",
                "  result := 0xUUUU_UUUU_UUUU_UUUU_UUUU_UUUU_UUUU_UUUU",
                "",
                "VSR[VRT+32] := ox_flag ? undefined : result",
                "",
                "CR.bit[56] := lt_flag",
                "CR.bit[57] := gt_flag",
                "CR.bit[58] := eq_flag",
                "CR.bit[59] := ox_flag"
            ],
            "body": [
                "",
                "",
                "Let src be the signed integer value in VSR[VRB+32].",
                "",
                "src is placed into VSR[VRT+32] in signed",
                "packed decimal format.",
                "",
                "For PS=0, the contents of nibble element 31 (i.e., sign",
                "code) of VSR[VRT+32] are set to 0xC for",
                "values greater than or equal to 0 and to 0xD for values",
                "less than 0.",
                "",
                "For PS=1, the contents of nibble element 31 (i.e., sign",
                "code) of VSR[VRT+32] are set to 0xF for",
                "values greater than or equal to 0 and to 0xD for values",
                "less than 0.",
                "",
                "If the signed integer value in VSR[VRB+32] is greater",
                "than 10-1 or less than -10-1, the value is too large to be represented in",
                "packed decimal format, and the contents of VSR[VRT+32]",
                "are undefined.",
                "",
                "CR field 6 is set to reflect src compared to",
                "zero and whether or not src is too large in magnitude to",
                "be represented in packed decimal format.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Decimal Convert To Signed Quadword",
                    "form": "VX",
                    "mnemonic": "bcdctsq.",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "385",
                    "size": "9"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] < 0xA)",
                "do i = 0 to 30",
                "   inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "src_sign    := (VSR[VRB+32].nibble[31] = 0xB) |",
                " (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag     := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag     := (eq_flag=0) & (src_sign=1)",
                "gt_flag     := (eq_flag=0) & (src_sign=0)",
                "",
                "result      := si128_CONVERT_FROM_BCD(VSR[VRB+32])",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56]  := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57]  := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58]  := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59]  := inv_flag"
            ],
            "body": [
                "",
                "",
                "Let src be the packed decimal value in VSR[VRB+32].",
                "",
                "src is placed into VSR[VRT+32] in signed",
                "integer format.",
                "",
                "A valid encoding of a signed packed decimal value requires the",
                "following.",
                "",
                "",
                "",
                "Packed decimal values with sign codes of 0xA, 0xC, 0xE, or 0xF are interpreted as positive",
                "values.",
                "",
                "Packed decimal values with sign codes of 0xB or",
                "0xD are interpreted as negative values.",
                "",
                "CR field 6 is set to reflect src compared to zero.",
                "",
                "If src is an invalid encoding of a packed",
                "decimal value, the contents of VSR[VRT+32] are undefined",
                "and CR field 6 is set to 0b0001.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply-by-10 Unsigned Quadword",
                    "form": "VX",
                    "mnemonic": "vmul10uq",
                    "operands": [
                        "VRT",
                        "VRA"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "513",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src  := EXTZ(VSR[VRA+32])",
                "prod := (src << 3) + (src << 1)",
                "VSR[VRT+32] := CHOP128(prod)"
            ],
            "body": [
                "",
                "",
                "Let src be the unsigned integer value in VSR[VRA+32].",
                "",
                "The rightmost 128 bits of the product of src multiplied",
                "by the value 10 are placed into VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply-by-10  write Carry-out Unsigned Quadword",
                    "form": "VX",
                    "mnemonic": "vmul10cuq",
                    "operands": [
                        "VRT",
                        "VRA"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src  := EXTZ(VSR[VRA+32])",
                "prod := (src << 3) + (src << 1)",
                "VSR[VRT+32] := CHOP128(prod >> 128)"
            ],
            "body": [
                "",
                "",
                "Let src be the unsigned integer value in VSR[VRA+32].",
                "",
                "The product of src multiplied by the value 10 is shifted",
                "right by 128 bits.",
                "The rightmost 128 bits of the shifted result is placed into",
                "VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply-by-10 Extended Unsigned Quadword",
                    "form": "VX",
                    "mnemonic": "vmul10euq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "577",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src  := EXTZ(VSR[VRA+32])",
                "cin  := EXTZ(VSR[VRB+32].bit[124:127])",
                "prod := (src << 3) + (src << 1) + cin",
                "VSR[VRT+32] := CHOP128(prod)"
            ],
            "body": [
                "",
                "",
                "Let src be the unsigned integer value in VSR[VRA+32].",
                "",
                "Let cin be the unsigned packed decimal value in bits",
                "124:127 of VSR[VRB+32].",
                "Values of cin greater than 9 are undefined.",
                "",
                "The rightmost 128 bits of the sum of cin and the product",
                "of src multiplied by the value 10 are placed into",
                "VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Vector Multiply-by-10 Extended  write Carry-out Unsigned Quadword",
                    "form": "VX",
                    "mnemonic": "vmul10ecuq",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "65",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "src  := EXTZ(VSR[VRA+32])",
                "cin  := EXTZ(VSR[VRB+32].bit[124:127])",
                "prod := (src << 3) + (src << 1) + cin",
                "VSR[VRT+32] := CHOP128(prod>>128)"
            ],
            "body": [
                "",
                "",
                "Let src be the unsigned integer value in VSR[VRA+32].",
                "",
                "Let cin be the unsigned packed decimal value in bits",
                "124:127 of VSR[VRA+32].",
                "Values of cin greater than 9 are undefined.",
                "",
                "The sum of cin and the product of src",
                "multiplied by the value 10 is shifted right by 128 bits.",
                "The rightmost 128 bits of the shifted result is placed into",
                "VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Decimal Copy Sign",
                    "form": "VX",
                    "mnemonic": "bcdcpsgn.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "833",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := (VSR[VRA+32].nibble[31] < 0xA) |",
                "inv_flag := (VSR[VRB+32].nibble[31] < 0xA)",
                "do i = 0 to 30",
                "   inv_flag := inv_flag | (VSR[VRA+32].nibble[i] > 0x9)",
                "inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                " (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag  := (VSR[VRA+32].nibble[0:30] = 0)",
                "lt_flag  := (eq_flag=0) & (src_sign=1)",
                "gt_flag  := (eq_flag=0) & (src_sign=0)",
                "",
                "result.nibble[0:30] := VSR[VRA+32].nibble[0:30]",
                "result.nibble[31]   := VSR[VRB+32].nibble[31]",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56]  := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57]  := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58]  := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59]  := inv_flag"
            ],
            "body": [
                "",
                "",
                "The decimal value in VSR[VRA+32] is placed into",
                "VSR[VRT+32] with the sign code of the decimal value in",
                "VSR[VRB+32].",
                "",
                "CR field 6 is set to reflect the result compared to zero.",
                "",
                "If either the decimal value in VSR[VRA+32] or the decimal",
                "value in VSR[VRB+32] is an invalid encoding,",
                "the contents of VSR[VRT+32] are undefined and CR field 6 is set to 0b0001.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Decimal Set Sign",
                    "form": "VX",
                    "mnemonic": "bcdsetsgn.",
                    "operands": [
                        "VRT",
                        "VRB",
                        "PS"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "31",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "385",
                    "size": "9"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] < 0xA)",
                "do i = 0 to 30",
                "   inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                " (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag  := (eq_flag=0) & (src_sign=1)",
                "gt_flag  := (eq_flag=0) & (src_sign=0)",
                "",
                "result.nibble[0:30] := VSR[VRB+32].nibble[0:30]",
                "result.nibble[31]   := (src_sign=0) ? ((PS=0) ? 0xC:0xF) : 0xD",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56]  := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57]  := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58]  := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59]  := inv_flag"
            ],
            "body": [
                "",
                "",
                "Let src be the packed decimal value in VSR[VRB+32].",
                "",
                "Packed decimal values with sign codes of 0xA, 0xC, 0xE, or 0xF are interpreted as positive",
                "values.",
                "",
                "Packed decimal values with sign codes of 0xB or",
                "0xD are interpreted as negative values.",
                "",
                "If src is negative, src is placed into",
                "VSR[VRT+32] with the sign code set to 0xD.",
                "",
                "If src is positive and PS=0, src",
                "is placed into VSR[VRT+32] with the sign code set to",
                "0xC.",
                "",
                "If src is positive and PS=1, src",
                "is placed into VSR[VRT+32] with the sign code set to",
                "0xF.",
                "",
                "CR field 6 is set to reflect src compared to zero.",
                "",
                "If src is an invalid encoding of a packed",
                "decimal value, the contents of VSR[VRT+32] are undefined",
                "and CR field 6 is set to 0b0001.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Decimal Shift",
                    "form": "VX",
                    "mnemonic": "bcds.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "PS"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "193",
                    "size": "9"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "n := EXTS(VSR[VRA+32].byte[7])",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] < 0xA)",
                "do i = 0 to 30",
                "   inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                " (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag  := (eq_flag=0) & (src_sign=1)",
                "gt_flag  := (eq_flag=0) & (src_sign=0)",
                "",
                "if n > 0 then do     // shift left",
                "  shcnt               := (n<32) ? n : 31",
                "  src.nibble[0:30]    := VSR[VRB+32].nibble[0:30]",
                "  src.nibble[31:61]   := 0",
                "  result.nibble[0:30] := src.data.nibble[shcnt:shcnt+30]",
                "  ox_flag := (shcnt > 0) & (src.nibble[0:shcnt-1] != 0)",
                "end",
                "else do              // shift right",
                "  shcnt               := ((~n+1)<32) ? (~n+1) : 31",
                "  src.nibble[0:30]    := 0",
                "  src.nibble[31:61]   := VSR[VRB+32].nibble[0:30]",
                "  result.nibble[0:30] := src.nibble[31-shcnt:61-shcnt]",
                "  ox_flag := 0b0",
                "end",
                "",
                "result.nibble[31] := (src_sign=0) ? ((PS=0) ? 0xC : 0xF) : 0xD",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "",
                "",
                "Let n be the signed integer value in byte element",
                "7 of VSR[VRA+32].",
                "",
                "Let src be the signed packed decimal value in VSR[VRB+32].",
                "",
                "A valid encoding of a signed packed decimal value requires the",
                "following.",
                "",
                "",
                "",
                "Packed decimal source operands with sign codes of 0xA,",
                "0xC, 0xE, or 0xF are interpreted",
                "as positive values.",
                "",
                "Packed decimal source operands with sign codes of 0xB or",
                "0xD are interpreted as negative values.",
                "",
                "If n is greater than zero, src is shifted",
                "left n digits.",
                "Zeros are supplied to vacated digits on the right.",
                "If any non-zero digits are shifted out, an overflow occurs.",
                "",
                "If n is less than zero, src is shifted right",
                "-n digits.",
                "Zeros are supplied to vacated digits on the left.",
                "",
                "If the packed decimal value in VSR[VRB+32] is negative,",
                "the sign code of the result is set to 0b1101.",
                "",
                "If the packed decimal value in VSR[VRB+32] is positive,",
                "the sign code of the result is set to 0b1100 if",
                "PS=0 and is set to 0b1111 if PS=1.",
                "",
                "The shifted result is placed into VSR[VRT+32].",
                "",
                "CR field 6 is set to reflect src compared to zero,",
                "including whether or not significant digits were shifted out when the",
                "shift count is positive (i.e., left shift operation).",
                "",
                "If src is an invalid encoding of a packed",
                "decimal value, the contents of VSR[VRT+32] are undefined",
                "and CR field 6 is set to 0b0001.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Decimal Unsigned Shift",
                    "form": "VX",
                    "mnemonic": "bcdus.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "129",
                    "size": "9"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "n := EXTS(VSR[VRA+32].byte[7])",
                "",
                "inv_flag := 0",
                "do i = 0 to 31",
                "   inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:31] = 0)",
                "gt_flag  := (eq_flag=0)",
                "",
                "if n > 0 then do     // shift left",
                "  shcnt := (n<33) ? n : 32",
                "  src.nibble[0:31] := VSR[VRB+32]",
                "  src.nibble[32:63] := 0",
                "  result := src.nibble[shcnt:shcnt+31]",
                "  ox_flag := (shcnt > 0) & (src.nibble[0:shcnt-1] != 0)",
                "end",
                "else do              // shift right",
                "  shcnt := ((~n+1)<33) ? (~n+1) : 32",
                "  src.nibble[0:31]  := 0",
                "  src.nibble[32:63] := VSR[VRB+32]",
                "  result := src.nibble[32-shcnt:63-shcnt]",
                "  ox_flag := 0",
                "end",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := 0b0",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "",
                "",
                "Let n be the signed integer value in byte element",
                "7 of VSR[VRA+32].",
                "",
                "Let src be the unsigned packed decimal value in",
                "VSR[VRB+32].",
                "",
                "A valid encoding of an unsigned packed decimal value requires the",
                "contents of each nibble 0-31 must be a value in the range 0x0 to 0x9.",
                "",
                "If n is greater than zero, src is shifted",
                "left n digits.",
                "Zeros are supplied to vacated digits on the right.",
                "If any non-zero digits are shifted out, an overflow occurs.",
                "",
                "If n is less than zero, src is shifted right",
                "-n digits.",
                "Zeros are supplied to vacated digits on the left.",
                "",
                "The shifted result is placed into VSR[VRT+32].",
                "",
                "CR field 6 is set to reflect src compared to zero,",
                "including whether or not significant digits were shifted out when the",
                "shift count is positive (i.e., left shift operation).",
                "",
                "If src is an invalid encoding of a packed",
                "decimal value, the contents of VSR[VRT+32] are undefined",
                "and CR field 6 is set to 0b0001.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Decimal Shift  Round",
                    "form": "VX",
                    "mnemonic": "bcdsr.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "PS"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "449",
                    "size": "9"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "n := EXTS(VSR[VRA+32].byte[7])",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] < 0xA)",
                "do i = 0 to 30",
                "   inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                " (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag  := (eq_flag=0) & (src_sign=1)",
                "gt_flag  := (eq_flag=0) & (src_sign=0)",
                "",
                "if n > 0 then do     // shift left",
                "  shcnt := Clamp(n, 0, 31)",
                "  src.nibble[0:30]    := VSR[VRB+32].nibble[0:30]",
                "  src.nibble[31:61]   := 0",
                "  result.nibble[0:30] := src.nibble[shcnt:shcnt+30]",
                "  ox_flag := (shcnt > 0) & (src.nibble[0:shcnt-1] != 0)",
                "  g_flag  := 0",
                "end",
                "else do              // shift right",
                "  shcnt := Clamp(~n + 1, 0, 31)",
                "  src.nibble[0:30]    := 0",
                "  src.nibble[31:61]   := VSR[VRB+32].nibble[0:30]",
                "  result.nibble[0:30] := src.nibble[31-shcnt:61-shcnt]",
                "  ox_flag := 0",
                "  g_flag  := (shcnt > 0) &",
                "             (EXTZ(src.nibble[62-shcnt]) >= 5)",
                "end",
                "result.nibble[31] := (src_sign=0) ? ((PS=0) ? 0xC : 0xF) : 0xD",
                "",
                "result := (g_flag=0) ? result : bcd_INCREMENT(result)",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "",
                "",
                "Let n be the signed integer value in byte element",
                "7 of VSR[VRA+32].",
                "",
                "Let src be the signed packed decimal value in VSR[VRB+32].",
                "",
                "A valid encoding of a signed packed decimal source operand requires",
                "the following.",
                "",
                "",
                "",
                "Packed decimal source operands with sign codes of 0xA,",
                "0xC, 0xE, or 0xF are interpreted",
                "as positive values.",
                "",
                "Packed decimal source operands with sign codes of 0xB or",
                "0xD are interpreted as negative values.",
                "",
                "If n is greater than zero, src is shifted",
                "left n digits.",
                "Zeros are supplied to vacated digits on the right.",
                "If any non-zero digits are shifted out, an overflow occurs.",
                "",
                "If n is less than zero, src is shifted right",
                "-n digits.",
                "Zeros are supplied to vacated digits on the left.",
                "If the value of the last nibble shifted out on the right was greater",
                "than or equal to 5, the magnitude of the result is incremented by 1.",
                "",
                "If src is negative, the sign code of the result is set to",
                "0b1101.",
                "",
                "If src is positive, the sign code of the result is set to",
                "0b1100 if PS=0 and is set to 0b1111 if PS=1.",
                "",
                "The shifted and rounded result is placed into VSR[VRT+32].",
                "",
                "CR field 6 is set to reflect src compared to zero,",
                "including whether or not significant digits were shifted out when the",
                "shift count is positive (i.e., left shift operation).",
                "",
                "If src is an invalid encoding of a packed",
                "decimal value, the contents of VSR[VRT+32] are undefined",
                "and CR field 6 is set to 0b0001.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Decimal Truncate",
                    "form": "VX",
                    "mnemonic": "bcdtrunc.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB",
                        "PS"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "1"
                },
                {
                    "name": "PS",
                    "size": "1"
                },
                {
                    "name": "257",
                    "size": "9"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := (VSR[VRB+32].nibble[31] < 0xA)",
                "do i = 0 to 30",
                "   inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "length  := VSR[VRA+32].bit[48:63]",
                "",
                "ox_flag := 0",
                "",
                "src_sign := (VSR[VRB+32].nibble[31] = 0xB) |",
                " (VSR[VRB+32].nibble[31] = 0xD)",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:30] = 0)",
                "lt_flag  :=  src_sign & ~eq_flag",
                "gt_flag  := ~src_sign & ~eq_flag",
                "",
                "if length < 31 then do",
                "  do i = 0 to 30-length",
                "     if VSR[VRB+32].nibble[i]!=0b0000 then ox_flag := 1",
                "     result.nibble[i] := 0b0000",
                "  end",
                "  if length > 0 then do",
                "     do i = 31-length to 30",
                "        result.nibble[i] := VSR[VRB+32].nibble[i]",
                "     end",
                "  end",
                "end",
                "else result.nibble[0:30] := VSR[VRB+32].nibble[0:30]",
                "",
                "result.nibble[31] := (src_sign=0) ? ((PS=0) ? 0xC : 0xF) : 0xD",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := inv_flag ? 0b0 : lt_flag",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "",
                "",
                "Let length be the integer value in bits 48:63 of",
                "VSR[VRA+32].",
                "",
                "Let src be the signed decimal value in VSR[VRB+32].",
                "",
                "A valid encoding of a packed decimal source operand requires the",
                "following.",
                "",
                "",
                "",
                "Packed decimal values with sign codes of 0xA, 0xC, 0xE, or 0xF are interpreted as positive",
                "values.",
                "",
                "Packed decimal values with sign codes of 0xB or",
                "0xD are interpreted as negative values.",
                "",
                "If src is negative, the sign code of the result is set to",
                "0b1101.",
                "",
                "If src is positive, the sign code of the result is set to",
                "0b1100 if PS=0 and is set to 0b1111 if PS=1.",
                "",
                "src is copied into VSR[VRT+32] with the",
                "leftmost 31-length digits each set to 0b0000.",
                "If any of the leftmost 31-length digits of the signed",
                "decimal value in VSR[VRB+32] are non-zero, an overflow",
                "occurs.",
                "",
                "CR field 6 is set to reflect src compared to zero,",
                "including whether or not significant digits were truncated.",
                "",
                "If src is an invalid encoding of a packed",
                "decimal value, the contents of VSR[VRT+32] are undefined",
                "and CR field 6 is set to 0b0001.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Decimal Unsigned Truncate",
                    "form": "VX",
                    "mnemonic": "bcdutrunc.",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "321",
                    "size": "9"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "inv_flag := 0",
                "do i = 0 to 31",
                "   inv_flag := inv_flag | (VSR[VRB+32].nibble[i] > 0x9)",
                "end",
                "",
                "length := VSR[VRA+32].bit[48:63]",
                "",
                "ox_flag := 0",
                "",
                "eq_flag  := (VSR[VRB+32].nibble[0:31]  = 0)",
                "gt_flag  := (VSR[VRB+32].nibble[0:31] != 0)",
                "",
                "if length < 32 then do",
                "  do i = 0 to 31-length",
                "     if VSR[VRB+32].nibble[i]!=0b0000 then ox_flag := 1",
                "     result.nibble[i] := 0b0000",
                "  end",
                "  if length > 0 then do",
                "     do i = 32-length to 31",
                "        result.nibble[i] := VSR[VRB+32].nibble[i]",
                "     end",
                "  end",
                "end",
                "else result := VSR[VRB+32]",
                "",
                "VSR[VRT+32] := inv_flag ? undefined : result",
                "",
                "CR.bit[56] := 0b0",
                "CR.bit[57] := inv_flag ? 0b0 : gt_flag",
                "CR.bit[58] := inv_flag ? 0b0 : eq_flag",
                "CR.bit[59] := inv_flag | ox_flag"
            ],
            "body": [
                "",
                "",
                "Let length be the integer value in bits 48:63 of",
                "VSR[VRA+32].",
                "",
                "Let src be the unsigned decimal value in VSR[VRB+32].",
                "",
                "A valid encoding of a packed decimal source operand requires the",
                "contents of each nibble 0-31 must be a value in the range 0x0 to 0x9.",
                "",
                "src is copied into VSR[VRT+32] with the",
                "leftmost 32-length digits each set to 0b0000.",
                "If any of the leftmost 32-length digits of the signed",
                "decimal value in VSR[VRB+32] are non-zero, an overflow",
                "occurs.",
                "",
                "CR field 6 is set to reflect src compared to",
                "zero, including whether or not significant digits were truncated.",
                "",
                "If src is an invalid encoding of a packed",
                "decimal value, the contents of VSR[VRT+32] are undefined",
                "and CR field 6 is set to 0b0001.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move To Vector Status and Control Register",
                    "form": "VX",
                    "mnemonic": "mtvscr",
                    "operands": [
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "10"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "1604",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSCR := VSR[VRB+32].word[3]"
            ],
            "body": [
                "",
                "",
                "The contents of word element 3 of VSR[VRB+32] are placed",
                "into the VSCR.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mtvscr"
            ]
        },
        {
            "category": "Vector Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Move From Vector Status and Control Register",
                    "form": "VX",
                    "mnemonic": "mfvscr",
                    "operands": [
                        "VRT"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "4",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "10"
                },
                {
                    "name": "1540",
                    "size": "11"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "VSR[VRT+32] := EXTZ128(VSCR)"
            ],
            "body": [
                "",
                "",
                "The contents of the VSCR are placed into word element 3 of VSR[VRT+32].",
                "",
                "The remaining word elements in VSR[VRT+32] are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mfvscr"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Scalar Doubleword",
                    "form": "DS",
                    "mnemonic": "lxsd",
                    "operands": [
                        "VRT",
                        "DS(RA)"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                },
                {
                    "name": "Prefixed Load VSX Scalar Doubleword",
                    "form": "8LS:D",
                    "mnemonic": "plxsd",
                    "operands": [
                        "VRT",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "8",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "42",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \"lxsd\"  then",
                "  EA := (RA|0) + EXTS64(DS||0b00)",
                "if \"plxsd\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"plxsd\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "VSR[VRT+32].dword[0] := MEM(EA,8)",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let XT be the value VRT + 32.",
                "",
                "For lxsd, let the effective address (EA) be the sum of the contents of register RA, or the",
                "value 0 if RA=0, and the value DS||0b00, sign-extended to 64 bits.",
                "",
                "For plxsd with R=0, let the effective",
                "address (EA) be the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For plxsd with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "When Big-Endian byte ordering is employed, the contents of the",
                "doubleword in storage at address EA are placed into",
                "load_data in such an order that;",
                "",
                "",
                "",
                "load_data is placed into doubleword element 0 of",
                "VSR[VRT+32].",
                "",
                "The contents of doubleword element 1 of VSR[VRT+32] are set to 0.",
                "",
                "For plxsd, if R is equal to",
                "1 and RA is not equal to 0, the instruction",
                "form is invalid.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Scalar Doubleword Indexed",
                    "form": "X",
                    "mnemonic": "lxsdx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "588",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32*TX+T].dword[0] := MEM(EA,8)",
                "VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let EA be the sum of the contents of GPR[RA],",
                "or 0 if RA is equal to 0, and the contents of GPR[RB].",
                "",
                "When Big-Endian byte ordering is employed, the contents of the",
                "doubleword in storage at address EA are placed into",
                "load_data in such an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of the",
                "doubleword in storage at address EA are placed into",
                "load_data in such an order that;",
                "",
                "",
                "",
                "load_data is placed into doubleword element 0 of",
                "VSR[XT].",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Scalar as Integer Byte  Zero Indexed",
                    "form": "X",
                    "mnemonic": "lxsibzx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "781",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32*TX+T].dword[0] := EXTZ64(MEM(EA,1))",
                "VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let the effective address (EA) be sum of the contents of",
                "GPR[RA], or 0 if RA is equal to 0, and the",
                "contents of GPR[RB].",
                "",
                "The unsigned integer in the byte in storage addressed by EA is placed in doubleword element 0 of VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Scalar as Integer Halfword  Zero Indexed",
                    "form": "X",
                    "mnemonic": "lxsihzx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "813",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32*TX+T].dword[0] := EXTZ64(MEM(EA,2))",
                "VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let the effective address (EA) be sum of the contents of",
                "GPR[RA], or 0 if RA is equal to 0, and the",
                "contents of GPR[RB].",
                "",
                "The unsigned integer in the halfword in storage addressed by",
                "EA is placed in doubleword element 0 of VSR[XT].",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Scalar as Integer Word Algebraic Indexed",
                    "form": "X",
                    "mnemonic": "lxsiwax",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "76",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32*TX+T].dword[0] := EXTS64(MEM(EA,4))",
                "VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let EA be the sum of the contents of GPR[RA],",
                "or 0 if RA is equal to 0, and the contents of GPR[RB].",
                "",
                "When Big-Endian byte ordering is employed, the contents of the word",
                "in storage at address EA are placed into load_data in such an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of the",
                "word in storage at address EA are placed into load_data in such an order that;",
                "",
                "",
                "",
                "load_data is sign-extended to a doubleword and placed in",
                "doubleword element 0 of VSR[XT].",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Scalar as Integer Word  Zero Indexed",
                    "form": "X",
                    "mnemonic": "lxsiwzx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "12",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32*TX+T].dword[0] := ExtendZero(MEM(EA,4))",
                "VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let EA be the sum of the contents of GPR[RA],",
                "or 0 if RA is equal to 0, and the contents of GPR[RB].",
                "",
                "When Big-Endian byte ordering is employed, the contents of the word",
                "in storage at address EA are placed into load_data in such an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of the",
                "word in storage at address EA are placed into load_data in such an order that;",
                "",
                "",
                "",
                "load_data is zero-extended and placed in doubleword",
                "element 0 of VSR[XT].",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Scalar Single-Precision",
                    "form": "DS",
                    "mnemonic": "lxssp",
                    "operands": [
                        "VRT",
                        "DS(RA)"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                },
                {
                    "name": "Prefixed Load VSX Scalar Single-Precision",
                    "form": "8LS:D",
                    "mnemonic": "plxssp",
                    "operands": [
                        "VRT",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "8",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "43",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if \"lxssp\"  then",
                "  EA := (RA|0) + EXTS64(DS||0b00)",
                "if \"plxssp\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"plxssp\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "load_data := MEM(EA,4)",
                "result := bfp_CONVERT_FROM_BFP32(MEM(EA,4))",
                "VSR[VRT+32].dword[0] := bfp64_CONVERT_FROM_BFP(result)",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let XT be the value VRT + 32.",
                "",
                "For lxssp, let the effective address (EA) be the sum of the contents of register RA, or the",
                "value 0 if RA=0, and the value DS||0b00, sign-extended to 64 bits.",
                "",
                "For plxssp with R=0, let the",
                "effective address (EA) be the sum of the contents of",
                "register RA, or the value 0 if RA=0, and the",
                "value d0||d1, sign-extended to 64 bits.",
                "",
                "For plxssp with R=1, let the",
                "effective address (EA) be the sum of the address of the",
                "instruction and the value d0||d1,",
                "sign-extended to 64 bits.",
                "",
                "When Big-Endian byte ordering is employed, the contents of the word",
                "in storage at address EA are placed into load_data in such an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of the",
                "word in storage at address EA are placed into load_data in such an order that;",
                "",
                "",
                "",
                "load_data, interpreted as a single-precision",
                "floating-point value, is placed into doubleword element 0 of",
                "VSR[VRT+32] in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[VRT+32] are",
                "set to 0.",
                "",
                "For plxssp, if R is equal to",
                "1 and RA is not equal to 0, the instruction",
                "form is invalid.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Scalar Single-Precision Indexed",
                    "form": "X",
                    "mnemonic": "lxsspx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "524",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "load_data := MEM(EA,4)",
                "result := bfp_CONVERT_FROM_BFP32(MEM(EA,4))",
                "VSR[VRT+32].dword[0] := bfp64_CONVERT_FROM_BFP(result)",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let EA be the sum of the contents of GPR[RA],",
                "or 0 if RA is equal to 0, and the contents of GPR[RB].",
                "",
                "When Big-Endian byte ordering is employed, the contents of the word",
                "in storage at address EA are placed into load_data in such an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of the",
                "word in storage at address EA are placed into load_data in such an order that;",
                "",
                "",
                "",
                "load_data, interpreted as a single-precision",
                "floating-point value, is placed in doubleword element 0 of VSR[XT] in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Vector",
                    "form": "DQ",
                    "mnemonic": "lxv",
                    "operands": [
                        "XT",
                        "DQ(RA)"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                },
                {
                    "name": "Prefixed Load VSX Vector",
                    "form": "8LS:D",
                    "mnemonic": "plxv",
                    "operands": [
                        "XT",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "8",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "imm18",
                    "size": "18"
                },
                {
                    "name": "25",
                    "size": "5"
                },
                {
                    "name": "TX",
                    "size": "1"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if \"lxv\" & TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if \"lxv\" & TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "if \"plxv\" & MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \"lxv\"  then",
                "  EA := (RA|0) + EXTS64(DQ||0b0000)",
                "if \"plxv\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"plxv\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "VSR[32*TX+T] := MEM(EA,16)"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX +",
                "T.",
                "",
                "For lxv, let the effective address (EA) be the sum of the contents of register RA, or the",
                "value 0 if RA=0, and the value DQ||0b0000, sign-extended to 64 bits.",
                "",
                "For plxv with R=0, let the effective",
                "address (EA) be the sum of the contents of register",
                "RA, or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For plxv with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "When Big-Endian byte ordering is employed, the contents of the",
                "quadword in storage at address EA are placed into",
                "load_data in such an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of the",
                "quadword in storage at address EA are placed into",
                "load_data in such an order that;",
                "",
                "",
                "",
                "load_data is placed into VSR[XT].",
                "",
                "For plxv, if R is equal to 1 and RA is not equal to 0, the instruction form is",
                "invalid.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract_fp32_from_shorth",
                "vec_extract_fp32_from_shortl",
                "vec_xl",
                "vec_xl_be"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Vector Byte*16 Indexed",
                    "form": "X",
                    "mnemonic": "lxvb16x",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "876",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "do i = 0 to 15",
                "  VSR[32*TX+T].byte[i] := MEM(EA+i, 1)",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let the effective address (EA) be the sum of the contents",
                "of GPR[RA], or 0 if RA is equal to 0, and the",
                "contents of GPR[RB].",
                "",
                "For each integer value from 0 to 15, do the following.",
                "",
                "",
                "",
                "The contents of the byte in storage at address EA+i are",
                "placed into byte element i of VSR[XT],",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_xl_be"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Vector Doubleword*2 Indexed",
                    "form": "X",
                    "mnemonic": "lxvd2x",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "844",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32*TX+T].dword[0] := MEM(EA, 8)",
                "VSR[32*TX+T].dword[1] := MEM(EA+8, 8)"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let EA be the sum of the contents of GPR[RA],",
                "or 0 if RA is equal to 0, and the contents of GPR[RB].",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "When Big-Endian byte ordering is employed, the contents of the",
                "doubleword in storage at address EA+8i are",
                "placed into load_data in such an order that;",
                "",
                "",
                "",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of the",
                "doubleword in storage at address EA+8i are",
                "placed into load_data in such an order that;",
                "",
                "",
                "",
                "",
                "",
                "",
                "load_data is placed into doubleword element i of VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_xl_be"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Vector Special Value Quadword",
                    "form": "X",
                    "mnemonic": "lxvkq",
                    "operands": [
                        "XT",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "31",
                    "size": "5"
                },
                {
                    "name": "IMM",
                    "size": "5"
                },
                {
                    "name": "360",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if UIM=0b00001 then VSR[32*TX+T] := 0x3FFF_0000_0000_0000_0000_0000_0000_0000  /* QP +1.0  */",
                "if UIM=0b00010 then VSR[32*TX+T] := 0x4000_0000_0000_0000_0000_0000_0000_0000  /* QP +2.0  */",
                "if UIM=0b00011 then VSR[32*TX+T] := 0x4000_8000_0000_0000_0000_0000_0000_0000  /* QP +3.0  */",
                "if UIM=0b00100 then VSR[32*TX+T] := 0x4001_0000_0000_0000_0000_0000_0000_0000  /* QP +4.0  */",
                "if UIM=0b00101 then VSR[32*TX+T] := 0x4001_4000_0000_0000_0000_0000_0000_0000  /* QP +5.0  */",
                "if UIM=0b00110 then VSR[32*TX+T] := 0x4001_8000_0000_0000_0000_0000_0000_0000  /* QP +6.0  */",
                "if UIM=0b00111 then VSR[32*TX+T] := 0x4001_C000_0000_0000_0000_0000_0000_0000  /* QP +7.0  */",
                "if UIM=0b01000 then VSR[32*TX+T] := 0x7FFF_0000_0000_0000_0000_0000_0000_0000  /* QP +Inf  */",
                "if UIM=0b01001 then VSR[32*TX+T] := 0x7FFF_8000_0000_0000_0000_0000_0000_0000  /* QP dQNaN */",
                "if UIM=0b10000 then VSR[32*TX+T] := 0x8000_0000_0000_0000_0000_0000_0000_0000  /* QP -0.0  */",
                "if UIM=0b10001 then VSR[32*TX+T] := 0xBFFF_0000_0000_0000_0000_0000_0000_0000  /* QP -1.0  */",
                "if UIM=0b10010 then VSR[32*TX+T] := 0xC000_0000_0000_0000_0000_0000_0000_0000  /* QP -2.0  */",
                "if UIM=0b10011 then VSR[32*TX+T] := 0xC000_8000_0000_0000_0000_0000_0000_0000  /* QP -3.0  */",
                "if UIM=0b10100 then VSR[32*TX+T] := 0xC001_0000_0000_0000_0000_0000_0000_0000  /* QP -4.0  */",
                "if UIM=0b10101 then VSR[32*TX+T] := 0xC001_4000_0000_0000_0000_0000_0000_0000  /* QP -5.0  */",
                "if UIM=0b10110 then VSR[32*TX+T] := 0xC001_8000_0000_0000_0000_0000_0000_0000  /* QP -6.0  */",
                "if UIM=0b10111 then VSR[32*TX+T] := 0xC001_C000_0000_0000_0000_0000_0000_0000  /* QP -7.0  */",
                "if UIM=0b11000 then VSR[32*TX+T] := 0xFFFF_0000_0000_0000_0000_0000_0000_0000  /* QP -Inf  */"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "UIM specifies one of a set of common values that is",
                "placed into VSR[XT].",
                "Unspecified values of UIM are reserved.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Vector with Length",
                    "form": "X",
                    "mnemonic": "lxvl",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "269",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA := (RA=0) ? 0 : GPR[RA]",
                "nb := EXTZ(GPR[RB].bit[0:7])",
                "if nb>16 then nb := 16",
                "",
                "load_data := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "",
                "if MSR.LE = 0 then  // Big-Endian byte-ordering",
                "  load_data.byte[0:nb-1]   := MEM(EA,nb)",
                "else                // Little-Endian byte-ordering",
                "  load_data.byte[16-nb:15] := MEM(EA,nb)",
                "",
                "VSR[32*TX+T] := load_data"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let the effective address (EA) be the contents of",
                "GPR[RA], or 0 if RA is equal to 0.",
                "",
                "Let nb be the unsigned integer value in bits 0:7 of",
                "GPR[RB].",
                "",
                "If nb is equal to 0, the storage access is not performed",
                "and the contents of VSR[XT] are set to 0.",
                "",
                "Otherwise, when Big-Endian byte-ordering is employed, do the",
                "following.",
                "",
                "",
                "",
                "If nb less than 16, the contents of the",
                "nb bytes in storage starting at address EA",
                "are placed into the leftmost nb bytes of VSR[XT], and the contents of the rightmost 16-nb bytes",
                "of VSR[XT] are set to 0x00.",
                "",
                "",
                "Otherwise, the contents of the quadword in storage at address",
                "EA are placed into VSR[XT].",
                "",
                "",
                "Otherwise, when Little-Endian byte ordering is employed, do the",
                "following.",
                "",
                "",
                "",
                "If nb less than 16, the contents of the nb",
                "bytes in storage starting at address EA are placed into",
                "the rightmost nb bytes of VSR[XT] in",
                "byte-reversed order, and the contents of the leftmost 16-nb bytes of VSR[XT] are set to 0x00.",
                "",
                "",
                "Otherwise, the contents of the quadword in storage at address",
                "EA are placed into VSR[XT] in byte-reversed",
                "order.",
                "",
                "",
                "If the contents of bits 8:63 of GPR[RB] are not equal to",
                "0, the results are boundedly undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_xl_len"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Vector with Length Left-justified",
                    "form": "X",
                    "mnemonic": "lxvll",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "301",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA := (RA=0) ? 0 : GPR[RA]",
                "nb := EXTZ(GPR[RB].bit[0:7])",
                "if nb>16 then nb := 16",
                "if nb>0 then do i = 0 to nb-1",
                "  VSR[32*TX+T].byte[i] := MEM(EA+i,1)",
                "end",
                "if nb<16 then do i = nb to 15",
                "  VSR[32*TX+T].byte[i] := 0x00",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let the effective address (EA) be the contents of",
                "GPR[RA], or 0 if RA is equal to 0.",
                "",
                "Let nb be the unsigned integer value in bits 0:7 of GPR[RB].",
                "",
                "If nb is equal to 0, the storage access is not performed",
                "and the contents of VSR[XT] are set to 0.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "If nb less than 16, the contents of the",
                "nb bytes in storage starting at address EA",
                "are placed into the lefttmost nb bytes of VSR[XT], and the contents of the rightmost 16-nb bytes",
                "of VSR[XT] are set to 0x00.",
                "",
                "",
                "Otherwise, the contents of the quadword in storage at address",
                "EA are placed into VSR[XT].",
                "",
                "",
                "Data is loaded from storage into VSR[XT] in Big-Endian",
                "byte ordering (i.e., the byte in storage at address EA is",
                "placed into byte element 0 of VSR[XT], the byte in",
                "storage at address EA+1 is placed in byte element 1 of",
                "VSR[XT], and so forth).",
                "",
                "",
                "If the contents of bits 8:63 of GPR[RB] are not equal to",
                "0, the results are boundedly undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_xl_len_r"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Vector Paired",
                    "form": "DQ",
                    "mnemonic": "lxvp",
                    "operands": [
                        "XTp",
                        "DQ(RA)"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Load VSX Vector Paired",
                    "form": "8LS:D",
                    "mnemonic": "plxvp",
                    "operands": [
                        "XTp",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "8",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "58",
                    "size": "6"
                },
                {
                    "name": "Tp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EAbase := (RA=0) ? 0 : GPR[RA]",
                "if \"lxvp\" then",
                "  EAdisp := EXTS64(DQ || 0b0000)",
                "if \"plxvp\" then",
                "  EAdisp := EXTS64(d0 || d1)",
                "if \"lxvp\"        then EA := EAbase + EAdisp",
                "if \"plxvp\" & R=0 then EA := EAbase + EAdisp",
                "if \"plxvp\" & R=1 then EA := CIA    + EAdisp",
                "",
                "load_data := MEM(EA, 32)",
                "",
                "VSR[32*TX+2*Tp]   := load_data.bit[  0:127]",
                "VSR[32*TX+2*Tp+1] := load_data.bit[128:255]"
            ],
            "body": [
                "",
                "",
                "Let XTp be the value 32TX +",
                "2Tp (i.e., only even values of XTp can be",
                "encoded in the instruction).",
                "",
                "Let EAbase be the contents of GPR[RA], or 0",
                "if RA=0.",
                "",
                "For lxvp, let the effective address (EA) be",
                "the sum of the integer value in GPR[RA], or 0 if",
                "RA=0, and the value DQ||0b0000,",
                "sign-extended to 64 bits.",
                "",
                "For plxvp, if R=0, let the effective address",
                "(EA) be the sum of the integer value in GPR[RA], or 0 if RA=0, and the value d0||d1, sign-extended to 64 bits.",
                "",
                "For plxvp, if R=1, let the effective address",
                "(EA) be the sum of the address of the instruction and the",
                "value d0||d1, sign-extended to 64 bits.",
                "",
                "When Big-Endian byte ordering is employed, the contents of the",
                "octword in storage at address EA are placed into",
                "load_data in such an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of the",
                "octword in storage at address EA are placed into",
                "load_data in such an order that;",
                "",
                "",
                "",
                "Bits 0-127 of load_data are placed into VSR[XTp].",
                "",
                "Bits 128-255 of load_data is placed into VSR[XTp+1].",
                "",
                "For plxvp, if R is equal to",
                "1 and RA is not equal to 0, the instruction",
                "form is invalid.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Vector Paired Indexed",
                    "form": "X",
                    "mnemonic": "lxvpx",
                    "operands": [
                        "XTp",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "Tp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "333",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "load_data := MEM(EA,32)",
                "VSR[32*TX+2*Tp]   := load_data.bit[  0:127]",
                "VSR[32*TX+2*Tp+1] := load_data.bit[128:255]"
            ],
            "body": [
                "",
                "",
                "Let XTp be the value 32TX +",
                "2Tp (i.e., only even values of XTp can be",
                "encoded in the instruction).",
                "",
                "Let the effective address (EA) be the sum of the integer",
                "value in GPR[RA], or 0 if RA=0, and the",
                "integer value in GPR[RB].",
                "",
                "When Big-Endian byte ordering is employed, the contents of the",
                "octword in storage at address EA are placed into",
                "load_data in such an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of the",
                "octword in storage at address EA are placed into",
                "load_data in such an order that;",
                "",
                "",
                "",
                "Bits 0-127 of load_data are placed into VSR[XTp].",
                "",
                "Bits 128-255 of load_data is placed into VSR[XTp+1].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Vector Rightmost Byte Indexed",
                    "form": "X",
                    "mnemonic": "lxvrbx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "13",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "VSR[32*TX+T] = EXTZ128(MEM(EA,1))"
            ],
            "body": [
                "",
                "",
                "Let XT be the value of 32TX + T.",
                "",
                "Let EA be the sum of GPR[RA], or 0 if",
                "RA=0, and GPR[RB].",
                "",
                "Load the contents of the byte in storage at address EA",
                "into byte element 15 of VSR[XT].",
                "The contents of byte elements 0-14 of VSR[XT] are set to",
                "0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Vector Rightmost Doubleword Indexed",
                    "form": "X",
                    "mnemonic": "lxvrdx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "109",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "VSR[32*TX+T] = EXTZ128(MEM(EA,8))"
            ],
            "body": [
                "",
                "",
                "Let XT be the value of 32TX + T.",
                "",
                "Let EA be the sum of GPR[RA], or 0 if",
                "RA=0, and GPR[RB].",
                "",
                "Load the contents of the doubleword in storage at address EA into doubleword element 1 of VSR[XT].",
                "The contents of doubleword element 0 of VSR[XT] are set",
                "to 0.",
                "",
                "When Big-Endian byte ordering is employed, the contents of the",
                "doubleword in storage at address EA are placed into",
                "load_data in such an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of the",
                "doubleword in storage at address EA are placed into",
                "load_data in such an order that;",
                "",
                "",
                "",
                "load_data is placed into doubleword element 1 of",
                "VSR[XT].",
                "The contents of doubleword element 0 of VSR[XT] are set",
                "to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Vector Rightmost Halfword Indexed",
                    "form": "X",
                    "mnemonic": "lxvrhx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "45",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "VSR[32*TX+T] = EXTZ128(MEM(EA,2))"
            ],
            "body": [
                "",
                "",
                "Let XT be the value of 32TX + T.",
                "",
                "Let EA be the sum of GPR[RA], or 0 if",
                "RA=0, and GPR[RB].",
                "",
                "When Big-Endian byte ordering is employed, the contents of the",
                "halfword in storage at address EA are placed into",
                "loaddata in such an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of the",
                "halfword in storage at address EA are placed into",
                "loaddata in such an order that;",
                "",
                "",
                "",
                "load_data is placed into halfword element 7 of",
                "VSR[XT].",
                "The contents of halfword elements 0-6 of VSR[XT] are set",
                "to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Vector Rightmost Word Indexed",
                    "form": "X",
                    "mnemonic": "lxvrwx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "77",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "VSR[32*TX+T] = EXTZ128(MEM(EA,4))"
            ],
            "body": [
                "",
                "",
                "Let XT be the value of 32TX + T.",
                "",
                "Let EA be the sum of GPR[RA], or 0 if",
                "RA=0, and GPR[RB].",
                "",
                "When Big-Endian byte ordering is employed, the contents of the word",
                "in storage at address EA are placed into load_data in such an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of the",
                "word in storage at address EA are placed into load_data in such an order that;",
                "",
                "",
                "",
                "load_data is placed into word element 3 of VSR[XT].",
                "The contents of word elements 0-2 of VSR[XT] are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Vector Indexed",
                    "form": "X",
                    "mnemonic": "lxvx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "4",
                    "size": "4"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "12",
                    "size": "5"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32*TX+T] := MEM(EA,16)"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let the effective address (EA) be the sum of the contents",
                "of GPR[RA], or 0 if RA is equal to 0, and the",
                "contents of GPR[RB].",
                "",
                "When Big-Endian byte ordering is employed, the contents of the",
                "quadword in storage at address EA are placed into",
                "load_data in such an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of the",
                "quadword in storage at address EA are placed into",
                "load_data in such an order that;",
                "",
                "",
                "",
                "load_data is placed into VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Vector Doubleword  Splat Indexed",
                    "form": "X",
                    "mnemonic": "lxvdsx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "332",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "load_data := MEM(EA, 8)",
                "",
                "VSR[32*TX+T].dword[0] := load_data",
                "VSR[32*TX+T].dword[1] := load_data"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let EA be the sum of the contents of GPR[RA],",
                "or 0 if RA is equal to 0, and the contents of GPR[RB].",
                "",
                "When Big-Endian byte ordering is employed, the contents of the",
                "doubleword in storage at address EA are placed into",
                "load_data in such an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of the",
                "doubleword in storage at address EA are placed into",
                "load_data in such an order that;",
                "",
                "",
                "",
                "load_data is copied into each doubleword element of",
                "VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Vector Halfword*8 Indexed",
                    "form": "X",
                    "mnemonic": "lxvh8x",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "812",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "do i = 0 to 7",
                "  VSR[32*TX+T].hword[i] := MEM(EA+2*i, 2)",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let the effective address (EA) be the sum of the contents",
                "of GPR[RA], or 0 if RA is equal to 0, and the",
                "contents of GPR[RB].",
                "",
                "For each integer value from 0 to 7, do the following.",
                "",
                "",
                "",
                "When Big-Endian byte ordering is employed, the contents of the",
                "halfword in storage at address EA+2i are placed",
                "into load_data in such an order that;",
                "",
                "",
                "",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of the",
                "quadword in storage at address EA are placed into",
                "VSR[XT] in such an order that;",
                "",
                "",
                "",
                "",
                "",
                "",
                "load_data is placed into halfword element i",
                "of VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_xl_be"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Vector Word*4 Indexed",
                    "form": "X",
                    "mnemonic": "lxvw4x",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "780",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "VSR[32*TX+T].word[0] := MEM(EA, 4)",
                "VSR[32*TX+T].word[1] := MEM(EA+4, 4)",
                "VSR[32*TX+T].word[2] := MEM(EA+8, 4)",
                "VSR[32*TX+T].word[3] := MEM(EA+12, 4)"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let EA be the sum of the contents of GPR[RA],",
                "or 0 if RA is equal to 0, and the contents of GPR[RB].",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "When Big-Endian byte ordering is employed, the contents of the word",
                "in storage at address EA+4i are placed into",
                "load_data in such an order that;",
                "",
                "",
                "",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of the",
                "word in storage at address EA+4i are placed",
                "into word element i of VSR[XT] in such an",
                "order that;",
                "",
                "",
                "",
                "",
                "",
                "",
                "load_data is placed into word element i of",
                "VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mul",
                "vec_xl_be"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Load VSX Vector Word  Splat Indexed",
                    "form": "X",
                    "mnemonic": "lxvwsx",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "364",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "load_data := MEM(EA,4)",
                "",
                "do i = 0 to 3",
                "  VSR[32*TX+T].word[i] := load_data",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let the effective address (EA) be the sum of the contents",
                "of GPR[RA], or 0 if RA is equal to 0, and the",
                "contents of GPR[RB].",
                "",
                "When Big-Endian byte ordering is employed, the contents of the word",
                "in storage at address EA are placed into load_data in such an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of the",
                "quadword in storage at address EA are placed into",
                "load_data in such an order that;",
                "",
                "",
                "",
                "load_data is copied into each word element of VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Scalar Doubleword",
                    "form": "DS",
                    "mnemonic": "stxsd",
                    "operands": [
                        "VRS",
                        "DS(RA)"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                },
                {
                    "name": "Prefixed Store VSX Scalar Doubleword",
                    "form": "8LS:D",
                    "mnemonic": "pstxsd",
                    "operands": [
                        "VRS",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "8",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "46",
                    "size": "6"
                },
                {
                    "name": "VRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if \"stxsd\"  then",
                "  EA := (RA|0) + EXTS64(DS||0b00)",
                "if \"pstxsd\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"pstxsd\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA,8)    := VSR[VRS+32].dword[0]",
                ""
            ],
            "body": [
                "",
                "",
                "Let XS be the value VRS + 32.",
                "",
                "For stxsd, let the effective address (EA) be the sum of the contents of register RA, or the",
                "value 0 if RA=0, and the value DS||0b00, sign-extended to 64 bits.",
                "",
                "For pstxsd with R=0, let the",
                "effective address (EA) be the sum of the contents of",
                "register RA, or the value 0 if RA=0, and the",
                "value d0||d1, sign-extended to 64 bits.",
                "",
                "For pstxsd with R=1, let the",
                "effective address (EA) be the sum of the address of the",
                "instruction and the value d0||d1,",
                "sign-extended to 64 bits.",
                "",
                "Let store_data be the contents of doubleword element 0",
                "of VSR[XS].",
                "",
                "When Big-Endian byte ordering is employed, store_data is",
                "placed in the doubleword in storage at address EA in such",
                "order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, store_data",
                "is placed in the doubleword in storage at address EA in",
                "such order that;",
                "",
                "",
                "",
                "For pstxsd, if R is equal to",
                "1 and RA is not equal to 0, the instruction",
                "form is invalid.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Scalar Doubleword Indexed",
                    "form": "X",
                    "mnemonic": "stxsdx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "716",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "MEM(EA,8)    := VSR[XS].dword[0]",
                ""
            ],
            "body": [
                "",
                "",
                "Let XS be the value 32SX + S.",
                "",
                "Let EA be the sum of the contents of GPR[RA],",
                "or 0 if RA is equal to 0, and the contents of GPR[RB].",
                "",
                "Let store_data be the contents of doubleword element 0",
                "of VSR[XS].",
                "",
                "When Big-Endian byte ordering is employed, store_data is",
                "placed in the doubleword in storage at address EA in such",
                "order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, store_data",
                "is placed in the doubleword in storage at address EA in",
                "such order that;",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Scalar as Integer Byte Indexed",
                    "form": "X",
                    "mnemonic": "stxsibx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "909",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "MEM(EA,1) := VSR[32*SX+S].byte[7]"
            ],
            "body": [
                "",
                "",
                "Let XS be the value 32SX + S.",
                "",
                "Let the effective address (EA) be sum of the contents of",
                "GPR[RA], or 0 if RA is equal to 0, and the",
                "contents of GPR[RB].",
                "",
                "The contents of byte element 7 of VSR[XS] are placed into",
                "the byte in storage addressed by EA.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Scalar as Integer Halfword Indexed",
                    "form": "X",
                    "mnemonic": "stxsihx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "941",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "MEM(EA,2) := VSR[32*SX+S].hword[3]",
                ""
            ],
            "body": [
                "",
                "",
                "Let XS be the value 32SX + S.",
                "",
                "Let the effective address (EA) be sum of the contents of",
                "GPR[RA], or 0 if RA is equal to 0, and the",
                "contents of GPR[RB].",
                "",
                "The contents of halfword element 3 of VSR[XS] are placed",
                "into the halfword in storage addressed by EA.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Scalar as Integer Word Indexed",
                    "form": "X",
                    "mnemonic": "stxsiwx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "140",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ( (RA=0) ? 0 : GPR[RA] ) + GPR[RB]",
                "",
                "MEM(EA,4) := VSR[32*SX+S].word[1]",
                ""
            ],
            "body": [
                "",
                "",
                "Let XS be the value 32SX + S.",
                "",
                "Let EA be the sum of the contents of GPR[RA],",
                "or 0 if RA is equal to 0, and the contents of GPR[RB].",
                "",
                "Let store_data be the contents of word element 1 of",
                "VSR[XS].",
                "",
                "When Big-Endian byte ordering is employed, store_data is",
                "placed in the word in storage at address EA in such order",
                "that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, store_data",
                "is placed in the word in storage at address EA in such",
                "order that;",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Scalar Single-Precision",
                    "form": "DS",
                    "mnemonic": "stxssp",
                    "operands": [
                        "VRS",
                        "DS(RA)"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                },
                {
                    "name": "Prefixed Store VSX Scalar Single-Precision",
                    "form": "8LS:D",
                    "mnemonic": "pstxssp",
                    "operands": [
                        "VRS",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "8",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "47",
                    "size": "6"
                },
                {
                    "name": "VRS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VEC=0 then Vector_Unavailable()",
                "",
                "if \"stxsso\"  then",
                "  EA := (RA|0) + EXTS64(DS||0b00)",
                "if \"pstxssp\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"pstxssp\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA,4) := bfp32_CONVERT_FROM_BFP64(VSR[VRS+32].dword[0])",
                ""
            ],
            "body": [
                "",
                "",
                "Let XS be the value VRS + 32.",
                "",
                "For stxssp, let the effective address (EA) be the sum of the contents of register RA, or the",
                "value 0 if RA=0, and the value DS||0b00, sign-extended to 64 bits.",
                "",
                "For pstxssp with R=0, let the",
                "effective address (EA) be the sum of the contents of",
                "register RA, or the value 0 if RA=0, and the",
                "value d0||d1, sign-extended to 64 bits.",
                "",
                "For pstxssp with R=1, let the",
                "effective address (EA) be the sum of the address of the",
                "instruction and the value d0||d1,",
                "sign-extended to 64 bits.",
                "",
                "Let store_data be the double-precision floating-point",
                "value in doubleword element 0 of VSR[XS] converted to",
                "single-precision format",
                "",
                "When Big-Endian byte ordering is employed, store_data is",
                "placed in the word in storage at address EA in such order",
                "that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, store_data",
                "is placed in the word in storage at address EA in such",
                "order that;",
                "",
                "",
                "",
                "For pstxssp, if R is equal to",
                "1 and RA is not equal to 0, the instruction",
                "form is invalid.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Scalar Single-Precision Indexed",
                    "form": "X",
                    "mnemonic": "stxsspx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "652",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "MEM(EA,4) := bfp32_CONVERT_FROM_BFP64(VSR[32*SX+S].dword[0])",
                ""
            ],
            "body": [
                "",
                "",
                "Let XS be the value 32SX + S.",
                "",
                "Let EA be the sum of the contents of GPR[RA],",
                "or 0 if RA is equal to 0, and the contents of GPR[RB].",
                "",
                "Let store_data be the double-precision floating-point",
                "value in doubleword element 0 of VSR[XS] converted to",
                "single-precision format",
                "",
                "When Big-Endian byte ordering is employed, store_data is",
                "placed in the word in storage at address EA in such order",
                "that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, store_data",
                "is placed in the word in storage at address EA in such",
                "order that;",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Vector",
                    "form": "DQ",
                    "mnemonic": "stxv",
                    "operands": [
                        "XS",
                        "DQ(RA)"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                },
                {
                    "name": "Prefixed Store VSX Vector",
                    "form": "8LS:D",
                    "mnemonic": "pstxv",
                    "operands": [
                        "XS",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "8",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "imm18",
                    "size": "18"
                },
                {
                    "name": "27",
                    "size": "5"
                },
                {
                    "name": "SX",
                    "size": "1"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if stxv\" & SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if stxv\" & SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "if \"pstxv\" & MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \"stxv\"  then",
                "  EA := (RA|0) + EXTS64(DQ||0b0000)",
                "if \"pstxv\" & R=0 then",
                "  EA := (RA|0) + EXTS64(d0||d1)",
                "if \"pstxv\" & R=1 then",
                "  EA := CIA + EXTS64(d0||d1)",
                "",
                "MEM(EA,16) := VSR[32*SX+S]",
                ""
            ],
            "body": [
                "",
                "",
                "Let XS be the value 32SX +",
                "S.",
                "",
                "For stxv, let the effective address (EA) be the sum of the contents of GPR[RA], or the value",
                "0 if RA=0, and the value DQ||0b0000, sign-extended to 64 bits.",
                "",
                "For pstxv with R=0, let the effective",
                "address (EA) be the sum of the contents of GPR[RA], or the value 0 if RA=0, and the value",
                "d0||d1, sign-extended to 64 bits.",
                "",
                "For pstxv with R=1, let the effective",
                "address (EA) be the sum of the address of the instruction",
                "and the value d0||d1, sign-extended to 64",
                "bits.",
                "",
                "Let store_data be the contents of VSR[XS].",
                "",
                "When Big-Endian byte ordering is employed, store_data is",
                "placed into the quadword in storage at address EA in such",
                "an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, store_data",
                "is placed into the quadword in storage at address EA in",
                "such an order that;",
                "",
                "",
                "",
                "For pstxv, if R is equal to",
                "1 and RA is not equal to 0, the instruction",
                "form is invalid.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_xst",
                "vec_xst_be"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Vector Byte*16 Indexed",
                    "form": "X",
                    "mnemonic": "stxvb16x",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "1004",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "do i = 0 to 15",
                "  MEM(EA+i,1) := VSR[32*SX+S].byte[i]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XS be the value 32SX + S.",
                "",
                "Let the effective address (EA) be the sum of the contents",
                "of GPR[RA], or 0 if RA is equal to 0, and the",
                "contents of GPR[RB].",
                "",
                "For each integer value from 0 to 15, do the following.",
                "",
                "",
                "",
                "The contents of byte element i of VSR[XS] are",
                "placed into the byte in storage at address EA+i.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_xst_be"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Vector Doubleword*2 Indexed",
                    "form": "X",
                    "mnemonic": "stxvd2x",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "972",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "MEM(EA,8)     := VSR[32*SX+S].dword[0]",
                "MEM(EA+8,8)   := VSR[32*SX+S].dword[1]"
            ],
            "body": [
                "",
                "",
                "Let XS be the value 32SX + S.",
                "",
                "Let EA be the sum of the contents of GPR[RA],",
                "or 0 if RA is equal to 0, and the contents of GPR[RB].",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let store_data be the contents of doubleword element",
                "i of VSR[XS].",
                "",
                "",
                "When Big-Endian byte ordering is employed, store_data is",
                "placed in the doubleword in storage at address EA+8i in such order that;",
                "",
                "",
                "",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, store_data",
                "is placed in the doubleword in storage at address EA+8i in such order that;",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_xst_be"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Vector Halfword*8 Indexed",
                    "form": "X",
                    "mnemonic": "stxvh8x",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "940",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "do i = 0 to 7",
                "  MEM(EA+2*i,2) := VSR[32*SX+S].hword[i]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XS be the value 32SX + S.",
                "",
                "Let the effective address (EA) be the sum of the contents",
                "of GPR[RA], or 0 if RA is equal to 0, and the",
                "contents of GPR[RB].",
                "",
                "For each integer value from 0 to 7, do the following.",
                "",
                "",
                "",
                "The contents of byte element i of VSR[XS] are",
                "placed into the byte in storage at address EA+i.",
                "",
                "",
                "For each integer value from 0 to 7, do the following.",
                "",
                "",
                "",
                "When Big-Endian byte ordering is employed, the contents of halfword",
                "element i of VSR[XS] are placed into the",
                "halfword in storage at address EA+2i in such an",
                "order that;",
                "",
                "",
                "",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, the contents of",
                "halfword element i of VSR[XS] are placed into",
                "the halfword in storage at address EA+2i in",
                "such an order that;",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_xst_be"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Vector with Length",
                    "form": "X",
                    "mnemonic": "stxvl",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "397",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA := (RA=0) ? 0 : GPR[RA]",
                "",
                "nb := EXTZ(GPR[RB].bit[0:7])",
                "if nb>16 then nb := 16",
                "",
                "if MSR.LE = 0 then       // Big-Endian byte-ordering",
                "  store_data := VSR[32*SX+S].byte[0:nb-1]",
                "else                     // Little-Endian byte ordering",
                "  store_data := VSR[32*SX+S].byte[16-nb:15]",
                "",
                "MEM(EA,nb) := store_data"
            ],
            "body": [
                "",
                "",
                "Let XS be the value 32SX + S.",
                "",
                "Let the effective address (EA) be the contents of",
                "GPR[RA], or 0 if RA is equal to 0.",
                "",
                "Let nb be the unsigned integer value in bits 0:7 of",
                "GPR[RB].",
                "",
                "If nb is equal to 0, the storage access is not performed.",
                "",
                "Otherwise, when Big-Endian byte-ordering is employed, do the",
                "following.",
                "",
                "",
                "",
                "If nb less than 16, the contents of the",
                "leftmost nb bytes of VSR[XS] are placed in",
                "storage starting at address EA.",
                "",
                "",
                "Otherwise, the contents of VSR[XS] are placed into the",
                "quadword in storage at address EA.",
                "",
                "",
                "Otherwise, when Little-Endian byte ordering is employed, do the",
                "following.",
                "",
                "",
                "",
                "If nb less than 16, the contents of the",
                "rightmost nb bytes of VSR[XS] are placed in",
                "storage starting at address EA in byte-reversed order.",
                "",
                "",
                "Otherwise, the contents of VSR[XS] are placed into the",
                "quadword in storage at address EA in byte-reversed order.",
                "",
                "",
                "If the contents of bits 8:63 of GPR[RB] are not equal to",
                "0, the results are boundedly undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_xst_len"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Vector with Length Left-justified",
                    "form": "X",
                    "mnemonic": "stxvll",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "429",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA := (RA=0) ? 0 : GPR[RA]",
                "",
                "nb := EXTZ(GPR[RB].bit[0:7])",
                "if nb>16 then nb := 16",
                "",
                "if nb>0 then do i = 0 to nb-1",
                "  MEM(EA+i,1) := VSR[32*SX+S].byte[i]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XS be the value 32SX + S.",
                "",
                "Let the effective address (EA) be the contents of",
                "GPR[RA], or 0 if RA is equal to 0.",
                "",
                "Let nb be the unsigned integer value in bits 0:7 of GPR[RB].",
                "",
                "If nb is equal to 0, the storage access is not performed.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "If nb less than 16, the contents of the",
                "leftmost nb bytes of VSR[XS] are placed in",
                "storage starting at address EA.",
                "",
                "",
                "Otherwise, the contents of VSR[XS] are placed into the",
                "quadword in storage at address EA.",
                "",
                "",
                "Data is stored from VSR[XS] into storage in Big-Endian",
                "byte ordering (i.e., the contents of byte element 0 of VSR[XS] are placed into the byte in storage at address EA, the contents of byte element 1 of VSR[XS] are placed",
                "into the byte in storage at address EA+1, and so forth).",
                "",
                "",
                "If the contents of bits 8:63 of GPR[RB] are not equal to",
                "0, the results are boundedly undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_xst_len_r"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Vector Rightmost Byte Indexed",
                    "form": "X",
                    "mnemonic": "stxvrbx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "141",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB];",
                "MEM(EA,1) = VSR[32*SX+S].byte[15];"
            ],
            "body": [
                "",
                "",
                "Let XS be the value of 32SX + S.",
                "",
                "Let EA be the sum of GPR[RA], or 0 if",
                "RA=0, and GPR[RB].",
                "",
                "The contents of byte element 15 of VSR[XS] are placed",
                "into storage at address EA.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Vector Rightmost Doubleword Indexed",
                    "form": "X",
                    "mnemonic": "stxvrdx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "237",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "MEM(EA,8) = VSR[32*SX+S].dword[1]"
            ],
            "body": [
                "",
                "",
                "Let XS be the value of 32SX + S.",
                "",
                "Let EA be the sum of GPR[RA], or 0 if",
                "RA=0, and GPR[RB].",
                "",
                "Let store_data be the contents of doubleword element 1",
                "of VSR[XS].",
                "",
                "When Big-Endian byte ordering is employed, store_data is",
                "placed into the doubleword in storage at address EA in such an order",
                "that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, store_data",
                "is placed into the doubleword in storage at address EA in",
                "such an order that;",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Vector Rightmost Halfword Indexed",
                    "form": "X",
                    "mnemonic": "stxvrhx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "173",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "MEM(EA,2) = VSR[32*SX+S].hword[7]"
            ],
            "body": [
                "",
                "",
                "Let XS be the value of 32SX + S.",
                "",
                "Let EA be the sum of GPR[RA], or 0 if",
                "RA=0, and GPR[RB].",
                "",
                "Let store_data be the contents of halfword element 7 of",
                "VSR[XS].",
                "",
                "When Big-Endian byte ordering is employed, store_data is",
                "placed into the halfword in storage at address EA in such an order",
                "that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, store_data",
                "is placed into the halfword in storage at address EA in",
                "such an order that;",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Vector Rightmost Word Indexed",
                    "form": "X",
                    "mnemonic": "stxvrwx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "205",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA = ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "MEM(EA,4) = VSR[32*SX+S].word[3]"
            ],
            "body": [
                "",
                "",
                "Let XS be the value of 32SX + S.",
                "",
                "Let EA be the sum of GPR[RA], or 0 if",
                "RA=0, and GPR[RB].",
                "",
                "Let store_data be the contents of word element 3 of",
                "VSR[XS].",
                "",
                "When Big-Endian byte ordering is employed, store_data is",
                "placed into the word in storage at address EA in such an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, store_data",
                "is placed into the word in storage at address EA in such",
                "an order that;",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Vector Word*4 Indexed",
                    "form": "X",
                    "mnemonic": "stxvw4x",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "908",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "MEM(EA,4)     := VSR[32*SX+S].word[0]",
                "MEM(EA+4,4)   := VSR[32*SX+S].word[1]",
                "MEM(EA+8,4)   := VSR[32*SX+S].word[2]",
                "MEM(EA+12,4)  := VSR[32*SX+S].word[3]"
            ],
            "body": [
                "",
                "",
                "Let XS be the value 32SX + S.",
                "",
                "Let EA be the sum of the contents of GPR[RA],",
                "or 0 if RA is equal to 0, and the contents of GPR[RB].",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let store_data be the contents of word element",
                "i of VSR[XS].",
                "",
                "",
                "When Big-Endian byte ordering is employed, store_data is",
                "placed in the word in storage at address EA+4i",
                "in such order that;",
                "",
                "",
                "",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, store_data",
                "is placed in the word in storage at address EA+4i in such order that;",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_xst_be"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Vector Paired",
                    "form": "DQ",
                    "mnemonic": "stxvp",
                    "operands": [
                        "XSp",
                        "DQ(RA)"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Store VSX Vector Paired",
                    "form": "8LS:D",
                    "mnemonic": "pstxvp",
                    "operands": [
                        "XSp",
                        "D(RA)",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "8",
                    "size": "9"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "d0",
                    "size": "18"
                },
                {
                    "name": "62",
                    "size": "6"
                },
                {
                    "name": "Sp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "d1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EAbase := (RA=0) ? 0 : GPR[RA]",
                "if \"stxvp\" then",
                "  EAdisp := EXTS64(DQ || 0b0000)",
                "if \"pstxvp\" then",
                "  EAdisp := EXTS64(d0 || d1)",
                "",
                "if \"stxvp\"        then EA := EAbase + EAdisp",
                "if \"pstxvp\" & R=0 then EA := EAbase + EAdisp",
                "if \"pstxvp\" & R=1 then EA := CIA    + EAdisp",
                "",
                "store_data.bit[  0:127] := VSR[32*SX+2*Sp]",
                "store_data.bit[128:255] := VSR[32*SX+2*Sp+1]",
                "",
                "MEM(EA,32) := store_data"
            ],
            "body": [
                "",
                "",
                "Let XSp be the value 32SX+2Sp (i.e., only even values of XSp can be encoded in the instruction).",
                "",
                "For stxvp, let the effective address (EA) be",
                "the sum of the integer value in GPR[RA], or 0 if",
                "RA=0 and the value DQ||0b0000,",
                "sign-extended to 64 bits.",
                "",
                "For pstxvp, if R=0, let the effective address",
                "(EA) be the sum of the integer value in GPR[RA], or 0 if RA=0, and the value d0||d1, sign-extended to 64 bits.",
                "",
                "For pstxvp, if R=1, let the effective address",
                "(EA) be the sum of the address of the instruction and the",
                "value d0||d1, sign-extended to 64 bits.",
                "",
                "Let store_data be the contents of VSR[XSp]",
                "concatenated with VSR[XSp+1].",
                "",
                "When Big-Endian byte ordering is employed, store_data is",
                "placed into the octword in storage at address EA in such",
                "an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, store_data",
                "is placed into the octword in storage at address EA in",
                "such an order that;",
                "",
                "",
                "",
                "For pstxvp, if R is equal to",
                "1 and RA is not equal to 0, the instruction",
                "form is invalid.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Vector Paired Indexed",
                    "form": "X",
                    "mnemonic": "stxvpx",
                    "operands": [
                        "XSp",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "Sp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "461",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "store_data.bit[  0:127] := VSR[32*SX+2*Sp]",
                "store_data.bit[128:255] := VSR[32*SX+2*Sp+1]",
                "",
                "MEM(EA,32) := store_data"
            ],
            "body": [
                "",
                "",
                "Let XSp be the value 32SX +",
                "2Sp (i.e., only even values of XSp can be",
                "encoded in the instruction).",
                "",
                "Let the effective address (EA) be the sum of the integer",
                "value in GPR[RA], or 0 if RA=0, and the",
                "integer value in GPR[RB].",
                "",
                "Let store_data be the contents of VSR[XSp]",
                "concatenated with VSR[XSp+1].",
                "",
                "When Big-Endian byte ordering is employed, store_data is",
                "placed into the octword in storage at address EA in such",
                "an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, store_data",
                "is placed into the octword in storage at address EA in",
                "such an order that;",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "Store VSX Vector Indexed",
                    "form": "X",
                    "mnemonic": "stxvx",
                    "operands": [
                        "XS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "S",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "396",
                    "size": "10"
                },
                {
                    "name": "SX",
                    "size": "1"
                }
            ],
            "code": [
                "if SX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if SX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "EA := ((RA=0) ? 0 : GPR[RA]) + GPR[RB]",
                "",
                "MEM(EA,16) := VSR[32*SX+S]"
            ],
            "body": [
                "",
                "",
                "Let XS be the value 32SX + S.",
                "",
                "Let the effective address (EA) be the sum of the contents",
                "of GPR[RA], or 0 if RA is equal to 0, and the",
                "contents of GPR[RB].",
                "",
                "When Big-Endian byte ordering is employed, store_data is",
                "placed into the quadword in storage at address EA in such",
                "an order that;",
                "",
                "",
                "",
                "When Little-Endian byte ordering is employed, store_data",
                "is placed into the quadword in storage at address EA in",
                "such an order that;",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Absolute Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xsabsdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "345",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src := VSR[32*BX+B].dword[0]",
                "VSR[32*TX+T].dword[0] := bfp64_NEGATIVE_ABSOLUTE(src)",
                "VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "The absolute value of the double-precision floating-point operand in",
                "doubleword element 0 of VSR[XB] is placed into doubleword",
                "element 0 of VSR[XT] in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Absolute Quad-Precision",
                    "form": "X",
                    "mnemonic": "xsabsqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "804",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[VRT+32] := bfp128_NEGATIVE_ABSOLUTE(VSR[VRB+32])"
            ],
            "body": [
                "",
                "",
                "Let XT be the value VRT + 32.",
                "",
                "Let XB be the value VRB + 32.",
                "",
                "The absolute value of the quad-precision floating-point value in",
                "VSR[XB] is placed into VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Add Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xsadddp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "32",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP64(VSR[VRA+32].dword[0])",
                "src2   := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "v      := bfp_ADD(src1, src2)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN, v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "src2 is added to src1, producing a",
                "sum having unbounded range and precision.",
                "",
                "The sum is normalized.",
                "",
                "See Table, Actions for xsadddp, on",
                "pagetable:PPC1ChVSX-Add.",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Add Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xsaddsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1     := bfp_CONVERT_FROM_BFP64(VSR[VRA+32].dword[0])",
                "src2     := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "v        := bfp_ADD(src1, src2)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN, v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result64",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "src2 is added to src1, producing a",
                "sum having unbounded range and precision.",
                "",
                "The sum is normalized.",
                "",
                "See Table,",
                "Actions for xsaddsp, on",
                "pagetable:PPC1ChVSX-Table-51-Actions-for-xsaddsp.",
                "",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result as",
                "represented in single-precision format.",
                "FR is set to indicate if the result was incremented when rounded.",
                "FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Add Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xsaddqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "VSX Scalar Add Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xsaddqpo",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "4",
                    "size": "10"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_ADD(src1, src2)",
                "rnd    := bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1  then SetFX(FPSCR.VXISI)",
                "if ox_flag=1     then SetFX(FPSCR.OX)",
                "if ux_flag=1     then SetFX(FPSCR.UX)",
                "if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[VRT+32] := result",
                "  FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
                "",
                "Let src2 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
                "",
                "If either src1 or src2 is a Signalling NaN,",
                "an Invalid Operation exception occurs and VXSNAN is set",
                "to 1.",
                "",
                "If src1 and src2 are Infinity values having",
                "opposite signs, an Invalid Operation exception occurs and VXISI is set to 1.",
                "",
                "If src1 is a Signalling NaN, the result is the Quiet NaN",
                "corresponding to src1.",
                "",
                "Otherwise, if src1 is a Quiet NaN, the result is",
                "src1.",
                "",
                "Otherwise, if src2 is a Signalling NaN, the result is the",
                "Quiet NaN corresponding to src2.",
                "",
                "Otherwise, if src2 is a Quiet NaN, the result is",
                "src2.",
                "",
                "Otherwise, if src1 and src2 are Infinity",
                "values having opposite signs, the result is the default Quiet",
                "NaN.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "The normalized sum of src2 added to src1 is",
                "produced with unbounded significand precision and exponent range.",
                "",
                "",
                "See",
                "Table,",
                "Actions for xsaddqp[o], on",
                "pagetable:PPC1ChVSX-Table-5-Actions-for-add-bfp128-src1,src2.",
                "",
                "",
                "If the intermediate result is Tiny (i.e., the unbiased",
                "exponent is less than -16382) and UE=0, the",
                "significand is shifted right N bits, where N",
                "is the difference between -16382 and the unbiased",
                "exponent of the intermediate result.",
                "The exponent of the intermediate result is set to the value",
                "-16382.",
                "",
                "",
                "If RO=1, let the rounding mode be Round to Odd.",
                "Otherwise, let the rounding mode be specified by RN.",
                "The intermediate result is rounded to quad-precision using the",
                "specified rounding mode.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into VSR[VRT+32] in quad-precision",
                "format.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the rounded result was",
                "incremented. FI is set to indicate the result is inexact.",
                "",
                "If a trap-disabled Invalid Operation exception occurs, FR",
                "and FI are set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Compare Exponents Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xscmpexpdp",
                    "operands": [
                        "BF",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "59",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := VSR[32*AX+A].dword[0]",
                "src2 := VSR[32*BX+B].dword[0]",
                "",
                "src1.exponent := EXTZ(src1.bit[1:11])",
                "src2.exponent := EXTZ(src2.bit[1:11])",
                "src1.fraction := EXTZ(src1.bit[12:63])",
                "src2.fraction := EXTZ(src2.bit[12:63])",
                "",
                "src1.class.NaN := (src1.exponent = 2047) & (src1.fraction != 0)",
                "src2.class.NaN := (src2.exponent = 2047) & (src2.fraction != 0)",
                "",
                "lt_flag := (src1.exponent < src2.exponent)",
                "gt_flag := (src1.exponent > src2.exponent)",
                "eq_flag := (src1.exponent = src2.exponent)",
                "uo_flag := src1.class.NaN | src2.class.NaN",
                "",
                "CR.bit[4*BF+32] := FPSCR.FL := !uo_flag & lt_flag",
                "CR.bit[4*BF+33] := FPSCR.FG := !uo_flag & gt_flag",
                "CR.bit[4*BF+34] := FPSCR.FE := !uo_flag & eq_flag",
                "CR.bit[4*BF+35] := FPSCR.FU :=  uo_flag"
            ],
            "body": [
                "",
                "",
                "Let XA be the sum 32AX + A.",
                "",
                "Let XB be the sum 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "The exponent of src1 is compared with the exponent of",
                "src2.",
                "The result of the compare is placed into FPCC and",
                "CR field BF.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Compare Exponents Quad-Precision",
                    "form": "X",
                    "mnemonic": "xscmpexpqp",
                    "operands": [
                        "BF",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "164",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "src1           := VSR[VRA+32]",
                "src2           := VSR[VRB+32]",
                "",
                "src1.exponent  := EXTZ(src1.bit[1:15])",
                "src2.exponent  := EXTZ(src2.bit[1:15])",
                "src1.fraction  := EXTZ(src1.bit[16:127])",
                "src2.fraction  := EXTZ(src2.bit[16:127])",
                "",
                "src1.class.NaN := (src1.exponent = 32767) &",
                "                  (src1.fraction != 0)",
                "src2.class.NaN := (src2.exponent = 32767) &",
                "                  (src2.fraction != 0)",
                "",
                "lt_flag := (src1.exponent < src2.exponent)",
                "gt_flag := (src1.exponent > src2.exponent)",
                "eq_flag := (src1.exponent = src2.exponent)",
                "uo_flag := src1.class.NaN | src2.class.NaN",
                "",
                "CR.bit[4*BF+32] := FPSCR.FL := !uo_flag & lt_flag",
                "CR.bit[4*BF+33] := FPSCR.FG := !uo_flag & gt_flag",
                "CR.bit[4*BF+34] := FPSCR.FE := !uo_flag & eq_flag",
                "CR.bit[4*BF+35] := FPSCR.FU :=  uo_flag"
            ],
            "body": [
                "",
                "",
                "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
                "",
                "Let src2 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
                "",
                "The exponent of src1 is compared with the exponent of",
                "src2 as unsigned integer values.",
                "The result of the compare is placed into FPCC and",
                "CR field BF.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Compare Equal Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xscmpeqdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "3",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "",
                "vxsnan_flag := src1.class.SNaN | src2.class.SNaN",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vxsnan_flag=1 SetFX(FPSCR.VXSNAN)",
                "",
                "if vex_flag=0 then do",
                "  if src1=src2 then",
                "     VSR[32*TX+T].dword[0] := 0xFFFF_FFFF_FFFF_FFFF",
                "     VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  end",
                "  else do",
                "     VSR[32*TX+T].dword[0] := 0x0000_0000_0000_0000",
                "     VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  end",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword 0 of VSR[XB].",
                "",
                "If src1 or src2 is a SNaN, an Invalid",
                "Operation exception occurs.",
                "",
                "src1 is compared to src2.",
                "",
                "A NaN compared to any value, including itself, compares false for the",
                "predicate, equal.",
                "",
                "The contents of doubleword 0 of VSR[XT] are set to",
                "0xFFFF_FFFF_FFFF_FFFF if src1 is equal to",
                "src2, and are set to 0x0000_0000_0000_0000",
                "otherwise.",
                "",
                "The contents of doubleword 1 of VSR[XT] are set to",
                "0x0000_0000_0000_0000.",
                "",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is",
                "not modified.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Compare Equal Quad-Precision",
                    "form": "X",
                    "mnemonic": "xscmpeqqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "68",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2 := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "vxsnan_flag := src1.class.SNaN | src2.class.SNaN",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vxsnan_flag=1 SetFX(FPSCR.VXSNAN)",
                "",
                "if vex_flag=0 then do",
                "  if bfp_COMPARE_EQ(src1, src2)=1 then",
                "     VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "  else",
                "     VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "",
                "Let src1 be the quad-precision floating-point value in",
                "VSR[VRA+32].",
                "",
                "Let src2 be the quad-precision floating-point value in",
                "VSR[VRB+32].",
                "",
                "If src1 or src2 is a SNaN, an Invalid",
                "Operation exception occurs.",
                "",
                "src1 is compared to src2.",
                "",
                "A NaN compared to any value, including itself, compares false for the",
                "predicate, equal.",
                "",
                "The contents of VSR[VRT+32] are set to all 1s if",
                "src1 is equal to src2, and are set to all 0s",
                "otherwise.",
                "",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32]",
                "is not modified.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Compare Greater Than or Equal Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xscmpgedp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "19",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "",
                "if src1.class.SNaN=1 | src2.class.SNaN=1 then do",
                "  vxsnan_flag := 0b1",
                "  if FPSCR.VE=0 then vxvc_flag := 0b1",
                "end",
                "else",
                "  vxvc_flag := src1.class.QNaN | src2.class.QNaN)",
                "",
                "vex_flag := FPSCR.VE & (vxsnan_flag | vxvc_flag)",
                "",
                "if vxsnan_flag=1 SetFX(FPSCR.VXSNAN)",
                "if vxvc_flag=1 SetFX(FPSCR.VXVC)",
                "",
                "if vex_flag=0 then do",
                "  if src1 >= src2 then",
                "     VSR[32*TX+T].dword[0] := 0xFFFF_FFFF_FFFF_FFFF",
                "     VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  end",
                "  else do",
                "     VSR[32*TX+T].dword[0] := 0x0000_0000_0000_0000",
                "     VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  end",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword 0 of VSR[XB].",
                "",
                "src1 is compared to src2.",
                "",
                "A NaN compared to any value, including itself, compares false for the",
                "predicate, greater than or equal.",
                "",
                "The contents of doubleword 0 of VSR[XT] are set to",
                "0xFFFF_FFFF_FFFF_FFFF if src1 is greater",
                "than or equal to src2, and are set to 0x0000_0000_0000_0000 otherwise.",
                "",
                "The contents of doubleword 1 of VSR[XT] are set to",
                "0x0000_0000_0000_0000.",
                "",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is",
                "not modified.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Compare Greater Than or Equal Quad-Precision",
                    "form": "X",
                    "mnemonic": "xscmpgeqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "196",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2 := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src1.class.SNaN=1 | src2.class.SNaN=1 then do",
                "  vxsnan_flag := 0b1",
                "  if FPSCR.VE=0 then vxvc_flag := 0b1",
                "end",
                "else",
                "  vxvc_flag := src1.class.QNaN | src2.class.QNaN",
                "",
                "vex_flag := FPSCR.VE & (vxsnan_flag | vxvc_flag)",
                "",
                "if vxsnan_flag=1 SetFX(FPSCR.VXSNAN)",
                "if (vxvc_flag=1)   SetFX(FPSCR.VXVC)",
                "",
                "if vex_flag=0 then do",
                "  if bfp_COMPARE_GE(src1, src2)=1 then",
                "     VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "  else",
                "     VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "",
                "Let src1 be the quad-precision floating-point value in",
                "VSR[VRA+32].",
                "",
                "Let src2 be the quad-precision floating-point value in",
                "VSR[VRB+32].",
                "",
                "src1 is compared to src2.",
                "",
                "A NaN compared to any value, including itself, compares false for the",
                "predicate, greater than or equal.",
                "",
                "The contents of VSR[VRT+32] are set to all 1s if",
                "src1 is greater than or equal to src2, and",
                "are set to all 0s otherwise.",
                "",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32]",
                "is not modified.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Compare Greater Than Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xscmpgtdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "11",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "",
                "if src1.class.SNaN=1 | src2.class.SNaN=1 then do",
                "  vxsnan_flag := 0b1",
                "  if FPSCR.VE=0 then vxvc_flag := 0b1",
                "end",
                "else",
                "  vxvc_flag := src1.class.QNaN | src2.class.QNaN",
                "",
                "vex_flag := FPSCR.VE & (vxsnan_flag | vxvc_flag)",
                "",
                "if vxsnan_flag=1 SetFX(FPSCR.VXSNAN)",
                "if vxvc_flag=1   SetFX(FPSCR.VXVC)",
                "",
                "if vex_flag=0 then do",
                "  if src1 > src2 then",
                "     VSR[32*TX+T].dword[0] := 0xFFFF_FFFF_FFFF_FFFF",
                "     VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  end",
                "  else do",
                "     VSR[32*TX+T].dword[0] := 0x0000_0000_0000_0000",
                "     VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  end",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword 0 of VSR[XB].",
                "",
                "src1 is compared to src2.",
                "",
                "A NaN compared to any value, including itself, compares false for the",
                "predicate, greater than.",
                "",
                "The contents of doubleword 0 of VSR[VRT] are set to",
                "0xFFFF_FFFF_FFFF_FFFF if src1 is greater",
                "than src2, and are set to 0x0000_0000_0000_0000 otherwise.",
                "",
                "The contents of doubleword 1 of VSR[VRT] are set to",
                "0x0000_0000_0000_0000.",
                "",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32]",
                "is not modified.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Compare Greater Than Quad-Precision",
                    "form": "X",
                    "mnemonic": "xscmpgtqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "228",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2 := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src1.class.SNaN=1 | src2.class.SNaN=1 then do",
                "  vxsnan_flag := 0b1",
                "  if FPSCR.VE=0 then vxvc_flag := 0b1",
                "end",
                "else",
                "  vxvc_flag := src1.class.QNaN | src2.class.QNaN",
                "",
                "vex_flag := FPSCR.VE & (vxsnan_flag | vxvc_flag)",
                "",
                "if vxsnan_flag=1 SetFX(FPSCR.VXSNAN)",
                "if (vxvc_flag=1)   SetFX(FPSCR.VXVC)",
                "",
                "if vex_flag=0 then do",
                "  if bfp_COMPARE_GT(src1, src2)=1 then",
                "     VSR[VRT+32] := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "  else",
                "     VSR[VRT+32] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "",
                "Let src1 be the quad-precision floating-point value in",
                "VSR[VRA+32].",
                "",
                "Let src2 be the quad-precision floating-point value in",
                "VSR[VRB+32].",
                "",
                "src1 is compared to src2.",
                "",
                "A NaN compared to any value, including itself, compares false for the",
                "predicate, greater than.",
                "",
                "The contents of VSR[VRT+32] are set to all 1s if",
                "src1 is greater than src2, and are set to all",
                "0s otherwise.",
                "",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32]",
                "is not modified.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Compare Ordered Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xscmpodp",
                    "operands": [
                        "BF",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "43",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "",
                "if src1.class.SNaN=1 | src2.class.SNaN=1 then do",
                "  vxsnan_flag := 0b1",
                "  if FPSCR.VE=0 then vxvc_flag := 0b1",
                "end",
                "else",
                "  vxvc_flag := src1.class.QNaN | src2.class.QNaN",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "CR.bit[4*BF+32] := FPSCR.FL := src1 < src2",
                "CR.bit[4*BF+33] := FPSCR.FG := src1 > src2",
                "CR.bit[4*BF+34] := FPSCR.FE := src1 = src2",
                "CR.bit[4*BF+35] := FPSCR.FU := src1.class.SNaN |",
                "                              src1.class.QNaN |",
                "                              src2.class.SNaN |",
                "                              src2.class.QNaN"
            ],
            "body": [
                "",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "src1 is compared to src2.",
                "",
                "Zeros of same or opposite signs compare equal.",
                "",
                "Infinities of same signs compare equal.",
                "",
                "See Table, Actions for xscmpodp -",
                "Part 1: Compare Ordered, on pagetable:PPC1ChVSX-Compare.",
                "",
                "The result of the compare is placed into CR field BF and",
                "the FPCC.",
                "",
                "If either of the operands is a NaN, either quiet or signaling, CR",
                "field BF and the FPCC are set to reflect",
                "unordered.",
                "If either of the operands is a Signaling NaN, VXSNAN is",
                "set, and Invalid Operation is disabled (VE=0), VXVC is set.",
                "If neither operand is a Signaling NaN but at least one operand is a",
                "Quiet NaN, VXVC is set.",
                "",
                "See Table, Actions for xscmpodp - Part",
                "2: Result, on pagetable:PPC1ChVSX-Result.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Compare Ordered Quad-Precision",
                    "form": "X",
                    "mnemonic": "xscmpoqp",
                    "operands": [
                        "BF",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "132",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2 := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src1.class.SNaN=1 | src2.class.SNaN=1 then do",
                "  vxsnan_flag := 0b1",
                "  if FPSCR.VE=0 then vxvc_flag := 0b1",
                "end",
                "else",
                "  vxvc_flag := src1.class.QNaN | src2.class.QNaN",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "CR.bit[4*BF+32] := FPSCR.FL := src1 < src2",
                "CR.bit[4*BF+33] := FPSCR.FG := src1 > src2",
                "CR.bit[4*BF+34] := FPSCR.FE := src1 = src2",
                "CR.bit[4*BF+35] := FPSCR.FU := src1.class.SNaN |",
                "                              src1.class.QNaN |",
                "                              src2.class.SNaN |",
                "                              src2.class.QNaN"
            ],
            "body": [
                "",
                "",
                "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
                "",
                "Let src2 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
                "",
                "src1 is compared to src2.",
                "",
                "Zeros of same or opposite signs compare equal.",
                "Infinities of same signs compare equal.",
                "",
                "Bit 0 of CR field BF and FL are",
                "set to indicate if src1 is less than src2.",
                "",
                "Bit 1 of CR field BF and FG are",
                "set to indicate if src1 is greater than src2.",
                "",
                "Bit 2 of CR field BF and FE are",
                "set to indicate if src1 is equal to src2.",
                "",
                "Bit 3 of CR field BF and FU are",
                "set to indicate unordered (i.e., src1 or src2",
                "is a NaN).",
                "",
                "If either of the operands is a NaN, either quiet or signaling, CR",
                "field BF and the FPCC are set to reflect",
                "unordered.",
                "If either of the operands is a Signaling NaN, an Invalid Operation",
                "exception occurs and VXSNAN is set, and if Invalid",
                "Operation exceptions are disabled (VE=0), VXVC is set.",
                "If neither operand is a Signaling NaN but at least one operand is a",
                "Quiet NaN, an Invalid Operation exception occurs and VXVC",
                "is set.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Compare Unordered Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xscmpudp",
                    "operands": [
                        "BF",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "35",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "",
                "vxsnan_flag := src1.class.SNaN | src2.class.SNaN",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "CR.bit[4*BF+32] := FPSCR.FL := src1 < src2",
                "CR.bit[4*BF+33] := FPSCR.FG := src1 > src2",
                "CR.bit[4*BF+34] := FPSCR.FE := src1 = src2",
                "CR.bit[4*BF+35] := FPSCR.FU := src1.class.SNaN |",
                "                              src1.class.QNaN |",
                "                              src2.class.SNaN |",
                "                              src2.class.QNaN"
            ],
            "body": [
                "",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "src1 is compared to src2.",
                "",
                "Zeros of same or opposite signs compare equal equal.",
                "",
                "Infinities of same signs compare equal.",
                "",
                "See Table, Actions for",
                "xscmpudp - Part 1: Compare Unordered, on",
                "pagetable:PPC1ChVSX-Compare-Unordered.",
                "",
                "The result of the compare is placed into CR field BF and",
                "the FPCC.",
                "",
                "If either of the operands is a NaN, either quiet or signaling, CR",
                "field BF and the FPCC are set to reflect",
                "unordered.",
                "If either of the operands is a Signaling NaN, VXSNAN is",
                "set.",
                "",
                "See Table, Actions for xscmpudp -",
                "Part 2: Result, on pagetable:PPC1ChVSX-Result-l1.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Compare Unordered Quad-Precision",
                    "form": "X",
                    "mnemonic": "xscmpuqp",
                    "operands": [
                        "BF",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "644",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2 := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "vxsnan_flag := src1.class.SNaN | src2.class.SNaN",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "CR.bit[4*BF+32] := FPSCR.FL := src1 < src2",
                "CR.bit[4*BF+33] := FPSCR.FG := src1 > src2",
                "CR.bit[4*BF+34] := FPSCR.FE := src1 = src2",
                "CR.bit[4*BF+35] := FPSCR.FU := src1.class.SNaN |",
                "                              src1.class.QNaN |",
                "                              src2.class.SNaN |",
                "                              src2.class.QNaN"
            ],
            "body": [
                "",
                "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
                "",
                "Let src2 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
                "",
                "src1 is compared to src2.",
                "",
                "Zeros of same or opposite signs compare equal.",
                "Infinities of same signs compare equal.",
                "",
                "Bit 0 of CR field BF and FL are",
                "set to indicate if src1 is less than src2.",
                "",
                "Bit 1 of CR field BF and FG are",
                "set to indicate if src1 is greater than src2.",
                "",
                "Bit 2 of CR field BF and FE are",
                "set to indicate if src1 is equal to src2.",
                "",
                "Bit 3 of CR field BF and FU are",
                "set to indicate unordered (i.e., src1 or src2",
                "is a NaN).",
                "",
                "If either of the operands is a Signaling NaN, an Invalid Operation",
                "exception occurs and VXSNAN is set to 1.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Copy Sign Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xscpsgndp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "176",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := VSR[32*AX+A].dword[0] & 0x8000_0000_0000_0000",
                "src2 := VSR[32*BX+B].dword[0] & 0x7FFF_FFFF_FFFF_FFFF",
                "VSR[32*TX+T].dword[0] := src1 | src2",
                "VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Bit 0 of VSR[XT] is set to the contents of bit 0 of",
                "VSR[XA].",
                "",
                "Bits 1:63 of VSR[XT] are set to the contents of bits 1:63",
                "of VSR[XB].",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Copy Sign Quad-Precision",
                    "form": "X",
                    "mnemonic": "xscpsgnqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "100",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := VSR[VRA+32] & 0x8000_0000_0000_0000_0000_0000_0000_0000",
                "src2 := VSR[VRB+32] & 0x7FFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "",
                "VSR[VRT+32] := src1 | src2"
            ],
            "body": [
                "",
                "",
                "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
                "",
                "Let src2 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
                "",
                "src2 is placed into VSR[VRT+32] with the sign",
                "of src1.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round Double-Precision to Half-Precision format",
                    "form": "XX2",
                    "mnemonic": "xscvdphp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "17",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "347",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[BX*32+B].dword[0])",
                "rnd    := bfp_ROUND_TO_BFP16(FPSCR.RN,src)",
                "result := bfp16_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[TX*32+T].hword[0:2] := 0x0000_0000_0000",
                "  VSR[TX*32+T].hword[3]   := result",
                "  VSR[TX*32+T].dword[1]   := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF              := fprf_CLASS_BFP16(result)",
                "end",
                "FPSCR.FR := (vex_flag=0) & inc_flag",
                "FPSCR.FI := (vex_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "If src is an SNaN, the result is the half-precision",
                "representation of that SNaN converted to a QNaN.",
                "",
                "Otherwise, if src is a QNaN, the result is the",
                "half-precision representation of that QNaN.",
                "",
                "Otherwise, if src is an Infinity, the result is the",
                "half-precision representation of Infinity with the same sign as",
                "src.",
                "",
                "Otherwise, if src is a Zero, the result is the",
                "half-precision representation of Zero with the same sign as",
                "src.",
                "",
                "Otherwise, the result is the half-precision representation of",
                "src rounded to half-precision using the rounding mode",
                "specified by RN.",
                "",
                "The result is zero-extended and placed into doubleword element",
                "0 of VSR[XT].",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set to 0.",
                "",
                "FPRF is set to the class and sign of the result as",
                "represented in half-precision.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert Double-Precision to Quad-Precision format",
                    "form": "X",
                    "mnemonic": "xscvdpqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "22",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "836",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "",
                "if src.class.SNaN then",
                "  result := bfp128_CONVERT_FROM_BFP(bfp_QUIET(src))",
                "else",
                "  result := bfp128_CONVERT_FROM_BFP(src)",
                "",
                "vxsnan_flag := src.class.SNaN",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[VRT+32] := result",
                "  FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := 0",
                "FPSCR.FI := 0"
            ],
            "body": [
                "",
                "",
                "Let src be the floating-point value in doubleword element",
                "0 of VSR[VRB+32] represented in double-precision format.",
                "",
                "src is placed into VSR[VRT+32] in",
                "quad-precision format.",
                "",
                "If src is a Signalling NaN, an Invalid Operation",
                "exception occurs and VXSNAN is set to 1.",
                "",
                "FPRF is set to the class and sign of the result.",
                "",
                "FR is set to 0. FI is set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[XT] and FPRF are not modified.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round Double-Precision to Single-Precision format",
                    "form": "XX2",
                    "mnemonic": "xscvdpsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "265",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_BFP32(FPSCR.RN,src)",
                "result := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].word[0] := result",
                "  VSR[32*TX+T].word[1] := result",
                "  VSR[32*TX+T].word[2] := 0x0000_0000",
                "  VSR[32*TX+T].word[3] := 0x0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP32(result)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "If src is a SNaN, the result is src converted",
                "to a QNaN (i.e., bit 12 of src is set to",
                "1). VXSNAN is set to 1.",
                "",
                "Otherwise, if src is a QNaN, an Infinity, or a Zero, the",
                "result is src.",
                "",
                "Otherwise, the result is src rounded to single-precision",
                "using the rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is placed into word elements 0 and 1 of",
                "VSR[XT] in single-precision format.",
                "",
                "The contents of word elements 2 and 3 of",
                "VSR[XT] are set to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert Scalar Single-Precision to Vector Single-Precision format Non-signalling",
                    "form": "XX2",
                    "mnemonic": "xscvdpspn",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "267",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "result := bfp32_CONVERT_FROM_BFP(src)",
                "",
                "VSR[32*TX+T].word[0] := result",
                "VSR[32*TX+T].word[1] := result",
                "VSR[32*TX+T].word[2] := 0x0000_0000",
                "VSR[32*TX+T].word[3] := 0x0000_0000"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the single-precision floating-point value in",
                "doubleword element 0 of VSR[XB] represented",
                "in double-precision format.",
                "",
                "src is placed into word elements 0 and 1 of",
                "VSR[XT] in single-precision format.",
                "",
                "The contents of word elements 2 and 3 of",
                "VSR[XT] are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_insert"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round to zero Double-Precision to Signed Doubleword format",
                    "form": "XX2",
                    "mnemonic": "xscvdpsxds",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "344",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "result := si64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxcvi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[1] := result",
                "  VSR[32*TX+T].dword[2] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := 0bUUUUU",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "If src is a NaN, the result is the value 0x8000_0000_0000_0000 and VXCVI is set to 1.",
                "If src is an SNaN, VXSNAN is also set to",
                "1.",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode Round Toward Zero.",
                "",
                "If the rounded value is greater than 2-1, the result is",
                "0x7FFF_FFFF_FFFF_FFFF and VXCVI is set to",
                "1.",
                "",
                "Otherwise, if the rounded value is less than -2, the result is 0x8000_0000_0000_0000 and VXCVI is set to 1.",
                "",
                "Otherwise, the result is the rounded value converted to 64-bit",
                "signed-integer format, and if the result is inexact (i.e., not equal",
                "to src), XX is set to 1.",
                "",
                "If a trap-enabled invalid operation exception occurs,",
                "",
                "",
                "",
                "Otherwise,",
                "",
                "",
                "",
                "See Table .",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round to zero Double-Precision to Signed Word format",
                    "form": "XX2",
                    "mnemonic": "xscvdpsxws",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "88",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "result := si32_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxcvi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].word[0] := result",
                "  VSR[32*TX+T].word[1] := result",
                "  VSR[32*TX+T].word[2] := 0x0000_0000",
                "  VSR[32*TX+T].word[3] := 0x0000_0000",
                "  FPSCR.FPRF := 0bUUUUU",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "If src is a NaN, the result is the value 0x8000_0000 and VXCVI is set to 1.",
                "If src is an SNaN, VXSNAN is also set to 1.",
                "",
                "Otherwise, src is rounded to a floating-point",
                "integer using the rounding mode Round Toward Zero.",
                "",
                "If the rounded value is greater than 2-1, the result is",
                "0x7FFF_FFFF and VXCVI is set to 1.",
                "",
                "Otherwise, if the rounded value is less than -2, the result is 0x8000_0000 and VXCVI is set to 1.",
                "",
                "Otherwise, the result is the rounded value converted to 32-bit",
                "signed-integer format, and if the result is inexact (i.e., not equal",
                "to src), XX is set to 1.",
                "",
                "If a trap-enabled invalid operation exception occurs,",
                "",
                "",
                "",
                "Otherwise,",
                "",
                "",
                "",
                "See Table .",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round to zero Double-Precision to Unsigned Doubleword format",
                    "form": "XX2",
                    "mnemonic": "xscvdpuxds",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "328",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "result := ui64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxcvi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[1] := result",
                "  VSR[32*TX+T].dword[2] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := 0bUUUUU",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "If src is a NaN, the result is the value 0x0000_0000_0000_0000 and VXCVI is set to 1.",
                "If src is an SNaN, VXSNAN is also",
                "set to 1.",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode Round Toward Zero.",
                "",
                "If the rounded value is greater than 2-1, the result is",
                "0xFFFF_FFFF_FFFF_FFFF and VXCVI is set to",
                "1.",
                "",
                "Otherwise, if the rounded value is less than 0, the result is",
                "0x0000_0000_0000_0000 and VXCVI is set to",
                "1.",
                "",
                "Otherwise, the result is the rounded value converted to 64-bit",
                "unsigned-integer format, and if the result is inexact (i.e., not",
                "equal to src), XX is set to 1.",
                "",
                "If a trap-enabled invalid operation exception occurs,",
                "",
                "",
                "",
                "Otherwise,",
                "",
                "",
                "",
                "See Table .",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round to zero Double-Precision to Unsigned Word format",
                    "form": "XX2",
                    "mnemonic": "xscvdpuxws",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "72",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "result := ui32_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxcvi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].word[0] := result",
                "  VSR[32*TX+T].word[1] := result",
                "  VSR[32*TX+T].word[2] := 0x0000_0000",
                "  VSR[32*TX+T].word[3] := 0x0000_0000",
                "  FPSCR.FPRF := 0bUUUUU",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "If src is a NaN, the result is the value 0x0000_0000 and VXCVI is set to 1.",
                "If src is an SNaN, VXSNAN is also set to 1.",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode Round Toward Zero.",
                "",
                "If the rounded value is greater than 2-1, the result is",
                "0xFFFF_FFFF and VXCVI is set to 1.",
                "",
                "Otherwise, if the rounded value is less than 0, the result is",
                "0x0000_0000 and VXCVI is set to 1.",
                "",
                "Otherwise, the result is the rounded value converted to 32-bit",
                "unsigned-integer format, and if the result is inexact (i.e., not",
                "equal to src), XX is set to 1.",
                "",
                "If a trap-enabled invalid operation exception occurs,",
                "",
                "",
                "",
                "Otherwise,",
                "",
                "",
                "",
                "See Table .",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert Half-Precision to Double-Precision format",
                    "form": "XX2",
                    "mnemonic": "xscvhpdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "16",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "347",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "src := bfp_CONVERT_FROM_BFP16(VSR[BX*32+B].hword[3])",
                "",
                "if src.class.SNaN=1 then",
                "  result := bfp64_CONVERT_FROM_BFP(bfp_QUIET(src))",
                "else",
                "  result := bfp64_CONVERT_FROM_BFP(src)",
                "",
                "vxsnan_flag := src.class.SNaN",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[TX*32+T].dword[0] := result",
                "  VSR[TX*32+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR := 0",
                "FPSCR.FI := 0"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the half-precision floating-point value in the",
                "rightmost halfword of doubleword element 0 of VSR[XB].",
                "",
                "If src is an SNaN, the result is the double-precision",
                "representation of that SNaN converted to a QNaN.",
                "",
                "Otherwise, if src is a QNaN, the result is the",
                "double-precision representation of that QNaN.",
                "",
                "Otherwise, if src is an Infinity, the result is the",
                "double-precision representation of Infinity with the same sign as",
                "src.",
                "",
                "Otherwise, if src is a Zero, the result is the",
                "double-precision representation of Zero with the same sign as",
                "src.",
                "",
                "Otherwise, if src is a denormal value, the result is the",
                "normalized double-precision representation of src.",
                "",
                "Otherwise, the result is the double-precision representation of",
                "src.",
                "",
                "The result is placed into doubleword element 0 of",
                "VSR[XT].",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set to 0.",
                "",
                "FPRF is set to the class and sign of the result as",
                "represented in double-precision format.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified.",
                "",
                "FR is set to 0. FI is set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round Quad-Precision to Double-Precision format [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xscvqpdp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "VSX Scalar Convert with round Quad-Precision to Double-Precision format [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xscvqpdpo",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "20",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "836",
                    "size": "10"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "rnd    := bfp_ROUND_TO_BFP64(RO,FPSCR.RN,src)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[VRT+32].dword[0] := result",
                "  VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR := (vxsnan_flag=0) & inc_flag",
                "FPSCR.FI := (vxsnan_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src be the quad-precision floating-point value in",
                "VSR[VRB+32].",
                "",
                "If src is a Signalling NaN, an Invalid Operation",
                "exception occurs and VXSNAN is set to 1.",
                "",
                "If src is a Signalling NaN, the result is the Quiet NaN",
                "corresponding to the Signalling NaN, with the significand truncated",
                "to the rounding precision.",
                "",
                "Otherwise, if src is a Quiet NaN, then the result is",
                "src with the significand truncated to double-precision.",
                "",
                "Otherwise, if src is an Infinity or a Zero, the result is",
                "src.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "If src is Tiny (i.e., the unbiased exponent is",
                "less than -1022) and UE=0, the significand is",
                "shifted right N bits, where N is the",
                "difference between -1022 and the unbiased exponent of",
                "src.",
                "The exponent of src is set to the value -1022.",
                "",
                "",
                "If RO=1, let the rounding mode be Round to Odd.",
                "Otherwise, let the rounding mode be specified by RN.",
                "Unless the result is an Infinity or a Zero, the intermediate result",
                "is rounded to double-precision (i.e., 11-bit exponent range and",
                "53-bit significand precision) using the specified rounding mode.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into doubleword element 0 of VSR[VRT+32] in double-precision format.",
                "The contents of doubleword element 1 of VSR[VRT+32] are",
                "set to 0.",
                "",
                "FPRF is set to the class and sign of the result as",
                "represented in double-precision format.",
                "FR is set to indicate if the rounded result was",
                "incremented. FI is set to indicate the result is inexact.",
                "",
                "If a trap-disabled Invalid Operation exception occurs, FR",
                "and FI are set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round to zero Quad-Precision to Signed Doubleword format",
                    "form": "X",
                    "mnemonic": "xscvqpsdz",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "25",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "836",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN | src.class.SNaN then do",
                "  result := 0x8000_0000_0000_0000",
                "  vxsnan_flag := src.class.SNaN",
                "  vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity then do",
                "  vxcvi_flag := 1",
                "  if src.sign = 0 then",
                "     result := 0x7FFF_FFFF_FFFF_FFFF",
                "  else",
                "     result := 0x8000_0000_0000_0000",
                "end",
                "else if src.class.Zero then",
                "  result := 0x0000_0000_0000_0000",
                "else do",
                "  rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "  if bfp_COMPARE_GT(rnd, +2<sup>63</sup>-1) then do",
                "     result := 0x7FFF_FFFF_FFFF_FFFF",
                "     vxcvi_flag := 1",
                "  end",
                "  else if bfp_COMPARE_LT(rnd, -2<sup>63</sup>) then do",
                "     result := 0x8000_0000_0000_0000",
                "     vxcvi_flag := 1",
                "  end",
                "  else do",
                "     result := si64_CONVERT_FROM_BFP(rnd)",
                "     if xx_flag=1 then SetFX(FPSCR.XX)",
                "  end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE & vx_flag",
                "",
                "if ex_flag=0 then do",
                "  VSR[VRT+32].dword[0] := result",
                "  VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src be the quad-precision floating-point value in",
                "VSR[VRB+32].",
                "",
                "If src is a Signalling NaN, an Invalid Operation",
                "exception occurs and VXSNAN and VXCVI are set",
                "to 1.",
                "",
                "If src is a Quiet NaN or an Infinity, an Invalid",
                "Operation exception occurs and VXCVI is set to 1.",
                "",
                "If src is a NaN, the result is 0x8000_0000_0000_0000.",
                "",
                "Otherwise, if src is a Zero, the result is 0x0000_0000_0000_0000.",
                "",
                "Otherwise, if src is +Infinity, the result is",
                "0x7FFF_FFFF_FFFF_FFFF.",
                "",
                "Otherwise, if src is -Infinity, the result is",
                "0x8000_0000_0000_0000.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "Let rnd be the value src truncated to a",
                "floating-point integer.",
                "",
                "",
                "If rnd is greater than +2-1, an Invalid",
                "Operation exception occurs, VXCVI is set to 1, and the",
                "result is 0x7FFF_FFFF_FFFF_FFFF.",
                "",
                "",
                "Otherwise, if rnd is less than -2, an Invalid Operation",
                "exception occurs, VXCVI is set to 1, and the result is",
                "0x8000_0000_0000_0000.",
                "",
                "",
                "Otherwise, the result is the value rnd, and an Inexact",
                "exception occurs if rnd is inexact (i.e., rnd",
                "is not equal to src).",
                "",
                "",
                "The result is placed into doubleword element 0 of VSR[VRT+32] in signed integer format.",
                "",
                "The contents of doubleword element 1 of VSR[VRT+32] are",
                "set to 0.",
                "",
                "FPRF is set to undefined. FR is set to 0.",
                "FI is set to indicate if the rounded result is inexact.",
                "",
                "If an Invalid Operation exception occurs, FR and",
                "FI are set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified.",
                "",
                "See Table, Actions for",
                "xscvdpsxds, on",
                "pagetable:PPC1ChVSX-Actions-for-xscvdpsxds.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round to zero Quad-Precision to Signed Quadword",
                    "form": "X",
                    "mnemonic": "xscvqpsqz",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "8",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "836",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN=1 | src.class.SNaN=1 then do",
                "  result := 0x8000_0000_0000_0000_0000_0000_0000_0000",
                "  vxsnan_flag := src.class.SNaN",
                "  vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity=1 then do",
                "  vxcvi_flag := 1",
                "  if src.sign = 0 then",
                "     result := 0x7FFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "  else",
                "     result := 0x8000_0000_0000_0000_0000_0000_0000_0000",
                "end",
                "else if src.class.Zero=1 then",
                "  result := 0x0000_0000_0000_0000_0000_0000_0000",
                "else do",
                "  rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "  if bfp_COMPARE_GT(rnd, +2<sup>127</sup>-1) then do",
                "     result := 0x7FFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "     vxcvi_flag := 1",
                "  end",
                "  else if bfp_COMPARE_LT(rnd, -2<sup>127</sup>) then do",
                "     result := 0x8000_0000_0000_0000_0000_0000_0000_0000",
                "     vxcvi_flag := 1",
                "  end",
                "  else do",
                "     result := si128_CONVERT_FROM_BFP(rnd)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "  end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE & vx_flag",
                "",
                "if ex_flag=0 then do",
                "  VSR[VRT+32] := result",
                "  FPSCR.FPRF := 0bUUUUU",
                "end",
                "",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src be the quad-precision floating-point value in",
                "VSR[VRB+32].",
                "",
                "If src is a Signalling NaN, an Invalid Operation",
                "exception occurs and VXSNAN and VXCVI are set",
                "to 1.",
                "",
                "If src is a Quiet NaN or an Infinity, an Invalid",
                "Operation exception occurs and VXCVI is set to 1.",
                "",
                "If src is a NaN, the result is -2.",
                "",
                "Otherwise, if src is a Zero, the result is 0.",
                "",
                "Otherwise, if src is +Infinity, the result is",
                "2-1.",
                "",
                "Otherwise, if src is -Infinity, the result is",
                "-2.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "Let rnd be the value src truncated to a",
                "floating-point integer.",
                "",
                "",
                "If rnd is greater than +2-1, an Invalid",
                "Operation exception occurs, VXCVI is set to 1, and the",
                "result is 2.",
                "",
                "",
                "Otherwise, if rnd is less than -2, an Invalid Operation",
                "exception occurs, VXCVI is set to 1, and the result is",
                "-2.",
                "",
                "",
                "Otherwise, the result is the value rnd, and an Inexact",
                "exception occurs if rnd is inexact (i.e., rnd",
                "is not equal to src).",
                "",
                "",
                "The result is placed into doubleword element 0 of VSR[VRT+32] in signed integer format.",
                "",
                "The contents of doubleword element 1 of VSR[VRT+32] are",
                "set to 0.",
                "",
                "FPRF is set to undefined. FR is set to 0.",
                "FI is set to indicate if the rounded result is inexact.",
                "",
                "If an Invalid Operation exception occurs, FR and",
                "FI are set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified.",
                "",
                "See Table,",
                "Actions for xscvqpsqz, on",
                "pagetable:PPC1ChVSX-Table-2-Actions-for-xscvqpsdz.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round to zero Quad-Precision to Signed Word format",
                    "form": "X",
                    "mnemonic": "xscvqpswz",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "9",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "836",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN=1 | src.class.SNaN=1 then do",
                "  result := 0xFFFF_FFFF_8000_0000",
                "  vxsnan_flag := src.class.SNaN",
                "  vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity=1 then do",
                "  vxcvi_flag := 1",
                "  if src.sign=0 then",
                "     result := 0x0000_0000_7FFF_FFFF",
                "  else",
                "     result := 0xFFFF_FFFF_8000_0000",
                "end",
                "else if src.class.Zero=1 then",
                "  result := 0x0000_0000_0000_0000",
                "else do",
                "  rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "  if bfp_COMPARE_GT(rnd, +2<sup>31</sup>-1) then do",
                "     result := 0x0000_0000_7FFF_FFFF",
                "     vxcvi_flag := 1",
                "  end",
                "  else if bfp_COMPARE_LT(rnd, -2<sup>31</sup>) then do",
                "     result := 0xFFFF_FFFF_8000_0000",
                "     vxcvi_flag := 1",
                "  end",
                "  else do",
                "     result := si64_CONVERT_FROM_BFP(rnd)",
                "     if xx_flag=1 then SetFX(FPSCR.XX)",
                "  end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE & vx_flag",
                "",
                "if ex_flag=0 then do",
                "  VSR[VRT+32].dword[0] := result",
                "  VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := 0bUUUUU",
                "end",
                "FPSCR.FR := 0",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src be the quad-precision floating-point value in",
                "VSR[VRB+32].",
                "",
                "If src is a Signalling NaN, an Invalid Operation",
                "exception occurs and VXSNAN and VXCVI are set",
                "to 1.",
                "",
                "If src is a Quiet NaN or an Infinity, an Invalid",
                "Operation exception occurs and VXCVI is set to 1.",
                "",
                "If src is a NaN, the result is 0xFFFF_FFFF_8000_0000.",
                "",
                "Otherwise, if src is a Zero, the result is 0x0000_0000_0000_0000.",
                "",
                "Otherwise, if src is a +Infinity, the result",
                "is 0x0000_0000_7FFF_FFFF.",
                "",
                "Otherwise, if src is a -Infinity, the result",
                "is 0xFFFF_FFFF_8000_0000.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "Let rnd be the value src truncated to a",
                "floating-point integer.",
                "",
                "",
                "If rnd is greater than +2-1, an Invalid",
                "Operation exception occurs, VXCVI is set to 1, and the",
                "result is 0x0000_0000_7FFF_FFFF.",
                "",
                "",
                "Otherwise, if rnd is less than -2, an Invalid Operation",
                "exception occurs, VXCVI is set to 1, and the result is",
                "0xFFFF_FFFF_8000_0000.",
                "",
                "",
                "Otherwise, the result is the value rnd, and an Inexact",
                "exception occurs if rnd is inexact (i.e., rnd",
                "is not equal to src).",
                "",
                "",
                "The result is placed into doubleword element 0 of VSR[VRT+32] in signed integer format.",
                "",
                "The contents of doubleword element 1 of VSR[VRT+32] are",
                "set to 0.",
                "",
                "FPRF is set to undefined. FR is set to 0.",
                "FI is set to indicate if the rounded result is inexact.",
                "",
                "If an Invalid Operation exception occurs, FR and",
                "FI are set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified.",
                "",
                "See Table,",
                "Actions for xscvqpswz, on",
                "pagetable:PPC1ChVSX-Table-14-@@@Actions-for-xscvqpsdz.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round to zero Quad-Precision to Unsigned Doubleword format",
                    "form": "X",
                    "mnemonic": "xscvqpudz",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "17",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "836",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN=1 | src.class.SNaN=1 then do",
                "  result := 0x0000_0000_0000_0000",
                "  vxsnan_flag := src.class.SNaN",
                "  vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity=1 then do",
                "  vxcvi_flag := 1",
                "  if src.sign=0 then",
                "     result := 0xFFFF_FFFF_FFFF_FFFF",
                "  else",
                "     result := 0x0000_0000_0000_0000",
                "end",
                "else if src.class.Zero then result := 0x0000_0000_0000_0000",
                "else do",
                "  rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "  if bfp_COMPARE_GT(rnd, +2<sup>64</sup>-1) then do",
                "     result := 0xFFFF_FFFF_FFFF_FFFF",
                "     vxcvi_flag := 1",
                "  end",
                "  else if bfp_COMPARE_LT(rnd, 0) then do",
                "     result := 0x0000_0000_0000_0000",
                "     vxcvi_flag := 1",
                "  end",
                "  else do",
                "     result := ui64_CONVERT_FROM_BFP(rnd)",
                "     if xx_flag=1 then SetFX(FPSCR.XX)",
                "  end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE & vx_flag",
                "",
                "if ex_flag=0 then do",
                "  VSR[VRT+32].dword[0] := result",
                "  VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := 0bUUUUU",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src be the quad-precision floating-point value in",
                "VSR[VRB+32].",
                "",
                "If src is a Signalling NaN, an Invalid Operation",
                "exception occurs and VXSNAN and VXCVI are set",
                "to 1.",
                "",
                "If src is a Quiet NaN or an Infinity, an Invalid",
                "Operation exception occurs and VXCVI is set to 1.",
                "",
                "If src is a NaN, the result is 0x0000_0000_0000_0000.",
                "",
                "Otherwise, if src is a Zero, the result is 0x0000_0000_0000_0000.",
                "",
                "Otherwise, if src is a positive Infinity, the result is",
                "0xFFFF_FFFF_FFFF_FFFF.",
                "",
                "Otherwise, if src is a negative Infinity, the result is",
                "0x0000_0000_0000_0000.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "Let rnd be the value src truncated to a",
                "floating-point integer.",
                "",
                "",
                "If rnd is greater than +2-1, an Invalid",
                "Operation exception occurs, VXCVI is set to 1, and the",
                "result is 0xFFFF_FFFF_FFFF_FFFF.",
                "",
                "",
                "Otherwise, if rnd is less than 0, an Invalid",
                "Operation exception occurs, VXCVI is set to 1, and the",
                "result is 0x0000_0000_0000_0000.",
                "",
                "",
                "Otherwise, the result is the value rnd, and an Inexact",
                "exception occurs if rnd is inexact (i.e., rnd",
                "is not equal to src).",
                "",
                "",
                "The result is placed into doubleword element 0 of VSR[VRT+32] in unsigned integer format.",
                "",
                "The contents of doubleword element 1 of VSR[VRT+32] are",
                "set to 0.",
                "",
                "FPRF is set to undefined. FR is set to 0.",
                "FI is set to indicate if the rounded result is inexact.",
                "",
                "If an Invalid Operation exception occurs, FR and",
                "FI are set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified.",
                "",
                "See Table,",
                "Actions for xscvqpudz, on",
                "pagetable:PPC1ChVSX-Table-20-Actions-for-xscvqpud.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round to zero Quad-Precision to Unsigned Quadword",
                    "form": "X",
                    "mnemonic": "xscvqpuqz",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "836",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSypX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN=1 | src.class.SNaN=1 then do",
                "  result := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "  vxsnan_flag := src.class.SNaN",
                "  vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity=1 then do",
                "  vxcvi_flag := 1",
                "  if src.sign=0 then",
                "     result := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "  else",
                "     result := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "end",
                "else if src.class.Zero=1 then",
                "  result := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "else do",
                "  rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "  if bfp_COMPARE_GT(rnd, +2<sup>128</sup>-1) then do",
                "     result := 0xFFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF",
                "     vxcvi_flag := 1",
                "  end",
                "  else if bfp_COMPARE_LT(rnd, 0) then do",
                "     result := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "     vxcvi_flag := 1",
                "  end",
                "  else do",
                "     result := si128_CONVERT_FROM_BFP(rnd)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "  end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE & vx_flag",
                "",
                "if ex_flag=0 then do",
                "  VSR[VRT+32] := result",
                "  FPSCR.FPRF := 0bUUUUU",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src be the quad-precision floating-point value in",
                "VSR[VRB+32].",
                "",
                "If src is a Signalling NaN, an Invalid Operation",
                "exception occurs and VXSNAN and VXCVI are set",
                "to 1.",
                "",
                "If src is a Quiet NaN or an Infinity, an Invalid",
                "Operation exception occurs and VXCVI is set to 1.",
                "",
                "If src is a NaN, the result is 0.",
                "",
                "Otherwise, if src is a Zero, the result is 0.",
                "",
                "Otherwise, if src is +Infinity, the result is",
                "2-1.",
                "",
                "Otherwise, if src is -Infinity, the result is",
                "0.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "Let rnd be the value src truncated to a",
                "floating-point integer.",
                "",
                "",
                "If rnd is greater than +2-1, an Invalid",
                "Operation exception occurs, VXCVI is set to 1, and the",
                "result is +2-1.",
                "",
                "",
                "Otherwise, if rnd is less than 0, an Invalid",
                "Operation exception occurs, VXCVI is set to 1, and the",
                "result is 0.",
                "",
                "",
                "Otherwise, the result is the value rnd, and an Inexact",
                "exception occurs if rnd is inexact (i.e., rnd",
                "is not equal to src).",
                "",
                "",
                "The result is placed into VSR[VRT+32] in unsigned integer",
                "format.",
                "",
                "FPRF is set to undefined. FR is set to 0.",
                "FI is set to indicate if the rounded result is inexact.",
                "",
                "If an Invalid Operation exception occurs, FR and",
                "FI are set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified.",
                "",
                "See Table,",
                "Actions for xscvqpudz, on",
                "pagetable:PPC1ChVSX-Table-20-Actions-for-xscvqpud.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round to zero Quad-Precision to Unsigned Word format",
                    "form": "X",
                    "mnemonic": "xscvqpuwz",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "836",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.QNaN=1 | src.class.SNaN=1 then do",
                "  result := 0x0000_0000",
                "  vxsnan_flag := src.class.SNaN",
                "  vxcvi_flag := 1",
                "end",
                "else if src.class.Infinity=1 then do",
                "  vxcvi_flag := 1",
                "  if src.sign=0 then",
                "     result := 0x0000_0000_FFFF_FFFF",
                "  else",
                "     result := 0x0000_0000_0000_0000",
                "end",
                "else if src.class.Zero=1 then",
                "  result := 0x0000_0000",
                "else do",
                "  rnd := bfp_ROUND_TO_INTEGER(0b001,src)",
                "  if bfp_COMPARE_GT(rnd, +2<sup>32</sup>-1) then do",
                "     result := 0x0000_0000_FFFF_FFFF",
                "     vxcvi_flag := 1",
                "  end",
                "  else if bfp_COMPARE_LT(rnd, bfp_ZERO) then do",
                "     result := 0x0000_0000_0000_0000",
                "     vxcvi_flag := 1",
                "  end",
                "  else do",
                "     result := ui64_CONVERT_FROM_BFP(rnd)",
                "     if xx_flag=1 then SetFX(FPSCR.XX)",
                "  end",
                "end",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxcvi_flag=1  then SetFX(FPSCR.VXCVI)",
                "",
                "vx_flag := vxsnan_flag | vxcvi_flag",
                "ex_flag := FPSCR.VE & vx_flag",
                "",
                "if ex_flag=0 then do",
                "  VSR[VRT+32].dword[0] := result",
                "  VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := 0bUUUUU",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src be the quad-precision floating-point value in",
                "VSR[VRB+32].",
                "",
                "If src is a Signalling NaN, an Invalid Operation",
                "exception occurs and VXSNAN and VXCVI are set",
                "to 1.",
                "",
                "If src is a Quiet NaN or an Infinity, an Invalid",
                "Operation exception occurs and VXCVI is set to 1.",
                "",
                "If src is a NaN, the result is 0x0000_0000_0000_0000.",
                "",
                "Otherwise, if src is a Zero, the result is 0x0000_0000_0000_0000.",
                "",
                "Otherwise, if src is a positive Infinity, the result is",
                "0x0000_0000_FFFF_FFFF.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "Let rnd be the value src truncated to a",
                "floating-point integer.",
                "",
                "",
                "If rnd is greater than +2-1, an Invalid",
                "Operation exception occurs, VXCVI is set to 1, and the",
                "result is 0x0000_0000_FFFF_FFFF.",
                "",
                "",
                "Otherwise, if rnd is less than 0, an Invalid",
                "Operation exception occurs, VXCVI is set to 1, and the",
                "result is 0x0000_0000_0000_0000.",
                "",
                "",
                "Otherwise, the result is the value rnd, and an Inexact",
                "exception occurs if rnd is inexact (i.e., rnd",
                "is not equal to src).",
                "",
                "",
                "The result is placed into doubleword element 0 of VSR[VRT+32] in unsigned integer format.",
                "",
                "The contents of doubleword element 1 of VSR[VRT+32] are",
                "set to 0.",
                "",
                "FPRF is set to undefined. FR is set to 0.",
                "FI is set to indicate if the rounded result is inexact.",
                "",
                "If an Invalid Operation exception occurs, FR and",
                "FI are set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified.",
                "",
                "See Table,",
                "Actions for xscvqpuwz, on",
                "pagetable:PPC1ChVSX-Table-16-@@@Actions-for-xscvqpuwz.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert Single-Precision to Double-Precision format",
                    "form": "XX2",
                    "mnemonic": "xscvspdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "329",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[0])",
                "vxsnan_flag := src.class.SNaN",
                "result := bfp64_CONVERT_FROM_BFP(src)",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "FPSCR.FR := 0b0",
                "FPSCR.FI := 0b0",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the single-precision floating-point value in",
                "word element 0 of VSR[XB].",
                "",
                "If src is a SNaN, the result is src,",
                "converted to a QNaN (i.e., bit 9 of src set",
                "to 1). VXSNAN is set to 1.",
                "",
                "Otherwise, the result is src.",
                "",
                "The result is placed into doubleword element 0 of",
                "VSR[XT] in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to 0.",
                "FI is set to 0.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] is not modified, FPRF is not modified,",
                "FR is set to 0, and FI is set to",
                "0.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert Single-Precision to Double-Precision format Non-signalling",
                    "form": "XX2",
                    "mnemonic": "xscvspdpn",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "331",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[0])",
                "result := bfp64_CONVERT_FROM_BFP(src)",
                "VSR[32*TX+T].dword[0] := result",
                "VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the single-precision floating-point value in",
                "word element 0 of VSR[XB].",
                "",
                "src is placed into doubleword element 0 of",
                "VSR[XT] in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round Signed Quadword to Quad-Precision",
                    "form": "X",
                    "mnemonic": "xscvsqqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "11",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "836",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_SI128(VSR[VRB+32])",
                "rnd    := bfp_ROUND_TO_BFP128(0,FPSCR.RN,src)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(XX)",
                "",
                "VSR[VRT+32] := result",
                "FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "FPSCR.FR    := inc_flag",
                "FPSCR.FI    := xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src be the 128-bit signed integer value in VSR[VRB+32].",
                "",
                "src is converted to an unbounded-precision floating-point",
                "value and rounded to quad-precision using the rounding mode specified",
                "by RN.",
                "",
                "The result is placed into VSR[VRT+32] in quad-precision",
                "format.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round Signed Doubleword to Double-Precision format",
                    "form": "XX2",
                    "mnemonic": "xscvsxddp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "376",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_SI64(VSR[32*BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "VSR[32*TX+T].dword[0] := result",
                "VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "FPSCR.FR   := inc_flag",
                "FPSCR.FI   := xx_flag"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the signed integer value in doubleword element",
                "0 of VSR[XB].",
                "",
                "src is converted to an unbounded-precision floating-point",
                "value and rounded to double-precision using the rounding mode",
                "specified by RN.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round Signed Doubleword to Single-Precision format",
                    "form": "XX2",
                    "mnemonic": "xscvsxdsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "312",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_SI64(VSR[32*BX+B].dword[0])",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "VSR[32*TX+T].dword[0] := result64",
                "VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "FPSCR.FR   := inc_flag",
                "FPSCR.FI   := xx_flag"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the two\u00e2\u20ac\u2122s-complement integer value in doubleword element 0",
                "of VSR[XB].",
                "",
                "src is converted to floating-point format, and rounded to",
                "single-precision using the rounding mode specified by RN.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result as",
                "represented in single-precision format.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert Signed Doubleword to Quad-Precision format",
                    "form": "X",
                    "mnemonic": "xscvsdqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "10",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "836",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src         := bfp_CONVERT_FROM_SI64(VSR[VRB+32].dword[0])",
                "result      := bfp128_CONVERT_FROM_BFP(src)",
                "",
                "VSR[VRT+32] := result",
                "FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "FPSCR.FR    := 0",
                "FPSCR.FI    := 0"
            ],
            "body": [
                "",
                "",
                "Let src be the signed integer value in doubleword element",
                "0 of VSR[VRB+32].",
                "",
                "src is placed into VSR[VRT+32] in",
                "quad-precision floating-point format.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to 0. FI is set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert Unsigned Doubleword to Quad-Precision format",
                    "form": "X",
                    "mnemonic": "xscvudqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "2",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "836",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src         := bfp_CONVERT_FROM_UI64(VSR[VRB+32].dword[0])",
                "result      := bfp128_CONVERT_FROM_BFP(src)",
                "",
                "VSR[VRT+32] := result",
                "FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "FPSCR.FR    := 0",
                "FPSCR.FI    := 0"
            ],
            "body": [
                "",
                "",
                "Let src be the unsigned integer value in doubleword",
                "element 0 of VSR[VRB+32].",
                "",
                "src is placed into VSR[VRT+32] in",
                "quad-precision floating-point format.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to 0. FI is set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round Unsigned Quadword to Quad-Precision format",
                    "form": "X",
                    "mnemonic": "xscvuqqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "3",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "836",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_UI128(VSR[VRB+32])",
                "rnd    := bfp_ROUND_TO_BFP128(0b0,FPSCR.RN,src)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(XX)",
                "",
                "VSR[VRT+32] := result",
                "FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "FPSCR.FR    := inc_flag",
                "FPSCR.FI    := xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src be the 128-bit unsigned integer value in",
                "VSR[VRB+32].",
                "",
                "src is converted to an unbounded-precision floating-point",
                "value and rounded to quad-precision using the rounding mode specified",
                "by RN.",
                "",
                "The result is placed into VSR[VRT+32] in quad-precision",
                "format.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round Unsigned Doubleword to Double-Precision format",
                    "form": "XX2",
                    "mnemonic": "xscvuxddp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "360",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_UI64(VSR[32*BX+B].dword[0])",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "VSR[32*TX+T].dword[0] := result",
                "VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "FPSCR.FR   := inc_flag",
                "FPSCR.FI   := xx_flag"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the unsigned integer value in doubleword",
                "element 0 of VSR[XB].",
                "",
                "src is converted to an unbounded-precision floating-point",
                "value and rounded to double-precision using the rounding mode",
                "specified by RN.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Convert with round Unsigned Doubleword to Single-Precision format",
                    "form": "XX2",
                    "mnemonic": "xscvuxdsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "296",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_UI64(VSR[32*BX+B].dword[0])",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "VSR[32*TX+T].dword[0] := result64",
                "VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "FPSCR.FR   := inc_flag",
                "FPSCR.FI   := xx_flag"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the unsigned-integer value in doubleword element 0 of",
                "VSR[XB].",
                "",
                "src is converted to floating-point format, and rounded to",
                "single-precision using the rounding mode specified by RN.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result as",
                "represented in single-precision format.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Divide Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xsdivdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "56",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "src2   := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "v      := bfp_DIVIDE(src1,src2)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxidi_flag=1 then SetFX(FPSCR.VXIDI)",
                "if vxzdz_flag=1 then SetFX(FPSCR.VXZDZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vx_flag  := vxsnan_flag | vxidi_flag | vxzdz_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "zex_flag := FPSCR.ZE & zx_flag",
                "",
                "if vex_flag=0 & zex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "src1 is divided by",
                "src2, producing a quotient having unbounded range and",
                "precision.",
                "",
                "The quotient is normalized.",
                "",
                "See  (p. table:PPC1ChVSX-Divide).",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the result was incremented when rounded.",
                "FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception or a trap-enabled zero",
                "divide exception occurs, VSR[XT] and FPRF are",
                "not modified, and FR and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Divide Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xsdivqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "VSX Scalar Divide Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xsdivqpo",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "548",
                    "size": "10"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_DIVIDE(src1, src2)",
                "rnd    := bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxidi_flag=1 then SetFX(FPSCR.VXIDI)",
                "if vxzdz_flag=1 then SetFX(FPSCR.VXZDZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag := vxsnan_flag | vxidi_flag | vxzdz_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "zex_flag := FPSCR.ZE & zx_flag",
                "",
                "if vex_flag=0 & zex_flag=0 then do",
                "  VSR[VRT+32] := result",
                "  FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & (zx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & (zx_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
                "",
                "Let src2 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
                "",
                "If either src1 or src2 is a Signalling NaN,",
                "an Invalid Operation exception occurs and VXSNAN is set",
                "to 1",
                "",
                "If src1 and src2 are Infinity values, an",
                "Invalid Operation exception occurs and VXIDI is set to 1.",
                "",
                "If src1 and src2 are Zero values, an Invalid",
                "Operation exception occurs and VXZDZ is set to 1.",
                "",
                "If src1 is a finite value and src2 is a Zero",
                "value, an Zero Divide exception occurs and ZX is set to 1.",
                "",
                "If src1 is a Signalling NaN, the result is the Quiet NaN",
                "corresponding to src1.",
                "",
                "Otherwise, if src1 is a Quiet NaN, the result is",
                "src1.",
                "",
                "Otherwise, if src2 is a Signalling NaN, the result is the",
                "Quiet NaN corresponding to src2.",
                "",
                "Otherwise, if src2 is a Quiet NaN, the result is",
                "src2.",
                "",
                "Otherwise, if src1 and src2 are Infinity",
                "values, or if src1 and src2 are Zero values,",
                "the result is the default Quiet NaN.",
                "",
                "Otherwise, if src1 is a non-zero value and src2 is a Zero value, the result is an Infinity.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "The normalized quotient of src1 divided by src2 is produced with unbounded significand precision and exponent",
                "range.",
                "",
                "",
                "See",
                "Table,",
                "Actions for xsdivqp[o], on",
                "pagetable:PPC1ChVSX-Table-9-Actions-for-divide-bfp128-src1,src2.",
                "",
                "",
                "If the intermediate result is Tiny (i.e., the unbiased",
                "exponent is less than -16382) and UE=0, the",
                "significand is shifted right N bits, where N",
                "is the difference between -16382 and the unbiased",
                "exponent of the intermediate result.",
                "The exponent of the intermediate result is set to the value",
                "-16382.",
                "",
                "",
                "If RO=1, let the rounding mode be Round to Odd.",
                "Otherwise, let the rounding mode be specified by RN.",
                "Unless the result is an Infinity or a Zero, the intermediate result",
                "is rounded to quad-precision using the specified rounding mode.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into VSR[VRT+32] in quad-precision",
                "format.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-disabled Invalid Operation exception occurs, FR",
                "and FI are set to 0.",
                "",
                "If a trap-disabled Zero Divide exception occurs, FR and",
                "FI are set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception or a trap-enabled Zero",
                "Divide exception occurs, VSR[VRT+32] and FPRF",
                "are not modified, and FR and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Divide Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xsdivsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "24",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1     := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "src2     := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "v        := bfp_DIVIDE(src1,src2)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxidi_flag=1 then SetFX(FPSCR.VXIDI)",
                "if vxzdz_flag=1 then SetFX(FPSCR.VXZDZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vx_flag  := vxsnan_flag | vxidi_flag | vxzdz_flag",
                "",
                "vex_flag := FPSCR.VE & vx_flag",
                "zex_flag := FPSCR.ZE & zx_flag",
                "",
                "if vex_flag=0 & zex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result64",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "src1 is divided by",
                "src2, producing a quotient having unbounded range and",
                "precision.",
                "",
                "The quotient is normalized.",
                "",
                "See Table,",
                "Actions for xsdivsp, on",
                "pagetable:PPC1ChVSX-Table-62-Actions-for-xsdivsp.",
                "",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result as",
                "represented in single-precision format.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception or a trap-enabled zero",
                "divide exception occurs, VSR[XT] and FPRF are",
                "not modified, and FR and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Insert Exponent Double-Precision",
                    "form": "X",
                    "mnemonic": "xsiexpdp",
                    "operands": [
                        "XT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "918",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := GPR[RA]",
                "src2 := GPR[RB]",
                "",
                "VSR[32*TX+T].dword[0].bit[0]     := src1.bit[0]",
                "VSR[32*TX+T].dword[0].bit[1:11]  := src2.bit[53:63]",
                "VSR[32*TX+T].dword[0].bit[12:63] := src1.bit[12:63]",
                "VSR[32*TX+T].dword[1]            := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let XT be the sum 32TX + T.",
                "",
                "Let src1 be the unsigned integer value in GPR[RA].",
                "",
                "Let src2 be the unsigned integer value in GPR[RB].",
                "",
                "The contents of bit 0 of src1 are placed into bit 0 of",
                "VSR[XT].",
                "",
                "The contents of bits 53:63 of src2 are placed into bits",
                "1:11 of VSR[XT].",
                "",
                "The contents of bits 12:63 of src1 are placed into bits",
                "12:63 of VSR[XT].",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Insert Exponent Quad-Precision",
                    "form": "X",
                    "mnemonic": "xsiexpqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "868",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[VRT+32].bit[0]      := VSR[VRA+32].bit[0]",
                "VSR[VRT+32].bit[1:15]   := VSR[VRB+32].dword[0].bit[49:63]",
                "VSR[VRT+32].bit[16:127] := VSR[VRA+32].bit[16:127]"
            ],
            "body": [
                "",
                "",
                "The contents of bit 0 of VSR[VRA+32] are placed into bit",
                "0 of VSR[VRT+32].",
                "",
                "The contents of bit 49:63 of doubleword element 0 of VSR[VRB+32] are placed into bits 1:15 of VSR[VRT+32].",
                "",
                "The contents of bit 16:127 of VSR[VRA+32] are placed into",
                "bits 16:127 of VSR[VRT+32].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Multiply-Add Type-A Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xsmaddadp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Scalar Multiply-Add Type-M Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xsmaddmdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "41",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if \"xsmaddadp\" then do",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[0])",
                "  src3 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "end",
                "if \"xsmaddmdp\" then do",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "  src3 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[0])",
                "end",
                "",
                "v      := bfp_MULTIPLY_ADD(src1, src3, src2)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN, v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XA].",
                "",
                "For xsmaddadp, do the following.",
                "",
                "",
                "",
                "For xsmaddmdp, do the following.",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a product having",
                "unbounded range and precision.",
                "",
                "See part 1 of Table .",
                "",
                "src2 is added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "The sum is normalized.",
                "",
                "See part 2 of Table .",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Multiply-Add Type-A Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xsmaddasp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                },
                {
                    "name": "VSX Scalar Multiply-Add Type-M Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xsmaddmsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "9",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if \"xsmaddasp\" then do",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[0])",
                "  src3 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "end",
                "if \"xsmaddmsp\" then do",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "  src3 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[0])",
                "end",
                "",
                "v        := bfp_MULTIPLY_ADD(src1, src3, src2)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN, v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result64",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For xsmaddasp, do the following.",
                "",
                "",
                "",
                "For xsmaddmsp, do the following.",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a product having",
                "unbounded range and precision.",
                "",
                "See part 1 of",
                "Table,",
                "Actions for xsmadd(a|m)sp, on",
                "pagetable:PPC1ChVSX-Table-64-Actions-for-xsmadd-a|m-sp.",
                "",
                "src2 is added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "The sum is normalized.",
                "",
                "See part 2 of",
                "Table,",
                "Actions for xsmadd(a|m)sp, on",
                "pagetable:PPC1ChVSX-Table-64-Actions-for-xsmadd-a|m-sp.",
                "",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT] in",
                "double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result as",
                "represented in single-precision format.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Multiply-Add Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xsmaddqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "VSX Scalar Multiply-Add Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xsmaddqpo",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "388",
                    "size": "10"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRT+32])",
                "src3   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_MULTIPLY_ADD(src1, src3, src2)",
                "rnd    := bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1  then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1  then SetFX(FPSCR.VXISI)",
                "if ox_flag=1     then SetFX(FPSCR.OX)",
                "if ux_flag=1     then SetFX(FPSCR.UX)",
                "if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "ex_flag  := FPSCR.VE & vx_flag",
                "",
                "if ex_flag=0 then do",
                "  VSR[VRT+32] := result",
                "  FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
                "",
                "Let src2 be the floating-point value in VSR[VRT+32] represented in quad-precision format.",
                "",
                "Let src3 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
                "",
                "If either src1, src2, or src3 is",
                "a Signalling NaN, an Invalid Operation exception occurs and",
                "VXSNAN is set to 1.",
                "",
                "If src1 is an Infinity value and src3 is a",
                "Zero value, or if src1 is a Zero value and src3 is an Infinity value, an Invalid Operation exception occurs and",
                "VXIMZ is set to 1.",
                "",
                "If src2 and the product of src1 and",
                "src3 are Infinity values having opposite signs, an",
                "Invalid Operation exception occurs and VXISI is set to 1.",
                "",
                "If src1 is a Signalling NaN, the result is the Quiet NaN",
                "corresponding to src1.",
                "",
                "Otherwise, if src1 is a Quiet NaN, the result is",
                "src1.",
                "",
                "Otherwise, if src2 is a Signalling NaN, the result is the",
                "Quiet NaN corresponding to src2.",
                "",
                "Otherwise, if src2 is a Quiet NaN, the result is",
                "src2.",
                "",
                "Otherwise, if src3 is a Signalling NaN, the result is the",
                "Quiet NaN corresponding to src3.",
                "",
                "Otherwise, if src3 is a Quiet NaN, the result is",
                "src3.",
                "",
                "Otherwise, if src1 is an Infinity value and src3 is a Zero value, or if src1 is a Zero value and",
                "src3 is an Infinity value, the result is the default",
                "Quiet NaN.",
                "",
                "Otherwise, if the product of src1 and src3,",
                "and src2 are Infinity values having opposite signs, the",
                "result is the default Quiet NaN.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a",
                "product having unbounded significand precision and exponent range.",
                "",
                "",
                "See part 1 of Table.",
                "\"Actions for xsmadd(a|m)dp\".",
                "",
                "",
                "src2 is added to the product, producing a sum having",
                "unbounded range and precision.",
                "",
                "",
                "See part 2 of Table.",
                "\"Actions for xsmadd(a|m)dp\".",
                "",
                "",
                "If the intermediate result is Tiny (i.e., the unbiased",
                "exponent is less than -16382) and UE=0, the",
                "significand is shifted right N bits, where N",
                "is the difference between -16382 and the unbiased",
                "exponent of the intermediate result.",
                "The exponent of the intermediate result is set to the value",
                "-16382.",
                "",
                "",
                "If RO=1, let the rounding mode be Round to Odd.",
                "Otherwise, let the rounding mode be specified by RN.",
                "Unless the result is an Infinity or a Zero, the intermediate result",
                "is rounded to quad-precision using the specified rounding mode.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into VSR[VRT+32] in quad-precision",
                "format.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the rounded result was",
                "incremented. FI is set to indicate the result is inexact.",
                "",
                "If a trap-disabled Invalid Operation exception occurs, FR",
                "and FI are set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Maximum Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xsmaxdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "160",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32*AX+A].dword[0]",
                "src2   := VSR[32*BX+B].dword[0]",
                "result := bfp64_MAXIMUM(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "If src1 is greater than src2, src1 is placed into doubleword element 0 of VSR[XT].",
                "Otherwise, src2 is placed into doubleword element 0 of",
                "VSR[XT] in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "The maximum of +0 and -0 is +0.",
                "The maximum of a QNaN and any value is that value.",
                "The maximum of any value and an SNaN is that SNaN converted to a QNaN.",
                "",
                "FPRF, FR and FI are not modified.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] is not modified.",
                "",
                "See Table .",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Maximum Type-C Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xsmaxcdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "128",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32*AX+A].dword[0]",
                "src2   := VSR[32*BX+B].dword[0]",
                "result := bfp64_MAXIMUM_TYPE_C(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword 0 of VSR[XB].",
                "",
                "If src1 or src2 is a SNaN, an Invalid",
                "Operation exception occurs.",
                "",
                "If either src1 or src2 is a NaN, result is src2.",
                "",
                "Otherwise, if src1 is greater than src2,",
                "result is src1.",
                "",
                "Otherwise, result is src2.",
                "",
                "The contents of doubleword 0 of VSR[XT] are set to the",
                "value result.",
                "",
                "The contents of doubleword 1 of VSR[XT] are set to 0.",
                "",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is",
                "not modified.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Maximum Type-C Quad-Precision",
                    "form": "X",
                    "mnemonic": "xsmaxcqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "676",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2 := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "vxsnan_flag := (src1.class.SNaN=1) | (src2.class.SNaN=1)",
                "",
                "if (src1.class.SNaN=1) | (src1.class.QNaN=1) |",
                "  (src2.class.SNaN=1) | (src2.class.QNaN=1) then",
                "  result := VSR[VRB+32]",
                "",
                "else if bfp_COMPARE_GT(src1,src2) then",
                "  result := VSR[VRA+32]",
                "else",
                "  result := VSR[VRB+32]",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vxsnan_flag=1 then SetFX(VXSNAN)",
                "",
                "if vex_flag=0 then",
                "  VSR[VRT+32] := result"
            ],
            "body": [
                "",
                "Let src1 be the quad-precision floating-point value in",
                "VSR[VRA+32].",
                "",
                "Let src2 be the quad-precision floating-point value in",
                "VSR[VRB+32].",
                "",
                "If src1 or src2 is a SNaN, an Invalid",
                "Operation exception occurs.",
                "",
                "If either src1 or src2 is a NaN, result is src2.",
                "",
                "Otherwise, if src1 is greater than src2,",
                "result is src1.",
                "",
                "Otherwise, result is src2.",
                "",
                "The contents of VSR[VRT+32] are set to the value",
                "result.",
                "",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32]",
                "is not modified.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Maximum Type-J Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xsmaxjdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "144",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32*AX+A].dword[0]",
                "src2   := VSR[32*BX+B].dword[0]",
                "result := bfp64_MAXIMUM_TYPE_J(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword 0 of VSR[XB].",
                "",
                "If src1 or src2 is a SNaN, an Invalid",
                "Operation exception occurs.",
                "",
                "If src1 is a NaN, result is src1.",
                "",
                "Otherwise, if src2 is a NaN, result is",
                "src2.",
                "",
                "Otherwise, if src1 is a Zero and src2 is a",
                "Zero and either src1 or src2 is a +Zero, the",
                "result is +Zero.",
                "",
                "Otherwise, if src1 is a -Zero and src2 is a",
                "-Zero, the result is -Zero.",
                "",
                "Otherwise, if src1 is greater than src2,",
                "result is src1.",
                "",
                "Otherwise, result is src2.",
                "",
                "The contents of doubleword 0 of VSR[XT] are set to the",
                "value result.",
                "",
                "The contents of doubleword 1 of VSR[XT] are set to 0.",
                "",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is",
                "not modified.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Minimum Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xsmindp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "168",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32*AX+A].dword[0]",
                "src2   := VSR[32*BX+B].dword[0]",
                "result := bfp64_MINIMUM(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "If src1 is less than src2, src1",
                "is placed into doubleword element 0 of VSR[XT] in",
                "double-precision format.",
                "Otherwise, src2 is placed into doubleword element 0 of",
                "VSR[XT] in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "The minimum of +0 and \u00e2\u20ac\u201c0 is \u00e2\u20ac\u201c0.",
                "The minimum of a QNaN and any value is that value.",
                "The minimum of any value and an SNaN is that SNaN converted to a QNaN.",
                "",
                "FPRF, FR and FI are not modified.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] is not modified.",
                "",
                "See Table .",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Minimum Type-C Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xsmincdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "136",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32*AX+A].dword[0]",
                "src2   := VSR[32*BX+B].dword[0]",
                "result := bfp64_MINIMUM_TYPE_C(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword 0 of VSR[XB].",
                "",
                "If src1 or src2 is a SNaN, an Invalid",
                "Operation exception occurs.",
                "",
                "If either src1 or src2 is a NaN, result is src2.",
                "",
                "Otherwise, if src1 is less than src2,",
                "result is src1.",
                "",
                "Otherwise, result is src2.",
                "",
                "The contents of doubleword 0 of VSR[XT] are set to the",
                "value result.",
                "",
                "The contents of doubleword 1 of VSR[XT] are set to 0.",
                "",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is",
                "not modified.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Minimum Type-C Quad-Precision",
                    "form": "X",
                    "mnemonic": "xsmincqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "740",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2 := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "vxsnan_flag := (src1.class.SNaN=1) | (src2.class.SNaN=1)",
                "",
                "if (src1.class.SNaN=1) | (src1.class.QNaN=1) |",
                "  (src2.class.SNaN=1) | (src2.class.QNaN=1) then",
                "  result := VSR[VRB+32]",
                "",
                "else if bfp_COMPARE_LT(src1,src2) then",
                "  result := VSR[VRA+32]",
                "else",
                "  result := VSR[VRB+32]",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vxsnan_flag=1 then SetFX(VXSNAN)",
                "",
                "if vex_flag=0 then",
                "  VSR[VRT+32] := result"
            ],
            "body": [
                "",
                "Let src1 be the quad-precision floating-point value in",
                "VSR[VRA+32].",
                "",
                "Let src2 be the quad-precision floating-point value in",
                "VSR[VRB+32].",
                "",
                "If src1 or src2 is a SNaN, an Invalid",
                "Operation exception occurs.",
                "",
                "If either src1 or src2 is a NaN, result is src2.",
                "",
                "Otherwise, if src1 is less than src2,",
                "result is src1.",
                "",
                "Otherwise, result is src2.",
                "",
                "The contents of VSR[VRT+32] are set to the value",
                "result.",
                "",
                "If a trap-enabled Invalid Operation occurs, VSR[VRT+32]",
                "is not modified.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Minimum Type-J Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xsminjdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "152",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := VSR[32*AX+A].dword[0]",
                "src2   := VSR[32*BX+B].dword[0]",
                "result := bfp64_MINIMUM_TYPE_J(src1,src2)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword 0 of VSR[XB].",
                "",
                "If src1 or src2 is a SNaN, an Invalid",
                "Operation exception occurs.",
                "",
                "If src1 is a NaN, result is src1.",
                "",
                "Otherwise, if src2 is a NaN, result is",
                "src2.",
                "",
                "Otherwise, if src1 is a Zero and src2 is a",
                "Zero and either src1 or src2 is a -Zero, the",
                "result is -Zero.",
                "",
                "Otherwise, if src1 is a +Zero and src2 is a",
                "+Zero, the result is +Zero.",
                "",
                "Otherwise, if src1 is less than src2,",
                "result is src1.",
                "",
                "Otherwise, result is src2.",
                "",
                "The contents of doubleword 0 of VSR[XT] are set to the",
                "value result.",
                "",
                "The contents of doubleword 1 of VSR[XT] are set to 0.",
                "",
                "If a trap-enabled Invalid Operation occurs, VSR[XT] is",
                "not modified.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Multiply-Subtract Type-A Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xsmsubadp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Scalar Multiply-Subtract Type-M Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xsmsubmdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "57",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if \"xsmsubadp\" then do",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[0])",
                "  src3 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "end",
                "if \"xsmsubmdp\" then do",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "  src3 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[0])",
                "end",
                "",
                "v      := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN, v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For xsmsubadp, do the following.",
                "",
                "",
                "",
                "For xsmsubmdp, do the following.",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a product having",
                "unbounded range and precision.",
                "",
                "See part 1 of Table .",
                "",
                "src2 is negated and added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "The result, having unbounded range and precision, is",
                "normalized.",
                "",
                "See part 2 of Table .",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the result was incremented when rounded.",
                "FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Multiply-Subtract Type-A Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xsmsubasp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                },
                {
                    "name": "VSX Scalar Multiply-Subtract Type-M Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xsmsubmsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "25",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if \"xsmsubasp\" then do",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[0])",
                "  src3 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "end",
                "if \"xsmsubmsp\" then do",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "  src3 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[0])",
                "end",
                "",
                "v        := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN, v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result64",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For xsmsubasp, do the following.",
                "",
                "",
                "",
                "For xsmsubmsp, do the following.",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a product having",
                "unbounded range and precision.",
                "",
                "See part 1 of",
                "Table,",
                "Actions for xsmsub(a|m)sp.",
                "",
                "src2 is negated and added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "The result, having unbounded range and precision, is",
                "normalized.",
                "",
                "See part 2 of",
                "Table,",
                "Actions for xsmsub(a|m)sp.",
                "",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result as",
                "represented in single-precision format.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Multiply-Subtract Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xsmsubqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "VSX Scalar Multiply-Subtract Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xsmsubqpo",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "420",
                    "size": "10"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRT+32])",
                "src3   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd    := bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[VRT+32] := result",
                "  FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
                "",
                "Let src2 be the floating-point value in VSR[VRT+32] represented in quad-precision format.",
                "",
                "Let src3 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
                "",
                "If either src1, src2, or src3 is",
                "a Signalling NaN, an Invalid Operation exception occurs and",
                "VXSNAN is set to 1.",
                "",
                "If src1 is an Infinity value and src3 is a",
                "Zero value, or if src1 is a Zero value and src3 is an Infinity value, an Invalid Operation exception occurs and",
                "VXIMZ is set to 1.",
                "",
                "If src2 and the product of src1 and",
                "src3 are Infinity values having same signs, an Invalid",
                "Operation exception occurs and VXISI is set to 1.",
                "",
                "If src1 is a Signalling NaN, the result is the Quiet NaN",
                "corresponding to src1.",
                "",
                "Otherwise, if src1 is a Quiet NaN, the result is",
                "src1.",
                "",
                "Otherwise, if src2 is a Signalling NaN, the result is the",
                "Quiet NaN corresponding to src2.",
                "",
                "Otherwise, if src2 is a Quiet NaN, the result is",
                "src2.",
                "",
                "Otherwise, if src3 is a Signalling NaN, the result is the",
                "Quiet NaN corresponding to src3.",
                "",
                "Otherwise, if src3 is a Quiet NaN, the result is",
                "src3.",
                "",
                "Otherwise, if src1 is an Infinity value and src3 is a Zero value, or if src1 is a Zero value and",
                "src3 is an Infinity value, the result is the default",
                "Quiet NaN.",
                "",
                "Otherwise, if the product of src1 and src3,",
                "and src2 are Infinity values having same signs, the",
                "result is the default Quiet NaN.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a",
                "product having unbounded significand precision and exponent range.",
                "",
                "",
                "See part 1 of",
                "Table.",
                "\"Actions for xsmsubqp[o]\".",
                "",
                "",
                "src2 is negated and added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "",
                "See part 2 of",
                "Table.",
                "\"Actions for xsmsubqp[o]\".",
                "",
                "",
                "If the intermediate result is Tiny (i.e., the unbiased",
                "exponent is less than -16382) and UE=0, the",
                "significand is shifted right N bits, where N",
                "is the difference between -16382 and the unbiased",
                "exponent of the intermediate result.",
                "The exponent of the intermediate result is set to the value",
                "-16382.",
                "",
                "",
                "If RO=1, let the rounding mode be Round to Odd.",
                "Otherwise, let the rounding mode be specified by RN.",
                "Unless the result is an Infinity or a Zero, the intermediate result",
                "is rounded to quad-precision using the specified rounding mode.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into VSR[VRT+32] in quad-precision",
                "format.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the rounded result was",
                "incremented. FI is set to indicate the result is inexact.",
                "",
                "If a trap-disabled Invalid Operation exception occurs, FR",
                "and FI are set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Multiply Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xsmuldp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "48",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "src2   := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "v      := bfp_MULTIPLY(src1,src2)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "src1 is multiplied by src2, producing a product having",
                "unbounded range and precision.",
                "",
                "The product is normalized.",
                "",
                "See Table .",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Multiply Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xsmulqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "VSX Scalar Multiply Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xsmulqpo",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "36",
                    "size": "10"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_MULTIPLY(src1, src2)",
                "rnd    := bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[VRT+32] := result",
                "  FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
                "",
                "Let src2 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
                "",
                "If either src1 or src2 is a Signalling NaN,",
                "an Invalid Operation exception occurs and VXSNAN is set",
                "to 1.",
                "",
                "If src1 is an Infinity value and src2 is a",
                "Zero value, or if src1 is a Zero value and src2 is an Infinity value, an Invalid Operation exception occurs and",
                "VXIMZ is set to 1.",
                "",
                "If src1 is a Signalling NaN, the result is the Quiet NaN",
                "corresponding to src1.",
                "",
                "Otherwise, if src1 is a Quiet NaN, the result is",
                "src1.",
                "",
                "Otherwise, if src2 is a Signalling NaN, the result is the",
                "Quiet NaN corresponding to src2.",
                "",
                "Otherwise, if src2 is a Quiet NaN, the result is",
                "src2.",
                "",
                "Otherwise, if src1 is an Infinity value and src2 is a Zero value, or if src1 is a Zero value and",
                "src2 is an Infinity value, the result is the default",
                "Quiet NaN.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "The normalized product of src1 multiplied by src2 is produced with unbounded significand precision and exponent",
                "range.",
                "",
                "",
                "See",
                "Table.",
                "\"Actions for xsmulqp[o]\".",
                "",
                "",
                "If the intermediate result is Tiny (i.e., the unbiased",
                "exponent is less than -16382) and UE=0, the",
                "significand is shifted right N bits, where N",
                "is the difference between -16382 and the unbiased",
                "exponent of the intermediate result.",
                "The exponent of the intermediate result is set to the value",
                "-16382.",
                "",
                "",
                "If RO=1, let the rounding mode be Round to Odd.",
                "Otherwise, let the rounding mode be specified by RN.",
                "Unless the result is an Infinity or a Zero, the intermediate result",
                "is rounded to quad-precision using the specified rounding mode.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into VSR[VRT+32] in quad-precision",
                "format.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the rounded result was",
                "incremented. FI is set to indicate the result is inexact.",
                "",
                "If a trap-disabled Invalid Operation exception occurs, FR",
                "and FI are set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Multiply Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xsmulsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "16",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1     := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "src2     := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "v        := bfp_MULTIPLY(src1,src2)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result64",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "src1 is multiplied by src2, producing a product having",
                "unbounded range and precision.",
                "",
                "The product is normalized.",
                "",
                "See Table,",
                "Actions for xsmulsp, on",
                "pagetable:PPC1ChVSX-Table-70-Actions-for-xsmulsp.",
                "",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result as",
                "represented in single-precision format.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Negative Absolute Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xsnabsdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "361",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src := VSR[32*BX+B].dword[0]",
                "VSR[32*TX+T].dword[0] := bfp64_NEGATIVE_ABSOLUTE(src)",
                "VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "The contents of doubleword element 0 of VSR[XB], with bit",
                "0 set to 1, is placed into doubleword element 0 of VSR[XT].",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Negative Absolute Quad-Precision",
                    "form": "X",
                    "mnemonic": "xsnabsqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "8",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "804",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[VRT+32] := bfp128_NEGATIVE_ABSOLUTE(VSR[VRB+32])"
            ],
            "body": [
                "",
                "",
                "Let src be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
                "",
                "The negative absolute value of src is placed into",
                "VSR[VRT+32] in quad-precision format.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Negate Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xsnegdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "377",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src := VSR[32*BX+B].dword[0]",
                "VSR[32*TX+T].dword[0] := bfp64_NEGATE(src)",
                "VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "The contents of doubleword element 0 of VSR[XB], with bit",
                "0 complemented, is placed into doubleword element 0 of VSR[XT].",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Negate Quad-Precision",
                    "form": "X",
                    "mnemonic": "xsnegqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "16",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "804",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[VRT+32] := bfp128_NEGATE(VSR[VRB+32])"
            ],
            "body": [
                "",
                "",
                "Let src be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
                "",
                "src is negated and placed into VSR[VRT+32] in",
                "quad-precision format.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Negative Multiply-Add Type-A Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xsnmaddadp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Scalar Negative Multiply-Add Type-M Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xsnmaddmdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "169",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if \"xsnmaddadp\" then do",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[0])",
                "  src3 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "end",
                "if \"xsnmaddmdp\" then do",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "  src3 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[0])",
                "end",
                "",
                "v      := bfp_MULTIPLY_ADD(src1, src3, src2)",
                "rnd    := bfp_NEGATE(bfp_ROUND_TO_BFP64(0b0,FPSCR.RN, v))",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP32(result)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XA].",
                "",
                "For xsnmaddadp, do the following.",
                "",
                "",
                "",
                "For xsnmaddmdp, do the following.",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a product having",
                "unbounded range and precision.",
                "",
                "See part 1 of Table .",
                "",
                "src2 is added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "The sum is normalized.",
                "",
                "See part 2 of Table .",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is negated and placed into doubleword element 0 of",
                "VSR[XT] in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "See",
                "Table,",
                "Scalar Floating-Point Final Result with Negation, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Negated-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Negative Multiply-Add Type-A Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xsnmaddasp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                },
                {
                    "name": "VSX Scalar Negative Multiply-Add Type-M Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xsnmaddmsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "137",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if \"xsnmaddasp\" then do",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[0])",
                "  src3 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "end",
                "if \"xsnmaddmsp\" then do",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "  src3 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[0])",
                "end",
                "",
                "v        := bfp_MULTIPLY_ADD(src1, src3, src2)",
                "rnd      := bfp_NEGATE(bfp_ROUND_TO_BFP32(FPSCR.RN, v))",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result64",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For xsnmaddasp, do the following.",
                "",
                "",
                "",
                "For xsnmaddmsp, do the following.",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a product having",
                "unbounded range and precision.",
                "",
                "See part 1 of",
                "Table,",
                "Actions for xsnmadd(a|m)sp, on",
                "pagetable:PPC1ChVSX-Table-72-Actions-for-xsnmadd-a|m-sp.",
                "",
                "src2 is added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "The sum is normalized.",
                "",
                "See part 2 of",
                "Table,",
                "Actions for xsnmadd(a|m)sp, on",
                "pagetable:PPC1ChVSX-Table-72-Actions-for-xsnmadd-a|m-sp.",
                "",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is negated and placed into doubleword element 0 of",
                "VSR[XT] in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result as",
                "represented in single-precision format.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "See",
                "Table,",
                "Scalar Floating-Point Final Result with Negation, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Negated-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Negative Multiply-Add Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xsnmaddqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "VSX Scalar Negative Multiply-Add Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xsnmaddqpo",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "452",
                    "size": "10"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRT+32])",
                "src3   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_MULTIPLY_ADD(src1,src3,src2)",
                "rnd    := bfp_NEGATE(bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v))",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[VRT+32] := result",
                "  FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
                "",
                "Let src2 be the floating-point value in VSR[VRT+32] represented in quad-precision format.",
                "",
                "Let src3 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
                "",
                "If either src1, src2, or src3 is",
                "a Signalling NaN, an Invalid Operation exception occurs and",
                "VXSNAN is set to 1.",
                "",
                "If src1 is an Infinity value and src3 is a",
                "Zero value, or if src1 is a Zero value and src3 is an Infinity value, an Invalid Operation exception occurs and",
                "VXIMZ is set to 1.",
                "",
                "If src2 and the product of src1 and",
                "src3 are Infinity values having opposite signs, an",
                "Invalid Operation exception occurs and VXISI is set to 1.",
                "",
                "If src1 is a Signalling NaN, the result is the Quiet NaN",
                "corresponding to src1.",
                "",
                "Otherwise, if src1 is a Quiet NaN, the result is",
                "src1.",
                "",
                "Otherwise, if src2 is a Signalling NaN, the result is the",
                "Quiet NaN corresponding to src2.",
                "",
                "Otherwise, if src2 is a Quiet NaN, the result is",
                "src2.",
                "",
                "Otherwise, if src3 is a Signalling NaN, the result is the",
                "Quiet NaN corresponding to src3.",
                "",
                "Otherwise, if src3 is a Quiet NaN, the result is",
                "src3.",
                "",
                "Otherwise, if src1 is an Infinity value and src3 is a Zero value, or if src1 is a Zero value and",
                "src3 is an Infinity value, the result is the default",
                "Quiet NaN.",
                "",
                "Otherwise, if the product of src1 and src3,",
                "and src2 are Infinity values having opposite signs, the",
                "result is the default Quiet NaN.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a",
                "product having unbounded significand precision and exponent range.",
                "",
                "",
                "See part 1 of Table.",
                "\"Actions for xsmadd(a|m)dp\".",
                "",
                "",
                "src2 is added to the product, producing a sum having",
                "unbounded range and precision.",
                "",
                "",
                "See part 2 of Table.",
                "\"Actions for xsmadd(a|m)dp\".",
                "",
                "",
                "If the intermediate result is Tiny (i.e., the unbiased",
                "exponent is less than -16382) and UE=0, the",
                "significand is shifted right N bits, where N",
                "is the difference between -16382 and the unbiased",
                "exponent of the intermediate result.",
                "The exponent of the intermediate result is set to the value",
                "-16382.",
                "",
                "",
                "If RO=1, let the rounding mode be Round to Odd.",
                "Otherwise, let the rounding mode be specified by RN.",
                "Unless the result is an Infinity or a Zero, the intermediate result",
                "is rounded to quad-precision using the specified rounding mode.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is negated and placed into VSR[VRT+32] in",
                "quad-precision format.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the rounded result was",
                "incremented. FI is set to indicate the result is inexact.",
                "",
                "If a trap-disabled Invalid Operation exception occurs, FR",
                "and FI are set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Negative Multiply-Subtract Type-A Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xsnmsubadp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Scalar Negative Multiply-Subtract Type-M Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xsnmsubmdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "185",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if \"xsnmsubadp\" then do",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[0])",
                "  src3 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "end",
                "if \"xsnmsubmdp\" then do",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "  src3 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[0])",
                "end",
                "",
                "v      := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd    := bfp_NEGATE(bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v))",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XA].",
                "",
                "For xsnmsubadp, do the following.",
                "",
                "",
                "",
                "For xsnmsubmdp, do the following.",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a product",
                "having unbounded range and precision.",
                "",
                "See part 1 of Table .",
                "",
                "src2 is negated and added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "The sum is normalized.",
                "",
                "See part 2 of Table .",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is negated and placed into doubleword element 0 of",
                "VSR[XT] in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "See",
                "Table,",
                "Scalar Floating-Point Final Result with Negation, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Negated-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Negative Multiply-Subtract Type-A Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xsnmsubasp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                },
                {
                    "name": "VSX Scalar Negative Multiply-Subtract Type-M Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xsnmsubmsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "153",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if \"xsnmsubasp\" then do",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[0])",
                "  src3 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "end",
                "if \"xsnmsubmsp\" then do",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "  src3 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[0])",
                "end",
                "",
                "v        := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd      := bfp_NEGATE(bfp_ROUND_TO_BFP32(FPSCR.RN, v))",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result64",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For xsnmsubasp, do the following.",
                "",
                "",
                "",
                "For xsnmsubmsp, do the following.",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a product having",
                "unbounded range and precision.",
                "",
                "See part 1 of",
                "Table,",
                "Actions for xsnmsub(a|m)sp, on",
                "pagetable:PPC1ChVSX-Table-75-Actions-for-xsnmsub-a|m-sp.",
                "",
                "src2 is negated and added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "The sum is normalized.",
                "",
                "See part 2 of",
                "Table,",
                "Actions for xsnmsub(a|m)sp, on",
                "pagetable:PPC1ChVSX-Table-75-Actions-for-xsnmsub-a|m-sp.",
                "",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is negated and placed into doubleword element 0 of",
                "VSR[XT] in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result as",
                "represented in single-precision format.",
                "FR is set to indicate if the result was incremented when rounded.",
                "FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "See",
                "Table,",
                "Scalar Floating-Point Final Result with Negation, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Negated-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Negative Multiply-Subtract Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xsnmsubqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "VSX Scalar Negative Multiply-Subtract Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xsnmsubqpo",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "484",
                    "size": "10"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRT+32])",
                "src3   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_MULTIPLY_ADD(src1, src3, bfp_NEGATE(src2))",
                "rnd    := bfp_NEGATE(bfp_ROUND_TO_BFP128(RO, FPSCR.RN, v))",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vximz_flag | vxisi_flag",
                "ex_flag  := FPSCR.VE & vx_flag",
                "",
                "if ex_flag=0 then do",
                "  VSR[VRT+32] := result",
                "  FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
                "",
                "Let src2 be the floating-point value in VSR[VRT+32] represented in quad-precision format.",
                "",
                "Let src3 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
                "",
                "If either src1, src2, or src3 is",
                "a Signalling NaN, an Invalid Operation exception occurs and",
                "VXSNAN is set to 1.",
                "",
                "If src1 is an Infinity value and src3 is a",
                "Zero value, or if src1 is a Zero value and src3 is an Infinity value, an Invalid Operation exception occurs and",
                "VXIMZ is set to 1.",
                "",
                "If src2 and the product of src1 and",
                "src3 are Infinity values having same signs, an Invalid",
                "Operation exception occurs and VXISI is set to 1.",
                "",
                "If src1 is a Signalling NaN, the result is the Quiet NaN",
                "corresponding to src1.",
                "",
                "Otherwise, if src1 is a Quiet NaN, the result is",
                "src1.",
                "",
                "Otherwise, if src2 is a Signalling NaN, the result is the",
                "Quiet NaN corresponding to src2.",
                "",
                "Otherwise, if src2 is a Quiet NaN, the result is",
                "src2.",
                "",
                "Otherwise, if src3 is a Signalling NaN, the result is the",
                "Quiet NaN corresponding to src3.",
                "",
                "Otherwise, if src3 is a Quiet NaN, the result is",
                "src3.",
                "",
                "Otherwise, if src1 is an Infinity value and src3 is a Zero value, or if src1 is a Zero value and",
                "src3 is an Infinity value, the result is the default",
                "Quiet NaN.",
                "",
                "Otherwise, if the product of src1 and src3,",
                "and src2 are Infinity values having same signs, the",
                "result is the default Quiet NaN.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a",
                "product having unbounded significand precision and exponent range.",
                "",
                "",
                "See part 1 of",
                "Table.",
                "\"Actions for xsmsubqp[o]\".",
                "",
                "",
                "src2 is negated and added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "",
                "See part 2 of",
                "Table.",
                "\"Actions for xsmsubqp[o]\".",
                "",
                "",
                "If the intermediate result is Tiny (i.e., the unbiased",
                "exponent is less than -16382) and UE=0, the",
                "significand is shifted right N bits, where N",
                "is the difference between -16382 and the unbiased",
                "exponent of the intermediate result.",
                "The exponent of the intermediate result is set to the value",
                "-16382.",
                "",
                "",
                "If RO=1, let the rounding mode be Round to Odd.",
                "Otherwise, let the rounding mode be specified by RN.",
                "Unless the result is an Infinity or a Zero, the intermediate result",
                "is rounded to quad-precision using the specified rounding mode.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is negated and placed into VSR[VRT+32] in",
                "quad-precision format.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the rounded result was",
                "incremented. FI is set to indicate the result is inexact.",
                "",
                "If a trap-disabled Invalid Operation exception occurs, FR",
                "and FI are set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Round to Double-Precision Integer using round to Nearest Away",
                    "form": "XX2",
                    "mnemonic": "xsrdpi",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "73",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_NEAR_AWAY(src)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR := 0b0",
                "FPSCR.FI := 0b0"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "src is rounded to an integer using the rounding mode",
                "Round to Nearest Away.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to 0. FI is set to 0.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Round to Double-Precision Integer exact using Current rounding mode",
                    "form": "XX2",
                    "mnemonic": "xsrdpic",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "107",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "",
                "if FPSCR.RN=0b00 then",
                "  rnd := bfp_ROUND_TO_INTEGER_NEAR_EVEN(src)",
                "if FPSCR.RN=0b01 then",
                "  rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "if FPSCR.RN=0b10 then",
                "  rnd := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "if FPSCR.RN=0b11 then",
                "  rnd := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point",
                "value in doubleword element 0 of VSR[XB].",
                "",
                "src is rounded to an integer using the rounding",
                "mode specified by RN.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Round to Double-Precision Integer using round toward -Infinity",
                    "form": "XX2",
                    "mnemonic": "xsrdpim",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "121",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR := 0b0",
                "FPSCR.FI := 0b0"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "src is rounded to an integer using the rounding mode",
                "Round toward -Infinity.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to 0. FI is set to 0.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Round to Double-Precision Integer using round toward +Infinity",
                    "form": "XX2",
                    "mnemonic": "xsrdpip",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "105",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR := 0b0",
                "FPSCR.FI := 0b0"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "src is rounded to an integer using the rounding mode",
                "Round toward +Infinity.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to 0. FI is set to 0.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Round to Double-Precision Integer using round toward Zero",
                    "form": "XX2",
                    "mnemonic": "xsrdpiz",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "89",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "rnd    := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "end",
                "FPSCR.FR := 0b0",
                "FPSCR.FI := 0b0"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "src is rounded to an integer using the rounding mode",
                "Round toward Zero.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to 0. FI is set to 0.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Reciprocal Estimate Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xsredp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "90",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "v      := bfp_RECIPROCAL_ESTIMATE(src)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "zex_flag := FPSCR.ZE & zx_flag",
                "",
                "if vex_flag=0 & zex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "  FPSCR.FR   := 0bU",
                "  FPSCR.FI   := 0bU",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "A double-precision floating-point estimate of the reciprocal of",
                "src is placed into doubleword element 0 of VSR[XT] in double-precision format.",
                "",
                "Unless the reciprocal of src would be a zero, an",
                "infinity, or a QNaN, the estimate has a relative error in precision",
                "no greater than one part in 16384 of the reciprocal of",
                "src. That is,",
                "",
                "Operation with various special values of the operand is summarized",
                "below.",
                "",
                "",
                "",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to an undefined value.",
                "FI is set to an undefined value.",
                "",
                "If a trap-enabled invalid operation exception or a trap-enabled zero",
                "divide exception occurs, VSR[XT] and FPRF are",
                "not modified.",
                "",
                "The results of executing this instruction is permitted to vary",
                "between implementations, and between different executions on the same",
                "implementation.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Reciprocal Estimate Single-Precision",
                    "form": "XX2",
                    "mnemonic": "xsresp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "26",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_BFP64(VSR[VRB+32].dword[0])",
                "v        := bfp_RECIPROCAL_ESTIMATE(src)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if 0bU then SetFX(FPSCR.XX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "zex_flag := FPSCR.ZE & zx_flag",
                "",
                "if vex_flag=0 & zex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result64",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "  FPSCR.FR   := 0bU",
                "  FPSCR.FI   := 0bU",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "A single-precision floating-point estimate of the reciprocal of",
                "src is placed into doubleword element 0 of",
                "VSR[XT] in double-precision format.",
                "",
                "Unless the reciprocal of src would be a zero, an",
                "infinity, the result of a trap-disabled Overflow exception, or a",
                "QNaN, the estimate has a relative error in precision no greater than",
                "one part in 16384 of the reciprocal of src.",
                "That is,",
                "",
                "Operation with various special values of the operand is summarized",
                "below.",
                "",
                "",
                "",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result as",
                "represented in single-precision format.",
                "FR is set to an undefined value.",
                "FI is set to an undefined value.",
                "",
                "If a trap-enabled invalid operation exception or a trap-enabled zero",
                "divide exception occurs, VSR[XT] and FPRF are",
                "not modified.",
                "",
                "The results of executing this instruction is permitted to vary",
                "between implementations, and between different executions on the same",
                "implementation.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Round to Quad-Precision Integer [with Inexact]",
                    "form": "Z23",
                    "mnemonic": "xsrqpi",
                    "operands": [
                        "R",
                        "VRT",
                        "VRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "EX",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "VSX Scalar Round to Quad-Precision Integer [with Inexact]",
                    "form": "Z23",
                    "mnemonic": "xsrqpix",
                    "operands": [
                        "R",
                        "VRT",
                        "VRB",
                        "RMC"
                    ],
                    "conditions": [
                        {
                            "field": "EX",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "5",
                    "size": "8"
                },
                {
                    "name": "X",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if R=0 then do",
                "  if RMC=0b00 then           // Round to Nearest Away",
                "     rmode := 0b100",
                "  if RMC=0b11 then do",
                "     if FPSCR.RN=0b00 then   // Round to Nearest Even",
                "        rmode := 0b000",
                "     if FPSCR.RN=0b01 then   // Round towards Zero",
                "        rmode := 0b001",
                "     if FPSCR.RN=0b10 then   // Round towards +Infinity",
                "        rmode := 0b010",
                "     if FPSCR.RN=0b11 then   // Round towards -Infinity",
                "        rmode := 0b011",
                "  end",
                "end",
                "else do // R=1",
                "  if RMC=0b00 then           // Round to Nearest Even",
                "     rmode := 0b000",
                "  if RMC=0b01 then           // Round towards Zero",
                "     rmode := 0b001",
                "  if RMC=0b10 then           // Round towards +Infinity",
                "     rmode := 0b010",
                "  if RMC=0b11 then           // Round towards -Infinity",
                "     rmode := 0b011",
                "end",
                "",
                "src := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "",
                "if src.class.SNaN then do",
                "  result := bfp128_CONVERT_FROM_BFP(bfp_QUIET(src))",
                "  vxsnan_flag := 1",
                "end",
                "else if src.class.QNaN     |",
                "       src.class.Infinity |",
                "       src.class.Zero  then",
                "  result := bfp128_CONVERT_FROM_BFP(src)",
                "else do",
                "  rnd    := bfp_ROUND_TO_INTEGER(rmode, src)",
                "  result := bfp128_CONVERT_FROM_BFP(rnd)",
                "end",
                "",
                "if vxsnan_flag=1  then SetFX(FPSCR.VXSNAN)",
                "if xx_flag & EX then SetFX(FPSCR.XX)",
                "",
                "vex_flag  := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[VRT+32] := result",
                "  FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := EX & (vxsnan_flag=0) & inc_flag",
                "FPSCR.FI := EX & (vxsnan_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let R and RMC specify the rounding mode as",
                "follows.",
                "",
                "",
                "",
                "",
                "Let src be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
                "",
                "If src is a Signalling NaN, an Invalid Operation",
                "exception occurs, VXSNAN is set to 1, and the result is",
                "the Quiet NaN corresponding to the Signalling NaN.",
                "",
                "Otherwise, if src is a Quiet NaN, an Infinity, or a Zero,",
                "then the result is src.",
                "",
                "Otherwise, src is rounded to an integer using the",
                "rounding mode rmode.",
                "",
                "The result is placed into VSR[VRT+32] in quad-precision",
                "format.",
                "",
                "FPRF is set to the class and sign of the result.",
                "",
                "For xsrqpi, FR is set to 0, FI is",
                "set to 0, and XX is not set by an Inexact exception.",
                "",
                "For xsrqpix, FR is set to indicate if the",
                "result was incremented when rounded, FI is set to",
                "indicate the result is inexact, and XX is set by an",
                "Inexact exception.",
                "",
                "If a trap-disabled Invalid Operation exception occurs, FPRF is set to an undefined value.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Round Quad-Precision to Double-Extended-Precision",
                    "form": "Z23",
                    "mnemonic": "xsrqpxp",
                    "operands": [
                        "R",
                        "VRT",
                        "VRB",
                        "RMC"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "RMC",
                    "size": "2"
                },
                {
                    "name": "37",
                    "size": "8"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "if R=0 then do",
                "  if RMC=0b00 then           // Round to Nearest Away",
                "     rmode := 0b100",
                "  if RMC=0b11 then do",
                "     if FPSCR.RN=0b00 then   // Round to Nearest Even",
                "        rmode := 0b000",
                "     if FPSCR.RN=0b01 then   // Round towards Zero",
                "        rmode := 0b001",
                "     if FPSCR.RN=0b10 then   // Round towards +Infinity",
                "        rmode := 0b010",
                "     if FPSCR.RN=0b11 then   // Round towards -Infinity",
                "        rmode := 0b011",
                "  end",
                "end",
                "else do // R=1",
                "  if RMC=0b00 then           // Round to Nearest Even",
                "     rmode := 0b000",
                "  if RMC=0b01 then           // Round towards Zero",
                "     rmode := 0b001",
                "  if RMC=0b10 then           // Round towards +Infinity",
                "     rmode := 0b010",
                "  if RMC=0b11 then           // Round towards -Infinity",
                "     rmode := 0b011",
                "end",
                "",
                "src    := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "rnd    := bfp_ROUND_TO_BFP80(rmode,src)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[VRT+32] := result",
                "  FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vxsnan_flag=0) & inc_flag",
                "FPSCR.FI := (vxsnan_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let R and RMC specify the rounding mode as",
                "follows.",
                "",
                "",
                "",
                "",
                "Let src be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
                "",
                "If src is a Signalling NaN, an Invalid Operation",
                "exception occurs, VXSNAN is set to 1, and the result is",
                "the Quiet NaN corresponding to the Signalling NaN, with the",
                "significand truncated to double-extended-precision.",
                "",
                "Otherwise, if src is a Quiet NaN, then the result is",
                "src with the significand truncated to",
                "double-extended-precision.",
                "",
                "Otherwise, if src is an Infinity or a Zero, the result is",
                "src.",
                "",
                "Otherwise, src is rounded to double-extended precision",
                "(i.e., 15-bit exponent range and 64-bit significand precision) using",
                "the specified rounding mode.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is placed into VSR[VRT+32] in quad-precision",
                "format.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the rounded result was",
                "incremented. FI is set to indicate the result is inexact.",
                "",
                "If a trap-disabled Invalid Operation exception occurs, FPRF is set to an undefined value, and FR and FI are set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Round to Single-Precision",
                    "form": "XX2",
                    "mnemonic": "xsrsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "281",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,src)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vex_flag := FPSCR.VE & vxsnan_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result64",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "src is rounded to single-precision using the rounding mode specified",
                "by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result as",
                "represented in single-precision format.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Reciprocal Square Root Estimate Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xsrsqrtedp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "74",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "v      := bfp_RECIPROCAL_SQUARE_ROOT_ESTIMATE(src)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vx_flag  := vxsnan_flag | vxsqrt_flag",
                "",
                "vex_flag := FPSCR.VE & vx_flag",
                "zex_flag := FPSCR.ZE & zx_flag",
                "",
                "if vex_flag=0 & zex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "  FPSCR.FR   := 0bU",
                "  FPSCR.FI   := 0bU",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "A double-precision floating-point  estimate of the reciprocal square",
                "root of src is placed into doubleword element 0 of",
                "VSR[XT] in double-precision format.",
                "",
                "Unless the reciprocal of the square root of src would be",
                "a zero, an infinity, or a QNaN, the estimate has a relative error in",
                "precision no greater than one part in 16384 of the reciprocal of the",
                "square root of src. That is,",
                "",
                "Operation with various special values of the operand is summarized",
                "below.",
                "",
                "",
                "",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to an undefined value.",
                "FI is set to an undefined value.",
                "",
                "If a trap-enabled invalid operation exception or a trap-enabled zero",
                "divide exception occurs, VSR[XT] and FPRF are",
                "not modified.",
                "",
                "The results of executing this instruction is permitted to vary",
                "between implementations, and between different executions on the same",
                "implementation.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Reciprocal Square Root Estimate Single-Precision",
                    "form": "XX2",
                    "mnemonic": "xsrsqrtesp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "10",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "v        := bfp_RECIPROCAL_SQUARE_ROOT_ESTIMATE(src)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if 0bU then SetFX(FPSCR.XX)",
                "if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "vx_flag  := vxsnan_flag | vxsqrt_flag",
                "",
                "vex_flag := FPSCR.VE & vx_flag",
                "zex_flag := FPSCR.ZE & zx_flag",
                "",
                "if vex_flag=0 & zex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result64",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "  FPSCR.FR   := 0bU",
                "  FPSCR.FI   := 0bU",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in doubleword",
                "element 0 of VSR[XB].",
                "",
                "A single-precision floating-point  estimate of the reciprocal square",
                "root of src is placed into doubleword element 0 of VSR[XT] in double-precision format.",
                "",
                "Unless the reciprocal of the square root of src would be a zero, an",
                "infinity, or a QNaN, the estimate has a relative error in precision",
                "no greater than one part in 16384 of the reciprocal of the square",
                "root of src. That is,",
                "",
                "Operation with various special values of the operand is summarized",
                "below.",
                "",
                "",
                "",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result as",
                "represented in single-precision format.",
                "FR is set to an undefined value.",
                "FI is set to an undefined value.",
                "",
                "If a trap-enabled invalid operation exception or a trap-enabled zero",
                "divide exception occurs, VSR[XT] and FPRF are",
                "not modified.",
                "",
                "The results of executing this instruction is permitted to vary",
                "between implementations, and between different executions on the same",
                "implementation.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Square Root Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xssqrtdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "75",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "v      := bfp_SQUARE_ROOT(src)",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxsqrt_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "The unbounded-precision square root of src is produced.",
                "",
                "See Table .",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Square Root Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xssqrtqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "VSX Scalar Square Root Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xssqrtqpo",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "27",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "804",
                    "size": "10"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src    := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_SQUARE_ROOT(src)",
                "rnd    := bfp_ROUND_TO_BFP128(RO,FPSCR.RN,v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxsqrt_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[VRT+32] := result",
                "  FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
                "",
                "If src is a Signalling NaN, an Invalid Operation",
                "exception occurs and VXSNAN is set to 1.",
                "",
                "If src is a negative, non-zero value, an Invalid",
                "Operation exception occurs and VXSQRT is set to 1.",
                "",
                "If src is a Signalling NaN, the result is the Quiet NaN",
                "corresponding to src.",
                "",
                "Otherwise, if src is a Quiet NaN, the result is",
                "src.",
                "",
                "Otherwise, if src is a negative value, the result is the",
                "default Quiet NaN.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "The normalized square root of src is produced with",
                "unbounded significand precision and exponent range.",
                "",
                "",
                "See",
                "Table,",
                "Actions for xssqrtqp[o], on",
                "pagetable:PPC1ChVSX-Table-15-Actions-for-bfp128-square-root-src.",
                "",
                "",
                "If RO=1, let the rounding mode be Round to Odd.",
                "Otherwise, let the rounding mode be specified by RN.",
                "Unless the result is an Infinity or a Zero, the intermediate result",
                "is rounded to quad-precision using the specified rounding mode.",
                "",
                "",
                "See Section, Rounding on",
                "pagesec:PPC1ChVSX-Rounding for a description of rounding",
                "modes.",
                "",
                "",
                "If there is loss of precision, an Inexact exception occurs.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into VSR[VRT+32] in quad-precision",
                "format.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the rounded result was",
                "incremented. FI is set to indicate the result is inexact.",
                "",
                "If a trap-disabled Invalid Operation exception occurs, FPRF is set to an undefined value, and FR and FI are set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Square Root Single-Precision",
                    "form": "XX2",
                    "mnemonic": "xssqrtsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "11",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src      := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "v        := bfp_SQUARE_ROOT(src)",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag := vxsnan_flag | vxsqrt_flag",
                "",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result64",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "The unbounded-precision square root of src is produced.",
                "",
                "See Table .",
                "",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT]",
                "in double-precision format.",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result as",
                "represented in single-precision format.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Subtract Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xssubdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "40",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "src2   := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "v      := bfp_ADD(src1,bfp_NEGATE(src2))",
                "rnd    := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "result := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP64(result)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "src2 is negated and added to src1, producing a",
                "sum having unbounded range and precision.",
                "",
                "See Table .",
                "",
                "The sum is normalized.",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT].",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Subtract Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xssubqp",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "0"
                        }
                    ],
                    "release": "v3.0"
                },
                {
                    "name": "VSX Scalar Subtract Quad-Precision [using round to Odd]",
                    "form": "X",
                    "mnemonic": "xssubqpo",
                    "operands": [
                        "VRT",
                        "VRA",
                        "VRB"
                    ],
                    "conditions": [
                        {
                            "field": "RO",
                            "value": "1"
                        }
                    ],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "VRA",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "516",
                    "size": "10"
                },
                {
                    "name": "RO",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1   := bfp_CONVERT_FROM_BFP128(VSR[VRA+32])",
                "src2   := bfp_CONVERT_FROM_BFP128(VSR[VRB+32])",
                "v      := bfp_ADD(src1, bfp_NEGATE(src2))",
                "rnd    := bfp_ROUND_TO_BFP128(RO,FPSCR.RN,v)",
                "result := bfp128_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[VRT+32] := result",
                "  FPSCR.FPRF  := fprf_CLASS_BFP128(result)",
                "end",
                "FPSCR.FR := (vx_flag=0) & inc_flag",
                "FPSCR.FI := (vx_flag=0) & xx_flag"
            ],
            "body": [
                "",
                "",
                "Let src1 be the floating-point value in VSR[VRA+32] represented in quad-precision format.",
                "",
                "Let src2 be the floating-point value in VSR[VRB+32] represented in quad-precision format.",
                "",
                "If either src1 or src2 is a Signalling NaN,",
                "an Invalid Operation exception occurs and VXSNAN is set",
                "to 1.",
                "",
                "If src1 and src2 are Infinity values having",
                "same signs, an Invalid Operation exception occurs and VXISI is set to 1.",
                "",
                "If src1 is a Signalling NaN, the result is the Quiet NaN",
                "corresponding to src1.",
                "",
                "Otherwise, if src1 is a Quiet NaN, the result is",
                "src1.",
                "",
                "Otherwise, if src2 is a Signalling NaN, the result is the",
                "Quiet NaN corresponding to src2.",
                "",
                "Otherwise, if src2 is a Quiet NaN, the result is",
                "src2.",
                "",
                "Otherwise, if src1 and src2 are Infinity",
                "values having same signs, the result is the default Quiet",
                "NaN.",
                "",
                "Otherwise, do the following.",
                "",
                "",
                "",
                "The normalized sum of the negation of src2 added to",
                "src1 is produced with unbounded significand precision and",
                "exponent range.",
                "",
                "",
                "See Table, Actions",
                "for xssubqp[o], on",
                "pagetable:PPC1ChVSX-Table-2-Actions-for-xpsub.",
                "",
                "",
                "If the intermediate result is Tiny (i.e., the unbiased",
                "exponent is less than -16382) and UE=0, the",
                "significand is shifted right N bits, where N",
                "is the difference between -16382 and the unbiased",
                "exponent of the intermediate result.",
                "The exponent of the intermediate result is set to the value",
                "-16382.",
                "",
                "",
                "If RO=1, let the rounding mode be Round to Odd.",
                "Otherwise, let the rounding mode be specified by RN.",
                "Unless the result is an Infinity or a Zero, the intermediate result",
                "is rounded to quad-precision using the specified rounding mode.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into VSR[VRT+32] in quad-precision",
                "format.",
                "",
                "FPRF is set to the class and sign of the result.",
                "FR is set to indicate if the rounded result was",
                "incremented. FI is set to indicate the result is inexact.",
                "",
                "If a trap-disabled Invalid Operation exception occurs, FPRF is set to an undefined value, and FR and FI are set to 0.",
                "",
                "If a trap-enabled Invalid Operation exception occurs, VSR[VRT+32] and FPRF are not modified, and FR and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Subtract Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xssubsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "8",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_xflags()",
                "",
                "src1     := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[0])",
                "src2     := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[0])",
                "v        := bfp_ADD(src1,bfp_NEGATE(src2))",
                "rnd      := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "result32 := bfp32_CONVERT_FROM_BFP(rnd)",
                "result64 := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "if ox_flag=1 then SetFX(FPSCR.OX)",
                "if ux_flag=1 then SetFX(FPSCR.UX)",
                "if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "vx_flag  := vxsnan_flag | vxisi_flag",
                "vex_flag := FPSCR.VE & vx_flag",
                "",
                "if vex_flag=0 then do",
                "  VSR[32*TX+T].dword[0] := result64",
                "  VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000",
                "  FPSCR.FPRF := fprf_CLASS_BFP32(result32)",
                "  FPSCR.FR   := inc_flag",
                "  FPSCR.FI   := xx_flag",
                "end",
                "else do",
                "  FPSCR.FR   := 0b0",
                "  FPSCR.FI   := 0b0",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "src2 is negated and added to src1, producing",
                "the sum, v, having unbounded range and precision.",
                "",
                "See Table,",
                "Actions for xssubsp, on",
                "pagetable:PPC1ChVSX-Table-79-Actions-for-xssubsp.",
                "",
                "v is normalized and rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "The result is placed into doubleword element 0 of VSR[XT].",
                "",
                "The contents of doubleword element 1 of VSR[XT] are set",
                "to 0.",
                "",
                "FPRF is set to the class and sign of the result as",
                "represented in single-precision format.",
                "FR is set to indicate if the result was incremented when",
                "rounded. FI is set to indicate the result is inexact.",
                "",
                "If a trap-enabled invalid operation exception occurs, VSR[XT] and FPRF are not modified, and FR",
                "and FI are set to 0.",
                "",
                "See Table, VSX",
                "Scalar Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Scalar-Floating-Point-Results.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Test for software Divide Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xstdivdp",
                    "operands": [
                        "BF",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "61",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1    := VSR[32*AX+A].dword[0]",
                "src2    := VSR[32*BX+B].dword[0]",
                "e_a     := src1.bit[1:11] - 1023",
                "e_b     := src2.bit[1:11] - 1023",
                "fe_flag := IsNaN(src1) | IsInf(src1) |",
                "          IsNaN(src2) | IsInf(src2) | IsZero(src2) |",
                "          ( e_b <= -1022 ) |",
                "          ( e_b >=  1021 ) |",
                "          ( !IsZero(src1) & ( (e_a - e_b) >=  1023 ) ) |",
                "          ( !IsZero(src1) & ( (e_a - e_b) <= -1021 ) ) |",
                "          ( !IsZero(src1) & ( e_a <= -970 ) )",
                "fg_flag := IsInf(src1) | IsInf(src2) |",
                "          IsZero(src2) | IsDen(src2)",
                "fl_flag := xsredp_error() <= 2<sup>-14</sup>",
                "CR[BF]  := 0b1 || fg_flag || fe_flag || 0b0"
            ],
            "body": [
                "",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src1 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XA].",
                "",
                "Let src2 be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "Let e_a be the unbiased exponent of src1.",
                "",
                "Let e_b be the unbiased exponent of src2.",
                "",
                "fe_flag is set to 1 for any of the following conditions.",
                "",
                "",
                "",
                "Otherwise fe_flag is set to 0.",
                "",
                "fg_flag is set to 1 for any of the following conditions.",
                "",
                "",
                "",
                "Otherwise fg_flag is set to 0.",
                "",
                "CR field BF is set to the value 0b1||fg_flag||fe_flag||0b0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Test for software Square Root Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xstsqrtdp",
                    "operands": [
                        "BF",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "7"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "106",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src     := VSR[32*BX+B].dword[0]",
                "e_b     := src.bit[1:11] - 1023",
                "fe_flag := IsNaN(src) | IsInf(src) | IsZero(src) |",
                "          IsNeg(src) | ( e_b <= -970 )",
                "fg_flag := IsInf(src) | IsZero(src) | IsDen(src)",
                "fl_flag := xsrsqrtedp_error() <= 2<sup>-14</sup>",
                "",
                "CR.field[BF] := 0b1 || fg_flag || fe_flag || 0b0"
            ],
            "body": [
                "",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "Let e_b be the unbiased exponent of src.",
                "",
                "fe_flag is set to 1 for any of the following conditions.",
                "",
                "",
                "",
                "Otherwise fe_flag is set to 0.",
                "",
                "fg_flag is set to 1 for any of the following conditions.",
                "",
                "",
                "",
                "Otherwise fg_flag is set to 0.",
                "",
                "CR field BF is set to the value 0b1||fg_flag||fe_flag||0b0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Test Data Class Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xststdcdp",
                    "operands": [
                        "BF",
                        "XB",
                        "DCMX"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "DCMX",
                    "size": "7"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "362",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src            := VSR[32*BX+B].dword[0]",
                "exponent       := src.bit[1:11]",
                "fraction       := src.bit[12:63]",
                "",
                "class.Infinity := (exponent = 0x7FF) & (fraction  = 0)",
                "class.NaN      := (exponent = 0x7FF) & (fraction != 0)",
                "class.Zero     := (exponent = 0x000) & (fraction  = 0)",
                "class.Denormal := (exponent = 0x000) & (fraction != 0)",
                "",
                "match          := (DCMX.bit[0] & class.NaN)              |",
                " (DCMX.bit[1] & class.Infinity & !sign) |",
                " (DCMX.bit[2] & class.Infinity &  sign) |",
                " (DCMX.bit[3] & class.Zero     & !sign) |",
                " (DCMX.bit[4] & class.Zero     &  sign) |",
                " (DCMX.bit[5] & class.Denormal & !sign) |",
                " (DCMX.bit[6] & class.Denormal &  sign)",
                "",
                "CR.bit[4*BF+32] := FPSCR.FL := src.sign",
                "CR.bit[4*BF+33] := FPSCR.FG := 0b0",
                "CR.bit[4*BF+34] := FPSCR.FE := match",
                "CR.bit[4*BF+35] := FPSCR.FU := 0b0"
            ],
            "body": [
                "",
                "",
                "Let XB be the sum 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "Bit 0 of CR field BF and bit 0 of FPCC are set to the sign bit of src.",
                "",
                "Bit 1 of CR field BF and bit 1 of FPCC are set to 0b0.",
                "",
                "Bit 2 of CR field BF and bit 2 of FPCC are set to indicate whether the data class of src,",
                "as represented in double-precision format, matches any of the data",
                "classes specified by DCMX (Data Class Mask).",
                "",
                "",
                "",
                "",
                "Bit 3 of CR field BF and bit 3 of FPCC are set to 0b0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Test Data Class Quad-Precision",
                    "form": "X",
                    "mnemonic": "xststdcqp",
                    "operands": [
                        "BF",
                        "VRB",
                        "DCMX"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "DCMX",
                    "size": "7"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "708",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src            := VSR[VRB+32]",
                "exponent       := src.bit[1:15]",
                "fraction       := src.bit[16:127]",
                "",
                "class.Infinity := (exponent = 0x7FFF) & (fraction  = 0)",
                "class.NaN      := (exponent = 0x7FFF) & (fraction != 0)",
                "class.Zero     := (exponent = 0x0000) & (fraction  = 0)",
                "class.Denormal := (exponent = 0x0000) & (fraction != 0)",
                "",
                "match          := (DCMX.bit[0] & class.NaN)              |",
                " (DCMX.bit[1] & class.Infinity & !sign) |",
                " (DCMX.bit[2] & class.Infinity &  sign) |",
                " (DCMX.bit[3] & class.Zero     & !sign) |",
                " (DCMX.bit[4] & class.Zero     &  sign) |",
                " (DCMX.bit[5] & class.Denormal & !sign) |",
                " (DCMX.bit[6] & class.Denormal &  sign)",
                "",
                "CR.bit[4*BF+32] := FPSCR.FL := src.sign",
                "CR.bit[4*BF+33] := FPSCR.FG := 0b0",
                "CR.bit[4*BF+34] := FPSCR.FE := match",
                "CR.bit[4*BF+35] := FPSCR.FU := 0b0"
            ],
            "body": [
                "",
                "",
                "Let src be the quad-precision floating-point value in",
                "VSR[VRB+32].",
                "",
                "Let the DCMX (Data Class Mask) field specify one or more",
                "of the 7 possible data classes, where each bit corresponds to a",
                "specific data class.",
                "",
                "",
                "",
                "",
                "Bit 0 of CR field BF and bit 0 of FPCC are set to the sign of src.",
                "",
                "Bit 1 of CR field BF and bit 1 of FPCC are set to 0b0.",
                "",
                "Bit 2 of CR field BF and bit 2 of FPCC are set to indicate whether the data class of src,",
                "as represented in quad-precision format, matches any of the data",
                "classes specified by DCM.",
                "",
                "Bit 3 of CR field BF and bit 3 of FPCC are set to 0b0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Test Data Class Single-Precision",
                    "form": "XX2",
                    "mnemonic": "xststdcsp",
                    "operands": [
                        "BF",
                        "XB",
                        "DCMX"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "DCMX",
                    "size": "7"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "298",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src            := VSR[32*BX+B].dword[0]",
                "exponent       := src.bit[1:11]",
                "fraction       := src.bit[12:63]",
                "",
                "class.Infinity := (exponent = 0x7FF) & (fraction  = 0)",
                "class.NaN      := (exponent = 0x7FF) & (fraction != 0)",
                "class.Zero     := (exponent = 0x000) & (fraction  = 0)",
                "class.Denormal := (exponent = 0x000) & (fraction != 0) |",
                " (exponent > 0x000) & (exponent < 0x381)",
                "",
                "match          := (DCMX.bit[0] & class.NaN)              |",
                " (DCMX.bit[1] & class.Infinity & !sign) |",
                " (DCMX.bit[2] & class.Infinity &  sign) |",
                " (DCMX.bit[3] & class.Zero     & !sign) |",
                " (DCMX.bit[4] & class.Zero     &  sign) |",
                " (DCMX.bit[5] & class.Denormal & !sign) |",
                " (DCMX.bit[6] & class.Denormal &  sign)",
                "",
                "not_SP_value   := (src != Convert_SPtoDP(Convert_DPtoSP(src)))",
                "",
                "CR.bit[4*BF]   := FPSCR.FL := src.sign",
                "CR.bit[4*BF+1] := FPSCR.FG := 0b0",
                "CR.bit[4*BF+2] := FPSCR.FE := match",
                "CR.bit[4*BF+3] := FPSCR.FU := not_SP_value"
            ],
            "body": [
                "",
                "",
                "Let XB be the sum 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "Bit 0 of CR field BF and bit 0 of FPCC are set to the sign bit of src.",
                "",
                "Bit 1 of CR field BF and bit 1 of FPCC are set to 0b0.",
                "",
                "Bit 2 of CR field BF and bit 2 of FPCC are set to indicate whether the data class of src,",
                "as represented in single-precision format, matches any of the data",
                "classes specified by DCMX (Data Class Mask).",
                "",
                "",
                "",
                "",
                "Bit 3 of CR field BF and bit 3 of FPCC are set to indicate if src is not representable in",
                "single-precision format.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Extract Exponent Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xsxexpdp",
                    "operands": [
                        "RT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "347",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src := VSR[32*BX+B].dword[0]",
                "",
                "GPR[RT] := (src >> 52) & 0x0000_0000_0000_07FF"
            ],
            "body": [
                "",
                "",
                "Let XB be the sum 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "The value of the exponent field in src is placed into",
                "GPR[RT] in unsigned integer format.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Extract Exponent Quad-Precision",
                    "form": "X",
                    "mnemonic": "xsxexpqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "2",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "804",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src := VSR[VRB+32]",
                "VSR[VRT+32].dword[0] := EXTZ64(src.bit[1:15]), 64)",
                "VSR[VRT+32].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let src be the quad-precision floating-point value in",
                "VSR[VRB+32].",
                "",
                "The contents of the exponent field of src (bits 1:15) are",
                "zero-extended and placed into doubleword 0 of VSR[VRT+32].",
                "",
                "The contents of doubleword 1 of VSR[VRT+32] are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Extract Significand Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xsxsigdp",
                    "operands": [
                        "RT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "347",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "exponent := VSR[32*BX+B].bit[1:11]",
                "fraction := EXTZ64(VSR[32*BX+B].bit[12:63])",
                "",
                "if (exponent != 0) & (exponent != 2047) then",
                "  significand := fraction | 0x0010_0000_0000_0000",
                "else",
                "  significand := fraction",
                "",
                "GPR[RT] := significand"
            ],
            "body": [
                "",
                "",
                "Let XB be the sum 32BX + B.",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element 0 of VSR[XB].",
                "",
                "The significand of src is placed into GPR[RT]",
                "in unsigned integer format.",
                "If src is a normal value, the implicit leading bit is set",
                "to 1.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Scalar Extract Significand Quad-Precision",
                    "form": "X",
                    "mnemonic": "xsxsigqp",
                    "operands": [
                        "VRT",
                        "VRB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "63",
                    "size": "6"
                },
                {
                    "name": "VRT",
                    "size": "5"
                },
                {
                    "name": "18",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "804",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src      := VSR[VRB+32]",
                "exponent := EXTZ(src.bit[1:15])",
                "fraction := EXTZ128(src.bit[16:127])",
                "",
                "if (exponent != 0) &  (exponent != 32767) then",
                "  VSR[VRT+32] := fraction |",
                "                   0x0001_0000_0000_0000_0000_0000_0000_0000",
                "else",
                "  VSR[VRT+32] := fraction"
            ],
            "body": [
                "",
                "",
                "Let src be the quad-precision floating-point value in",
                "VSR[VRB+32].",
                "",
                "The significand of src is placed into VSR[VRT+32].",
                "",
                "If the value of the exponent field of src is equal to",
                "0b000_0000_0000_0000 (i.e., Zero or Denormal value) or",
                "0b111_1111_1111_1111 (i.e., Infinity or NaN),",
                "0b0 is placed into bit 15 of VSR[VRT+32].",
                "Otherwise (i.e., Normal value), 0b1 is placed into bit 15",
                "of VSR[VRT+32].",
                "The contents of bits 0:14 of VSR[VRT+32] are set to 0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Absolute Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xvabsdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "473",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src := VSR[32*BX+B].dword[i]",
                "  VSR[32*TX+T].dword[i] := bfp64_ABSOLUTE(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The contents of doubleword element i of VSR[XB], with bit 0 set to 0, is placed into doubleword element",
                "i of VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_abs"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Absolute Single-Precision",
                    "form": "XX2",
                    "mnemonic": "xvabssp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "409",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src := VSR[32*BX+B].word[i]",
                "  VSR[32*TX+T].word[i] := bfp32_ABSOLUTE(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The contents of word element i of VSR[XB],",
                "with bit 0 set to 0, is placed into word element i of",
                "VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_abs"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Add Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvadddp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "96",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[i])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  v    := bfp_ADD(src1,src2)",
                "  rnd  := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XA].",
                "",
                "",
                "Let src2 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XB].",
                "",
                "",
                "src2 is added to src1, producing a",
                "sum having unbounded range and precision.",
                "",
                "",
                "The sum is normalized.",
                "",
                "",
                "See Table .",
                "",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[XT] in double-precision format.",
                "",
                "",
                "See Table,",
                "Vector Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_add",
                "vec_rsqrt"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Add Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvaddsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "64",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src1 := bfp_CONVERT_FROM_BFP32(VSR[32*AX+A].word[i])",
                "  src2 := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "  v    := bfp_ADD(src1,src2)",
                "  rnd  := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point operand",
                "in word element i of VSR[XA].",
                "",
                "",
                "Let src2 be the single-precision floating-point operand",
                "in word element i of VSR[XB].",
                "",
                "",
                "src2 is added to src1, producing a",
                "sum having unbounded range and precision.",
                "",
                "",
                "The sum is normalized.",
                "",
                "",
                "See Table .",
                "",
                "",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into word element i of VSR[XT] in single-precision format.",
                "",
                "",
                "See Table,",
                "Vector Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_add"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector bfloat16 GER (rank-2 update)",
                    "form": "XX3",
                    "mnemonic": "xvbf16ger2",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector bfloat16 GER (rank-2 update) Positive multiply, Positive accumulate",
                    "form": "XX3",
                    "mnemonic": "xvbf16ger2pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector bfloat16 GER (rank-2 update) Positive multiply, Negative accumulate",
                    "form": "XX3",
                    "mnemonic": "xvbf16ger2pn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector bfloat16 GER (rank-2 update) Negative multiply, Positive accumulate",
                    "form": "XX3",
                    "mnemonic": "xvbf16ger2np",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector bfloat16 GER (rank-2 update) Negative multiply, Negative accumulate",
                    "form": "XX3",
                    "mnemonic": "xvbf16ger2nn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update)",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvbf16ger2",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update) Positive multiply, Positive accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvbf16ger2pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update) Positive multiply, Negative accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvbf16ger2pn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update) Negative multiply, Positive accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvbf16ger2np",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector bfloat16 GER (rank-2 update) Negative multiply, Negative accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvbf16ger2nn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "121",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "242",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \"xvbf16ger2\" | \"xvbf16ger2pp\" | \"xvbf16ger2pn\" | \"xvbf16ger2np\" | \"xvbf16ger2nn\" then do",
                "  PMSK := 0b11      // enable all rank updates",
                "  XMSK := 0b1111    // enable all ACC[AT] rows",
                "  YMSK := 0b1111    // enable all ACC[AT] columns",
                "end",
                "",
                "do i = 0 to 3",
                "  do j = 0 to 3",
                "     if XMSK.bit[i]=1 & YMSK.bit[j]=1 then do",
                "        src11 := (PMSK.bit[0]=0) ? bfp_ZERO : bfp_CONVERT_FROM_BFLOAT16(VSR[32*AX+A].word[i].hword[0])",
                "        src21 := (PMSK.bit[0]=0) ? bfp_ZERO : bfp_CONVERT_FROM_BFLOAT16(VSR[32*BX+B].word[j].hword[0])",
                "        src12 := (PMSK.bit[1]=0) ? bfp_ZERO : bfp_CONVERT_FROM_BFLOAT16(VSR[32*AX+A].word[i].hword[1])",
                "        src22 := (PMSK.bit[1]=0) ? bfp_ZERO : bfp_CONVERT_FROM_BFLOAT16(VSR[32*BX+B].word[j].hword[1])",
                "",
                "        reset_flags()",
                "",
                "        p1 := bfp_MULTIPLY(src11, src21)",
                "        v1 := bfp_MULTIPLY_ADD(src12, src22, p1)",
                "        r1 := bfp_ROUND_TO_BFP32_SIGNIFICAND(v1)",
                "",
                "        if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "        if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "        if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "        if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "        if \"[pm]xvbf16ger2\" then do",
                "           reset_flags()",
                "",
                "           r2 := bfp_ROUND_TO_BFP32_DEFAULT(FPSCR.RN,r1)",
                "           ACC[AT][i].word[j] := bfp32_CONVERT_FROM_BFP(r2)",
                "",
                "           if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "           if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "           if ox_flag=1 then SetFX(FPSCR.OX)",
                "           if ux_flag=1 then SetFX(FPSCR.UX)",
                "           if xx_flag=1 then SetFX(FPSCR.XX)",
                "        end",
                "",
                "        else do",
                "           acc := bfp_CONVERT_FROM_BFP32(ACC[AT][i].word[j])",
                "",
                "           reset_flags()",
                "",
                "           if \"[pm]xvbf16ger2pp\" then v := bfp_ADD(r1, acc)",
                "           if \"[pm]xvbf16ger2pn\" then v := bfp_ADD(r1, bfp_NEGATE(acc))",
                "           if \"[pm]xvbf16ger2np\" then v := bfp_ADD(bfp_NEGATE(r1), acc)",
                "           if \"[pm]xvbf16ger2nn\" then v := bfp_ADD(bfp_NEGATE(r1), bfp_NEGATE(acc))",
                "",
                "           r2 := bfp_ROUND_TO_BFP32_DEFAULT(FPSCR.RN,v)",
                "           ACC[AT][i].word[j] := bfp32_CONVERT_FROM_BFP(r2)",
                "",
                "           if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "           if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "           if ox_flag=1 then SetFX(FPSCR.OX)",
                "           if ux_flag=1 then SetFX(FPSCR.UX)",
                "           if xx_flag=1 then SetFX(FPSCR.XX)",
                "        end",
                "     end",
                "     else",
                "        ACC[AT][i][j] := 0x0000_0000",
                "  end",
                "end"
            ],
            "body": [
                "",
                "Let XA be the value of 32AX + A.",
                "If XA is in the range 4AT to",
                "4AT+3, the instruction form is invalid.",
                "",
                "Let XB be the value of 32BX + B.",
                "If XB is in the range 4AT to",
                "4AT+3, the instruction form is invalid.",
                "",
                "Let the contents of ACC[AT] be a 44",
                "matrix of single-precision floating-point values.",
                "",
                "For xvbf16ger2, xvbf16ger2pp, xvbf16ger2pn, xvbf16ger2np, or xvbf16ger2nn,",
                "let PMSK=0b11, XMSK=0b1111, and YMSK=0b1111.",
                "",
                "For each integer value i from 0 to 3, and each integer",
                "value j from 0 to 3, do the following.",
                "",
                "",
                "",
                "If bit i of XMSK is equal to 1 and bit",
                "j of YMSK is equal to 1, do the following.",
                "",
                "",
                "",
                "If bit 0 of PMSK is equal to 1, let src10 be",
                "the bfloat16 floating-point value in halfword 0 of word element",
                "i of VSR[XA] and let src20 be the",
                "bfloat16 floating-point value in halfword 0 of word element",
                "j of VSR[XB].",
                "Otherwise, let src10 be the value 0.0 and let src20 be the value 0.0, causing the product of src10 and",
                "src20 to be 0.0.",
                "",
                "",
                "If bit 1 of PMSK is equal to 1, let src11 be",
                "the bfloat16 floating-point value in halfword 1 of word element",
                "i of VSR[XA] and let src21 be the",
                "bfloat16 floating-point value in halfword 1 of word element",
                "j of VSR[XB].",
                "Otherwise, let src11 be the value 0.0 and let src21 be the value 0.0, causing the product of src11 and",
                "src21 to be 0.0.",
                "",
                "",
                "Let prod be the product of src10 and",
                "src20, having infinite precision and unbounded exponent",
                "range.",
                "",
                "",
                "Let psum be the sum of the product, src11",
                "multiplied by src21, and prod, having",
                "infinite precision and unbounded exponent range.",
                "",
                "",
                "Let r1 be the value psum with its significand",
                "rounded to 24-bit precision using the rounding mode specified by",
                "RN, but retaining unbounded exponent range (i.e., cannot",
                "overflow or underflow).",
                "",
                "",
                "For [pm]xvbf16ger2, do the",
                "following.",
                "",
                "",
                "",
                "Let r2 be the value r1 rounded to 24-bit",
                "significand precision and 8-bit exponent range (i.e.,",
                "single-precision) using the rounding mode specified by RN.",
                "",
                "",
                "r2 is placed into word element j of",
                "ACC[AT][i] in single-precision floating-point format.",
                "",
                "",
                "",
                "For [pm]xvbf16ger2pp, do the",
                "following.",
                "",
                "",
                "",
                "Let v2 be the sum of r1 added to the",
                "single-precision floating-point value in word element j",
                "of ACC[AT][i], having infinite precision and unbounded",
                "exponent range.",
                "",
                "",
                "Let r2 be the value v2 rounded to 24-bit",
                "significand precision and 8-bit exponent range (i.e.,",
                "single-precision) using the rounding mode specified by RN.",
                "",
                "",
                "r2 is placed into word element j of",
                "ACC[AT][i] in single-precision floating-point format.",
                "",
                "",
                "",
                "For [pm]xvbf16ger2pn, do the",
                "following.",
                "",
                "",
                "",
                "Let v2 be the sum of r2 added to the negation",
                "of the single-precision floating-point value in word element",
                "j of ACC[AT][i], having infinite precision",
                "and unbounded exponent range.",
                "",
                "",
                "Let r2 be the value v2 rounded to 24-bit",
                "significand precision and 8-bit exponent range (i.e.,",
                "single-precision) using the rounding mode specified by RN.",
                "",
                "",
                "r2 is placed into word element j of",
                "ACC[AT][i] in single-precision floating-point format.",
                "",
                "",
                "",
                "For [pm]xvbf16ger2np, do the",
                "following.",
                "",
                "",
                "",
                "Let v2 be the sum of the negation of r2 added",
                "to the single-precision floating-point value in word element",
                "j of ACC[AT][i], having infinite precision",
                "and unbounded exponent range.",
                "",
                "",
                "Let r3 be the value v3 rounded to 24-bit",
                "significand precision and 8-bit exponent range (i.e.,",
                "single-precision) using the rounding mode specified by RN.",
                "",
                "",
                "r2 is placed into word element j of",
                "ACC[AT][i] in single-precision floating-point format.",
                "",
                "",
                "",
                "For [pm]xvbf16ger2nn, do the",
                "following.",
                "",
                "",
                "",
                "Let v2 be the sum of the negation of r2 added",
                "to the negation of the single-precision floating-point value in word",
                "element j of ACC[AT][i], having infinite",
                "precision and unbounded exponent range.",
                "",
                "",
                "Let r2 be the value v3 rounded to 24-bit",
                "significand precision and 8-bit exponent range (i.e.,",
                "single-precision) using the rounding mode specified by RN.",
                "",
                "",
                "r2 is placed into word element j of",
                "ACC[AT][i] in single-precision floating-point format.",
                "",
                "",
                "",
                "Otherwise, the contents of word element j of ACC[AT][i] are set to 0x0000_0000.",
                "",
                "",
                "Unlike most other VSX Vector Floating-Point instructions,",
                "this instruction always updates the target register (here, ACC[AT],",
                "even when a trap-enabled exception occurs.",
                "For every multiply-add operation that is performed as part of the",
                "execution of this instruction, the operation is performed as if all",
                "exception enable bits are zero, and the trap-disabled result is",
                "returned.",
                "If the operation causes underflow or produces an inexact result,",
                "whether the operation causes an Underflow or Inexact exception is",
                "based on the actual contents of the Underflow and Overflow Enable",
                "bits.",
                "Exception status is accumulated and the appropriate exception status",
                "bits in the FPSCR are updated at the completion of execution of the",
                "instruction.",
                "Otherwise, behavior is the same as any vector floating-point",
                "instruction that can cause an exception.",
                "Taking a Program interrupt on a trap-enabled exception when",
                "interrupts are enabled by MSR.FE0 and MSR.FE1",
                "is still supported, albeit with ACC[AT] updated based on",
                "a trap-disabled result.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Compare Equal To Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvcmpeqdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Vector Compare Equal To Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvcmpeqdp.",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "99",
                    "size": "7"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[i])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "",
                "  vxsnan_flag := IsSNaN(src1) | IsSNaN(src2)",
                "",
                "  if src1 = src2 then do",
                "     vresult.dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "     all_false        := 0b0",
                "  end",
                "  else do",
                "     vresult.dword[i] := 0x0000_0000_0000_0000",
                "     all_true         := 0b0",
                "  end",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "  if vex_flag=0 then",
                "     CR[6] := all_true || 0b0 || all_false || 0b0",
                "  else",
                "     CR[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XA].",
                "",
                "",
                "Let src2 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XB].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of doubleword element i of VSR[XT] are set",
                "to all 1s if src1 is equal to src2, and is",
                "set to all 0s otherwise.",
                "",
                "",
                "A NaN input causes the comparison to return false for that element.",
                "",
                "",
                "Two zero inputs of same or different signs return true for that",
                "element.",
                "",
                "",
                "Two infinity inputs of same signs return true for that element.",
                "",
                "",
                "If Rc=1, CR Field 6 is set as follows.",
                "",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT] and the contents of CR",
                "field 6 are undefined if Rc is equal to 1.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpeq",
                "vec_cmpne",
                "vec_all_eq",
                "vec_all_nan",
                "vec_all_ne",
                "vec_all_nge",
                "vec_all_numeric",
                "vec_any_eq",
                "vec_any_nan",
                "vec_any_ne",
                "vec_any_numeric"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Compare Equal To Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvcmpeqsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Vector Compare Equal To Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvcmpeqsp.",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "67",
                    "size": "7"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src1 := bfp_CONVERT_FROM_BFP32(VSR[32*AX+A].word[i])",
                "  src2 := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "",
                "  vxsnan_flag := IsSNaN(src1) | IsSNaN(src2)",
                "",
                "  if src1 = src2 then do",
                "     vresult.word[i] := 0xFFFF_FFFF",
                "     all_false       := 0b0",
                "  end",
                "  else do",
                "     vresult.word[i] := 0x0000_0000",
                "     all_true        := 0b0",
                "  end",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "  if vex_flag=0 then",
                "     CR.field[6] := all_true || 0b0 || all_false || 0b0",
                "  else",
                "     CR.field[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point operand",
                "in word element i of VSR[XA].",
                "",
                "",
                "Let src2 be the single-precision floating-point operand",
                "in word element i of VSR[XB].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of word element i of VSR[XT] are",
                "set to all 1s if src1 is equal to src2, and",
                "is set to all 0s otherwise.",
                "",
                "",
                "A NaN input causes the comparison to return false for that element.",
                "",
                "",
                "Two zero inputs of same or different signs return true for that",
                "element.",
                "",
                "",
                "Two infinity inputs of same signs return true for that element.",
                "",
                "",
                "If Rc=1, CR Field 6 is set as follows.",
                "",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT] and the contents of CR",
                "field 6 are undefined if Rc is equal to 1.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpeq",
                "vec_cmpne",
                "vec_all_eq",
                "vec_all_nan",
                "vec_all_ne",
                "vec_all_nge",
                "vec_all_numeric",
                "vec_any_eq",
                "vec_any_nan",
                "vec_any_ne",
                "vec_any_numeric"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Compare Greater Than or Equal To Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvcmpgedp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Vector Compare Greater Than or Equal To Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvcmpgedp.",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "115",
                    "size": "7"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[i])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "",
                "  if src1.class.SNaN | src2.class.SNaN then do",
                "     vxsnan_flag := 0b1",
                "     if FPSCR.VE=0 then vxvc_flag := 0b1",
                "  end",
                "  else vxvc_flag := IsQNaN(src1) | IsQNaN(src2)",
                "",
                "  if src1 >= src2 then do",
                "     vresult.dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "     all_false        := 0b0",
                "  end",
                "  else do",
                "     vresult.dword[i] := 0x0000_0000_0000_0000",
                "     all_true         := 0b0",
                "  end",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxvc_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "  if vex_flag=0 then",
                "     CR.field[6] := all_true || 0b0 || all_false || 0b0",
                "  else",
                "     CR.field[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XA].",
                "",
                "",
                "Let src2 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XB].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of doubleword element i of VSR[XT] are set to all 1s if src1 is greater than or",
                "equal to the double-precision floating-point operand in doubleword",
                "element i of src2, and is set to all 0s otherwise.",
                "",
                "",
                "A NaN input causes the comparison to return false for that element.",
                "",
                "",
                "Two zero inputs of same or different signs return true for that",
                "element.",
                "",
                "",
                "Two infinity inputs of same signs return true for that element.",
                "",
                "",
                "If Rc=1, CR Field 6 is set as follows.",
                "",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT] and the contents of CR",
                "field 6 are undefined if Rc is equal to 1.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpge",
                "vec_cmple",
                "vec_all_ge",
                "vec_all_le",
                "vec_all_nle",
                "vec_any_ge",
                "vec_any_le",
                "vec_any_nge",
                "vec_any_nle"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Compare Greater Than or Equal To Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvcmpgesp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Vector Compare Greater Than or Equal To Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvcmpgesp.",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "83",
                    "size": "7"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i=0 to 3",
                "  reset_xflags()",
                "",
                "  src1 := bfp_CONVERT_FROM_BFP32(VSR[32*AX+A].word[i])",
                "  src2 := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "",
                "  if src1.class.SNaN | src2.class.SNaN then do",
                "     vxsnan_flag := 0b1",
                "     if FPSCR.VE=0 then vxvc_flag := 0b1",
                "  end",
                "  else vxvc_flag := IsQNaN(src1) | IsQNaN(src2)",
                "",
                "  if src1 >= src2 then do",
                "     vresult.word[i] := 0xFFFF_FFFF",
                "     all_false       := 0b0",
                "  end",
                "  else do",
                "     vresult.word[i] := 0x0000_0000",
                "     all_true        := 0b0",
                "  end",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxvc_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "  if vex_flag=0 then",
                "     CR.field[6] := all_true || 0b0 || all_false || 0b0",
                "  else",
                "     CR.field[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point operand",
                "in word element i of VSR[XA].",
                "",
                "",
                "Let src2 be the single-precision floating-point operand",
                "in word element i of VSR[XB].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of word element i of VSR[XT] are",
                "set to all 1s if src1 is greater than or equal to",
                "src2, and is set to all 0s otherwise.",
                "",
                "",
                "A NaN input causes the comparison to return false for that element.",
                "",
                "",
                "Two zero inputs of same or different signs return true for that",
                "element.",
                "",
                "",
                "Two infinity inputs of same signs return true for that element.",
                "",
                "",
                "If Rc=1, CR Field 6 is set as follows.",
                "",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT] and the contents of CR",
                "field 6 are undefined if Rc is equal to 1.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpge",
                "vec_cmple",
                "vec_all_ge",
                "vec_all_le",
                "vec_all_nle",
                "vec_any_ge",
                "vec_any_le",
                "vec_any_nge",
                "vec_any_nle"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Compare Greater Than Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvcmpgtdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Vector Compare Greater Than Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvcmpgtdp.",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "107",
                    "size": "7"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[i])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "",
                "  if src1.class.SNaN | src2.class.SNaN then do",
                "     vxsnan_flag := 0b1",
                "     if FPSCR.VE=0 then vxvc_flag := 0b1",
                "  end",
                "  else vxvc_flag := IsQNaN(src1) | IsQNaN(src2)",
                "",
                "  if src1 > src2 then do",
                "     vresult.dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "     all_false        := 0b0",
                "  end",
                "  else do",
                "     vresult.dword[i] := 0x0000_0000_0000_0000",
                "     all_true         := 0b0",
                "  end",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxvc_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "  if vex_flag=0 then",
                "     CR.field[6] := all_true || 0b0 || all_false || 0b0",
                "  else",
                "     CR.field[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XA].",
                "",
                "",
                "Let src2 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XB].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of doubleword element i of VSR[XT] are set to all 1s if src1 is greater than",
                "src2, and is set to all 0s otherwise.",
                "",
                "",
                "A NaN input causes the comparison to return false for that element.",
                "",
                "",
                "Two zero inputs of same or different signs return false for that",
                "element.",
                "",
                "",
                "If Rc=1, CR Field 6 is set as follows.",
                "",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT] and the contents of CR",
                "field 6 are undefined if Rc is equal to 1.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpgt",
                "vec_cmplt",
                "vec_all_gt",
                "vec_all_lt",
                "vec_all_ngt",
                "vec_all_nlt",
                "vec_any_gt",
                "vec_any_lt",
                "vec_any_ngt",
                "vec_any_nlt"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Compare Greater Than Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvcmpgtsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "0"
                        }
                    ],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Vector Compare Greater Than Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvcmpgtsp.",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [
                        {
                            "field": "Rc",
                            "value": "1"
                        }
                    ],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "Rc",
                    "size": "1"
                },
                {
                    "name": "75",
                    "size": "7"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag   := 0b0",
                "all_false := 0b1",
                "all_true  := 0b1",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src1 := bfp_CONVERT_FROM_BFP32(VSR[32*AX+A].word[i])",
                "  src2 := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "",
                "  if IsSNaN(src1)=1 | IsSNaN(src2)=1 then do",
                "     vxsnan_flag := 0b1",
                "     if FPSCR.VE=0 then vxvc_flag := 0b1",
                "  end",
                "  else",
                "     vxvc_flag := src1.class.QNaN | src2.class.QNaN",
                "",
                "  if src1 > src2 then do",
                "     vresult.word[i] := 0xFFFF_FFFF",
                "     all_false       := 0b0",
                "  end",
                "  else do",
                "     vresult.word[i] := 0x0000_0000",
                "     all_true        := 0b0",
                "  end",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxvc_flag=1   then SetFX(FPSCR.VXVC)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxvc_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult",
                "",
                "if Rc=1 then do",
                "  if vex_flag=0 then",
                "     CR.field[6] := all_true || 0b0 || all_false || 0b0",
                "  else",
                "     CR.field[6] := 0bUUUU",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point operand",
                "in word element i of VSR[XA].",
                "",
                "",
                "Let src2 be the single-precision floating-point operand",
                "in word element i of VSR[XB].",
                "",
                "",
                "src1 is compared to src2.",
                "",
                "",
                "The contents of word element i of VSR[XT] are",
                "set to all 1s if src1 is greater than src2,",
                "and is set to all 0s otherwise.",
                "",
                "",
                "A NaN input causes the comparison to return false for that element.",
                "",
                "",
                "Two zero inputs of same or different signs return false for that",
                "element.",
                "",
                "",
                "If Rc=1, CR Field 6 is set as follows.",
                "",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT] and the contents of CR",
                "field 6 are undefined if Rc is equal to 1.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpgt",
                "vec_cmplt",
                "vec_all_gt",
                "vec_all_lt",
                "vec_all_ngt",
                "vec_all_nlt",
                "vec_any_gt",
                "vec_any_lt",
                "vec_any_ngt",
                "vec_any_nlt"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Copy Sign Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvcpsgndp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "240",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src1 := VSR[32*AX+A].dword[i] & 0x8000_0000_0000_0000",
                "  src2 := VSR[32*BX+B].dword[i] & 0x7FFF_FFFF_FFFF_FFFF",
                "  VSR[32*TX+T].dword[i] := src1 | src2",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The contents of bit 0 of doubleword element i of",
                "VSR[XA] are concatenated with the contents of bits 1:63",
                "of doubleword element i of VSR[XB] and placed",
                "into doubleword element i of VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cpsgn"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Copy Sign Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvcpsgnsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "208",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := VSR[32*AX+A].word[i] & 0x8000_0000",
                "  src2 := VSR[32*BX+B].word[i] & 0x7FFF_FFFF",
                "  VSR[32*TX+T].word[i] := src1 | src2",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The contents of bit 0 of word element i of VSR[XA] are concatenated with the contents of bits 1:31 of word",
                "element i of VSR[XB] and placed into word",
                "element i of VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cpsgn"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert bfloat16 to Single-Precision format Non-signaling",
                    "form": "XX2",
                    "mnemonic": "xvcvbf16spn",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "16",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "475",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "do i = 0 to 3",
                "  VSR[32*TX+T].word[i].hword[0] := VSR[32*BX+B].word[i].hword[1]",
                "  VSR[32*TX+T].word[i].hword[1] := 0x0000",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The contents of the rightmost halfword of word element i",
                "of VSR[XB] are placed into the leftmost halfword of word",
                "element i of VSR[XT].",
                "",
                "",
                "The contents of the rightmost halfword of word element i",
                "of VSR[XT] are set to 0.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert with round Double-Precision to Single-Precision format",
                    "form": "XX2",
                    "mnemonic": "xvcvdpsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "393",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,src)",
                "",
                "  vresult.dword[i].word[0] := bfp32_CONVERT_FROM_BFP(rnd)",
                "  vresult.dword[i].word[1] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[XT] := result"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the double-precision floating-point operand in",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "src is rounded to single-precision using the rounding",
                "mode specified by RN.",
                "",
                "",
                "The result is placed into bits 0:31 and bits 32:63 of doubleword",
                "element i of VSR[XT] in single-precision",
                "format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_floate",
                "vec_floato",
                "vec_pack"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert with round to zero Double-Precision to Signed Doubleword format",
                    "form": "XX2",
                    "mnemonic": "xvcvdpsxds",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "472",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "  vresult.dword[i] := si64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE & vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[XT] := result"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the double-precision floating-point operand in",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "If src is a NaN, the result is the value 0x8000_0000_0000_0000 and VXCVI is set to 1.",
                "If src is an SNaN, VXSNAN is also set to 1.",
                "",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode Round Toward Zero.",
                "",
                "",
                "If the rounded value is greater than 2-1, the result is",
                "0x7FFF_FFFF_FFFF_FFFF and VXCVI is set to",
                "1.",
                "",
                "",
                "Otherwise, if the rounded value is less than -2, the result is 0x8000_0000_0000_0000 and VXCVI is set to 1.",
                "",
                "",
                "Otherwise, the result is the rounded value converted to 64-bit",
                "signed-integer format, and if the result is inexact (i.e., not equal",
                "to src), XX is set to 1.",
                "",
                "",
                "The result is placed into doubleword element i of VSR[XT].",
                "",
                "",
                "See Table .",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_signed",
                "vec_unsigned"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert with round to zero Double-Precision to Signed Word format",
                    "form": "XX2",
                    "mnemonic": "xvcvdpsxws",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "216",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "  vresult.dword[i].word[0] := si32_CONVERT_FROM_BFP(rnd)",
                "  vresult.dword[i].word[1] := si32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE & vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the double-precision floating-point operand in",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "If src is a NaN, the result is the value 0x8000_0000 and VXCVI is set to 1.",
                "If src is an SNaN, VXSNAN is also set to 1.",
                "",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode Round Toward Zero.",
                "",
                "",
                "If the rounded value is greater than 2-1, the result is",
                "0x7FFF_FFFF and VXCVI is set to 1.",
                "",
                "",
                "Otherwise, if the rounded value is less than -2, the result is 0x8000_0000 and VXCVI is set to 1.",
                "",
                "",
                "Otherwise, the result is the rounded value converted to 32-bit",
                "signed-integer format, and if the result is inexact (i.e., not equal",
                "to src), XX is set to 1.",
                "",
                "",
                "The result is placed into bits 0:31 of doubleword element i of VSR[XT].",
                "",
                "",
                "The result is also placed into bits 32:63 of doubleword element",
                "i of VSR[XT].",
                "",
                "",
                "See Table .",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_signed2",
                "vec_signede",
                "vec_signedo"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert with round to zero Double-Precision to Unsigned Doubleword format",
                    "form": "XX2",
                    "mnemonic": "xvcvdpuxds",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "456",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "  vresult.dword[i] := ui64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE & vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the double-precision floating-point operand in",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "If src is a NaN, the result is the value 0x0000_0000_0000_0000 and VXCVI is set to 1.",
                "If src is an SNaN, VXSNAN is also set to 1.",
                "",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode Round Toward Zero.",
                "",
                "",
                "If the rounded value is greater than 2-1, the result is",
                "0xFFFF_FFFF_FFFF_FFFF and VXCVI is set to",
                "1.",
                "",
                "",
                "Otherwise, if the rounded value is less than 0, the result is",
                "0x0000_0000_0000_0000 and VXCVI is set to",
                "1.",
                "",
                "",
                "Otherwise, the result is the rounded value converted to 64-bit",
                "unsigned-integer format, and if the result is inexact (i.e., not",
                "equal to src), XX is set to 1.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[XT].",
                "",
                "",
                "See Table .",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert with round to zero Double-Precision to Unsigned Word format",
                    "form": "XX2",
                    "mnemonic": "xvcvdpuxws",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "200",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "  vresult.dword[i].word[0] := ui32_CONVERT_FROM_BFP(rnd)",
                "  vresult.dword[i].word[1] := ui32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE & vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the double-precision floating-point operand in",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "If src is a NaN, the result is the value 0x0000_0000 and VXCVI is set to 1.",
                "If src is an SNaN, VXSNAN is also set to 1.",
                "",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode Round Toward Zero.",
                "",
                "",
                "If the rounded value is greater than 2-1, the result is",
                "0xFFFF_FFFF and VXCVI is set to 1.",
                "",
                "",
                "Otherwise, if the rounded value is less than 0, the",
                "result is 0x0000_0000 and VXCVI is set to 1.",
                "",
                "",
                "Otherwise, the result is the rounded value converted to 32-bit",
                "unsigned-integer format, and if the result is inexact (i.e., not",
                "equal to src), XX is set to 1.",
                "",
                "",
                "The result is placed into bits 0:31 of doubleword element i of VSR[XT].",
                "",
                "",
                "The result is also placed into bits 32:63 of doubleword element",
                "i of VSR[XT].",
                "",
                "",
                "See Table .",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_unsigned2",
                "vec_unsignede",
                "vec_unsignedo"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert Half-Precision to Single-Precision format",
                    "form": "XX2",
                    "mnemonic": "xvcvhpsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "24",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "475",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "do i = 0 to 3",
                "  src := bfp_CONVERT_FROM_BFP16(VSR[BX*32+B].word[i].hword[1])",
                "",
                "  if src.class.SNaN=1 then",
                "     vresult.word[i] := bfp32_CONVERT_FROM_BFP(bfp_QUIET(src))",
                "  else",
                "     vresult.word[i] := bfp32_CONVERT_FROM_BFP(src)",
                "",
                "  vxsnan_flag := src.class.SNaN",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the half-precision floating-point value in the",
                "rightmost halfword of word element i of VSR[XB].",
                "",
                "",
                "If src is an SNaN, the result is the single-precision",
                "representation of that SNaN converted to a QNaN.",
                "",
                "",
                "Otherwise, if src is a QNaN, the result is the",
                "single-precision representation of that QNaN.",
                "",
                "",
                "Otherwise, if src is an Infinity, the result is the",
                "single-precision representation of Infinity with the same sign as",
                "src.",
                "",
                "",
                "Otherwise, if src is a Zero, the result is the",
                "single-precision representation of Zero with the same sign as",
                "src.",
                "",
                "",
                "Otherwise, if src is a denormal value, the result is the",
                "normalized single-precision representation of src.",
                "",
                "",
                "Otherwise, the result is the single-precision representation of",
                "src.",
                "",
                "",
                "The result is placed into word element i of VSR[XT].",
                "",
                "",
                "If a trap-enabled exception occurs, VSR[XT] is not",
                "modified.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract_fp32_from_shorth",
                "vec_extract_fp32_from_shortl"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert with round Single-Precision to bfloat16 format",
                    "form": "XX2",
                    "mnemonic": "xvcvspbf16",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "17",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "475",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "  reset_flags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "rnd := bfp_ROUND_TO_BFLOAT16(FPSCR.RN,src)",
                "  result.word[i].hword[0] := 0x0000",
                "  result.word[i].hword[1] := bfloat16_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                ":=         | (FPSCR.OE & ox_flag)",
                ":=         | (FPSCR.UE & ux_flag)",
                ":=         | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := result"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point value in",
                "word element i of VSR[XB].",
                "",
                "",
                "If src is an SNaN, let result be the bfloat16",
                "representation of that SNaN converted to a QNaN.",
                "",
                "",
                "Otherwise, if src is a QNaN, let result be",
                "the bfloat16 representation of that QNaN.",
                "",
                "",
                "Otherwise, if src is an Infinity, let result",
                "be the bfloat16 representation of Infinity with the same sign as",
                "src.",
                "",
                "",
                "Otherwise, if src is a Zero, let result be",
                "the bfloat16 representation of Zero with the same sign as src.",
                "",
                "",
                "Otherwise, let result be the bfloat16 representation of",
                "src rounded to bfloat16 precision using the rounding mode",
                "specified in RN.",
                "",
                "",
                "result is placed into rightmost halfword of word element",
                "i of VSR[XT].",
                "",
                "",
                "The leftmost halfword of word element i of VSR[XT] is set to 0x0000.",
                "",
                "",
                "If a trap-enabled exception occurs, VSR[XT] is not",
                "modified.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert Single-Precision to Double-Precision format",
                    "form": "XX2",
                    "mnemonic": "xvcvspdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "457",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP32(VSR[BX*32+B].dword[i].word[0])",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(src)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point operand in",
                "bits 0:31 of doubleword element i of VSR[XB].",
                "",
                "",
                "src is placed into doubleword element i of",
                "VSR[XT] in double-precison format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_doublee",
                "vec_doubleh",
                "vec_doublel",
                "vec_doubleo",
                "vec_unpackh",
                "vec_unpackl"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert with round Single-Precision to Half-Precision format",
                    "form": "XX2",
                    "mnemonic": "xvcvsphp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "25",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "475",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "reset_flags()",
                "",
                "do i = 0 to 3",
                "  src := bfp_CONVERT_FROM_BFP32(VSR[BX*32+B].word[i])",
                "  rnd := bfp_ROUND_TO_BFP16(FPSCR.RN,src)",
                "",
                "  vresult.word[i].hword[0] := 0x0000",
                "  vresult.word[i].hword[1] := bfp16_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "                     | (FPSCR.OE & ox_flag)",
                "                     | (FPSCR.UE & ux_flag)",
                "                     | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point value in",
                "word element i of VSR[XB].",
                "",
                "",
                "If src is an SNaN, the result is the half-precision",
                "representation of that SNaN converted to a QNaN.",
                "",
                "",
                "Otherwise, if src is a QNaN, the result is the",
                "half-precision representation of that QNaN.",
                "",
                "",
                "Otherwise, if src is an Infinity, the result is the",
                "half-precision representation of Infinity with the same sign as",
                "src.",
                "",
                "",
                "Otherwise, if src is a Zero, the result is the",
                "half-precision representation of Zero with the same sign as",
                "src.",
                "",
                "",
                "Otherwise, the result is the half-precision representation of",
                "src rounded to half-precision using the rounding mode",
                "specified by RN.",
                "",
                "",
                "The result is zero-extended and placed into word element i of VSR[XT].",
                "",
                "",
                "If a trap-enabled exception occurs, VSR[XT] is not",
                "modified.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert with round to zero Single-Precision to Signed Doubleword format",
                    "form": "XX2",
                    "mnemonic": "xvcvspsxds",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "408",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].dword[i].word[0])",
                "  rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "  vresult.dword[i] := si64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE & vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point operand in",
                "word element i2 of VSR[XB].",
                "",
                "",
                "If src is a NaN, the result is the value 0x8000_0000_0000_0000 and VXCVI is set to 1.",
                "If src is an SNaN, VXSNAN is also set to 1.",
                "",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode Round Toward Zero.",
                "",
                "",
                "If the rounded value is greater than 2-1, the result is",
                "0x7FFF_FFFF_FFFF_FFFF and VXCVI is set to",
                "1.",
                "",
                "",
                "Otherwise, if the rounded value is less than -2, the result is 0x8000_0000_0000_0000 and VXCVI is set to 1.",
                "",
                "",
                "Otherwise, the result is the rounded value converted to 64-bit",
                "signed-integer format, and if the result is inexact (i.e., not equal",
                "to src), XX is set to 1.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[XT].",
                "",
                "",
                "See Table .",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert with round to zero Single-Precision to Signed Word format",
                    "form": "XX2",
                    "mnemonic": "xvcvspsxws",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "152",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "  rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "  vresult.word[i] := si32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE & vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point operand in",
                "word element i of VSR[XB].",
                "",
                "",
                "If src is a NaN, the result is the value 0x8000_0000 and VXCVI is set to 1.",
                "If src is an SNaN, VXSNAN is also set to 1.",
                "",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode Round Toward Zero.",
                "",
                "",
                "If the rounded value is greater than 2-1, the result is",
                "0x7FFF_FFFF, and VXCVI is set to 1.",
                "",
                "",
                "Otherwise, if the rounded value is less than -2, the result is 0x8000_0000, and VXCVI is set to 1.",
                "",
                "",
                "Otherwise, the result is the rounded value converted to 32-bit",
                "signed-integer format, and if the result is inexact (i.e., not equal",
                "to src), XX is set to 1.",
                "",
                "",
                "The result is placed into word element i of VSR[XT].",
                "",
                "",
                "See Table .",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_signed",
                "vec_unsigned"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert with round to zero Single-Precision to Unsigned Doubleword format",
                    "form": "XX2",
                    "mnemonic": "xvcvspuxds",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "392",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].dword[i].word[0])",
                "  rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "  vresult.dword[i] := ui64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE & vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point operand in",
                "word element i2 of VSR[XB].",
                "",
                "",
                "If src is a NaN, the result is the value 0x0000_0000_0000_0000 and VXCVI is set to 1.",
                "If src is an SNaN, VXSNAN is also set to 1.",
                "",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode Round Toward Zero.",
                "",
                "",
                "If the rounded value is greater than 2-1, the result is",
                "0xFFFF_FFFF_FFFF_FFFF and VXCVI is set to",
                "1.",
                "",
                "",
                "Otherwise, if the rounded value is less than 0, the result is",
                "0x0000_0000_0000_0000 and VXCVI is set to",
                "1.",
                "",
                "",
                "Otherwise, the result is the rounded value converted to 64-bit",
                "unsigned-integer format, and if the result is inexact (i.e., not",
                "equal to src), XX is set to 1.",
                "",
                "",
                "The result is placed into doubleword element i of VSR[XT].",
                "",
                "",
                "See Table .",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert with round to zero Single-Precision to Unsigned Word format",
                    "form": "XX2",
                    "mnemonic": "xvcvspuxws",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "136",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "  rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "  vresult.word[i] := ui32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxcvi_flag=1 then SetFX(FPSCR.VXCVI)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "lag        := ex_flag | (FPSCR.VE & vxcvi_flag)",
                "lag        := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point operand in",
                "word element i of VSR[XB].",
                "",
                "",
                "If src is a NaN, the result is the value 0x0000_0000 and VXCVI is set to 1.",
                "If src is an SNaN, VXSNAN is also set to 1.",
                "",
                "",
                "Otherwise, src is rounded to a floating-point integer",
                "using the rounding mode Round Toward Zero.",
                "",
                "",
                "If the rounded value is greater than 2-1, the result is",
                "0xFFFF_FFFF and VXCVI is set to 1.",
                "",
                "",
                "Otherwise, if the rounded value is less than 0, the",
                "result is 0x0000_0000 and VXCVI is set to 1.",
                "",
                "",
                "Otherwise, the result is the rounded value converted to 32-bit",
                "unsigned-integer format, and if the result is inexact (i.e., not",
                "equal to src), XX is set to 1.",
                "",
                "",
                "The result is placed into word element i of VSR[XT].",
                "",
                "",
                "See Table .",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert with round Signed Doubleword to Double-Precision format",
                    "form": "XX2",
                    "mnemonic": "xvcvsxddp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "504",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_SI64(VSR[32*BX+B].dword[i])",
                "  rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the signed integer in doubleword element",
                "i of VSR[XB].",
                "",
                "",
                "src is converted to an unbounded-precision floating-point",
                "value and rounded to double-precision using the rounding mode",
                "specified by RN.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[XT] in double-precision format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_double"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert with round Signed Doubleword to Single-Precision format",
                    "form": "XX2",
                    "mnemonic": "xvcvsxdsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "440",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_SI64(VSR[32*BX+B].dword[i])",
                "  rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "  vresult.dword[i].word[0] := bfp32_CONVERT_FROM_BFP(rnd)",
                "  vresult.dword[i].word[1] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the signed integer in doubleword element",
                "i of VSR[XB].",
                "",
                "",
                "src is converted to an unbounded-precision floating-point",
                "value and rounded to single-precision using the rounding mode",
                "specified by RN.",
                "",
                "",
                "The result is placed into bits 0:31 of doubleword element i of VSR[XT] in single-precision format.",
                "",
                "",
                "The result is also placed into bits 32:63 of doubleword element",
                "i of VSR[XT] in single-precision format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_float2",
                "vec_floate",
                "vec_floato"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert Signed Word to Double-Precision format",
                    "form": "XX2",
                    "mnemonic": "xvcvsxwdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "248",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src := bfp_CONVERT_FROM_SI32(VSR[32*BX+B].dword[i].word[0])",
                "  VSR[32*TX+T].dword[i] := bfp64_CONVERT_FROM_BFP(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the signed integer value in bits 0:31 of",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "src is placed into doubleword element i of",
                "VSR[XT] in double-precision format.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_doublee",
                "vec_doubleh",
                "vec_doublel",
                "vec_doubleo"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert with round Signed Word to Single-Precision format",
                    "form": "XX2",
                    "mnemonic": "xvcvsxwsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "184",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_SI32(VSR[32*BX+B].word[i])",
                "  rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,src)",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "  ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the signed integer in word element i of VSR[XB].",
                "",
                "",
                "src is converted to an unbounded-precision floating-point",
                "value and rounded to single-precision using the rounding mode",
                "specified by RN.",
                "",
                "",
                "The result is placed into word element i of VSR[XT] in single-precision format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_float"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert with round Unsigned Doubleword to Double-Precision format",
                    "form": "XX2",
                    "mnemonic": "xvcvuxddp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "488",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_UI64(VSR[32*BX+B].dword[i])",
                "  rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,src)",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the unsigned integer in doubleword element",
                "i of VSR[XB].",
                "",
                "",
                "src is converted to an unbounded-precision floating-point",
                "value and rounded to double-precision using the rounding mode",
                "specified by RN.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[XT] in double-precision format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_double"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert with round Unsigned Doubleword to Single-Precision format",
                    "form": "XX2",
                    "mnemonic": "xvcvuxdsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "424",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_UI64(VSR[32*BX+B].dword[i])",
                "  rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,src)",
                "",
                "  vresult.dword[i].word[0] := bfp32_CONVERT_FROM_BFP(rnd)",
                "  vresult.dword[i].word[1] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the unsigned integer in doubleword element",
                "i of VSR[XB].",
                "",
                "",
                "src is converted to an unbounded-precision floating-point",
                "value and rounded to single-precision using the rounding mode",
                "specified by RN.",
                "",
                "",
                "The result is placed into bits 0:31 of doubleword element i of VSR[XT] in single-precision format.",
                "",
                "",
                "The result is also placed into bits 32:63 of doubleword element",
                "i of VSR[XT] in single-precision format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_floate",
                "vec_floato"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert Unsigned Word to Double-Precision format",
                    "form": "XX2",
                    "mnemonic": "xvcvuxwdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "232",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src := bfp_CONVERT_FROM_UI32(VSR[32*BX+B].dword[i].word[0])",
                "  VSR[32*TX+T].dword[i] := bfp64_CONVERT_FROM_BFP(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the unsigned integer value in bits 0:31 of",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "src is placed into doubleword element i of",
                "VSR[XT] in double-precision format.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_doublee",
                "vec_doubleh",
                "vec_doublel",
                "vec_doubleo"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Convert with round Unsigned Word to Single-Precision format",
                    "form": "XX2",
                    "mnemonic": "xvcvuxwsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "168",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_UI32(VSR[32*BX+B].word[i])",
                "  rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the unsigned integer value in word element",
                "i of VSR[XB].",
                "",
                "",
                "src is converted to an unbounded-precision floating-point",
                "value and rounded to single-precision using the rounding mode",
                "specified by RN.",
                "",
                "",
                "The result is placed into word element i of VSR[XT] in",
                "single-precision format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_float"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Divide Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvdivdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "120",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[i])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  v    := bfp_DIVIDE(src1,src2)",
                "  rnd  := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxidi_flag=1 then SetFX(FPSCR.VXIDI)",
                "  if vxisi_flag=1 then SetFX(FPSCR.VXZDZ)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "  if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxidi_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxzdz_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.ZE & zx_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XA].",
                "",
                "",
                "Let src2 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XB].",
                "",
                "",
                "src1 is divided by",
                "src2, producing a quotient having unbounded range and",
                "precision.",
                "",
                "",
                "The quotient is normalized.",
                "",
                "",
                "See Table .",
                "",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[XT] in double-precision format.",
                "",
                "",
                "See Table,",
                "Vector Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_div"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Divide Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvdivsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "88",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src1 := bfp_CONVERT_FROM_BFP32(VSR[32*AX+A].word[i])",
                "  src2 := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "  v    := bfp_DIVIDE(src1,src2)",
                "  rnd  := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxidi_flag=1 then SetFX(FPSCR.VXIDI)",
                "  if vxisi_flag=1 then SetFX(FPSCR.VXZDZ)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "  if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxidi_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxzdz_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.ZE & zx_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point operand",
                "in word element i of VSR[XA].",
                "",
                "",
                "Let src2 be the single-precision floating-point operand",
                "in word element i of VSR[XB].",
                "",
                "",
                "src1 is divided by",
                "src2, producing a quotient having unbounded range and",
                "precision.",
                "",
                "",
                "The quotient is normalized.",
                "",
                "",
                "See Table .",
                "",
                "",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into word element i of VSR[XT] in single-precision format.",
                "",
                "",
                "See Table,",
                "Vector Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_div"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector 16-bit Floating-Point GER (rank-2 update)",
                    "form": "XX3",
                    "mnemonic": "xvf16ger2",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Positive accumulate",
                    "form": "XX3",
                    "mnemonic": "xvf16ger2pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Negative accumulate",
                    "form": "XX3",
                    "mnemonic": "xvf16ger2pn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Positive accumulate",
                    "form": "XX3",
                    "mnemonic": "xvf16ger2np",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Negative accumulate",
                    "form": "XX3",
                    "mnemonic": "xvf16ger2nn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update)",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvf16ger2",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Positive accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvf16ger2pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Positive multiply, Negative accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvf16ger2pn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Positive accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvf16ger2np",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 16-bit Floating-Point GER (rank-2 update) Negative multiply, Negative accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvf16ger2nn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "121",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "210",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \"xvf16ger2\" | \"xvf16ger2pp\" | \"xvf16ger2pn\" | \"xvf16ger2np\" | \"xvf16ger2nn\" then do",
                "  PMSK := 0b11",
                "  XMSK := 0b1111",
                "  YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "  do j = 0 to 3",
                "     if XMSK.bit[i] & YMSK.bit[j] then do",
                "        reset_flags()",
                "",
                "        src10 := bfp_CONVERT_FROM_BFP16((PMSK.bit[0]=0) ? 0x0000 : VSR[32*AX+A].word[i].hword[0])",
                "        src11 := bfp_CONVERT_FROM_BFP16((PMSK.bit[1]=0) ? 0x0000 : VSR[32*AX+A].word[i].hword[1])",
                "        src20 := bfp_CONVERT_FROM_BFP16((PMSK.bit[0]=0) ? 0x0000 : VSR[32*BX+B].word[j].hword[0])",
                "        src21 := bfp_CONVERT_FROM_BFP16((PMSK.bit[1]=0) ? 0x0000 : VSR[32*BX+B].word[j].hword[1])",
                "",
                "        p1    := bfp_MULTIPLY(src10, src20)",
                "        v1    := bfp_MULTIPLY_ADD(src11, src21, p1)",
                "        r1    := bfp_ROUND_TO_BFP32_DEFAULT(FPSCR.RN, v1)",
                "",
                "        if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "        if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "        if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "        if ox_flag=1 then SetFX(FPSCR.OX)",
                "        if ux_flag=1 then SetFX(FPSCR.UX)",
                "        if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "        reset_flags()",
                "",
                "        if \"[pm]xvf16ger2\" then",
                "           ACC[AT][i].word[j] := bfp32_CONVERT_FROM_BFP(r1)",
                "",
                "        else do",
                "           acc := bfp_CONVERT_FROM_BFP32(ACC[AT][i].word[j])",
                "",
                "           if \"[pm]xvf16ger2pp\" then v2 := bfp_ADD(r1, acc)",
                "           if \"[pm]xvf16ger2pn\" then v2 := bfp_ADD(r1, bfp_NEGATE(acc))",
                "           if \"[pm]xvf16ger2np\" then v2 := bfp_ADD(bfp_NEGATE(r1), acc)",
                "           if \"[pm]xvf16ger2nn\" then v2 := bfp_ADD(bfp_NEGATE(r1), bfp_NEGATE(acc))",
                "",
                "           r2 := bfp_ROUND_TO_BFP32_DEFAULT(FPSCR.RN, v2)",
                "           ACC[AT][i].word[j] := bfp32_CONVERT_FROM_BFP(r2)",
                "",
                "           if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "           if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "           if ox_flag=1 then SetFX(FPSCR.OX)",
                "           if ux_flag=1 then SetFX(FPSCR.UX)",
                "           if xx_flag=1 then SetFX(FPSCR.XX)",
                "        end",
                "     end",
                "     else",
                "        ACC[AT][i][j] := 0x0000_0000",
                "  end",
                "end"
            ],
            "body": [
                "",
                "Let XA be the value of 32AX + A.",
                "If XA is in the range 4AT to",
                "4AT+3, the instruction form is invalid.",
                "",
                "Let XB be the value of 32BX + B.",
                "If XB is in the range 4AT to",
                "4AT+3, the instruction form is invalid.",
                "",
                "Let the contents of ACC[AT] be a 44",
                "matrix of single-precision floating-point values.",
                "",
                "Let result be a 44 matrix of word",
                "elements to be used as a temporary Accumulator.",
                "",
                "For xvf16ger2, xvf16ger2pp,",
                "xvf16ger2pn, xvf16ger2np,",
                "or xvf16ger2nn, let PMSK=0b11,",
                "XMSK=0b1111, and YMSK=0b1111.",
                "",
                "For each integer value i from 0 to 3, and each integer",
                "value j from 0 to 3, do the following.",
                "",
                "",
                "",
                "If bit i of XMSK is equal to 1 and bit",
                "j of YMSK is equal to 1, do the following.",
                "",
                "",
                "",
                "If bit 0 of PMSK is equal to 1, let src10 be",
                "the half-precision floating-point value in hword 0 of word element",
                "i of VSR[XA] and let src20 be the",
                "half-precision floating-point value in hword 0 of word element",
                "j of VSR[XB].",
                "Otherwise, let src10 be the value 0.0 and let src20 be the value 0.0, causing the product of src10 and",
                "src20 to be 0.0.",
                "",
                "",
                "If bit 1 of PMSK is equal to 1, let src11 be",
                "the half-precision floating-point value in hword 1 of word element",
                "i of VSR[XA] and let src21 be the",
                "half-precision floating-point value in hword 1 of word element",
                "j of VSR[XB].",
                "Otherwise, let src11 be the value 0.0 and let src21 be the value 0.0, causing the product of src11 and",
                "src21 to be 0.0.",
                "",
                "",
                "Let prod be the single-precision product of src10 and src20.",
                "",
                "",
                "Let msum be the sum of prod added to the",
                "product of src11 and src21.",
                "msum is rounded to single-precision using the rounding",
                "mode specified in RN.",
                "",
                "",
                "For [pm]xvf16ger2, the",
                "rounded msum is placed into word element j of",
                "ACC[AT][i] in single-precision floating-point format.",
                "",
                "",
                "For [pm]xvf16ger2pp, the",
                "rounded msum is added to the single-precision",
                "floating-point value in word element j of ACC[AT][i], rounded to single-precision using the rounding mode",
                "specified in RN, and placed into word element j of ACC[AT][i] in single-precision floating-point",
                "format.",
                "",
                "",
                "For [pm]xvf16ger2pn, the",
                "rounded msum is added to the negation of the",
                "single-precision floating-point value in word element j",
                "of ACC[AT][i], rounded to single-precision using the",
                "rounding mode specified in RN, and placed into word",
                "element j of ACC[AT][i] in single-precision",
                "floating-point format.",
                "",
                "",
                "For [pm]xvf16ger2np, the",
                "negation of the rounded msum is added to the",
                "single-precision floating-point value in word element j",
                "of ACC[AT][i], rounded to single-precision using the",
                "rounding mode specified in RN, and placed into word",
                "element j of ACC[AT][i] in single-precision",
                "floating-point format.",
                "",
                "",
                "For [pm]xvf16ger2nn, the",
                "negation of the rounded msum is added to the negation of",
                "the single-precision floating-point value in word element j of ACC[AT][i], rounded to single-precision using the",
                "rounding mode specified in RN, and placed into word",
                "element j of ACC[AT][i] in single-precision",
                "floating-point format.",
                "",
                "",
                "",
                "Otherwise, the contents of ACC[AT][i][j] are set to",
                "0x0000_0000.",
                "",
                "",
                "Unlike most other VSX Vector Floating-Point instructions,",
                "this instruction always updates the target register (here, ACC[AT],",
                "even when a trap-enabled exception occurs.",
                "For every multiply-add operation that is performed as part of the",
                "execution of this instruction, the operation is performed as if all",
                "exception enable bits are zero, and the trap-disabled result is",
                "returned.",
                "If the operation causes underflow or produces an inexact result,",
                "whether the operation causes an Underflow or Inexact exception is",
                "based on the actual contents of the Underflow and Overflow Enable",
                "bits.",
                "Exception status is accumulated and the appropriate exception status",
                "bits in the FPSCR are updated at the completion of execution of the",
                "instruction.",
                "Otherwise, behavior is the same as any vector floating-point",
                "instruction that can cause an exception.",
                "Taking a Program interrupt on a trap-enabled exception when",
                "interrupts are enabled by MSR.FE0 and MSR.FE1",
                "is still supported, albeit with ACC[AT] updated based on",
                "a trap-disabled result.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector 32-bit Floating-Point GER (rank-1 update)",
                    "form": "XX3",
                    "mnemonic": "xvf32ger",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate",
                    "form": "XX3",
                    "mnemonic": "xvf32gerpp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate",
                    "form": "XX3",
                    "mnemonic": "xvf32gerpn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate",
                    "form": "XX3",
                    "mnemonic": "xvf32gernp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate",
                    "form": "XX3",
                    "mnemonic": "xvf32gernn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update)",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvf32ger",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvf32gerpp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvf32gerpn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvf32gernp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 32-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvf32gernn",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "121",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "12"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "218",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \"xvf32ger\" | \"xvf32gerpp\" | \"xvf32gerpn\" | \"xvf32gernp\" | \"xvf32gernn\" then do",
                "  XMSK := 0b1111",
                "  YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "  do j = 0 to 3",
                "     if XMSK.bit[i]=1 & YMSK.bit[j]=1 then do",
                "        reset_flags()",
                "",
                "        src1 := bfp_CONVERT_FROM_BFP32(VSR[32*AX+A].word[i])",
                "        src2 := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[j])",
                "        acc  := bfp_CONVERT_FROM_BFP32(ACC[AT][i].word[j])",
                "",
                "        if \"[pm]xvf32ger\"   then v := bfp_MULTIPLY( src1, src2 )",
                "        if \"[pm]xvf32gerpp\" then v := bfp_MULTIPLY_ADD( src1, src2, acc )",
                "        if \"[pm]xvf32gerpn\" then v := bfp_MULTIPLY_ADD( src1, src2, bfp_NEGATE(acc) )",
                "        if \"[pm]xvf32gernp\" then v := bfp_MULTIPLY_ADD( src1, src2, bfp_NEGATE(acc) )",
                "        if \"[pm]xvf32gernn\" then v := bfp_MULTIPLY_ADD( src1, src2, acc )",
                "",
                "        r := bfp_ROUND_TO_BFP32_DEFAULT(FPSCR.RN,v)",
                "",
                "        if \"[pm]xvf32gernp\" then r := bfp_NEGATE(r)",
                "        if \"[pm]xvf32gernn\" then r := bfp_NEGATE(r)",
                "",
                "        ACC[AT][i].word[j] := bfp32_CONVERT_FROM_BFP(r)",
                "",
                "        if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "        if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "        if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "        if ox_flag=1 then SetFX(FPSCR.OX)",
                "        if ux_flag=1 then SetFX(FPSCR.UX)",
                "        if xx_flag=1 then SetFX(FPSCR.XX)",
                "     end",
                "     else",
                "        ACC[AT][i].word[j] := 0x0000_0000",
                "  end",
                "end"
            ],
            "body": [
                "",
                "Let XA be the value of 32AX + A.",
                "If XA is in the range 4AT to",
                "4AT+3, the instruction form is invalid.",
                "",
                "Let XB be the value of 32BX + B.",
                "If XB is in the range 4AT to",
                "4AT+3, the instruction form is invalid.",
                "",
                "Let the contents of ACC[AT] be a 44",
                "matrix of single-precision floating-point values.",
                "",
                "For xvf32ger, xvf32gerpp, xvf32gerpn, xvf32gernp, or",
                "xvf32gernn, let XMSK=0b1111 and",
                "YMSK=0b1111.",
                "",
                "For each integer value i from 0 to 3, and each integer",
                "value j from 0 to 3, do the following.",
                "",
                "",
                "",
                "If bit i of XMSK is equal to 1 and bit j of YMSK is equal to 1, do the following.",
                "",
                "",
                "",
                "Let prod be the product of the single-precision",
                "floating-point value in word element i of VSR[XA] and the single-precision floating-point value in word",
                "element j of VSR[XB], having unbounded range",
                "and precision.",
                "",
                "",
                "For [pm]xvf32ger, prod is rounded to single-precision using the rounding mode",
                "specified in RN.",
                "The rounded result is placed into word element j of",
                "ACC[AT][i] in single-precision floating-point format.",
                "",
                "",
                "For [pm]xvf32gerpp, the single-precision floating-point",
                "value in word element j of ACC[AT][i] is",
                "added to prod.",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified in RN.",
                "The rounded result is placed into word element j of",
                "ACC[AT][i] in single-precision floating-point format.",
                "",
                "",
                "For [pm]xvf32gerpn, the single-precision floating-point",
                "value in word element j of ACC[AT][i] is",
                "subtracted from prod.",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified in RN.",
                "The rounded result is placed into word element j of",
                "ACC[AT][i] in single-precision floating-point format.",
                "",
                "",
                "For [pm]xvf32gernp, the single-precision floating-point",
                "value in word element j of ACC[AT][i] is",
                "subtracted from prod.",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified in RN.",
                "The rounded result is negated and placed into word element j of ACC[AT][i] in single-precision floating-point",
                "format.",
                "",
                "",
                "For [pm]xvf32gernn, the single-precision floating-point",
                "value in word element j of ACC[AT][i] is",
                "added to prod.",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified in RN.",
                "The rounded result is negated and placed into word element j of ACC[AT][i] in single-precision floating-point",
                "format.",
                "",
                "",
                "",
                "Otherwise, the contents of word element j of ACC[AT][i] are set to 0x0000_0000.",
                "",
                "",
                "Unlike other vector floating-point instructions, ACC[AT]",
                "is always updated by the execution of the instruction, even when a",
                "trap-enabled exception occurs.",
                "For every multiply-add operation that is performed as part of the",
                "execution of this instruction, if an exception occurs as the result",
                "of that particular multiply-add operation, the trap-disabled",
                "exception result is returned, even if that exception type is",
                "trap-enabled.",
                "Exception detection is based on the trap-disable definition.",
                "Exception status is  and the appropriate exception status bits in the",
                "FPSCR are updated at the completion of execution of the instruction.",
                "Otherwise, behavior is the same as any vector floating-point",
                "instruction that can cause an exception.",
                "Taking a Program interrupt on a trap-enabled exception when",
                "interrupts are enabled by MSR.FE0 and MSR.FE1",
                "is still supported, albeit with the ACC[AT] updated based",
                "on a trap-disabled result.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector 64-bit Floating-Point GER (rank-1 update)",
                    "form": "XX3",
                    "mnemonic": "xvf64ger",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector 64-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate",
                    "form": "XX3",
                    "mnemonic": "xvf64gerpp",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector 64-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate",
                    "form": "XX3",
                    "mnemonic": "xvf64gerpn",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector 64-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate",
                    "form": "XX3",
                    "mnemonic": "xvf64gernp",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector 64-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate",
                    "form": "XX3",
                    "mnemonic": "xvf64gernn",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update)",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvf64ger",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Positive multiply, Positive accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvf64gerpp",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Positive multiply, Negative accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvf64gerpn",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Negative multiply, Positive accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvf64gernp",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 64-bit Floating-Point GER (rank-1 update) Negative multiply, Negative accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvf64gernn",
                    "operands": [
                        "AT",
                        "XAp",
                        "XB",
                        "XMSK",
                        "YMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "121",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "12"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "Ap",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "250",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \"xvf64ger\" | \"xvf64gerpp\" | \"xvf64gerpn\" | \"xvf64gernp\" | \"xvf64gernn\" then do",
                "  XMSK := 0b1111",
                "  YMSK := 0b11",
                "end",
                "vsrc1.qword[0] := VSR[32*AX+Ap]",
                "vsrc1.qword[1] := VSR[32*AX+Ap+1]",
                "vsrc2          := VSR[32*BX+B]",
                "do i = 0 to 3",
                "  do j = 0 to 1",
                "     if XMSK.bit[i]=1 & YMSK.bit[j]=1 then do",
                "        reset_flags()",
                "",
                "        src1 := bfp_CONVERT_FROM_BFP64(vsrc1.dword[i])",
                "        src2 := bfp_CONVERT_FROM_BFP64(vsrc2.dword[j])",
                "        acc  := bfp_CONVERT_FROM_BFP64(ACC[AT][i].dword[j])",
                "",
                "        if \"[pm]xvf64ger\"   then v := bfp_MULTIPLY( src1, src2 )",
                "        if \"[pm]xvf64gerpp\" then v := bfp_MULTIPLY_ADD( src1, src2, acc )",
                "        if \"[pm]xvf64gerpn\" then v := bfp_MULTIPLY_ADD( src1, src2, bfp_NEGATE(acc) )",
                "        if \"[pm]xvf64gernp\" then v := bfp_MULTIPLY_ADD( src1, src2, bfp_NEGATE(acc) )",
                "        if \"[pm]xvf64gernn\" then v := bfp_MULTIPLY_ADD( src1, src2, acc )",
                "",
                "        r := bfp_ROUND_TO_BFP64_DEFAULT(FPSCR.RN,v)",
                "",
                "        if \"[pm]xvf64gernp\" then r := bfp_NEGATE(r)",
                "        if \"[pm]xvf64gernn\" then r := bfp_NEGATE(r)",
                "",
                "        ACC[AT][i].dword[j] := bfp64_CONVERT_FROM_BFP(r)",
                "",
                "        if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "        if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "        if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "        if ox_flag=1 then SetFX(FPSCR.OX)",
                "        if ux_flag=1 then SetFX(FPSCR.UX)",
                "        if xx_flag=1 then SetFX(FPSCR.XX)",
                "     end",
                "     else",
                "        ACC[AT][i].dword[j] := 0x0000_0000_0000_0000",
                "  end",
                "end"
            ],
            "body": [
                "",
                "Let XAp be the value of 32AX + Ap.",
                "If XAp is odd, or is in the range 4AT to 4AT+3, the instruction form",
                "is invalid.",
                "",
                "Let XB be the value of 32BX + B.",
                "If XB is in the range 4AT to",
                "4AT+3, the instruction form is invalid.",
                "",
                "Let the contents of ACC[AT] be a 42",
                "matrix of double-precision floating-point values.",
                "",
                "Let vsrcX be the concatenation of the contents of",
                "VSR[XAp] and VSR[XAp+1].",
                "",
                "Let vsrcY be the contents of VSR[XB].",
                "",
                "For xvf64ger, xvf64gerpp, xvf64gerpn, xvf64gernp, and",
                "xvf64gernn, let XMSK=0b1111 and",
                "YMSK=0b11.",
                "",
                "For each integer value i from 0 to 3, and each integer",
                "value j from 0 to 1, do the following.",
                "",
                "",
                "",
                "If bit i of XMSK is equal to 1",
                "and bit j of YMSK is equal to 1,",
                "do the following.",
                "",
                "",
                "",
                "Let prod be the product of the double-precision",
                "floating-point value in doubleword element i of",
                "vsrcX and the double-precision floating-point value in",
                "doubleword element j of vsrcY, having",
                "unbounded range and precision.",
                "",
                "",
                "For [pm]xvf64ger, prod is rounded to double-precision using the rounding mode",
                "specified in RN.",
                "The rounded result is placed into doubleword element j of",
                "ACC[AT][i] in double-precision floating-point format.",
                "",
                "",
                "For [pm]xvf64gerpp, prod is added to the",
                "double-precision floating-point value in doubleword element",
                "j of ACC[AT][i].",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified in RN.",
                "The rounded result is placed into doubleword element j of",
                "ACC[AT][i] in double-precision floating-point format.",
                "",
                "",
                "For [pm]xvf64gerpn, prod is added to the",
                "negation of the double-precision floating-point value in doubleword",
                "element j of ACC[AT][i].",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified in RN.",
                "The rounded result is placed into doubleword element j of",
                "ACC[AT][i] in double-precision floating-point format.",
                "",
                "",
                "For [pm]xvf64gernn, prod is added to the",
                "double-precision floating-point value in doubleword element",
                "j of ACC[AT][i].",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified in RN.",
                "The rounded result is negated and placed into doubleword element",
                "j of ACC[AT][i] in double-precision",
                "floating-point format.",
                "",
                "",
                "For [pm]xvf64gernp, prod is added to the",
                "negation of the double-precision floating-point value in doubleword",
                "element j of ACC[AT][i].",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified in RN.",
                "The rounded result is negated and placed into doubleword element",
                "j of ACC[AT][i] in double-precision",
                "floating-point format.",
                "",
                "",
                "",
                "Otherwise, the contents of doubleword element j of",
                "ACC[AT][i] are set to 0x0000_0000_0000_0000.",
                "",
                "",
                "Unlike most other VSX Vector Floating-Point instructions,",
                "this instruction always updates the target register (here, ACC[AT],",
                "even when a trap-enabled exception occurs.",
                "For every multiply-add operation that is performed as part of the",
                "execution of this instruction, the operation is performed as if all",
                "exception enable bits are zero, and the trap-disabled result is",
                "returned.",
                "If the operation causes underflow or produces an inexact result,",
                "whether the operation causes an Underflow or Inexact exception is",
                "based on the actual contents of the Underflow and Overflow Enable",
                "bits.",
                "Exception status is accumulated and the appropriate exception status",
                "bits in the FPSCR are updated at the completion of execution of the",
                "instruction.",
                "Otherwise, behavior is the same as any vector floating-point",
                "instruction that can cause an exception.",
                "Taking a Program interrupt on a trap-enabled exception when",
                "interrupts are enabled by MSR.FE0 and MSR.FE1",
                "is still supported, albeit with ACC[AT] updated based on",
                "a trap-disabled result.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector 4-bit Signed Integer GER (rank-8 update)",
                    "form": "XX3",
                    "mnemonic": "xvi4ger8",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector 4-bit Signed Integer GER (rank-8 update) Positive multiply, Positive accumulate",
                    "form": "XX3",
                    "mnemonic": "xvi4ger8pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 4-bit Signed Integer GER (rank-8 update)",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvi4ger8",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 4-bit Signed Integer GER (rank-8 update) Positive multiply, Positive accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvi4ger8pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "121",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "PMSK",
                    "size": "8"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "34",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \"xvi4ger8\" | \"xvi4ger8pp\" then do",
                "  PMSK := 0b11111111",
                "  XMSK := 0b1111",
                "  YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "  do j = 0 to 3",
                "     if XMSK.bit[i] & YMSK.bit[j] then do",
                "        prod0 := (PMSK.bit[0]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].nibble[0]) * EXTS(VSR[32*BX+B].word[j].nibble[0])",
                "        prod1 := (PMSK.bit[1]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].nibble[1]) * EXTS(VSR[32*BX+B].word[j].nibble[1])",
                "        prod2 := (PMSK.bit[2]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].nibble[2]) * EXTS(VSR[32*BX+B].word[j].nibble[2])",
                "        prod3 := (PMSK.bit[3]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].nibble[3]) * EXTS(VSR[32*BX+B].word[j].nibble[3])",
                "        prod4 := (PMSK.bit[4]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].nibble[4]) * EXTS(VSR[32*BX+B].word[j].nibble[4])",
                "        prod5 := (PMSK.bit[5]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].nibble[5]) * EXTS(VSR[32*BX+B].word[j].nibble[5])",
                "        prod6 := (PMSK.bit[6]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].nibble[6]) * EXTS(VSR[32*BX+B].word[j].nibble[6])",
                "        prod7 := (PMSK.bit[7]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].nibble[7]) * EXTS(VSR[32*BX+B].word[j].nibble[7])",
                "",
                "        psum  := prod0 + prod1 + prod2 + prod3 + prod4 + prod5 + prod6 + prod7",
                "",
                "        if \"[pm]xvi4ger8\"   then ACC[AT][i].word[j] := CHOP32( psum )",
                "        if \"[pm]xvi4ger8pp\" then ACC[AT][i].word[j] := CHOP32( psum + EXTS(ACC[AT][i].word[j]) )",
                "     end",
                "     else",
                "        ACC[AT][i].word[j] := 0x0000_0000",
                "  end",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XA be the value of 32AX + A.",
                "If XA is in the range 4AT to",
                "4AT+3, the instruction form is invalid.",
                "",
                "Let XB be the value of 32BX + B.",
                "If XB is in the range 4AT to",
                "4AT+3, the instruction form is invalid.",
                "",
                "Let the contents of ACC[AT] be a 44",
                "matrix of 32-bit signed integer values.",
                "",
                "For xvi4ger8 or xvi4ger8pp, let",
                "PMSK=0b11111111, XMSK=0b1111, and YMSK=0b1111.",
                "",
                "For each integer value i from 0 to 3, and each integer",
                "value j from 0 to 3, do the following.",
                "",
                "",
                "",
                "If bit i of XMSK is equal to 1 and bit",
                "j of YMSK is equal to 1, do the following.",
                "",
                "",
                "",
                "If bit 0 of PMSK is equal to 1, let",
                "prod0 be the product of the 4-bit signed integer value in",
                "nibble 0 of word element i of VSR[XA]",
                "(X[i][0]) and the 4-bit signed integer value in byte 0 of",
                "word element j of VSR[XB] (Y[j][0]), sign-extended to 32 bits.",
                "Otherwise, let prod0 be the value 0.",
                "",
                "",
                "If bit 1 of PMSK is equal to 1, let",
                "prod1 be the product of the 4-bit signed integer value in",
                "nibble 1 of word element i of VSR[XA]",
                "(X[i][1]) and the 4-bit signed integer value in nibble 1",
                "of word element j of VSR[XB] (Y[j][1]), sign-extended to 32 bits.",
                "Otherwise, let prod1 be the value 0.",
                "",
                "",
                "If bit 2 of PMSK is equal to 1, let",
                "prod2 be the product of the 4-bit signed integer value in",
                "nibble 2 of word element i of VSR[XA]",
                "(X[i][2]) and the 4-bit signed integer value in nibble 2",
                "of word element j of VSR[XB] (Y[j][2]), sign-extended to 32 bits.",
                "Otherwise, let prod2 be the value 0.",
                "",
                "",
                "If bit 3 of PMSK is equal to 1, let",
                "prod3 be the product of the 4-bit signed integer value in",
                "nibble 3 of word element i of VSR[XA]",
                "(X[i][3]) and the 4-bit signed integer value in nibble 3",
                "of word element j of VSR[XB] (Y[j][3]), sign-extended to 32 bits.",
                "Otherwise, let prod3 be the value 0.",
                "",
                "",
                "If bit 4 of PMSK is equal to 1, let",
                "prod4 be the product of the 4-bit signed integer value in",
                "nibble 4 of word element i of VSR[XA]",
                "(X[i][4]) and the 4-bit signed integer value in nibble 4",
                "of word element j of VSR[XB] (Y[j][4]), sign-extended to 32 bits.",
                "Otherwise, let prod4 be the value 0.",
                "",
                "",
                "If if bit 5 of PMSK is equal to 1, let",
                "prod5 be the product of the 4-bit signed integer value in",
                "nibble 5 of word element i of VSR[XA]",
                "(X[i][5]) and the 4-bit signed integer value in nibble 5",
                "of word element j of VSR[XB] (Y[j][5]), sign-extended to 32 bits.",
                "Otherwise, let prod5 be the value 0.",
                "",
                "",
                "If bit 6 of PMSK is equal to 1, let",
                "prod6 be the product of the 4-bit signed integer value in",
                "nibble 6 of word element i of VSR[XA]",
                "(X[i][6]) and the 4-bit signed integer value in nibble 6",
                "of word element j of VSR[XB] (Y[j][6]), sign-extended to 32 bits.",
                "Otherwise, let prod6 be the value 0.",
                "",
                "",
                "If bit 7 of PMSK is equal to 1, let",
                "prod7 be the product of the 4-bit signed integer value in",
                "nibble 7 of word element i of VSR[XA]",
                "(X[i][7]) and the 4-bit signed integer value in nibble 7",
                "of word element j of VSR[XB] (Y[j][7]), sign-extended to 32 bits.",
                "Otherwise, let prod7 be the value 0.",
                "",
                "",
                "Let psum be the sum of prod0, prod1, prod2, prod3, prod4,",
                "prod5, prod6, and prod7.",
                "",
                "",
                "For [pm]xvi4ger8, psum is placed into word element j of ACC[AT][i] in 32-bit signed integer format.",
                "",
                "",
                "For [pm]xvi4ger8pp, psum is added to the",
                "32-bit signed integer value in word element j of",
                "ACC[AT][i], and the result is placed into word element",
                "j of ACC[AT][i] in 32-bit signed integer",
                "format.",
                "",
                "",
                "",
                "Otherwise, let ACC[AT][i][j] is set to 0x0000_0000.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update)",
                    "form": "XX3",
                    "mnemonic": "xvi8ger4",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) Positive multiply, Positive accumulate",
                    "form": "XX3",
                    "mnemonic": "xvi8ger4pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update)",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvi8ger4",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) Positive multiply, Positive accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvi8ger4pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "121",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "PMSK",
                    "size": "4"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "2",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \"xvi8ger4\" | \"xvi8ger4pp\" then do",
                "  PMSK := 0b1111",
                "  XMSK := 0b1111",
                "  YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "  do j = 0 to 3",
                "     if XMSK.bit[i] & YMSK.bit[j] then do",
                "        prod0 := (PMSK.bit[0]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].byte[0]) * EXTZ(VSR[32*BX+B].word[j].byte[0])",
                "        prod1 := (PMSK.bit[1]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].byte[1]) * EXTZ(VSR[32*BX+B].word[j].byte[1])",
                "        prod2 := (PMSK.bit[2]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].byte[2]) * EXTZ(VSR[32*BX+B].word[j].byte[2])",
                "        prod3 := (PMSK.bit[3]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].byte[3]) * EXTZ(VSR[32*BX+B].word[j].byte[3])",
                "",
                "        psum  := prod0 + prod1 + prod2 + prod3",
                "",
                "        if \"[pm]xvi8ger4\"   then ACC[AT][i].word[j] := CHOP32( psum )",
                "        if \"[pm]xvi8ger4pp\" then ACC[AT][i].word[j] := CHOP32( psum + EXTS(ACC[AT][i].word[j]) )",
                "     end",
                "     else",
                "        ACC[AT][i][j] := 0x0000_0000",
                "  end",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XA be the value of 32AX + A.",
                "If XA is in the range 4AT to",
                "4AT+3, the instruction form is invalid.",
                "",
                "Let XB be the value of 32BX + B.",
                "If XB is in the range 4AT to",
                "4AT+3, the instruction form is invalid.",
                "",
                "Let the contents of ACC[AT] be a 44",
                "matrix of 32-bit signed integer values.",
                "",
                "For xvi8ger4 or xvi8ger4pp, let",
                "PMSK=0b1111, XMSK=0b1111, and YMSK=0b1111.",
                "",
                "For each integer value i from 0 to 3, and each integer",
                "value j from 0 to 3, do the following.",
                "",
                "",
                "",
                "If bit i of XMSK is equal to 1 and bit",
                "j of YMSK is equal to 1, do the following.",
                "",
                "",
                "",
                "If bit 0 of PMSK is equal to 1, let",
                "prod0 be the product of the 8-bit signed integer value in",
                "byte 0 of word element i of VSR[XA]",
                "(X[i][0]) and the 8-bit unsigned integer value in byte 0",
                "of word element j of VSR[XB] (Y[j][0]), sign-extended to 32 bits.",
                "Otherwise, let prod0 be the value 0.",
                "",
                "",
                "If bit 1 of PMSK is equal to 1, let",
                "prod1 be the product of the 8-bit signed integer value in",
                "byte 1 of word element i of VSR[XA]",
                "(X[i][1]) and the 8-bit unsigned integer value in byte 1",
                "of word element j of VSR[XB] (Y[j][1]), sign-extended to 32 bits.",
                "Otherwise, let prod1 be the value 0.",
                "",
                "",
                "If bit 2 of PMSK is equal to 1, let",
                "prod2 be the product of the 8-bit signed integer value in",
                "byte 2 of word element i of VSR[XA]",
                "(X[i][2]) and the 8-bit unsigned integer value in byte 2",
                "of word element j of VSR[XB] (Y[j][2]), sign-extended to 32 bits.",
                "Otherwise, let prod2 be the value 0.",
                "",
                "",
                "If bit 3 of PMSK is equal to 1, let",
                "prod3 be the product of the 8-bit signed integer value in",
                "byte 3 of word element i of VSR[XA]",
                "(X[i][3]) and the 8-bit unsigned integer value in byte 3",
                "of word element j of VSR[XB] (Y[j][3]), sign-extended to 32 bits.",
                "Otherwise, let prod3 be the value 0.",
                "",
                "",
                "Let sum be the sum of prod0, prod1, prod2, and prod3.",
                "",
                "",
                "For [pm]xvi8ger4, psum is placed into word element j of ACC[AT][i] in 32-bit signed integer format.",
                "",
                "",
                "For [pm]xvi8ger4pp, psum is added to the",
                "32-bit signed integer value in word element j of",
                "ACC[AT][i], and the result is placed into word element",
                "j of ACC[AT][i] in 32-bit signed integer",
                "format.",
                "",
                "",
                "",
                "Otherwise, let word element j of ACC[AT][i]",
                "is set to 0x0000_0000.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) with Saturation Positive multiply, Positive accumulate",
                    "form": "XX3",
                    "mnemonic": "xvi8ger4spp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 8-bit Signed/Unsigned Integer GER (rank-4 update) with Saturation Positive multiply, Positive accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvi8ger4spp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "121",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "PMSK",
                    "size": "4"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "2",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \"xvi8ger4pps\" then do",
                "  PMSK := 0b1111",
                "  XMSK := 0b1111",
                "  YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "  do j = 0 to 3",
                "     if XMSK.bit[i] & YMSK.bit[j] then do",
                "        prod0 := (PMSK.bit[0]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].byte[0]) * EXTZ(VSR[32*BX+B].word[j].byte[0])",
                "        prod1 := (PMSK.bit[1]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].byte[1]) * EXTZ(VSR[32*BX+B].word[j].byte[1])",
                "        prod2 := (PMSK.bit[2]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].byte[2]) * EXTZ(VSR[32*BX+B].word[j].byte[2])",
                "        prod3 := (PMSK.bit[3]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].byte[3]) * EXTZ(VSR[32*BX+B].word[j].byte[3])",
                "",
                "        psum  := prod0 + prod1 + prod2 + prod3",
                "",
                "        ACC[AT][i].word[j] := si32_CLAMP( psum + EXTS(ACC[AT][i].word[j] )",
                "",
                "        if sat_flag=1 then VSCR.SAT := 1",
                "     end",
                "     else",
                "        ACC[AT][i][j] := 0x0000_0000",
                "  end",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XA be the value of 32AX + A.",
                "If XA is in the range 4AT to",
                "4AT+3, the instruction form is invalid.",
                "",
                "Let XB be the value of 32BX + B.",
                "If XB is in the range 4AT to",
                "4AT+3, the instruction form is invalid.",
                "",
                "Let the contents of ACC[AT] be a 44",
                "matrix of 32-bit signed integer values.",
                "",
                "For xvi8ger4spp, let PMSK=0b1111,",
                "XMSK=0b1111, and YMSK=0b1111.",
                "",
                "For each integer value i from 0 to 3, and each integer",
                "value j from 0 to 3, do the following.",
                "",
                "",
                "",
                "If bit i of XMSK is equal to 1 and bit",
                "j of YMSK is equal to 1, do the following.",
                "",
                "",
                "",
                "If bit 0 of PMSK is equal to 1, let",
                "prod0 be the product of the 8-bit signed integer value in",
                "byte 0 of word element i of VSR[XA]",
                "(X[i][0]) and the 8-bit unsigned integer value in byte 0",
                "of word element j of VSR[XB] (Y[j][0]), sign-extended to 32 bits.",
                "Otherwise, let prod0 be the value 0.",
                "",
                "",
                "If bit 1 of PMSK is equal to 1, let",
                "prod1 be the product of the 8-bit signed integer value in",
                "byte 1 of word element i of VSR[XA]",
                "(X[i][1]) and the 8-bit unsigned integer value in byte 1",
                "of word element j of VSR[XB] (Y[j][1]), sign-extended to 32 bits.",
                "Otherwise, let prod1 be the value 0.",
                "",
                "",
                "If bit 2 of PMSK is equal to 1, let",
                "prod2 be the product of the 8-bit signed integer value in",
                "byte 2 of word element i of VSR[XA]",
                "(X[i][2]) and the 8-bit unsigned integer value in byte 2",
                "of word element j of VSR[XB] (Y[j][2]), sign-extended to 32 bits.",
                "Otherwise, let prod2 be the value 0.",
                "",
                "",
                "If bit 3 of PMSK is equal to 1, let",
                "prod3 be the product of the 8-bit signed integer value in",
                "byte 3 of word element i of VSR[XA]",
                "(X[i][3]) and the 8-bit unsigned integer value in byte 3",
                "of word element j of VSR[XB] (Y[j][3]), sign-extended to 32 bits.",
                "Otherwise, let prod3 be the value 0.",
                "",
                "",
                "Let psum be the sum of prod0, prod1, prod2, and prod3.",
                "",
                "",
                "psum is added to the 32-bit signed integer value in word",
                "element j of ACC[AT][i] and the result is",
                "placed into word element j of ACC[AT][i] in",
                "32-bit signed integer format.",
                "",
                "",
                "If the result is less than -2, the result saturates to",
                "-2 and SAT is set to 1.",
                "",
                "",
                "If the result is greater than 2-1, the result",
                "saturates to 2-1 and SAT is set to 1.",
                "",
                "",
                "",
                "Otherwise, let word element j of ACC[AT][i]",
                "is set to 0x0000_0000.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector 16-bit Signed Integer GER (rank-2 update)",
                    "form": "XX3",
                    "mnemonic": "xvi16ger2",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector 16-bit Signed Integer GER (rank-2 update) Positive multiply, Positive accumulate",
                    "form": "XX3",
                    "mnemonic": "xvi16ger2pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update)",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvi16ger2",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update) Positive multiply, Positive accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvi16ger2pp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "121",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "10",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \"xvi16ger2s\" | \"xvi16ger2spp\" then do",
                "  PMSK := 0b11",
                "  XMSK := 0b1111",
                "  YMSK := 0b1111",
                "end",
                "",
                "do i = 0 to 3",
                "  do j = 0 to 3",
                "     if XMSK.bit[i] & YMSK.bit[j] then do",
                "        prod0 := (PMSK.bit[0]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].hword[0]) * EXTS(VSR[32*BX+B].word[j].hword[0])",
                "        prod1 := (PMSK.bit[1]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].hword[1]) * EXTS(VSR[32*BX+B].word[j].hword[1])",
                "",
                "        psum  := prod0 + prod1",
                "",
                "        if \"[pm]xvi16ger2\"   then ACC[AT][i].word[j] := CHOP32(psum)",
                "        if \"[pm]xvi16ger2pp\" then ACC[AT][i].word[j] := CHOP32(psum + EXTS(ACC[AT][i].word[j])",
                "     end",
                "     else",
                "        ACC[AT][i][j] := 0x0000_0000",
                "  end",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XA be the value of 32AX + A.",
                "If XA is in the range 4AT to",
                "4AT+3, the instruction form is invalid.",
                "",
                "Let XB be the value of 32BX + B.",
                "If XB is in the range 4AT to",
                "4AT+3, the instruction form is invalid.",
                "",
                "Let the contents of ACC[AT] be a 44",
                "matrix of 32-bit signed integer values.",
                "",
                "For xvi16ger2 or xvi16ger2pp, let",
                "PMSK=0b11, XMSK=0b1111, and YMSK=0b1111.",
                "",
                "For each integer value i from 0 to 3 and each integer",
                "value j from 0 to 3, do the following.",
                "",
                "",
                "",
                "If bit i of XMSK is equal to 1 and bit",
                "j of YMSK is equal to 1, do the following.",
                "",
                "",
                "",
                "If bit 0 of PMSK is equal to 1, let",
                "prod0 be the product of the 16-bit signed integer value",
                "in halfword 0 of word element i of VSR[XA]",
                "and the 16-bit signed integer value in halfword 0 of word element",
                "j of VSR[XB].",
                "Otherwise, let  prod0 be the value 0.",
                "",
                "",
                "If bit 1 of PMSK is equal to 1, let",
                "prod1 be the product of the 16-bit signed integer value",
                "in halfword 1 of word element i of VSR[XA]",
                "and the 16-bit signed integer value in halfword 1 of word element",
                "j of VSR[XB].",
                "Otherwise, let  prod1 be the value 0.",
                "",
                "",
                "Let psum be the sum of prod0 and prod1.",
                "",
                "",
                "For [pm]xvi16ger2, psum is placed into word element j of ACC[AT][i] in 32-bit signed integer format.",
                "",
                "",
                "For [pm]xvi16ger2pp,",
                "psum is added to the 32-bit signed integer value in word",
                "element j of ACC[AT][i], and the result is",
                "placed into word element j of ACC[AT][i] in",
                "32-bit signed integer format.",
                "",
                "",
                "",
                "Otherwise, let ACC[AT][i][j] is set to 0x0000_0000.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation",
                    "form": "XX3",
                    "mnemonic": "xvi16ger2s",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation Positive multiply, Positive accumulate",
                    "form": "XX3",
                    "mnemonic": "xvi16ger2spp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvi16ger2s",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                },
                {
                    "name": "Prefixed Masked VSX Vector 16-bit Signed Integer GER (rank-2 update) with Saturation Positive multiply, Positive accumulate",
                    "form": "MMIRR:XX3",
                    "mnemonic": "pmxvi16ger2spp",
                    "operands": [
                        "AT",
                        "XA",
                        "XB",
                        "XMSK",
                        "YMSK",
                        "PMSK"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "121",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "PMSK",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "6"
                },
                {
                    "name": "XMSK",
                    "size": "4"
                },
                {
                    "name": "YMSK",
                    "size": "4"
                },
                {
                    "name": "59",
                    "size": "6"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "42",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if \"xvi16ger2s\" | \"xvi16ger2spp\" then do",
                "  PMSK := 0b11",
                "  XMSK := 0b1111",
                "  YMSK := 0b1111",
                "end",
                "",
                "sat_flag := 0",
                "",
                "do i = 0 to 3",
                "  do j = 0 to 3",
                "     if XMSK.bit[i] & YMSK.bit[j] then do",
                "        prod0 := (PMSK.bit[0]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].hword[0]) * EXTS(VSR[32*BX+B].word[j].hword[0])",
                "        prod1 := (PMSK.bit[1]=0) ? 0 : EXTS(VSR[32*AX+A].word[i].hword[1]) * EXTS(VSR[32*BX+B].word[j].hword[1])",
                "",
                "        psum  := prod0 + prod1",
                "",
                "        if \"[pm]xvi16ger2s\" then",
                "           ACC[AT][i].word[j] := si32_CLAMP( psum )",
                "        if \"[pm]xvi16ger2spp\" then",
                "           ACC[AT][i].word[j] := si32_CLAMP( psum + EXTS(ACC[AT][i].word[j] )",
                "",
                "        if sat_flag=1 then VSCR.SAT := 1",
                "     end",
                "     else",
                "        ACC[AT][i][j] := 0x0000_0000",
                "  end",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XA be the value of 32AX + A.",
                "If XA is in the range 4AT to",
                "4AT+3, the instruction form is invalid.",
                "",
                "Let XB be the value of 32BX + B.",
                "If XB is in the range 4AT to",
                "4AT+3, the instruction form is invalid.",
                "",
                "Let the contents of ACC[AT] be a 44",
                "matrix of 32-bit signed integer values.",
                "",
                "For xvi16ger2s or xvi16ger2spp, let",
                "PMSK=0b11, XMSK=0b1111, and YMSK=0b1111.",
                "",
                "For each integer value i from 0 to 3 and each integer",
                "value j from 0 to 3, do the following.",
                "",
                "",
                "",
                "If bit i of XMSK is equal to 1 and bit",
                "j of YMSK is equal to 1, do the following.",
                "",
                "",
                "",
                "If bit 0 of PMSK is equal to 1, let",
                "prod0 be the product of the 16-bit signed integer value",
                "in halfword 0 of word element i of VSR[XA]",
                "and the 16-bit signed integer value in halfword 0 of word element",
                "j of VSR[XB].",
                "Otherwise, let  prod0 be the value 0.",
                "",
                "",
                "If bit 1 of PMSK is equal to 1, let",
                "prod1 be the product of the 16-bit signed integer value",
                "in halfword 1 of word element i of VSR[XA]",
                "and the 16-bit signed integer value in halfword 1 of word element",
                "j of VSR[XB].",
                "Otherwise, let  prod1 be the value 0.",
                "",
                "",
                "Let sum be the sum of prod0 and prod1.",
                "",
                "",
                "For [pm]xvi16ger2s, let",
                "result be psum.",
                "",
                "",
                "For [pm]xvi16ger2spp, let",
                "result be the sum of psum to the 32-bit",
                "signed integer value in word element j of ACC[AT][i].",
                "",
                "",
                "If result is less than -2, result",
                "saturates to -2 and",
                "SAT is set to 1.",
                "",
                "",
                "If result is greater than 2-1, result saturates to 2-1 and SAT is set to 1.",
                "",
                "",
                "result is placed into word element j of",
                "ACC[AT][i] in 32-bit signed integer format.",
                "",
                "",
                "",
                "Otherwise, let ACC[AT][i][j] is set to 0x0000_0000.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Insert Exponent Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xviexpdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "248",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src1 := VSR[32*AX+A].dword[i]",
                "  src2 := VSR[32*BX+B].dword[i]",
                "",
                "  VSR[32*TX+T].dword[i].bit[0]     := src1.bit[0]",
                "  VSR[32*TX+T].dword[i].bit[1:11]  := src2.bit[53:63]",
                "  VSR[32*TX+T].dword[i].bit[12:63] := src1.bit[12:63]",
                "end"
            ],
            "body": [
                "",
                "",
                "",
                "Let XT be the sum 32TX + T.",
                "",
                "Let XA be the sum 32AX + A.",
                "",
                "Let XB be the sum 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in doubleword",
                "element i of VSR[XA].",
                "",
                "",
                "Let src2 be the unsigned integer value in doubleword",
                "element i of VSR[XB].",
                "",
                "",
                "The contents of bits 0 of src1 are placed into bit 0 of",
                "doubleword element i of VSR[XT].",
                "",
                "",
                "The contents of bits 53:63 of src2 are placed into bits",
                "1:11 of doubleword element i of VSR[XT].",
                "",
                "",
                "The contents of bits 12:63 of src1 are placed into bits",
                "12:63 of doubleword element i of VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_insert_exp"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Insert Exponent Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xviexpsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "216",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src1 := VSR[32*AX+A].word[i]",
                "  src2 := VSR[32*BX+B].word[i]",
                "",
                "  VSR[32*TX+T].word[i].bit[0]    := src1.bit[0]",
                "  VSR[32*TX+T].word[i].bit[1:8]  := src2.bit[24:31]",
                "  VSR[32*TX+T].word[i].bit[9:31] := src1.bit[9:31]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the sum 32TX + T.",
                "",
                "Let XA be the sum 32AX + A.",
                "",
                "Let XB be the sum 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the unsigned integer value in word element",
                "i of VSR[XA].",
                "",
                "",
                "Let src2 be the unsigned integer value in word element",
                "i of VSR[XB].",
                "",
                "",
                "The contents of bits 0 of src1 are placed into bit 0 of",
                "word element i of VSR[XT].",
                "",
                "",
                "The contents of bits 24:31 of src2 are placed into bits",
                "1:8 of word element i of VSR[XT].",
                "",
                "",
                "The contents of bits 9:31 of src1 are placed into bits",
                "9:31 of word element i of VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_insert_exp"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Multiply-Add Type-A Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvmaddadp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Vector Multiply-Add Type-M Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvmaddmdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "105",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  if \"xvmaddadp\" then do",
                "     src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[i])",
                "     src2 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[i])",
                "     src3 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  end",
                "  else do",
                "     src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[i])",
                "     src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "     src3 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[i])",
                "  end",
                "",
                "  v   := bfp_MULTIPLY_ADD(src1,src3,src2)",
                "  rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "  if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := result"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "For xvmaddadp, do the following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "For xvmaddmdp, do the following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a product having",
                "unbounded range and precision.",
                "",
                "",
                "See part 1 of Table .",
                "",
                "",
                "src2 is added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "",
                "The sum is normalized.",
                "",
                "",
                "See part 2 of Table .",
                "",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[XT] in double-precision format.",
                "",
                "",
                "See Table,",
                "Vector Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_rsqrt",
                "vec_madd",
                "vec_recipdiv"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Multiply-Add Type-A Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvmaddasp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Vector Multiply-Add Type-M Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvmaddmsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "73",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  if \"xvmaddasp\" then do",
                "     src1 := bfp_CONVERT_FROM_BFP32(VSR[32*AX+A].word[i])",
                "     src2 := bfp_CONVERT_FROM_BFP32(VSR[32*TX+T].word[i])",
                "     src3 := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "  end",
                "  else do",
                "     src1 := bfp_CONVERT_FROM_BFP32(VSR[32*AX+A].word[i])",
                "     src2 := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "     src3 := bfp_CONVERT_FROM_BFP32(VSR[32*TX+T].word[i])",
                "  end",
                "",
                "  v   := bfp_MULTIPLY_ADD(src1,src3,src2)",
                "  rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "  if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := result"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "For xvmaddasp, do the following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "For xvmaddmsp, do the following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a product having",
                "unbounded range and precision.",
                "",
                "",
                "See part 1 of Table .",
                "",
                "",
                "src2 is added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "",
                "The sum is normalized.",
                "",
                "",
                "See part 2 of Table .",
                "",
                "",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into word element i of VSR[XT] in single-precision format.",
                "",
                "",
                "See Table,",
                "Vector Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_madd",
                "vec_recipdiv",
                "vec_rsqrt"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Maximum Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvmaxdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "224",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src1 := VSR[32*AX+A].dword[i]",
                "  src2 := VSR[32*BX+B].dword[i]",
                "  vresult.dword[i] := bfp64_MAXIMUM(src1,src2)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XA].",
                "",
                "",
                "Let src2 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XB].",
                "",
                "",
                "If src1 is greater than src2, src1 is placed into doubleword element i of VSR[XT] in double-precision format.",
                "Otherwise, src2 is placed into doubleword element",
                "i of VSR[XT] in double-precision format.",
                "",
                "",
                "The maximum of +0 and -0 is +0.",
                "The maximum of a QNaN and any value is that value.",
                "The maximum of any value and an SNaN when VE=0 is that",
                "SNaN converted to a QNaN.",
                "",
                "",
                "See Table .",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_max"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Maximum Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvmaxsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "192",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src1 := VSR[32*AX+A].word[i]",
                "  src2 := VSR[32*BX+B].word[i]",
                "  vresult.word[i] := bfp32_MAXIMUM(src1,src2)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point operand",
                "in word element i of VSR[XA].",
                "",
                "",
                "Let src2 be the single-precision floating-point operand",
                "in word element i of VSR[XB].",
                "",
                "",
                "If src1 is greater than src2, src1 is placed into word element i of VSR[XT] in",
                "single-precision format.",
                "Otherwise, src2 is placed into word element i of",
                "VSR[XT] in single-precision format.",
                "",
                "",
                "The maximum of +0 and \u00e2\u20ac\u201c0 is +0.",
                "The maximum of a QNaN and any value is that value.",
                "The maximum of any value and an SNaN when VE=0 is that SNaN converted",
                "to a QNaN.",
                "",
                "",
                "See Table .",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_max"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Minimum Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvmindp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "232",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src1 := VSR[32*AX+A].dword[i]",
                "  src2 := VSR[32*BX+B].dword[i]",
                "  vresult.dword[i] := bfp64_MINIMUM(src1,src2)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XA].",
                "",
                "",
                "Let src2 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XB].",
                "",
                "",
                "If src1 is less than src2, src1",
                "is placed into doubleword element i of VSR[XT] in double-precision format.",
                "Otherwise, src2 is placed into doubleword element",
                "i of VSR[XT] in double-precision format.",
                "",
                "",
                "The minimum of +0 and -0 is -0.",
                "The minimum of a QNaN and any value is that value.",
                "The minimum of any value and an SNaN when VE=0 is that",
                "SNaN converted to a QNaN.",
                "",
                "",
                "See Table .",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_min"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Minimum Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvminsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "200",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src1 := VSR[32*AX+A].word[i]",
                "  src2 := VSR[32*BX+B].word[i]",
                "  vresult.word[i] := bfp32_MINIMUM(src1,src2)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point operand",
                "in word element i of VSR[XA].",
                "",
                "",
                "Let src2 be the single-precision floating-point operand",
                "in word element i of VSR[XB].",
                "",
                "",
                "If src1 is less than src2, src1",
                "is placed into word element i of VSR[XT] in",
                "single-precision format.",
                "Otherwise, src2 is placed into word element i",
                "of VSR[XT] in single-precision format.",
                "",
                "",
                "The minimum of +0 and -0 is -0.",
                "The minimum of a QNaN and any value is that value.",
                "The minimum of any value and an SNaN when VE=0 is that",
                "SNaN converted to a QNaN.",
                "",
                "",
                "See Table .",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_min"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Multiply-Subtract Type-A Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvmsubadp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Vector Multiply-Subtract Type-M Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvmsubmdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "121",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  if \"xvmsubadp\" then do",
                "     src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[i])",
                "     src2 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[i])",
                "     src3 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  end",
                "  else do",
                "     src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[i])",
                "     src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "     src3 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[i])",
                "  end",
                "",
                "  v   := bfp_MULTIPLY_ADD(src1,src3,bfp_NEGATE(src2))",
                "  rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "  if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := result"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "For xvmsubadp, do the following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "For xvmsubmdp, do the following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a product having",
                "unbounded range and precision.",
                "",
                "",
                "See part 1 of Table .",
                "",
                "",
                "src2 is negated and added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "",
                "The sum is normalized.",
                "",
                "",
                "See part 2 of Table .",
                "",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[XT] in double-precision format.",
                "",
                "",
                "See Table,",
                "Vector Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_msub"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Multiply-Subtract Type-A Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvmsubasp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Vector Multiply-Subtract Type-M Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvmsubmsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "89",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  if \"xvmsubasp\" then do",
                "     src1 := bfp_CONVERT_FROM_BFP32(VSR[32*AX+A].word[i])",
                "     src2 := bfp_CONVERT_FROM_BFP32(VSR[32*TX+T].word[i])",
                "     src3 := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "  end",
                "  else do",
                "     src1 := bfp_CONVERT_FROM_BFP32(VSR[32*AX+A].word[i])",
                "     src2 := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "     src3 := bfp_CONVERT_FROM_BFP32(VSR[32*TX+T].word[i])",
                "  end",
                "",
                "  v   := bfp_MULTIPLY_ADD(src1,src3,bfp_NEGATE(src2))",
                "  rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "  if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := result"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "For xvmsubasp, do the following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "For xvmsubmsp, do the following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a product having",
                "unbounded range and precision.",
                "",
                "",
                "See part 1 of Table .",
                "",
                "",
                "src2 is negated and added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "",
                "The sum is normalized.",
                "",
                "",
                "See part 2 of Table .",
                "",
                "",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into word element i of VSR[XT] in single-precision format.",
                "",
                "",
                "See Table,",
                "Vector Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_msub"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Multiply Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvmuldp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "112",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[i])",
                "  src3 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  v    := bfp_MULTIPLY(src1,src3)",
                "  rnd  := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XA].",
                "",
                "",
                "Let src2 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XB].",
                "",
                "",
                "src1 is multiplied by src2, producing a product having",
                "unbounded range and precision.",
                "",
                "",
                "The product is normalized.",
                "",
                "",
                "See Table .",
                "",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[XT] in double-precision format.",
                "",
                "",
                "See Table,",
                "Vector Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mul",
                "vec_recipdiv",
                "vec_rsqrt"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Multiply Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvmulsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "80",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src1 := bfp_CONVERT_FROM_BFP32(VSR[32*AX+A].word[i])",
                "  src3 := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "  v    := bfp_MULTIPLY(src1,src3)",
                "  rnd  := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point operand",
                "in word element i of VSR[XA].",
                "",
                "",
                "Let src2 be the single-precision floating-point operand",
                "in word element i of VSR[XB].",
                "",
                "",
                "src1 is multiplied by src2, producing a product having",
                "unbounded range and precision.",
                "",
                "",
                "The product is normalized.",
                "",
                "",
                "See Table .",
                "",
                "",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into word element i of VSR[XT] in single-precision format.",
                "",
                "",
                "See Table,",
                "Vector Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_mul",
                "vec_recipdiv",
                "vec_rsqrt"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Negative Absolute Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xvnabsdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "489",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src := VSR[32*BX+B].dword[i]",
                "  VSR[32*TX+T].dword[i] := bfp64_NEGATIVE_ABSOLUTE(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The contents of doubleword element i of VSR[XB], with bit 0 set to 1, is placed into doubleword element",
                "i of VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_nabs"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Negative Absolute Single-Precision",
                    "form": "XX2",
                    "mnemonic": "xvnabssp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "425",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src := VSR[32*BX+B].word[i]",
                "  VSR[32*TX+T].word[i] := bfp32_NEGATIVE_ABSOLUTE(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The contents of word element i of VSR[XB],",
                "with bit 0 set to 1, is placed into word element i of VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_nabs"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Negate Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xvnegdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "505",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src := VSR[32*BX+B].dword[i]",
                "  VSR[32*TX+T].dword[i] := bfp64_NEGATE(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The contents of doubleword element i of VSR[XB], with bit 0 complemented, is placed into doubleword element",
                "i of VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_neg"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Negate Single-Precision",
                    "form": "XX2",
                    "mnemonic": "xvnegsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "441",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src := VSR[32*BX+B].word[i]",
                "  VSR[32*TX+T].word[i] := bfp32_NEGATE(src)",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The contents of word element i of VSR[XB],",
                "with bit 0 complemented, is placed into word element i of VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_neg"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Negative Multiply-Add Type-A Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvnmaddadp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Vector Negative Multiply-Add Type-M Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvnmaddmdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "233",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  if \"xvnmaddadp\" then do",
                "     src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[i])",
                "     src2 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[i])",
                "     src3 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  end",
                "  else do",
                "     src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[i])",
                "     src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "     src3 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[i])",
                "  end",
                "",
                "  v   := bfp_MULTIPLY_ADD(src1,src3,src2)",
                "  rnd := bfp_NEGATE(bfp_ROUND_TO_BFP64(FPSCR.RN,v))",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "  if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "For xvnmaddadp, do the following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "For xvnmaddmdp, do the following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a product having",
                "unbounded range and precision.",
                "",
                "",
                "See part 1 of Table .",
                "",
                "",
                "src2 is added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "",
                "The sum is normalized.",
                "",
                "",
                "See part 2 of Table .",
                "",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is negated and placed into doubleword element i of VSR[XT] in double-precision format.",
                "",
                "",
                "See",
                "Table,",
                "Vector Floating-Point Final Result with Negation, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results-with-Negation.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_nmadd"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Negative Multiply-Add Type-A Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvnmaddasp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Vector Negative Multiply-Add Type-M Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvnmaddmsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "201",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  if \"xvnmaddasp\" then do",
                "     src1 := bfp_CONVERT_FROM_BFP32(VSR[32*AX+A].word[i])",
                "     src2 := bfp_CONVERT_FROM_BFP32(VSR[32*TX+T].word[i])",
                "     src3 := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "  end",
                "  else do",
                "     src1 := bfp_CONVERT_FROM_BFP32(VSR[32*AX+A].word[i])",
                "     src2 := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "     src3 := bfp_CONVERT_FROM_BFP32(VSR[32*TX+T].word[i])",
                "  end",
                "",
                "  v   := bfp_MULTIPLY_ADD(src1,src3,src2)",
                "  rnd := bfp_NEGATE(bfp_ROUND_TO_BFP32(FPSCR.RN,v))",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP32(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "  if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "For xvnmaddasp, do the following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "For xvnmaddmsp, do the following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a product having",
                "unbounded range and precision.",
                "",
                "",
                "See part 1 of Table .",
                "",
                "",
                "src2 is added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "",
                "The sum is normalized.",
                "",
                "",
                "See part 2 of Table .",
                "",
                "",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is negated and placed into word element i of",
                "VSR[XT] in single-precision format.",
                "",
                "",
                "See",
                "Table,",
                "Vector Floating-Point Final Result with Negation, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results-with-Negation.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_nmadd"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Negative Multiply-Subtract Type-A Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvnmsubadp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Vector Negative Multiply-Subtract Type-M Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvnmsubmdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "249",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  if \"xvnmsubadp\" then do",
                "     src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[i])",
                "     src2 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[i])",
                "     src3 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  end",
                "  else do",
                "     src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[i])",
                "     src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "     src3 := bfp_CONVERT_FROM_BFP64(VSR[32*TX+T].dword[i])",
                "  end",
                "",
                "  v   := bfp_MULTIPLY_ADD(src1,src3,bfp_NEGATE(src2))",
                "  rnd := bfp_NEGATE(bfp_ROUND_TO_BFP64(FPSCR.RN,v))",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "  if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "For xvmsubadp, do the following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "For xvmsubmdp, do the following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a product having",
                "unbounded range and precision.",
                "",
                "",
                "See part 1 of Table .",
                "",
                "",
                "src2 is negated and added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "",
                "The sum is normalized.",
                "",
                "",
                "See part 2 of Table .",
                "",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is negated and placed into doubleword element i of VSR[XT] in double-precision format.",
                "",
                "",
                "See",
                "Table,",
                "Vector Floating-Point Final Result with Negation, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results-with-Negation.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_recipdiv",
                "vec_rsqrt",
                "vec_nmsub"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Negative Multiply-Subtract Type-A Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvnmsubasp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                },
                {
                    "name": "VSX Vector Negative Multiply-Subtract Type-M Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvnmsubmsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "217",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  if \"xvnmsubasp\" then do",
                "     src1 := bfp_CONVERT_FROM_BFP32(VSR[32*AX+A].word[i])",
                "     src2 := bfp_CONVERT_FROM_BFP32(VSR[32*TX+T].word[i])",
                "     src3 := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "  end",
                "  else do",
                "     src1 := bfp_CONVERT_FROM_BFP32(VSR[32*AX+A].word[i])",
                "     src2 := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "     src3 := bfp_CONVERT_FROM_BFP32(VSR[32*TX+T].word[i])",
                "  end",
                "",
                "  v   := bfp_MULTIPLY_ADD(src1,src3,bfp_NEGATE(src2))",
                "  rnd := bfp_NEGATE(bfp_ROUND_TO_BFP32(FPSCR.RN,v))",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP32(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vximz_flag=1 then SetFX(FPSCR.VXIMZ)",
                "  if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vximz_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "For xvnmsubasp, do the following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "For xvnmsubmsp, do the following.",
                "",
                "",
                "",
                "",
                "",
                "",
                "src1 is multiplied by src3, producing a product having",
                "unbounded range and precision.",
                "",
                "",
                "See part 1 of Table .",
                "",
                "",
                "src2 is negated and added to the product, producing a sum",
                "having unbounded range and precision.",
                "",
                "",
                "The sum is normalized.",
                "",
                "",
                "See part 2 of Table .",
                "",
                "",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is negated and placed into word element i of",
                "VSR[XT] in single-precision format.",
                "",
                "",
                "See",
                "Table,",
                "Vector Floating-Point Final Result with Negation, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results-with-Negation.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_recipdiv",
                "vec_nmsub",
                "vec_rsqrt"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Round to Double-Precision Integer using round to Nearest Away",
                    "form": "XX2",
                    "mnemonic": "xvrdpi",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "201",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  rnd := bfp_ROUND_TO_INTEGER_NEAR_AWAY(src)",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the double-precision floating-point operand in",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "src is rounded to an integer using the rounding mode",
                "Round to Nearest Away.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[XT] in double-precision format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_nearbyint",
                "vec_round"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Round to Double-Precision Integer Exact using Current rounding mode",
                    "form": "XX2",
                    "mnemonic": "xvrdpic",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "235",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "",
                "  if FPSCR.RN=0b00 then",
                "     rnd := bfp_ROUND_TO_INTEGER_NEAR_EVEN(src)",
                "  if FPSCR.RN=0b01 then",
                "     rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "  if FPSCR.RN=0b10 then",
                "     rnd := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "  if FPSCR.RN=0b11 then",
                "     rnd := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "  ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the double-precision floating-point operand in",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "src is rounded to an integer using the rounding mode",
                "specified by RN.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[XT] in double-precision format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_rint"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Round to Double-Precision Integer using round toward -Infinity",
                    "form": "XX2",
                    "mnemonic": "xvrdpim",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "249",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  rnd := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the double-precision floating-point operand in",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "src is rounded to an integer using the rounding mode",
                "Round toward -Infinity.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[XT] in double-precision format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_floor"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Round to Double-Precision Integer using round toward +Infinity",
                    "form": "XX2",
                    "mnemonic": "xvrdpip",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "233",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  rnd := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the double-precision floating-point operand in",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "src is rounded to an integer using the rounding mode",
                "Round toward +Infinity.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[XT] in double-precision format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_ceil"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Round to Double-Precision Integer using round toward Zero",
                    "form": "XX2",
                    "mnemonic": "xvrdpiz",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "217",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the double-precision floating-point operand in",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "src is rounded to an integer using the rounding mode",
                "Round toward Zero.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[XT] in double-precision format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_trunc"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Reciprocal Estimate Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xvredp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "218",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  v   := bfp_RECIPROCAL_ESTIMATE(src)",
                "  rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "  vresult.word[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.ZE & zx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the double-precision floating-point operand in",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "A double-precision floating-point estimate of the reciprocal of",
                "src is placed into doubleword element i of",
                "VSR[XT] in double-precision format.",
                "",
                "",
                "Unless the reciprocal of src would be a zero, an",
                "infinity, or a QNaN, the estimate has a relative error in precision",
                "no greater than one part in 16384 of the reciprocal of src. That is,",
                "",
                "",
                "Operation with various special values of the operand is summarized",
                "below.",
                "",
                "",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "The results of executing this instruction is permitted to vary",
                "between implementations, and between different executions on the same",
                "implementation.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_re",
                "vec_recipdiv"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Reciprocal Estimate Single-Precision",
                    "form": "XX2",
                    "mnemonic": "xvresp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "154",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "  v   := bfp_RECIPROCAL_ESTIMATE(src)",
                "  rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.ZE & zx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point operand in",
                "word element i of VSR[XB].",
                "",
                "",
                "A single-precision floating-point estimate of the reciprocal of",
                "src is placed into word element i of",
                "VSR[XT] in single-precision format.",
                "",
                "",
                "Unless the reciprocal of src would be a zero, an",
                "infinity, or a QNaN, the estimate has a relative error in precision",
                "no greater than one part in 16384 of the reciprocal of src. That is,",
                "",
                "",
                "Operation with various special values of the operand is summarized",
                "below.",
                "",
                "",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "The results of executing this instruction is permitted to vary",
                "between implementations, and between different executions on the same",
                "implementation.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_re",
                "vec_recipdiv"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Round to Single-Precision Integer using round to Nearest Away",
                    "form": "XX2",
                    "mnemonic": "xvrspi",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "137",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "  rnd := bfp_ROUND_TO_INTEGER_NEAR_AWAY(src)",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point operand in",
                "word element i of VSR[XB].",
                "",
                "",
                "src is rounded to an integer using the rounding mode",
                "Round to Nearest Away.",
                "",
                "",
                "The result is placed into word element i of VSR[XT] in",
                "single-precision format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_nearbyint"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Round to Single-Precision Integer Exact using Current rounding mode",
                    "form": "XX2",
                    "mnemonic": "xvrspic",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "171",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "  if FPSCR.RN=0b00 then",
                "rnd := bfp_ROUND_TO_INTEGER_NEAR_EVEN(src)",
                "  if FPSCR.RN=0b01 then",
                "rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "  if FPSCR.RN=0b10 then",
                "rnd := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "  if FPSCR.RN=0b11 then",
                "rnd := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point operand in",
                "word element i of VSR[XB].",
                "",
                "",
                "src is rounded to an integer value using the rounding",
                "mode specified by RN.",
                "",
                "",
                "The result is placed into word element i of VSR[XT] in single-precision format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_rint"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Round to Single-Precision Integer using round toward -Infinity",
                    "form": "XX2",
                    "mnemonic": "xvrspim",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "185",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "  rnd := bfp_ROUND_TO_INTEGER_FLOOR(src)",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point operand in",
                "word element i of VSR[XB].",
                "",
                "",
                "src is rounded to an integer using the rounding mode",
                "Round toward -Infinity.",
                "",
                "",
                "The result is placed into word element i of VSR[XT] in",
                "single-precision format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_floor"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Round to Single-Precision Integer using round toward +Infinity",
                    "form": "XX2",
                    "mnemonic": "xvrspip",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "169",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "  rnd := bfp_ROUND_TO_INTEGER_CEIL(src)",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point operand in",
                "word element i of VSR[XB].",
                "",
                "",
                "src is rounded to an integer using the rounding mode",
                "Round toward +Infinity.",
                "",
                "",
                "The result is placed into word element i of VSR[XT] in single-precision format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_ceil"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Round to Single-Precision Integer using round toward Zero",
                    "form": "XX2",
                    "mnemonic": "xvrspiz",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "153",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "  rnd := bfp_ROUND_TO_INTEGER_TRUNC(src)",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point operand in",
                "word element i of VSR[XB].",
                "",
                "",
                "src is rounded to an integer using the rounding mode",
                "Round toward Zero.",
                "",
                "",
                "The result is placed into word element i of VSR[XT] in single-precision format.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_trunc"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Reciprocal Square Root Estimate Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xvrsqrtedp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "202",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  v   := bfp_RECIPROCAL_SQUARE_ROOT_ESTIMATE(src)",
                "  rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "  if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxsqrt_flag)",
                "ex_flag := ex_flag | (FPSCR.ZE & zx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the double-precision floating-point operand in",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "A double-precision floating-point estimate of the reciprocal square",
                "root of src is placed into doubleword element i of VSR[XT] in double-precision format.",
                "",
                "",
                "Unless the reciprocal of the square root of src would be",
                "a zero, an infinity, or a QNaN, the estimate has a relative error in",
                "precision no greater than one part in 16384 of the reciprocal of the",
                "square root of src. That is,",
                "",
                "",
                "Operation with various special values of the operand is summarized",
                "below.",
                "",
                "",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "The results of executing this instruction is permitted to vary",
                "between implementations, and between different executions on the same",
                "implementation.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_rsqrt",
                "vec_rsqrte"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Reciprocal Square Root Estimate Single-Precision",
                    "form": "XX2",
                    "mnemonic": "xvrsqrtesp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "138",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "  v   := bfp_RECIPROCAL_SQUARE_ROOT_ESTIMATE(src)",
                "  rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "  if zx_flag=1 then SetFX(FPSCR.ZX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxsqrt_flag)",
                "ex_flag := ex_flag | (FPSCR.ZE & zx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point operand in",
                "word element i of VSR[XB].",
                "",
                "",
                "A single-precision floating-point estimate of the reciprocal square",
                "root of src is placed into word element i of",
                "VSR[XT] in single-precision format.",
                "",
                "",
                "Unless the reciprocal of the square root of src would be",
                "a zero, an infinity, or a QNaN, the estimate has a relative error in",
                "precision no greater than one part in 16384 of the reciprocal of the",
                "square root of src. That is,",
                "",
                "",
                "Operation with various special values of the operand is summarized",
                "below.",
                "",
                "",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "The results of executing this instruction is permitted to vary",
                "between implementations, and between different executions on the same",
                "implementation.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_rsqrt",
                "vec_rsqrte"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Square Root Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xvsqrtdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "203",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  v   := bfp_SQUARE_ROOT(src)",
                "  rnd := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxsqrt_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the double-precision floating-point operand in",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "The unbounded-precision square root of src is produced.",
                "",
                "",
                "See Table .",
                "",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into doubleword element i of",
                "VSR[XT] in double-precision format.",
                "",
                "",
                "See Table,",
                "Vector Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sqrt"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Square Root Single-Precision",
                    "form": "XX2",
                    "mnemonic": "xvsqrtsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "139",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].word[i])",
                "  v   := bfp_SQUARE_ROOT(src)",
                "  rnd := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxsqrt_flag=1 then SetFX(FPSCR.VXSQRT)",
                "  if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxsqrt_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the",
                "following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point operand in",
                "word element i of VSR[XB].",
                "",
                "",
                "The unbounded-precision square root of src is produced.",
                "",
                "",
                "See Table .",
                "",
                "",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into word element i of VSR[XT] in single-precision format.",
                "",
                "",
                "See Table,",
                "Vector Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sqrt"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Subtract Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvsubdp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "104",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  reset_xflags()",
                "",
                "  src1 := bfp_CONVERT_FROM_BFP64(VSR[32*AX+A].dword[i])",
                "  src2 := bfp_CONVERT_FROM_BFP64(VSR[32*BX+B].dword[i])",
                "  v    := bfp_ADD(src1,bfp_NEGATE(src2))",
                "  rnd  := bfp_ROUND_TO_BFP64(0b0,FPSCR.RN,v)",
                "",
                "  vresult.dword[i] := bfp64_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxisi_flag=1 then SetFX(FPSCR.VXISI)",
                "  if ox_flag=1 then SetFX(FPSCR.OX)",
                "  if ux_flag=1 then SetFX(FPSCR.UX)",
                "  if xx_flag=1 then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XA].",
                "",
                "",
                "Let src2 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XB].",
                "",
                "",
                "src2 is negated and added to src1, producing a",
                "sum having unbounded range and precision.",
                "",
                "",
                "The sum is normalized.",
                "",
                "",
                "See Table .",
                "",
                "",
                "The intermediate result is rounded to double-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into doubleword element i of VSR[XT]",
                "in double-precision format.",
                "",
                "",
                "See Table,",
                "Vector Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sub"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Subtract Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvsubsp",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "72",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ex_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  reset_xflags()",
                "",
                "  src1 := bfp_CONVERT_FROM_BFP32(VSR[32*AX+A].word[i])",
                "  src2 := bfp_CONVERT_FROM_BFP32(VSR[32*BX+B].word[i])",
                "  v    := bfp_ADD(src1,bfp_NEGATE(src2))",
                "  rnd  := bfp_ROUND_TO_BFP32(FPSCR.RN,v)",
                "",
                "  vresult.word[i] := bfp32_CONVERT_FROM_BFP(rnd)",
                "",
                "  if vxsnan_flag=1 then SetFX(FPSCR.VXSNAN)",
                "  if vxisi_flag=1  then SetFX(FPSCR.VXISI)",
                "  if ox_flag=1     then SetFX(FPSCR.OX)",
                "  if ux_flag=1     then SetFX(FPSCR.UX)",
                "  if xx_flag=1     then SetFX(FPSCR.XX)",
                "",
                "  ex_flag := ex_flag | (FPSCR.VE & vxsnan_flag)",
                "ex_flag := ex_flag | (FPSCR.VE & vxisi_flag)",
                "ex_flag := ex_flag | (FPSCR.OE & ox_flag)",
                "ex_flag := ex_flag | (FPSCR.UE & ux_flag)",
                "ex_flag := ex_flag | (FPSCR.XE & xx_flag)",
                "end",
                "",
                "if ex_flag=0 then VSR[32*TX+T] := vresult"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point operand",
                "in word element i of VSR[XA].",
                "",
                "",
                "Let src2 be the single-precision floating-point operand",
                "in word element i of VSR[XB].",
                "",
                "",
                "src2 is negated and added to src1, producing a",
                "sum having unbounded range and precision.",
                "",
                "",
                "The sum is normalized.",
                "",
                "",
                "See Table .",
                "",
                "",
                "The intermediate result is rounded to single-precision using the",
                "rounding mode specified by RN.",
                "",
                "",
                "See Table,",
                "Scalar Floating-Point Intermediate Result Handling, on",
                "pagetable:PPC1ChVSX-Floating-Point-Result-Rounding.",
                "",
                "",
                "The result is placed into word element i of VSR[XT] in",
                "single-precision format.",
                "",
                "",
                "See Table,",
                "Vector Floating-Point Final Result, on",
                "pagetable:PPC1ChVSX-Vector-Floating-Point-Results.",
                "",
                "",
                "If a trap-enabled exception occurs in any element of the vector, no",
                "results are written to VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sub"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Test for software Divide Double-Precision",
                    "form": "XX3",
                    "mnemonic": "xvtdivdp",
                    "operands": [
                        "BF",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "125",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "eq_flag := 0b0",
                "gt_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  src1    := VSR[32*AX+A].dword[i]",
                "  src2    := VSR[32*BX+B].dword[i]",
                "  e_a     := src1.bit[1:11] - 1023",
                "  e_b     := src2.bit[1:11] - 1023",
                "  fe_flag := fe_flag | IsNaN(src1) | IsInf(src1) |",
                "             IsNaN(src2) | IsInf(src2) | IsZero(src2) |",
                "             ( e_b <= -1022 ) |",
                "             ( e_b >=  1021 ) |",
                "             ( !IsZero(src1) & ( (e_a - e_b) >=  1023 ) ) |",
                "             ( !IsZero(src1) & ( (e_a - e_b) <= -1021 ) ) |",
                "             ( !IsZero(src1) & ( e_a <= -970 ) )",
                "  fg_flag := fg_flag | IsInf(src1) | IsInf(src2) |",
                "             IsZero(src2) | IsDen(src2)",
                "end",
                "",
                "fl_flag := xvredp_error() <= 2<sup>-14</sup>",
                "CR[BF]  := 0b1 || fg_flag || fe_flag || 0b0"
            ],
            "body": [
                "",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "fe_flag is initialized to 0.",
                "",
                "fg_flag is initialized to 0.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src1 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XA].",
                "",
                "",
                "Let src2 be the double-precision floating-point operand",
                "in doubleword element i of VSR[XB].",
                "",
                "",
                "Let e_a be the unbiased exponent of src1.",
                "",
                "",
                "Let e_b be the unbiased exponent of src2.",
                "",
                "",
                "fe_flag is set to 1 for any of the following",
                "conditions.",
                "",
                "",
                "",
                "",
                "",
                "",
                "fg_flag is set to 1 for any of the following",
                "conditions.",
                "",
                "",
                "",
                "",
                "CR field BF is set to the value 0b1||fg_flag||fe_flag||0b0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Test for software Divide Single-Precision",
                    "form": "XX3",
                    "mnemonic": "xvtdivsp",
                    "operands": [
                        "BF",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "93",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "eq_flag := 0b0",
                "gt_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  src1    := VSR[32*AX+A].word[i]",
                "  src2    := VSR[32*BX+B].word[i]",
                "  e_a     := src1.bit[1:8] - 127",
                "  e_b     := src2.bit[1:8] - 127",
                "  fe_flag := fe_flag | IsNaN(src1) | IsInf(src1) |",
                "             IsNaN(src2) | IsInf(src2) | IsZero(src2) |",
                "             ( e_b <= -126 ) |",
                "             ( e_b >=  125 ) |",
                "             ( !IsZero(src1) & ( (e_a - e_b) >=  127 ) ) |",
                "             ( !IsZero(src1) & ( (e_a - e_b) <= -125 ) ) |",
                "             ( !IsZero(src1) & ( e_a <= -103 ) )",
                "  fg_flag := fg_flag | IsInf(src1) | IsInf(src2) |",
                "             IsZero(src2) | IsDen(src2)",
                "end",
                "",
                "fl_flag := xvredp_error() <= 2<sup>-14</sup>",
                "CR.field[BF]  := 0b1 || fg_flag || fe_flag || 0b0"
            ],
            "body": [
                "",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "fe_flag is initialized to 0.",
                "",
                "fg_flag is initialized to 0.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src1 be the single-precision floating-point operand",
                "in word element i of VSR[XA].",
                "",
                "",
                "Let src2 be the single-precision floating-point operand",
                "in word element i of VSR[XB].",
                "",
                "",
                "Let e_a be the unbiased exponent of src1.",
                "",
                "",
                "Let e_b be the unbiased exponent of src2.",
                "",
                "",
                "fe_flag is set to 1 for any of the following",
                "conditions.",
                "",
                "",
                "",
                "",
                "",
                "",
                "fg_flag is set to 1 for any of the following",
                "conditions.",
                "",
                "",
                "",
                "",
                "CR field BF is set to the value 0b1||fg_flag||fe_flag||0b0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Test for software Square Root Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xvtsqrtdp",
                    "operands": [
                        "BF",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "7"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "234",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "fe_flag := 0b0",
                "fg_flag := 0b0",
                "",
                "do i = 0 to 1",
                "  src     := VSR[32*BX+B].dword[i]",
                "  e_b     := src2.bit[1:11] - 1023",
                "  fe_flag := fe_flag | IsNaN(src) | IsInf(src)  |",
                "             IsZero(src) | IsNeg(src) | ( e_a <= -970 )",
                "  fg_flag := fg_flag | IsInf(src) | IsZero(src) |",
                "             IsDen(src)",
                "end",
                "",
                "fl_flag := xvrsqrtedp_error() <= 2<sup>-14</sup>",
                "CR.field[BF]  := 0b1 || fg_flag || fe_flag || 0b0"
            ],
            "body": [
                "",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "fe_flag is initialized to 0.",
                "",
                "fg_flag is initialized to 0.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the double-precision floating-point operand in",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "Let e_b be the unbiased exponent of src.",
                "",
                "",
                "fe_flag is set to 1 for any of the following",
                "conditions.",
                "",
                "",
                "",
                "",
                "",
                "",
                "fg_flag is set to 1 for the following",
                "condition.",
                "",
                "",
                "",
                "",
                "CR field BF is set to the value 0b1||fg_flag||fe_flag||0b0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Test for software Square Root Single-Precision",
                    "form": "XX2",
                    "mnemonic": "xvtsqrtsp",
                    "operands": [
                        "BF",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "7"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "170",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "fe_flag := 0b0",
                "fg_flag := 0b0",
                "",
                "do i = 0 to 3",
                "  src     := VSR[32*BX+B].word[i]",
                "  e_b     := src2.bit[1:8] - 127",
                "  fe_flag := fe_flag | IsNaN(src) | IsInf(src) |",
                "             IsZero(src) | IsNeg(src) | ( e_a <= -103 )",
                "  fg_flag := fg_flag | IsInf(src) | IsZero(src) |",
                "             IsDen(src)",
                "end",
                "",
                "fl_flag = xvrsqrtesp_error() <= 2<sup>-14</sup>",
                "CR.field[BF]  = 0b1 || fg_flag || fe_flag || 0b0"
            ],
            "body": [
                "",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "fe_flag is initialized to 0.",
                "",
                "fg_flag is initialized to 0.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point operand in",
                "word element i of VSR[XB].",
                "",
                "",
                "Let e_b be the unbiased exponent of src.",
                "",
                "",
                "fe_flag is set to 1 for any of the following",
                "conditions.",
                "",
                "",
                "",
                "",
                "",
                "",
                "fg_flag is set to 1 for the following",
                "condition.",
                "",
                "",
                "",
                "",
                "CR field BF is set to the value 0b1||fg_flag||fe_flag||0b0.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Test Data Class Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xvtstdcdp",
                    "operands": [
                        "XT",
                        "XB",
                        "DCMX"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "dcmx2",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "15",
                    "size": "4"
                },
                {
                    "name": "dcmx0",
                    "size": "1"
                },
                {
                    "name": "5",
                    "size": "3"
                },
                {
                    "name": "dcmx1",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "DCMX := dc || dm || dx",
                "",
                "do i = 0 to 1",
                "  src            := VSR[32*BX+B].dword[i]",
                "  sign           := src.bit[0]",
                "  exponent       := src.bit[1:11]",
                "  fraction       := src.bit[12:63]",
                "",
                "  class.Infinity := (exponent = 0x7FF) & (fraction  = 0)",
                "  class.NaN      := (exponent = 0x7FF) & (fraction != 0)",
                "  class.Zero     := (exponent = 0x000) & (fraction  = 0)",
                "  class.Denormal := (exponent = 0x000) & (fraction != 0)",
                "",
                "  match          := (DCMX.bit[0] & class.NaN)              |",
                " (DCMX.bit[1] & class.Infinity & !sign) |",
                " (DCMX.bit[2] & class.Infinity &  sign) |",
                " (DCMX.bit[3] & class.Zero     & !sign) |",
                " (DCMX.bit[4] & class.Zero     &  sign) |",
                " (DCMX.bit[5] & class.Denormal & !sign) |",
                " (DCMX.bit[6] & class.Denormal &  sign)",
                "",
                "  if match = 1 then",
                "     VSR[32*TX+T].dword[i] := 0xFFFF_FFFF_FFFF_FFFF",
                "  else",
                "     VSR[32*TX+T].dword[i] := 0x0000_0000_0000_0000",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XB be the sum 32BX + B.",
                "",
                "Let XT be the sum 32TX + T.",
                "",
                "Let DCMX be the value dc concatenated with",
                "dm concatenated with dx.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "If src matches one of the 7 possible data classes",
                "specified by DCMX (Data Class Mask), the contents of",
                "doubleword element i of VSR[XT] are set to",
                "0xFFFF_FFFF_FFFF_FFFF.",
                "Otherwise, the contents of doubleword element i of",
                "VSR[XT] are set to 0x0000_0000_0000_0000.",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_test_data_class"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Test Data Class Single-Precision",
                    "form": "XX2",
                    "mnemonic": "xvtstdcsp",
                    "operands": [
                        "XT",
                        "XB",
                        "DCMX"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "dcmx2",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "13",
                    "size": "4"
                },
                {
                    "name": "dcmx0",
                    "size": "1"
                },
                {
                    "name": "5",
                    "size": "3"
                },
                {
                    "name": "dcmx1",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "DCMX := dc || dm || dx",
                "",
                "do i = 0 to 3",
                "  src            := VSR[32*BX+B].word[i]",
                "  sign           := src.bit[0]",
                "  exponent       := src.bit[1:8]",
                "  fraction       := src.bit[9:31]",
                "",
                "  class.Infinity := (exponent = 0xFF) & (fraction  = 0)",
                "  class.NaN      := (exponent = 0xFF) & (fraction != 0)",
                "  class.Zero     := (exponent = 0x00) & (fraction  = 0)",
                "  class.Denormal := (exponent = 0x00) & (fraction != 0)",
                "",
                "  match          := (DCMX.bit[0] & class.NaN)              |",
                " (DCMX.bit[1] & class.Infinity & !sign) |",
                " (DCMX.bit[2] & class.Infinity &  sign) |",
                " (DCMX.bit[3] & class.Zero     & !sign) |",
                " (DCMX.bit[4] & class.Zero     &  sign) |",
                " (DCMX.bit[5] & class.Denormal & !sign) |",
                " (DCMX.bit[6] & class.Denormal &  sign)",
                "",
                "  if match = 1 then",
                "     VSR[32*TX+T].dword[i] := 0xFFFF_FFFF",
                "  else",
                "     VSR[32*TX+T].dword[i] := 0x0000_0000",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XB be the sum 32BX + B.",
                "",
                "Let XT be the sum 32TX + T.",
                "",
                "Let DCMX be the value dc concatenated with",
                "dm concatenated with dx.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point value in",
                "word element i of VSR[XB].",
                "",
                "",
                "If src matches one of the 7 possible data classes",
                "specified by DCMX (Data Class Mask), the contents of word",
                "element i of VSR[XT] are set to 0xFFFF_FFFF.",
                "Otherwise, the contents of word element i of VSR[XT] are set to 0x0000_0000.",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_test_data_class"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Test Least-Significant Bit by Byte",
                    "form": "XX2",
                    "mnemonic": "xvtlsbb",
                    "operands": [
                        "BF",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "BF",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "2",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "475",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ALL_TRUE  := 1",
                "ALL_FALSE := 1",
                "",
                "do i = 0 to 15",
                "  ALL_TRUE  := ALL_TRUE  & (VSR[XB].byte[i].bit[7]=1)",
                "  ALL_FALSE := ALL_FALSE & (VSR[XB].byte[i].bit[7]=0)",
                "end",
                "",
                "CR.field_WRITE(BF, ALL_TRUE, 0, ALL_FALSE, 0);"
            ],
            "body": [
                "",
                "",
                "Set CR field BF to indicate if bit 7 of every byte",
                "element in VSR[XB] is equal to 1 (ALL_TRUE)",
                "or equal to 0 (ALL_FALSE).",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Extract Exponent Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xvxexpdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "475",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src := VSR[32*BX+B].dword[i]",
                "  VSR[32*TX+T].dword[i] := EXTZ64(src.bit[1:11])",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the sum 32TX + T.",
                "",
                "Let XB be the sum 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "The value of the exponent field in src is placed into",
                "doubleword element i of VSR[XT] in unsigned",
                "integer format.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract_exp"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Extract Exponent Single-Precision",
                    "form": "XX2",
                    "mnemonic": "xvxexpsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "8",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "475",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src := VSR[32*BX+B].word[i]",
                "  VSR[32*TX+T].word[i] := EXTZ32(src.bit[1:8])",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the sum 32TX + T.",
                "",
                "Let XB be the sum 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point value in",
                "word element i of VSR[XB].",
                "",
                "",
                "The value of the exponent field in src is placed into",
                "word element i of VSR[XT] in unsigned integer",
                "format.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract_exp"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Extract Significand Double-Precision",
                    "form": "XX2",
                    "mnemonic": "xvxsigdp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "475",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "  src := VSR[32*BX+B].dword[i]",
                "  exponent := EXTZ(src.bit[1:11])",
                "  fraction := EXTZ64(src.bit[12:63])",
                "",
                "  if (exponent != 0) &  (exponent != 2047) then",
                "     fraction := fraction | 0x0010_0000_0000_0000",
                "",
                "  VSR[32*TX+T].dword[i] := fraction",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the sum 32TX + T.",
                "",
                "Let XB be the sum 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "Let src be the double-precision floating-point value in",
                "doubleword element i of VSR[XB].",
                "",
                "",
                "The significand of src is placed into doubleword element",
                "i of VSR[XT] in unsigned integer format.",
                "If src is a normal value, the implicit leading bit is set",
                "to 1.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract_sig"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Extract Significand Single-Precision",
                    "form": "XX2",
                    "mnemonic": "xvxsigsp",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "9",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "475",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "  src := VSR[32*BX+B].word[i]",
                "  exponent := EXTZ(src.bit[1:8])",
                "  fraction := EXTZ32(src.bit[9:31])",
                "",
                "  if (exponent != 0) &  (exponent != 255) then",
                "     fraction := fraction | 0x0080_0000",
                "",
                "  VSR[32*TX+T].word[i] := fraction",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the sum 32TX + T.",
                "",
                "Let XB be the sum 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "Let src be the single-precision floating-point value in",
                "word element i of VSR[XB].",
                "",
                "",
                "The significand of src is placed into word element",
                "i of VSR[XT] in unsigned integer format.",
                "If src is a normal value, the implicit leading bit is set",
                "to 1.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract_sig"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Blend Variable Byte",
                    "form": "8RR:XX4",
                    "mnemonic": "xxblendvb",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "XC"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "80",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "20"
                },
                {
                    "name": "33",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "C",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "2"
                },
                {
                    "name": "CX",
                    "size": "1"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "do i = 0 to 15",
                "  if VSR[32*CX+C].byte[i].bit[0]=0 then",
                "     VSR[32*TX+T].byte[i] := VSR[32*AX+A].byte[i]",
                "  else",
                "     VSR[32*TX+T].byte[i] := VSR[32*BX+B].byte[i]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let XC be the value 32CX + C.",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "If the contents of bit 0 of byte element i of VSR[XC] is equal to 0, the contents of byte element i of",
                "VSR[XA] are placed into byte element i of",
                "VSR[XT].",
                "Otherwise, the contents of byte element i of VSR[XB] are placed into byte element i of VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Blend Variable Halfword",
                    "form": "8RR:XX4",
                    "mnemonic": "xxblendvh",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "XC"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "80",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "20"
                },
                {
                    "name": "33",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "C",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "2"
                },
                {
                    "name": "CX",
                    "size": "1"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "do i = 0 to 7",
                "  if VSR[32*CX+C].hword[i].bit[0]=0 then",
                "     VSR[32*TX+T].hword[i] := VSR[32*AX+A].hword[i]",
                "  else",
                "     VSR[32*TX+T].hword[i] := VSR[32*BX+B].hword[i]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let XC be the value 32CX + C.",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "If the contents of bit 0 of halfword element i of",
                "VSR[XC] is equal to 0, the contents of halfword element",
                "i of VSR[XA] are placed into halfword element",
                "i of VSR[XT].",
                "Otherwise, the contents of halfword element i of",
                "VSR[XB] are placed into halfword element i of",
                "VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Blend Variable Word",
                    "form": "8RR:XX4",
                    "mnemonic": "xxblendvw",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "XC"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "80",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "20"
                },
                {
                    "name": "33",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "C",
                    "size": "5"
                },
                {
                    "name": "2",
                    "size": "2"
                },
                {
                    "name": "CX",
                    "size": "1"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "do i = 0 to 3",
                "  if VSR[32*CX+C].word[i].bit[0]=0 then",
                "     VSR[32*TX+T].word[i] := VSR[32*AX+A].word[i]",
                "  else",
                "     VSR[32*TX+T].word[i] := VSR[32*BX+B].word[i]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let XC be the value 32CX + C.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "If the contents of bit 0 of word element i of VSR[XC] is equal to 0, the contents of word element i of",
                "VSR[XA] are placed into word element i of",
                "VSR[XT].",
                "Otherwise, the contents of word element i of VSR[XB] are placed into word element i of VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Blend Variable Doubleword",
                    "form": "8RR:XX4",
                    "mnemonic": "xxblendvd",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "XC"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "80",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "20"
                },
                {
                    "name": "33",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "C",
                    "size": "5"
                },
                {
                    "name": "3",
                    "size": "2"
                },
                {
                    "name": "CX",
                    "size": "1"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "do i = 0 to 1",
                "  if VSR[32*CX+C].dword[i].bit[0]=0 then",
                "     VSR[32*TX+T].dword[i] := VSR[32*AX+A].dword[i]",
                "  else",
                "     VSR[32*TX+T].dword[i] := VSR[32*BX+B].dword[i]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let XC be the value 32CX + C.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "If the contents of bit 0 of doubleword element i of",
                "VSR[XC] is equal to 0, the contents of doubleword element",
                "i of VSR[XA] are placed into doubleword",
                "element i of VSR[XT].",
                "Otherwise, the contents of doubleword element i of",
                "VSR[XB] are placed into doubleword element i",
                "of VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Byte-Reverse Doubleword",
                    "form": "XX2",
                    "mnemonic": "xxbrd",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "23",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "475",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 1",
                "vsrc := VSR[32*BX+B].dword[i]",
                "  do j = 0 to 7",
                "     VSR[32*TX+T].dword[i].byte[j] := vsrc.byte[7-j]",
                "  end",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 1, do the following.",
                "",
                "",
                "",
                "The contents of byte 7 of doubleword element i of",
                "VSR[XB] are placed into byte 0 of doubleword element",
                "i of VSR[XT].",
                "",
                "",
                "The contents of byte 6 of doubleword element i of",
                "VSR[XB] are placed into byte 1 of doubleword element",
                "i of VSR[XT].",
                "",
                "",
                "The contents of byte 5 of doubleword element i of",
                "VSR[XB] are placed into byte 2 of doubleword element",
                "i of VSR[XT].",
                "",
                "",
                "The contents of byte 4 of doubleword element i of",
                "VSR[XB] are placed into byte 3 of doubleword element",
                "i of VSR[XT].",
                "",
                "",
                "The contents of byte 3 of doubleword element i of",
                "VSR[XB] are placed into byte 4 of doubleword element",
                "i of VSR[XT].",
                "",
                "",
                "The contents of byte 2 of doubleword element i of",
                "VSR[XB] are placed into byte 5 of doubleword element",
                "i of VSR[XT].",
                "",
                "",
                "The contents of byte 1 of doubleword element i of",
                "VSR[XB] are placed into byte 6 of doubleword element",
                "i of VSR[XT].",
                "",
                "",
                "The contents of byte 0 of doubleword element i of",
                "VSR[XB] are placed into byte 7 of doubleword element",
                "i of VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_revb"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Byte-Reverse Halfword",
                    "form": "XX2",
                    "mnemonic": "xxbrh",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "7",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "475",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 7",
                "  vsrc := VSR[32*BX+B].hword[i]",
                "  do j = 0 to 1",
                "     VSR[32*TX+T].hword[i].byte[j] := vsrc.byte[1-j]",
                "  end",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 7, do the following.",
                "",
                "",
                "",
                "The contents of byte 1 of halfword element i of",
                "VSR[XB] are placed into byte 0 of halfword element",
                "i of VSR[XT].",
                "",
                "",
                "The contents of byte 0 of halfword element i of",
                "VSR[XB] are placed into byte 1 of halfword element",
                "i of VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_revb"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Byte-Reverse Quadword",
                    "form": "XX2",
                    "mnemonic": "xxbrq",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "31",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "475",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 15",
                "  VSR[32*TX+T].byte[i] := VSR[32*BX+B].byte[15-i]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "The contents of byte sub-element 15-i of VSR[XB] are placed into byte sub-element i of VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_revb"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Byte-Reverse Word",
                    "form": "XX2",
                    "mnemonic": "xxbrw",
                    "operands": [
                        "XT",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "15",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "475",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "do i = 0 to 3",
                "  vsrc := VSR[32*BX+B].word[i]",
                "  do j = 0 to 3",
                "     VSR[32*TX+T].word[i].byte[j] := vsrc.byte[3-j]",
                "  end",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "For each integer value i from 0 to 3, do the following.",
                "",
                "",
                "",
                "The contents of byte 3 of word element i of VSR[XB] are placed into byte 0 of word element i of",
                "VSR[XT].",
                "",
                "",
                "The contents of byte 2 of word element i of VSR[XB] are placed into byte 1 of word element i of",
                "VSR[XT].",
                "",
                "",
                "The contents of byte 1 of word element i of VSR[XB] are placed into byte 2 of word element i of",
                "VSR[XT].",
                "",
                "",
                "The contents of byte 0 of word element i of VSR[XB] are placed into byte 3 of word element i of",
                "VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_revb"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Evaluate",
                    "form": "8RR:XX4",
                    "mnemonic": "xxeval",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "XC",
                        "IMM"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "80",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "12"
                },
                {
                    "name": "IMM",
                    "size": "8"
                },
                {
                    "name": "34",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "C",
                    "size": "5"
                },
                {
                    "name": "1",
                    "size": "2"
                },
                {
                    "name": "CX",
                    "size": "1"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "src1 := VSR[32xAX+A]",
                "src2 := VSR[32xBX+B]",
                "src3 := VSR[32xCX+C]",
                "result := (~src1&~src2&~src3 & qword_bit_splat(IMM.bit[0]) |",
                "        (~src1&~src2& src3 & qword_bit_splat(IMM.bit[1]) |",
                "        (~src1& src2&~src3 & qword_bit_splat(IMM.bit[2]) |",
                "        (~src1& src2& src3 & qword_bit_splat(IMM.bit[3]) |",
                "        ( src1&~src2&~src3 & qword_bit_splat(IMM.bit[4]) |",
                "        ( src1&~src2& src3 & qword_bit_splat(IMM.bit[5]) |",
                "        ( src1& src2&~src3 & qword_bit_splat(IMM.bit[6]) |",
                "        ( src1& src2& src3 & qword_bit_splat(IMM.bit[7])",
                "VSR[32xTX+T] := result"
            ],
            "body": [
                "",
                "",
                "For each integer value i, 0 to 127, do the following.",
                "",
                "",
                "",
                "Let j be the value of the concatenation of the contents",
                "of bit i of VSR[XA], bit i of",
                "VSR[XB], bit i of VSR[XC].",
                "",
                "",
                "The value of bit j of IMM is placed into bit",
                "i of VSR[XT].",
                "",
                "",
                "See",
                "Table,",
                "xxeval(A, B, C, IMM) Equivalent Functions, on",
                "pagetable:PPC1ChVSX-xxeval-A,-B,-C,-IMM-Equivalent-Functions",
                "for the equivalent function evaluated by this instruction for any",
                "given value of IMM.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Extract Unsigned Word",
                    "form": "XX2",
                    "mnemonic": "xxextractuw",
                    "operands": [
                        "XT",
                        "XB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "165",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src := VSR[32*BX+B].byte[UIM:UIM+3]",
                "",
                "VSR[32*TX+T].dword[0] := EXTZ64(src)",
                "VSR[32*TX+T].dword[1] := 0x0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "The contents of byte elements UIM:UIM+3 of VSR[XB]  are placed into word element 1 of VSR[XT].",
                "The contents of the remaining word elements of VSR[XT]",
                "are set to 0.",
                "",
                "If the value of UIM is greater than 12, the results are",
                "undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_extract4b",
                "vec_insert"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Insert Word",
                    "form": "XX2",
                    "mnemonic": "xxinsertw",
                    "operands": [
                        "XT",
                        "XB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "UIM",
                    "size": "4"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "181",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32*TX+T].byte[UIM:UIM+3] := VSR[32*BX+B].bit[32:63]"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "The contents of word element 1 of VSR[XB] are placed into",
                "byte elements UIM:UIM+3 of VSR[XT].",
                "The contents of the remaining byte elements of VSR[XT]",
                "are not modified.",
                "",
                "If the value of UIM is greater than 12, the results are",
                "undefined.",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_insert",
                "vec_insert4b"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Generate PCV from Byte Mask",
                    "form": "X",
                    "mnemonic": "xxgenpcvbm",
                    "operands": [
                        "XT",
                        "VRB",
                        "IMM"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "IMM",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "919",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if IMM=0b00000 then do  // Big-Endian expansion",
                "  j := 0",
                "  do i = 0 to 15",
                "     if VSR[VRB+32].byte[i].bit[0]=1 then do",
                "        VSR[XT].byte[i] := j",
                "        j := j + 1",
                "     end",
                "     else",
                "        VSR[XT].byte[i] := i + 0x10",
                "  end",
                "end",
                "",
                "else if IMM=0b00001 then do  // Big-Endian compression",
                "  j := 0",
                "  do i = 0 to 15",
                "     if VSR[VRB+32].byte[i].bit[0]=1 then do",
                "        VSR[XT].byte[j] = i",
                "        j = j + 1",
                "     end",
                "  end",
                "  do i = j to 15",
                "     VSR[XT].byte[i] = 0xUU",
                "  end",
                "end",
                "",
                "else if IMM=0b00010 then do  // Little-Endian expansion",
                "  j := 0;",
                "  do i = 0 to 15",
                "     if VSR[VRB+32].byte[15-i].bit[0]=1 then do",
                "        VSR[XT].byte[15-i] := j",
                "        j := j + 1",
                "     end",
                "     else",
                "        VSR[XT].byte[15-i] := i + 0x10",
                "  end",
                "end",
                "",
                "else if IMM=0b00011 then do  // Little-Endian compression",
                "  j := 0",
                "  do i = 0 to 15",
                "     if VSR[VRB+32].byte[15-i].bit[0]=1 then do",
                "        VSR[XT].byte[15-j] := i",
                "        j := j + 1",
                "     end",
                "  end",
                "  do i = j to 15",
                "        VSR[XT].byte[15-i] := 0xUU",
                "  end",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "If IMM=0b00000, let pcv be the permute",
                "control vector required to enable a left-indexed permute (vperm or xxperm) to implement an expansion of the",
                "leftmost byte elements of a source vector into the byte elements of a",
                "result vector specified by the byte-element mask in VSR[VRB+32].",
                "",
                "If IMM=0b00001, let pcv be the permute",
                "control vector required to enable a left-indexed permute (vperm or xxperm) to implement a compression of the sparse",
                "byte elements in a source vector specified by the byte-element mask",
                "in VSR[VRB+32] into the leftmost byte elements of a",
                "result vector.",
                "",
                "If IMM=0b00010, let pcv be the permute",
                "control vector required to enable a right-indexed permute (vpermr or xxpermr) to implement an expansion of the",
                "rightmost byte elements of a source vector into the byte elements of",
                "a result vector specified by the byte-element mask in VSR[VRB+32].",
                "",
                "If IMM=0b00011, let pcv be the permute",
                "control vector required to enable a right-indexed permute (vpermr or xxpermr) to implement a compression of the",
                "sparse byte elements in a source vector specified by the byte-element",
                "mask in VSR[VRB+32] into the rightmost byte elements of a",
                "result vector.",
                "",
                "pcv is placed into VSR[XT].",
                "",
                "Unused values of IMM are reserved.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Generate PCV from Halfword Mask",
                    "form": "X",
                    "mnemonic": "xxgenpcvhm",
                    "operands": [
                        "XT",
                        "VRB",
                        "IMM"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "IMM",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "919",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if IMM=0b00000 then do  // Big-Endian expansion",
                "  j := 0",
                "  do i = 0 to 7",
                "     if VSR[VRB+32].hword[i].bit[0]=1 then do",
                "        VSR[XT].hword[i].byte[0] := 2*j + 0x00",
                "        VSR[XT].hword[i].byte[1] := 2*j + 0x01",
                "        j := j + 1",
                "     end",
                "     else do",
                "        VSR[XT].hword[i].byte[0] := 2*i + 0x10",
                "        VSR[XT].hword[i].byte[1] := 2*i + 0x11",
                "     end",
                "  end",
                "end",
                "",
                "else if IMM=0b00001 then do  // Big-Endian compression",
                "  j := 0",
                "  do i = 0 to 7",
                "     if VSR[VRB+32].hword[i].bit[0]=1 then do",
                "        VSR[XT].hword[j].byte[0] := 2*i + 0x00",
                "        VSR[XT].hword[j].byte[1] := 2*i + 0x01",
                "        j := j + 1",
                "     end",
                "  end",
                "  do i = j to 7",
                "     VSR[XT].hword[i] := 0xUUUU",
                "  end",
                "end",
                "",
                "else if IMM=0b00010 then do  // Little-Endian expansion",
                "  j := 0",
                "  do i = 0 to 7",
                "     if VSR[VRB+32].hword[7-i].bit[0]=1 then do",
                "        VSR[XT].hword[7-i].byte[1] := 2*j + 0x00",
                "        VSR[XT].hword[7-i].byte[0] := 2*j + 0x01",
                "        j := j + 1",
                "     end",
                "     else do",
                "        VSR[XT].hword[7-i].byte[1] := 2*i + 0x10",
                "        VSR[XT].hword[7-i].byte[0] := 2*i + 0x11",
                "     end",
                "  end",
                "end",
                "",
                "",
                "else if IMM=0b00011 then do  // Little-Endian compression",
                "  j := 0",
                "  do i = 0 to 7",
                "     if VSR[VRB+32].hword[7-i].bit[0]=1 then do",
                "        VSR[XT].hword[7-j].byte[1] := 2*i + 0x00",
                "        VSR[XT].hword[7-j].byte[0] := 2*i + 0x01",
                "        j := j + 1",
                "     end",
                "  end",
                "  do i = j to 7",
                "        VSR[XT].hword[7-i] := 0xUUUU",
                "  end",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "If IMM=0b00000, let pcv be the permute",
                "control vector required to enable a left-indexed permute (vperm or xxperm) to implement an expansion of the",
                "leftmost halfword elements of a source vector into the halfword",
                "elements of a result vector specified by the halfword-element mask in",
                "VSR[VRB+32].",
                "",
                "If IMM=0b00001, let pcv be the permute",
                "control vector required to enable a left-indexed permute (vperm or xxperm) to implement a compression of the sparse",
                "halfword elements in a source vector specified by the",
                "halfword-element mask in VSR[VRB+32] into the leftmost",
                "halfword elements of a result vector.",
                "",
                "If IMM=0b00010, let pcv be the permute",
                "control vector required to enable a right-indexed permute (vpermr or xxpermr) to implement an expansion of the",
                "rightmost halfword elements of a source vector into the halfword",
                "elements of a result vector specified by the halfword-element mask in",
                "VSR[VRB+32].",
                "",
                "If IMM=0b00011, let pcv be the permute",
                "control vector required to enable a right-indexed permute (vpermr or xxpermr) to implement a compression of the",
                "sparse halfword elements in a source vector specified by the",
                "halfword-element mask in VSR[VRB+32] into the rightmost",
                "halfword elements of a result vector.",
                "",
                "pcv is placed into VSR[XT].",
                "",
                "Unused values of IMM are reserved.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Generate PCV from Word Mask",
                    "form": "X",
                    "mnemonic": "xxgenpcvwm",
                    "operands": [
                        "XT",
                        "VRB",
                        "IMM"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "IMM",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "919",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if IMM=0b00000 then do  // Big-Endian expansion",
                "  j := 0",
                "  do i = 0 to 3",
                "     if VSR[VRB+32].word[i].bit[0]=1 then do",
                "        VSR[XT].word[i].byte[0] := 4*j + 0x00",
                "        VSR[XT].word[i].byte[1] := 4*j + 0x01",
                "        VSR[XT].word[i].byte[2] := 4*j + 0x02",
                "        VSR[XT].word[i].byte[3] := 4*j + 0x03",
                "        j = j + 1",
                "     end",
                "     else do",
                "        VSR[XT].word[i].byte[0] := 4*i + 0x10",
                "        VSR[XT].word[i].byte[1] := 4*i + 0x11",
                "        VSR[XT].word[i].byte[2] := 4*i + 0x12",
                "        VSR[XT].word[i].byte[3] := 4*i + 0x13",
                "     end",
                "  end",
                "end",
                "",
                "else if IMM=0b00001 then do  // Big-Endian compression",
                "  j := 0",
                "  do i = 0 to 3",
                "     if VSR[VRB+32].word[i].bit[0]=1 then do",
                "        VSR[XT].word[j].byte[0] := 4*i + 0x00",
                "        VSR[XT].word[j].byte[1] := 4*i + 0x01",
                "        VSR[XT].word[j].byte[2] := 4*i + 0x02",
                "        VSR[XT].word[j].byte[3] := 4*i + 0x03",
                "        j := j + 1",
                "     end",
                "  end",
                "  do i = j to 3",
                "     VSR[XT].word[i] := 0xUUUU_UUUU",
                "  end",
                "end",
                "",
                "else if IMM=0b00010 then do  // Little-Endian expansion",
                "  j := 0",
                "  do i = 0 to 3",
                "     if VSR[VRB+32].word[3-i].bit[0]=1 then do",
                "        VSR[XT].word[3-i].byte[3] := 4*j + 0x00",
                "        VSR[XT].word[3-i].byte[2] := 4*j + 0x01",
                "        VSR[XT].word[3-i].byte[1] := 4*j + 0x02",
                "        VSR[XT].word[3-i].byte[0] := 4*j + 0x03",
                "        j := j + 1",
                "     end",
                "     else do",
                "        VSR[XT].word[3-i].byte[3] := 4*i + 0x10",
                "        VSR[XT].word[3-i].byte[2] := 4*i + 0x11",
                "        VSR[XT].word[3-i].byte[1] := 4*i + 0x12",
                "        VSR[XT].word[3-i].byte[0] := 4*i + 0x13",
                "     end",
                "  end",
                "end",
                "else if IMM=0b00011 then do  // Little-Endian compression",
                "  j := 0",
                "  do i = 0 to 3",
                "     if VSR[VRB+32].word[3-i].bit[0]=1 then do",
                "        VSR[XT].word[3-j].byte[3] := 4*i + 0x00",
                "        VSR[XT].word[3-j].byte[2] := 4*i + 0x01",
                "        VSR[XT].word[3-j].byte[1] := 4*i + 0x02",
                "        VSR[XT].word[3-j].byte[0] := 4*i + 0x03",
                "        j := j + 1",
                "     end",
                "  end",
                "  do i = j to 3",
                "        VSR[XT].word[3-i] := 0xUUUU_UUUU",
                "  end",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "If IMM=0b00000, let pcv be the permute",
                "control vector required to enable a left-indexed permute (vperm or xxperm) to implement an expansion of the",
                "leftmost word elements of a source vector into the word elements of a",
                "result vector specified by the word-element mask in VSR[VRB+32].",
                "",
                "If IMM=0b00001, let pcv be the permute",
                "control vector required to enable a left-indexed permute (vperm or xxperm) to implement a compression of the sparse",
                "word elements in a source vector specified by the word-element mask",
                "in VSR[VRB+32] into the leftmost word elements of a",
                "result vector.",
                "",
                "If IMM=0b00010, let pcv be the permute",
                "control vector required to enable a right-indexed permute (vpermr or xxpermr) to implement an expansion of the",
                "rightmost word elements of a source vector into the word elements of",
                "a result vector specified by the word-element mask in VSR[VRB+32].",
                "",
                "If IMM=0b00011, let pcv be the permute",
                "control vector required to enable a right-indexed permute (vpermr or xxpermr) to implement a compression of the",
                "sparse word elements in a source vector specified by the word-element",
                "mask in VSR[VRB+32] into the rightmost word elements of a",
                "result vector.",
                "",
                "pcv is placed into VSR[XT].",
                "",
                "Unused values of IMM are reserved.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Generate PCV from Doubleword Mask",
                    "form": "X",
                    "mnemonic": "xxgenpcvdm",
                    "operands": [
                        "XT",
                        "VRB",
                        "IMM"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "IMM",
                    "size": "5"
                },
                {
                    "name": "VRB",
                    "size": "5"
                },
                {
                    "name": "919",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "if IMM=0b00000 then do  // Big-Endian expansion",
                "  j := 0",
                "  do i = 0 to 1",
                "     if VSR[VRB+32].dword[i].bit[0]=1 then do",
                "        VSR[XT].dword[i].byte[0] := 8*j + 0x00",
                "        VSR[XT].dword[i].byte[1] := 8*j + 0x01",
                "        VSR[XT].dword[i].byte[2] := 8*j + 0x02",
                "        VSR[XT].dword[i].byte[3] := 8*j + 0x03",
                "        VSR[XT].dword[i].byte[4] := 8*j + 0x04",
                "        VSR[XT].dword[i].byte[5] := 8*j + 0x05",
                "        VSR[XT].dword[i].byte[6] := 8*j + 0x06",
                "        VSR[XT].dword[i].byte[7] := 8*j + 0x07",
                "        j := j + 1",
                "     end",
                "     else do",
                "        VSR[XT].dword[i].byte[0] := 8*i + 0x10",
                "        VSR[XT].dword[i].byte[1] := 8*i + 0x11",
                "        VSR[XT].dword[i].byte[2] := 8*i + 0x12",
                "        VSR[XT].dword[i].byte[3] := 8*i + 0x13",
                "        VSR[XT].dword[i].byte[4] := 8*i + 0x14",
                "        VSR[XT].dword[i].byte[5] := 8*i + 0x15",
                "        VSR[XT].dword[i].byte[6] := 8*i + 0x16",
                "        VSR[XT].dword[i].byte[7] := 8*i + 0x17",
                "     end",
                "  end",
                "end",
                "",
                "else if IMM=0b00001 then do  // Big-Endian compression",
                "  j := 0",
                "  do i = 0 to 1",
                "     if VSR[VRB+32].dword[i].bit[0]=1 then do",
                "        VSR[XT].dword[j].byte[0] := 8*i + 0x00",
                "        VSR[XT].dword[j].byte[1] := 8*i + 0x01",
                "        VSR[XT].dword[j].byte[2] := 8*i + 0x02",
                "        VSR[XT].dword[j].byte[3] := 8*i + 0x03",
                "        VSR[XT].dword[j].byte[4] := 8*i + 0x04",
                "        VSR[XT].dword[j].byte[5] := 8*i + 0x05",
                "        VSR[XT].dword[j].byte[6] := 8*i + 0x06",
                "        VSR[XT].dword[j].byte[7] := 8*i + 0x07",
                "        j := j + 1",
                "     end",
                "  end",
                "  do i = j to 1",
                "     VSR[XT].dword[i] := 0xUUUU_UUUU_UUUU_UUUU",
                "  end",
                "end",
                "else if IMM=0b00010 then do  // Little-Endian expansion",
                "  j := 0",
                "  do i = 0 to 1",
                "     if VSR[VRB+32].dword[1-i].bit[0]=1 then do",
                "        VSR[XT].dword[1-i].byte[7] := 8*j + 0x00",
                "        VSR[XT].dword[1-i].byte[6] := 8*j + 0x01",
                "        VSR[XT].dword[1-i].byte[5] := 8*j + 0x02",
                "        VSR[XT].dword[1-i].byte[4] := 8*j + 0x03",
                "        VSR[XT].dword[1-i].byte[3] := 8*j + 0x04",
                "        VSR[XT].dword[1-i].byte[2] := 8*j + 0x05",
                "        VSR[XT].dword[1-i].byte[1] := 8*j + 0x06",
                "        VSR[XT].dword[1-i].byte[0] := 8*j + 0x07",
                "        j := j + 1",
                "     end",
                "     else do",
                "        VSR[XT].dword[1-i].byte[7] := 8*i + 0x10",
                "        VSR[XT].dword[1-i].byte[6] := 8*i + 0x11",
                "        VSR[XT].dword[1-i].byte[5] := 8*i + 0x12",
                "        VSR[XT].dword[1-i].byte[4] := 8*i + 0x13",
                "        VSR[XT].dword[1-i].byte[3] := 8*i + 0x14",
                "        VSR[XT].dword[1-i].byte[2] := 8*i + 0x15",
                "        VSR[XT].dword[1-i].byte[1] := 8*i + 0x16",
                "        VSR[XT].dword[1-i].byte[0] := 8*i + 0x17",
                "     end",
                "  end",
                "end",
                "",
                "else if IMM=0b00011 then do  // Little-Endian compression",
                "  j := 0",
                "  do i = 0 to 1",
                "     if VSR[VRB+32].dword[1-i].bit[0]=1 then do",
                "        VSR[XT].dword[1-j].byte[7] := 8*i + 0x00",
                "        VSR[XT].dword[1-j].byte[6] := 8*i + 0x01",
                "        VSR[XT].dword[1-j].byte[5] := 8*i + 0x02",
                "        VSR[XT].dword[1-j].byte[4] := 8*i + 0x03",
                "        VSR[XT].dword[1-j].byte[3] := 8*i + 0x04",
                "        VSR[XT].dword[1-j].byte[2] := 8*i + 0x05",
                "        VSR[XT].dword[1-j].byte[1] := 8*i + 0x06",
                "        VSR[XT].dword[1-j].byte[0] := 8*i + 0x07",
                "        j := j + 1",
                "     end",
                "  end",
                "  do i = j to 1",
                "        VSR[XT].dword[1-i] := 0xUUUU_UUUU_UUUU_UUUU",
                "  end",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "If IMM=0b00000, let pcv be the permute",
                "control vector required to enable a left-indexed permute (vperm or xxperm) to implement an expansion of the",
                "leftmost doubleword elements of a source vector into the doubleword",
                "elements of a result vector specified by the doubleword-element mask",
                "in VSR[VRB+32].",
                "",
                "If IMM=0b00001, let pcv be the the permute",
                "control vector required to enable a left-indexed permute (vperm or xxperm) to implement a compression of the sparse",
                "doubleword elements in a source vector specified by the",
                "doubleword-element mask in VSR[VRB+32] into the leftmost",
                "doubleword elements of a result vector.",
                "",
                "If IMM=0b00010, let pcv be the permute",
                "control vector required to enable a right-indexed permute (vpermr or xxpermr) to implement an expansion of the",
                "rightmost doubleword elements of a source vector into the doubleword",
                "elements of a result vector specified by the doubleword-element mask",
                "in VSR[VRB+32].",
                "",
                "If IMM=0b00011, let pcv be the permute",
                "control vector required to enable a right-indexed permute (vpermr or xxpermr) to implement a compression of the",
                "sparse doubleword elements in a source vector specified by the",
                "doubleword-element mask in VSR[VRB+32] into the rightmost",
                "doubleword elements of a result vector.",
                "",
                "pcv is placed into VSR[XT].",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Logical AND",
                    "form": "XX3",
                    "mnemonic": "xxland",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "130",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32*TX+T] := VSR[32*AX+A] & VSR[32*BX+B]"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "The contents of VSR[XA] are ANDed with the contents of",
                "VSR[XB] and the result is placed into VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_adde",
                "vec_addec",
                "vec_and",
                "vec_first_match_or_eos_index",
                "vec_first_mismatch_or_eos_index",
                "vec_sube",
                "vec_subec"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Logical AND with Complement",
                    "form": "XX3",
                    "mnemonic": "xxlandc",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "138",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32*TX+T] := VSR[32*AX+A] & ~VSR[32*BX+B]"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "The contents of VSR[XA] are ANDed with the complement of",
                "the contents of VSR[XB] and the result is placed into",
                "VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_andc"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Logical Equivalence",
                    "form": "XX3",
                    "mnemonic": "xxleqv",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "186",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32*TX+T] := VSR[32*AX+A] == VSR[32*BX+B]"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "The contents of VSR[XA] are exclusive-ORed with the",
                "contents of VSR[XB] and the complemented result is placed",
                "into VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_eqv"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Logical NAND",
                    "form": "XX3",
                    "mnemonic": "xxlnand",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "178",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32*TX+T] := ~( VSR[32*AX+A] & VSR[32*BX+B] )"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "The contents of VSR[XA] are ANDed with the contents of",
                "VSR[XB] and the complemented result is placed into",
                "VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_first_match_or_eos_index",
                "vec_nand"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Logical OR with Complement",
                    "form": "XX3",
                    "mnemonic": "xxlorc",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "170",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32*TX+T] := VSR[32*AX+A] | ~VSR[32*BX+B]"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "The contents of VSR[XA] are ORed with the complement of",
                "the contents of VSR[XB] and the result is placed into",
                "VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_first_mismatch_or_eos_index",
                "vec_orc"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Logical NOR",
                    "form": "XX3",
                    "mnemonic": "xxlnor",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "162",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32*TX+T] := ~( VSR[32*AX+A] | VSR[32*BX+B] )"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "The contents of VSR[XA] are ORed with the contents of",
                "VSR[XB] and the complemented result is placed into",
                "VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_cmpge",
                "vec_cmple",
                "vec_cmpne",
                "vec_first_match_index",
                "vec_nor",
                "vec_permxor"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Logical OR",
                    "form": "XX3",
                    "mnemonic": "xxlor",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "146",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32*TX+T] := VSR[32*AX+A] | VSR[32*BX+B]"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "The contents of VSR[XA] are ORed with the contents of",
                "VSR[XB] and the result is placed into VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_addec",
                "vec_or",
                "vec_rlnm",
                "vec_rsqrt",
                "vec_subec"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Logical XOR",
                    "form": "XX3",
                    "mnemonic": "xxlxor",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "154",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32*TX+T] := VSR[32*AX+A] ^ VSR[32*BX+B]"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "The contents of VSR[XA] are exclusive-ORed with the",
                "contents of VSR[XB] and the result is placed into",
                "VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_xor"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Merge High Word",
                    "form": "XX3",
                    "mnemonic": "xxmrghw",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "18",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32*TX+T].word[0] := VSR[32*AX+A].word[0]",
                "VSR[32*TX+T].word[1] := VSR[32*BX+B].word[0]",
                "VSR[32*TX+T].word[2] := VSR[32*AX+A].word[1]",
                "VSR[32*TX+T].word[3] := VSR[32*BX+B].word[1]"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "The contents of word element 0 of VSR[XA] are",
                "placed into word element 0 of VSR[XT].",
                "",
                "The contents of word element 0 of VSR[XB] are",
                "placed into word element 1 of VSR[XT].",
                "",
                "The contents of word element 1 of VSR[XA] are",
                "placed into word element 2 of VSR[XT].",
                "",
                "The contents of word element 1 of VSR[XB] are",
                "placed into word element 3 of VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Merge Low Word",
                    "form": "XX3",
                    "mnemonic": "xxmrglw",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "50",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32*TX+T].word[0] := VSR[32*AX+A].word[2]",
                "VSR[32*TX+T].word[1] := VSR[32*BX+B].word[2]",
                "VSR[32*TX+T].word[2] := VSR[32*AX+A].word[3]",
                "VSR[32*TX+T].word[3] := VSR[32*BX+B].word[3]"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "The contents of word element 2 of VSR[XA] are",
                "placed into word element 0 of VSR[XT].",
                "",
                "The contents of word element 2 of VSR[XB] are",
                "placed into word element 1 of VSR[XT].",
                "",
                "The contents of word element 3 of VSR[XA] are",
                "placed into word element 2 of VSR[XT].",
                "",
                "The contents of word element 3 of VSR[XB] are",
                "placed into word element 3 of VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Move From Accumulator",
                    "form": "X",
                    "mnemonic": "xxmfacc",
                    "operands": [
                        "AS"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "AS",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "0",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "177",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[4*AS]   := ACC[AS][0]",
                "VSR[4*AS+1] := ACC[AS][1]",
                "VSR[4*AS+2] := ACC[AS][2]",
                "VSR[4*AS+3] := ACC[AS][3]"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, the contents of row",
                "i of ACC[AS] are placed into VSR[4AS+i].",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Move To Accumulator",
                    "form": "X",
                    "mnemonic": "xxmtacc",
                    "operands": [
                        "AT"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "1",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "177",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ACC[AT][0] := VSR[4*AT]",
                "ACC[AT][1] := VSR[4*AT+1]",
                "ACC[AT][2] := VSR[4*AT+2]",
                "ACC[AT][3] := VSR[4*AT+3]"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, the contents of",
                "VSR[4AT+i] are placed into row i of",
                "ACC[AT].",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Permute",
                    "form": "XX3",
                    "mnemonic": "xxperm",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "26",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src.byte[0:15]  := VSR[32*AX+A]",
                "src.byte[16:31] := VSR[32*TX+T]",
                "pcv.byte[0:15]  := VSR[32*BX+B]",
                "",
                "do i = 0 to 15",
                "  idx := pcv.byte[i].bit[3:7]",
                "  VSR[32*TX+T].byte[i] := src.byte[idx]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let bytes 0:15 of src be the contents of VSR[XA].",
                "",
                "Let bytes 16:31 of src be the contents of VSR[XT].",
                "",
                "Let the permute control vector pcv be the contents of",
                "VSR[XB].",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let idx be the unsigned integer in bits 3:7 of byte",
                "element i of pcv.",
                "",
                "",
                "The contents of byte element idx of src is",
                "placed into byte element i of VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Permute Right-indexed",
                    "form": "XX3",
                    "mnemonic": "xxpermr",
                    "operands": [
                        "XT",
                        "XA",
                        "XB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "58",
                    "size": "8"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src.byte[0:15]  := VSR[32*AX+A]",
                "src.byte[16:31] := VSR[32*TX+T]",
                "pcv.byte[0:15]  := VSR[32*BX+B]",
                "",
                "do i = 0 to 15",
                "  idx := pcv.byte[i].bit[3:7]",
                "  VSR[32*TX+T].byte[i] := src.byte[31-idx]",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let bytes 0:15 of src be the contents of VSR[XA].",
                "",
                "Let bytes 16:31 of src be the contents of VSR[XT].",
                "",
                "Let the permute control vector pcv be the contents of",
                "VSR[XB].",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let idx be the unsigned integer in bits 3:7 of byte",
                "element i of pcv.",
                "",
                "",
                "The contents of byte element 31-idx of src is",
                "placed into byte element i of VSR[XT].",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Permute Doubleword Immediate",
                    "form": "XX3",
                    "mnemonic": "xxpermdi",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "DM"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "1"
                },
                {
                    "name": "DM",
                    "size": "2"
                },
                {
                    "name": "10",
                    "size": "5"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32*TX+T].dword[0] := VSR[32*AX+A].dword[DM.bit[0]]",
                "VSR[32*TX+T].dword[1] := VSR[32*BX+B].dword[DM.bit[1]]"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "If DM.bit[0]=0, the contents of doubleword element",
                "0 of VSR[XA] are placed into doubleword",
                "element 0 of VSR[XT].",
                "Otherwise the contents of doubleword element 1 of",
                "VSR[XA] are placed into doubleword element 0",
                "of VSR[XT].",
                "",
                "If DM.bit[1]=0, the contents of doubleword element",
                "0 of VSR[XB] are placed into doubleword",
                "element 1 of VSR[XT].",
                "Otherwise the contents of doubleword element 1 of",
                "VSR[XB] are placed into doubleword element 1",
                "of VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_float2",
                "vec_insert",
                "vec_insert4b",
                "vec_mergee",
                "vec_mergeh",
                "vec_mergel",
                "vec_mergeo",
                "vec_pack",
                "vec_signed2",
                "vec_splat",
                "vec_splats",
                "vec_unsigned2"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Permute Extended",
                    "form": "8RR:XX4",
                    "mnemonic": "xxpermx",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "XC",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "80",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "17"
                },
                {
                    "name": "IMM",
                    "size": "3"
                },
                {
                    "name": "34",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "C",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "2"
                },
                {
                    "name": "CX",
                    "size": "1"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src.qword[0] := VSR[32*AX+A]",
                "src.qword[1] := VSR[32*BX+B]",
                "do i = 0 to 15",
                "  section := VSR[32*CX+C].byte[i].bit[0:2]",
                "  eidx    := VSR[32*CX+C].byte[i].bit[3:7]",
                "  if section=UIM then",
                "     VSR[32*TX+T].byte[i] := src.byte[eidx]",
                "  else",
                "     VSR[32*TX+T].byte[i] := 0x00",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let XC be the value 32CX + C.",
                "",
                "Let UIM specify which 32-byte section of the long vector",
                "that src contains.",
                "",
                "Let src be the concatenation VSR[XA] and",
                "VSR[XB], comprising a 32-byte section of up to a 256-byte",
                "vector.",
                "",
                "For each integer value i from 0 to 15, do the following.",
                "",
                "",
                "",
                "Let eidx be the contents of bits 3:7 of byte element",
                "i of VSR[XC].",
                "",
                "",
                "If UIM is equal to the contents of bits 0:2 of byte",
                "element i of VSR[XC], the contents of byte",
                "element eidx of src are placed into byte",
                "element i of VSR[XT].",
                "Otherwise, the contents of byte element i of VSR[XT] are set to 0.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Select",
                    "form": "XX4",
                    "mnemonic": "xxsel",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "XC"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "C",
                    "size": "5"
                },
                {
                    "name": "3",
                    "size": "2"
                },
                {
                    "name": "CX",
                    "size": "1"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "src1 := VSR[32*AX+A]",
                "src2 := VSR[32*BX+B]",
                "mask := VSR[32*CX+C]",
                "",
                "VSR[32*TX+T] := (src1 & ~mask) | (src2 & mask)"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let XC be the value 32CX + C.",
                "",
                "Let src1 be the contents of VSR[XA].",
                "",
                "Let src2 be the contents of VSR[XB].",
                "",
                "Let mask be the contents of VSR[XC].",
                "",
                "The value, (src1mask)|(src2mask), is",
                "placed into VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_sel"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Set Accumulator to Zero",
                    "form": "X",
                    "mnemonic": "xxsetaccz",
                    "operands": [
                        "AT"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "AT",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "3",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "177",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "ACC[AT][0] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "ACC[AT][1] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "ACC[AT][2] := 0x0000_0000_0000_0000_0000_0000_0000_0000",
                "ACC[AT][3] := 0x0000_0000_0000_0000_0000_0000_0000_0000"
            ],
            "body": [
                "",
                "",
                "For each integer value i from 0 to 3, the contents of row",
                "i of ACC[AT] are set to 0.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Shift Left Double by Word Immediate",
                    "form": "XX3",
                    "mnemonic": "xxsldwi",
                    "operands": [
                        "XT",
                        "XA",
                        "XB",
                        "SHW"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "A",
                    "size": "5"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "1"
                },
                {
                    "name": "SHW",
                    "size": "2"
                },
                {
                    "name": "2",
                    "size": "5"
                },
                {
                    "name": "AX",
                    "size": "1"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "source.qword[0] := VSR[32*AX+A]",
                "source.qword[1] := VSR[32*BX+B]",
                "VSR[32*TX+T] := source.word[SHW:SHW+3]"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XA be the value 32AX + A.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "Let vsrc be the concatenation of the contents of",
                "VSR[XA] followed by the contents of VSR[XB].",
                "",
                "Words SHW:SHW+3 of vsrc are placed into",
                "VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_doublee",
                "vec_doubleh",
                "vec_doublel",
                "vec_doubleo",
                "vec_sldw",
                "vec_unpackh",
                "vec_unpackl"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Splat Immediate Byte",
                    "form": "X",
                    "mnemonic": "xxspltib",
                    "operands": [
                        "XT",
                        "IMM8"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "2"
                },
                {
                    "name": "IMM8",
                    "size": "8"
                },
                {
                    "name": "360",
                    "size": "10"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if TX=0 & MSR.VSX=0 then VSX_Unavailable()",
                "if TX=1 & MSR.VEC=0 then Vector_Unavailable()",
                "",
                "do i = 0 to 15",
                "  VSR[32*TX+T].byte[i] := UIM8",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the sum 32TX + T.",
                "",
                "The value IMM8 is copied into each byte element of",
                "VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_first_match_or_eos_index",
                "vec_first_mismatch_or_eos_index",
                "vec_mul",
                "vec_rlnm"
            ]
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Splat Immediate Double-Precision",
                    "form": "8RR:D",
                    "mnemonic": "xxspltidp",
                    "operands": [
                        "XT",
                        "IMM32"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "80",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "imm0",
                    "size": "16"
                },
                {
                    "name": "32",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "2",
                    "size": "4"
                },
                {
                    "name": "TX",
                    "size": "1"
                },
                {
                    "name": "imm1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "IMM32 := imm0<<16 | imm1;",
                "",
                "VSR[32*TX+T].dword[0] := bfp64_CONVERT_FROM_BFP(IMM32);",
                "VSR[32*TX+T].dword[1] := bfp64_CONVERT_FROM_BFP(IMM32);"
            ],
            "body": [
                "",
                "",
                "Let IMM32 be the concatenation of imm0 and",
                "imm1, representing a single-precision value.",
                "",
                "IMM32 is converted to double-precision format and placed",
                "into each doubleword element of VSR[XT].",
                "",
                "If IMM32 specifies a single-precision denormal value",
                "(i.e., bits 1:8 equal to 0 and bits 9:31 not equal to 0), the result",
                "is undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Splat Immediate Word",
                    "form": "8RR:D",
                    "mnemonic": "xxspltiw",
                    "operands": [
                        "XT",
                        "IMM32"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "80",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "imm0",
                    "size": "16"
                },
                {
                    "name": "32",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "3",
                    "size": "4"
                },
                {
                    "name": "TX",
                    "size": "1"
                },
                {
                    "name": "imm1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "IMM32 := imm0<<16 | imm1",
                "",
                "do i = 0 to 3",
                "  VSR[32*TX+T].word[i] := IMM32",
                "end"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let IMM32 be the concatenation of imm0 and",
                "imm1.",
                "",
                "IMM32 is placed into each word element of VSR[XT].",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Splat Immediate32 Doubleword Indexed",
                    "form": "8RR:D",
                    "mnemonic": "xxsplti32dx",
                    "operands": [
                        "XT",
                        "IX",
                        "IMM32"
                    ],
                    "conditions": [],
                    "release": "v3.1"
                }
            ],
            "layout": [
                {
                    "name": "80",
                    "size": "12"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "imm0",
                    "size": "16"
                },
                {
                    "name": "32",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "0",
                    "size": "3"
                },
                {
                    "name": "IX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                },
                {
                    "name": "imm1",
                    "size": "16"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "IMM32 := imm0<<16 | imm1",
                "",
                "VSR[32*TX+T].dword[0].word[IX] := IMM32",
                "VSR[32*TX+T].dword[1].word[IX] := IMM32"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let IMM32 be the concatenation of imm0 and",
                "imm1.",
                "",
                "IMM32 is placed into word element IX of each",
                "doubleword element of VSR[XT].",
                "The contents of the remaining word elements are not modified.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Vector-Scalar Extension Facility",
            "book": "I",
            "mnemonics": [
                {
                    "name": "VSX Vector Splat Word",
                    "form": "XX2",
                    "mnemonic": "xxspltw",
                    "operands": [
                        "XT",
                        "XB",
                        "UIM"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "60",
                    "size": "6"
                },
                {
                    "name": "T",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "UIM",
                    "size": "2"
                },
                {
                    "name": "B",
                    "size": "5"
                },
                {
                    "name": "164",
                    "size": "9"
                },
                {
                    "name": "BX",
                    "size": "1"
                },
                {
                    "name": "TX",
                    "size": "1"
                }
            ],
            "code": [
                "if MSR.VSX=0 then VSX_Unavailable()",
                "",
                "VSR[32*TX+T].word[0] := VSR[32*BX+B].word[UIM]",
                "VSR[32*TX+T].word[1] := VSR[32*BX+B].word[UIM]",
                "VSR[32*TX+T].word[2] := VSR[32*BX+B].word[UIM]",
                "VSR[32*TX+T].word[3] := VSR[32*BX+B].word[UIM]"
            ],
            "body": [
                "",
                "",
                "Let XT be the value 32TX + T.",
                "",
                "Let XB be the value 32BX + B.",
                "",
                "The contents of word element UIM of VSR[XB]",
                "are replicated in each word element of VSR[XT].",
                "",
                "",
                ""
            ],
            "intrinsics": [
                "vec_splat",
                "vec_splats"
            ]
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Instruction Cache Block Invalidate",
                    "form": "X",
                    "mnemonic": "icbi",
                    "operands": [
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "982",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "If the block containing the byte addressed by EA is in storage that",
                "is Memory Coherence Required and a block containing the byte",
                "addressed by EA is in the instruction cache of any processors, the",
                "block is invalidated in those instruction caches.",
                "",
                "If the block containing the byte addressed by EA is in storage that",
                "is not Memory Coherence Required and the block is in the instruction",
                "cache of this processor, the block is invalidated in that instruction",
                "cache.",
                "",
                "The function of this instruction is independent of whether the block",
                "containing the byte addressed by EA is in storage that is Write",
                "Through Required or Caching Inhibited.",
                "",
                "This instruction is treated as a Load (see Section",
                "), except",
                "that reference and change recording need not be done.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Instruction Cache Block Touch",
                    "form": "X",
                    "mnemonic": "icbt",
                    "operands": [
                        "CT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "CT",
                    "size": "4"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "22",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "The icbt instruction provides a hint that the",
                "program will probably soon execute code from the block containing the",
                "byte addressed by EA, and that the block containing the byte",
                "addressed by EA is to be loaded into the cache specified by the CT",
                "field.",
                "(See",
                "Section",
                "of Book II.) If the CT field is set to a value not supported by the",
                "implementation, no operation is performed.",
                "",
                "The hint is ignored if the block is Caching Inhibited.",
                "",
                "This instruction treated as a Load (see Section",
                "), except",
                "that the system data storage error handler is not invoked, and",
                "reference and change recording need not be done.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Data Cache Block Touch",
                    "form": "X",
                    "mnemonic": "dcbt",
                    "operands": [
                        "RA",
                        "RB",
                        "TH"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "TH",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "278",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "The dcbt instruction provides a hint that",
                "describes a block or data stream to which the program may perform a",
                "Load access.",
                "The instruction is also used to indicate imminent access or end of",
                "access to described load and store data streams.",
                "A hint that the program will probably soon load from a given storage",
                "location is ignored if the location is Caching Inhibited or Guarded.",
                "",
                "The only operation that is caused by the dcbt",
                "instruction is the providing of the hint.",
                "The actions (if any) taken by the processor in response to the hint",
                "are not considered to be caused by or associated with the",
                "dcbt instruction (e.g., dcbt",
                "is considered not to cause any data accesses).",
                "No means are provided by which software can synchronize these actions",
                "with the execution of the instruction stream.",
                "For example, these actions are not ordered by memory barriers.",
                "",
                "The dcbt instruction may complete before the",
                "operation it causes has been performed.",
                "",
                "The nature of the hint depends, in part, on the value of the TH",
                "field, as specified at the beginning of this section.",
                "If TH0b01010 and TH0b01011, this instruction is",
                "treated as a Load (see Section",
                "), except",
                "that the system data storage error handler is not invoked, and",
                "reference and change recording need not be done.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Data Cache Block Touch for Store",
                    "form": "X",
                    "mnemonic": "dcbtst",
                    "operands": [
                        "RA",
                        "RB",
                        "TH"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "TH",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "246",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "The dcbtst instruction provides a hint that",
                "describes a block or data stream to which the program may perform a",
                "Store access, or indicates the expected use thereof.",
                "A hint that the program will soon store to a given storage location",
                "is ignored if the location is Caching Inhibited or Guarded.",
                "",
                "The only operation that is caused by the dcbtst instruction is the providing of the hint.",
                "The actions (if any) taken by the processor in response to the hint",
                "are not considered to be caused by or associated with the",
                "dcbtst instruction (e.g., dcbtst is considered not to cause any data accesses).",
                "No means are provided by which software can synchronize these actions",
                "with the execution of the instruction stream.",
                "For example, these actions are not ordered by memory barriers.",
                "",
                "The dcbtst instruction may complete before the",
                "operation it causes has been performed.",
                "",
                "The nature of the hint depends, in part, on the value of the TH",
                "field, as specified at the beginning of this section.",
                "If TH0b01010 and TH0b01011, this instruction is",
                "treated as a Store (see Section",
                "), except",
                "that the system data storage error handler is not invoked, reference",
                "recording need not be done, and change recording is not done.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Data Cache Block set to Zero",
                    "form": "X",
                    "mnemonic": "dcbz",
                    "operands": [
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "1014",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "n := block size (bytes)",
                "m := log<sub>2</sub>(n)",
                "ea := EA<sub>0:63-m</sub> || <sup>m</sup>0",
                "MEM(ea, n) := <sup>n</sup>0x00"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "All bytes in the block containing the byte addressed by EA are set to",
                "zero.",
                "",
                "This instruction is treated as a Store (see Section",
                ").",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Data Cache Block Store",
                    "form": "X",
                    "mnemonic": "dcbst",
                    "operands": [
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "54",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "If the block containing the byte addressed by EA is in storage that",
                "is Memory Coherence Required and a block containing the byte",
                "addressed by EA is in the data cache of any processor and any",
                "locations in the block are considered to be modified there, those",
                "locations are written to main storage, additional locations in the",
                "block may be written to main storage, and the block ceases to be",
                "considered to be modified in that data cache.",
                "",
                "If the block containing the byte addressed by EA is in storage that",
                "is not Memory Coherence Required and the block is in the data cache",
                "of this processor and any locations in the block are considered to be",
                "modified there, those locations are written to main storage,",
                "additional locations in the block may be written to main storage, and",
                "the block ceases to be considered to be modified in that data cache.",
                "",
                "The function of this instruction is independent of whether the block",
                "containing the byte addressed by EA is in storage that is Write",
                "Through Required or Caching Inhibited.",
                "",
                "This instruction is treated as a Load (see Section",
                "), except",
                "that reference and change recording need not be done.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Data Cache Block Flush",
                    "form": "X",
                    "mnemonic": "dcbf",
                    "operands": [
                        "RA",
                        "RB",
                        "L"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "L",
                    "size": "2"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "86",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "L=0",
                "",
                "",
                "",
                "If the block containing the byte addressed by EA is in storage that",
                "is Memory Coherence Required and a block containing the byte",
                "addressed by EA is in the data cache of any processor and any",
                "locations in the block are considered to be modified there, those",
                "locations are written to main storage and additional locations in the",
                "block may be written to main storage.",
                "The block is invalidated in the data caches of all processors.",
                "",
                "",
                "If the block containing the byte addressed by EA is in storage that",
                "is not Memory Coherence Required and the block is in the data cache",
                "of this processor and any locations in the block are considered to be",
                "modified there, those locations are written to main storage and",
                "additional locations in the block may be written to main storage.",
                "The block is invalidated in the data cache of this processor.",
                "",
                "",
                "L=1 (dcbf local)",
                "",
                "",
                "",
                "The L=1 form of the dcbf instruction permits a",
                "program to limit the scope of the flush operation to the data",
                "cache of this processor.",
                "If the block containing the byte addressed by EA is in the data cache",
                "of this processor, it is removed from this cache.",
                "The coherence of the block is maintained to the extent required by",
                "the Memory Coherence Required storage attribute.",
                "",
                "",
                "L = 3 (dcbf local primary)",
                "",
                "",
                "",
                "The L=3 form of the dcbf instruction permits a",
                "program to limit the scope of the flush operation to the primary",
                "data cache of this processor.",
                "If the block containing the byte addressed by EA is in the primary",
                "data cache of this processor, it is removed from this cache.",
                "The coherence of the block is maintained to the extent required by",
                "the Memory Coherence Required storage attribute.",
                "",
                "",
                "L = 4 (data cache block flush to persistent storage)",
                "",
                "",
                "",
                "The L=4 form of the dcbf instruction performs all",
                "of the functions of dcbf with L=0.",
                "After all writes to main storage, caused by these functions, have",
                "updated main storage, if the block maps to main storage that is",
                "backed by persistent storage then all locations in the block in main",
                "storage that are considered to be modified relative to persistent",
                "storage are written to persistent storage and additional locations in",
                "the block in main storage may be written to persistent storage.",
                "",
                "",
                "L = 6 (data cache block store to persistent storage)",
                "",
                "",
                "",
                "The L=6 form of the dcbf instruction performs all",
                "of the functions of dcbst.",
                "After all writes to main storage, caused by these functions, have",
                "updated main storage, if the block maps to main storage that is",
                "backed by persistent storage then all locations in the block in main",
                "storage that are considered to be modified relative to persistent",
                "storage are written to persistent storage and additional locations in",
                "the block in main storage may be written to persistent storage.",
                "Programming NoteThis form of the  instruction is considered",
                "to be a functional extension of , and its",
                "extended mnemonic reflects that association.",
                "",
                "",
                "For the L operand, the values 2, 5, and 7 are reserved.",
                "The results of executing a dcbf instruction with",
                "L=2, 5, or 7 are boundedly undefined.",
                "",
                "The function of this instruction is independent of whether the block",
                "containing the byte addressed by EA is in storage that is Write",
                "Through Required or Caching Inhibited.",
                "",
                "This instruction is treated as a Load (see Section",
                "), except",
                "that reference and change recording need not be done.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Copy",
                    "form": "X",
                    "mnemonic": "copy",
                    "operands": [
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "774",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b +(RB)",
                "copy_buffer := memory(EA,128)||MEM<sub>metadata</sub>(EA,128)"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "The 128 bytes in storage, and associated metadata,  addressed by EA",
                "is loaded into the copy buffer.",
                "",
                "If the EA is not a multiple of 128, the system alignment error",
                "handler is invoked.",
                "",
                "If the specified block is in storage that is Caching Inhibited, the",
                "system data storage error handler is invoked",
                "",
                "This instruction is treated as a Load (see",
                "Section,",
                "Cache Management Instructions ), except that the data transfer",
                "ordering is described in",
                "Section,",
                "Storage Ordering of Copy/Paste-Initiated Data Transfers.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Paste",
                    "form": "X",
                    "mnemonic": "paste.",
                    "operands": [
                        "RA",
                        "RB",
                        "L"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "902",
                    "size": "10"
                },
                {
                    "name": "Rc",
                    "size": "1"
                }
            ],
            "code": [
                "if there was a copy-paste sequence error or a translation conflict",
                " CR0:=0b000||XER<sub>SO</sub>",
                "else",
                " if RA = 0 then b := 0",
                " else           b := (RA)",
                " EA := b +(RB)",
                " if L=1 then",
                "   copy_buffer.md:=0  /* clear metadata in buffer",
                " post(MEM(EA,128)||MEM<sub>metadata</sub>(EA,128)):=copy_buffer",
                " wait for completion status",
                " if there was a data transfer problem",
                "   CR0:=0b000||XER<sub>SO</sub>",
                " else",
                "   CR0:=0b001||XER<sub>SO</sub>",
                "clear the state of the Copy-Paste Facility",
                ""
            ],
            "body": [
                "",
                "If there was a copy-paste sequence error or a translation conflict,",
                "set CR0 to indicate failure.  Otherwise, continue as follows.",
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "If L=1, then set metadata bits in the copy buffer to zero.",
                "",
                "The physical target of the operation, and by implication the function",
                "to be performed, is determined by the real address that is translated",
                "from EA.",
                "If the real address is in the platform\u00e2\u20ac\u2122s system memory, a simple copy",
                "is performed.",
                "If the real address has an associated mapping to another system, the",
                "copy buffer is transmitted to the other system.",
                "If the real address is control memory for a device, the contents of",
                "the copy buffer is queued to the device.",
                "There is a wait for completion status on the data transfer.",
                "CR0 is set as follows based on the completion status.",
                "",
                "",
                "",
                "",
                "The state of the Copy-Paste Facility is cleared.",
                "",
                "If MSRPR=1, paste. with L=0 is an invalid form.",
                "",
                "If the EA is not a multiple of 128, the system alignment error",
                "handler is invoked.",
                "",
                "If the specified block is in storage that is Caching Inhibited, the",
                "system data storage error handler is invoked.",
                "",
                "If the associated copy specified control memory",
                "or the paste.",
                "specifies control memory that was not properly configured, the data",
                "storage error handler will be invoked.",
                "",
                "This instruction is treated as a Store (see",
                "Section,",
                "Cache Management Instructions ), except that the data transfer",
                "ordering is described in",
                "Section,",
                "Storage Ordering of Copy/Paste-Initiated Data Transfers.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Copy-Paste Abort",
                    "form": "X",
                    "mnemonic": "cpabort",
                    "operands": [],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "15"
                },
                {
                    "name": "838",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "clear the state of the Copy-Paste Facility"
            ],
            "body": [
                "",
                "The cpabort instruction causes a data transfer to",
                "fail if one is in progress.",
                "",
                "Any pending errors in the Copy-Paste Facility are cleared and the",
                "state is reset to prepare for a new copy.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Load Word Atomic",
                    "form": "X",
                    "mnemonic": "lwat",
                    "operands": [
                        "RT",
                        "RA",
                        "FC"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "FC",
                    "size": "5"
                },
                {
                    "name": "582",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA=0 then EA := 0",
                "else         EA := (RA)",
                "(RT<sub>32:63</sub>,mem(EA,4)):= lat(mem(EA-4,12), RT+1<sub>32:63</sub>, RT+2<sub>32:63</sub>, FC)",
                "RT<sub>0:31</sub>:=0"
            ],
            "body": [
                "",
                "Let the effective address (EA) be (RA).",
                "The least significant word of RT and the word of storage at EA are",
                "updated as specified by load atomic function code FC.",
                "The most significant word of RT is set to zero.",
                "Input operands are function code specific, and may include the least",
                "significant words of RT+1 and RT+2, and  mem(EA-4,12)",
                "",
                "Figure",
                "contains the defined function codes.",
                "An attempt to execute lwat specifying a reserved",
                "function code will cause the system data storage error handler to be",
                "invoked.",
                "",
                "EA must be a multiple of 4, and the portion of mem(EA-4,12) accessed",
                "by the instruction must be contained within an aligned 32-byte block",
                "of storage.",
                "If either of these requirements is not satisfied, the system",
                "alignment error handler is invoked.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Load Doubleword Atomic",
                    "form": "X",
                    "mnemonic": "ldat",
                    "operands": [
                        "RT",
                        "RA",
                        "FC"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "FC",
                    "size": "5"
                },
                {
                    "name": "614",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA=0 then EA := 0",
                "else         EA := (RA)",
                "(RT,mem(EA,8)):= lat(mem(EA-8,24), RT+1, RT+2, FC)"
            ],
            "body": [
                "",
                "Let the effective address (EA) be (RA).",
                "RT and the doubleword of storage at EA are updated as specified by",
                "load atomic function code FC.",
                "Input operands are function code specific, and may include RT+1,",
                "RT+2, and  mem(EA-8,24)",
                "",
                "Figure",
                "contains the defined function codes.",
                "An attempt to execute ldat specifying a reserved",
                "function code will cause the system data storage error handler to be",
                "invoked.",
                "",
                "EA must be a multiple of 8, and the portion of mem(EA-8,24) accessed",
                "by the instruction must be contained within an aligned 32-byte block",
                "of storage.",
                "If either of these requirements is not satisfied, the system",
                "alignment error handler is invoked.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Store Word Atomic",
                    "form": "X",
                    "mnemonic": "stwat",
                    "operands": [
                        "RS",
                        "RA",
                        "FC"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "FC",
                    "size": "5"
                },
                {
                    "name": "710",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA=0 then EA := 0",
                "else         EA := (RA)",
                "mem(EA,8):= stat(mem(EA,8), RS<sub>32:63</sub>, FC)"
            ],
            "body": [
                "",
                "Let the effective address (EA) be (RA).",
                "Four or eight bytes of storage at EA are updated as specified by",
                "store atomic function code FC.",
                "Input operands are function code specific, and may include",
                "RS and  mem(EA,8).",
                "",
                "Figure",
                "contains the defined function codes.",
                "An attempt to execute stwat specifying a reserved",
                "function code will cause the system data storage error handler to be",
                "invoked.",
                "",
                "EA must be a multiple of 4, and the portion of  mem(EA,8) accessed by",
                "the instruction must be contained within an aligned 32-byte block of",
                "storage.",
                "If either of these requirements is not satisfied, the system",
                "alignment error handler is invoked.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Store Doubleword Atomic",
                    "form": "X",
                    "mnemonic": "stdat",
                    "operands": [
                        "RS",
                        "RA",
                        "FC"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "FC",
                    "size": "5"
                },
                {
                    "name": "742",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA=0 then EA := 0",
                "else         EA := (RA)",
                "mem(EA,16):= stat(mem(EA,16), RS, FC)"
            ],
            "body": [
                "",
                "Let the effective address (EA) be (RA).",
                "Eight or sixteen bytes of storage at EA are updated as specified by",
                "store atomic function code FC.",
                "Input operands are function code specific, and may include RS and",
                "mem(EA,16).",
                "",
                "Figure",
                "contains the defined function codes.",
                "An attempt to execute stdat specifying a reserved",
                "function code will cause the system data storage error handler to be",
                "invoked.",
                "",
                "EA must be a multiple of 8, and the portion of  mem(EA,16) accessed",
                "by the instruction must be contained within an aligned 32-byte block",
                "of storage.",
                "If either of these requirements is not satisfied, the system",
                "alignment error handler is invoked.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Instruction Synchronize",
                    "form": "XL",
                    "mnemonic": "isync",
                    "operands": [],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "15"
                },
                {
                    "name": "150",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "Executing an isync instruction ensures that all",
                "instructions preceding the isync instruction have",
                "completed before the isync instruction completes,",
                "and that no subsequent instructions are initiated until after the",
                "isync instruction completes.",
                "It also ensures that all instruction cache block invalidations caused",
                "by icbi instructions preceding the",
                "isync instruction have been performed with",
                "respect to the processor executing the isync",
                "instruction, and then causes any prefetched instructions to be",
                "discarded.",
                "",
                "Except as described in the preceding sentence, the isync instruction may complete before storage accesses associated",
                "with instructions preceding the isync instruction",
                "have been performed.",
                "",
                "This instruction is context synchronizing (see Book III).",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Load Byte And Reserve Indexed",
                    "form": "X",
                    "mnemonic": "lbarx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "EH"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "52",
                    "size": "10"
                },
                {
                    "name": "EH",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b +(RB)",
                "RESERVE := 1",
                "RESERVE_LENGTH := 1",
                "RESERVE_ADDR := real_addr(EA)",
                "RT := <sup>56</sup>0 || MEM(EA, 1)"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The byte in storage addressed by EA is loaded into",
                "RT56:63. RT0:55 are set to 0.",
                "",
                "This instruction creates a reservation for use by a",
                "stbcx. or waitrsv",
                "instruction.",
                "A real address computed from the EA as described in Section",
                " is associated with the",
                "reservation, and replaces any address previously associated with the",
                "reservation.",
                "A length of 1 byte is associated with the reservation, and replaces",
                "any length previously associated with the reservation.",
                "",
                "The value of EH provides a hint as to whether the program will",
                "perform a subsequent store to the byte in storage addressed by EA",
                "before some other processor attempts to modify it.",
                "",
                "",
                "",
                "[0.72in][l]0Other programs might attempt to modify the byte",
                "in storage addressed by EA regardless of the result of the",
                "corresponding stbcx. instruction.",
                "",
                "",
                "[0.72in][l]1Other programs will not attempt to modify the",
                "byte in storage addressed by EA until the program that has acquired",
                "the lock performs a subsequent store releasing the lock.",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Load Halfword And Reserve Indexed",
                    "form": "X",
                    "mnemonic": "lharx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "EH"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "116",
                    "size": "10"
                },
                {
                    "name": "EH",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b +(RB)",
                "RESERVE := 1",
                "RESERVE_LENGTH := 2",
                "RESERVE_ADDR := real_addr(EA)",
                "RT := <sup>48</sup>0 || MEM(EA, 2)"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The halfword in storage addressed by EA is loaded into",
                "RT48:63. RT0:47 are set to 0.",
                "",
                "This instruction creates a reservation for use by a",
                "sthcx. or waitrsv",
                "instruction.",
                "A real address computed from the EA as described in Section",
                " is associated with the",
                "reservation, and replaces any address previously associated with the",
                "reservation.",
                "A length of 2 bytes is associated with the reservation, and replaces",
                "any length previously associated with the reservation.",
                "",
                "The value of EH provides a hint as to whether the program will",
                "perform a subsequent store to the halfword in storage addressed by EA",
                "before some other processor attempts to modify it.",
                "",
                "",
                "",
                "[0.72in][l]0Other programs might attempt to modify the",
                "halfword in storage addressed by EA regardless of the result of the",
                "corresponding sthcx. instruction.",
                "",
                "",
                "[0.72in][l]1Other programs will not attempt to modify the",
                "halfword in storage addressed by EA until the program that has",
                "acquired the lock performs a subsequent store releasing the lock.",
                "",
                "",
                "EA must be a multiple of 2.",
                "If it is not, either the system alignment error handler is invoked or",
                "the results are boundedly undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Load Word And Reserve Indexed",
                    "form": "X",
                    "mnemonic": "lwarx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "EH"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "20",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b +(RB)",
                "RESERVE := 1",
                "RESERVE_LENGTH := 4",
                "RESERVE_ADDR := real_addr(EA)",
                "RT := <sup>32</sup>0 || MEM(EA, 4)"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The word in storage addressed by EA is loaded into",
                "RT32:63. RT0:31 are set to 0.",
                "",
                "This instruction creates a reservation for use by a",
                "stwcx. or waitrsv",
                "instruction.",
                "A real address computed from the EA as described in Section",
                " is associated with the",
                "reservation, and replaces any address previously associated with the",
                "reservation.",
                "A length of 4 bytes is associated with the reservation, and replaces",
                "any length previously associated with the reservation.",
                "",
                "The value of EH provides a hint as to whether the program will",
                "perform a subsequent store to the word in storage addressed by EA",
                "before some other processor attempts to modify it.",
                "",
                "",
                "",
                "[0.72in][l]0Other programs might attempt to modify the word",
                "in storage addressed by EA regardless of the result of the",
                "corresponding stwcx. instruction.",
                "",
                "",
                "[0.72in][l]1Other programs will not attempt to modify the",
                "word in storage addressed by EA until the program that has acquired",
                "the lock performs a subsequent store releasing the lock.",
                "",
                "",
                "EA must be a multiple of 4.",
                "If it is not, either the system alignment error handler is invoked or",
                "the results are boundedly undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Store Byte Conditional Indexed",
                    "form": "X",
                    "mnemonic": "stbcx.",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "1389",
                    "size": "11"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "if RESERVE then",
                " if RESERVE_LENGTH = 1 &",
                "    RESERVE_ADDR = real_addr(EA) then",
                "     MEM(EA, 1) := (RS)<sub>56:63</sub>",
                "     undefined_case  := 0",
                "     store_performed := 1",
                "  else",
                "     z := smallest real page size supported by",
                "         implementation",
                "     if RESERVE_ADDR / z = real_addr(EA) / z then",
                "        undefined_case  := 1",
                "     else",
                "       undefined_case  := 0",
                "       store_performed := 0",
                "else",
                " undefined_case  := 0",
                " store_performed := 0",
                "if undefined_case then",
                " u1 := undefined 1-bit value",
                " if u1 then",
                "   MEM(EA, 1) := (RS)<sub>56:63</sub>",
                " u2 := undefined 1-bit value",
                " CR0 := 0b00 || u2 || XER<sub>SO</sub>",
                "else",
                " CR0 := 0b00 || store_performed || XER<sub>SO</sub>",
                "RESERVE := 0"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "If a reservation exists, the length associated with the reservation",
                "is 1 byte, and the real storage location specified by the",
                "stbcx. is the same as the real storage location",
                "specified by the lbarx instruction that",
                "established the reservation, (RS)56:63 are stored",
                "into the byte in storage addressed by EA.",
                "",
                "If a reservation exists, and either the length associated with the",
                "reservation is not 1 byte or the real storage location specified by",
                "the stbcx. is not the same as the real storage",
                "location specified by the lbarx instruction that",
                "established the reservation, the following applies.",
                "Let z denote the smallest real page size supported by the",
                "implementation.",
                "If the real storage location specified by the stbcx. is in the same aligned z-byte block of real storage as the",
                "real storage location specified by the lbarx",
                "instruction that established the reservation, it is undefined whether",
                "(RS)56:63 are stored into the byte in storage",
                "addressed by EA. Otherwise, no store is performed.",
                "",
                "If a reservation does not exist, no store is performed.",
                "",
                "CR Field 0 is set as follows.",
                "n is a 1-bit value that indicates whether the store was performed,",
                "except that if, per the preceding description, it is undefined",
                "whether the store is performed, the value of n is undefined (and need",
                "not reflect whether the store was performed).",
                "",
                "CR0LT GT EQ SO = 0b00 || n || XERSO",
                "",
                "The reservation is cleared.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Store Halfword Conditional Indexed",
                    "form": "X",
                    "mnemonic": "sthcx.",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.06"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "1453",
                    "size": "11"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "if RESERVE then",
                " if RESERVE_LENGTH = 2 &",
                "    RESERVE_ADDR = real_addr(EA) then",
                "     MEM(EA, 2) := (RS)<sub>48:63</sub>",
                "     undefined_case  := 0",
                "     store_performed := 1",
                "  else",
                "     z := smallest real page size supported by",
                "        implementation",
                "     if RESERVE_ADDR / z = real_addr(EA) / z then",
                "        undefined_case  := 1",
                "     else",
                "       undefined_case  := 0",
                "       store_performed := 0",
                "else",
                " undefined_case  := 0",
                " store_performed := 0",
                "if undefined_case then",
                " u1 := undefined 1-bit value",
                " if u1 then",
                "   MEM(EA, 2) := (RS)<sub>48:63</sub>",
                " u2 := undefined 1-bit value",
                " CR0 := 0b00 || u2 || XER<sub>SO</sub>",
                "else",
                " CR0 := 0b00 || store_performed || XER<sub>SO</sub>",
                "RESERVE := 0"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "If a reservation exists, the length associated with the reservation",
                "is 2 bytes, and the real storage location specified by the",
                "sthcx. is the same as the real storage location",
                "specified by the lharx instruction that",
                "established the reservation, (RS)48:63 are stored",
                "into the halfword in storage addressed by EA.",
                "",
                "If a reservation exists, and either the length associated with the",
                "reservation is not 2 bytes or the real storage location specified by",
                "the sthcx. is not the same as the real storage",
                "location specified by the lharx instruction that",
                "established the reservation, the following applies.",
                "Let z denote the smallest real page size supported by the",
                "implementation.",
                "If the real storage location specified by the sthcx. is in the same aligned z-byte block of real storage as the",
                "real storage location specified by the lharx",
                "instruction that established the reservation, it is undefined whether",
                "(RS)48:63 are stored into the halfword in storage",
                "addressed by EA. Otherwise, no store is performed.",
                "",
                "If a reservation does not exist, no store is performed.",
                "",
                "CR Field 0 is set as follows.",
                "n is a 1-bit value that indicates whether the store was performed,",
                "except that if, per the preceding description, it is undefined",
                "whether the store is performed, the value of n is undefined (and need",
                "not reflect whether the store was performed).",
                "",
                "CR0LT GT EQ SO = 0b00 || n ||",
                "XERSO",
                "",
                "The reservation is cleared.",
                "",
                "EA must be a multiple of 2.",
                "If it is not, either the system alignment error handler is invoked or",
                "the results are boundedly undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Store Word Conditional Indexed",
                    "form": "X",
                    "mnemonic": "stwcx.",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "301",
                    "size": "11"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "if RESERVE then",
                " if RESERVE_LENGTH = 4 &",
                "    RESERVE_ADDR = real_addr(EA) then",
                "     MEM(EA, 4) := (RS)<sub>32:63</sub>",
                "     undefined_case  := 0",
                "     store_performed := 1",
                "  else",
                "     z := smallest real page size supported by",
                "         implementation",
                "     if RESERVE_ADDR / z = real_addr(EA) / z then",
                "       undefined_case  := 1",
                "     else",
                "       undefined_case  := 0",
                "       store_performed := 0",
                "else",
                " undefined_case  := 0",
                " store_performed := 0",
                "if undefined_case then",
                " u1 := undefined 1-bit value",
                " if u1 then",
                "   MEM(EA, 4) := (RS)<sub>32:63</sub>",
                " u2 := undefined 1-bit value",
                " CR0 := 0b00 || u2 || XER<sub>SO</sub>",
                "else",
                " CR0 := 0b00 || store_performed || XER<sub>SO</sub>",
                "RESERVE := 0"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "If a reservation exists, the length associated with the reservation",
                "is 4 bytes, and the real storage location specified by the",
                "stwcx. is the same as the real storage location",
                "specified by the lwarx instruction that",
                "established the reservation, (RS)32:63 are stored",
                "into the word in storage addressed by EA.",
                "",
                "If a reservation exists, and either the length associated with the",
                "reservation is not 4 bytes or the real storage location specified by",
                "the stwcx. is not the same as the real storage",
                "location specified by the lwarx instruction that",
                "established the reservation, the following applies.",
                "Let z denote the smallest real page size supported by the",
                "implementation.",
                "If the real storage location specified by the stwcx. is in the same aligned z-byte block of real storage as the",
                "real storage location specified by the lwarx",
                "instruction that established the reservation, it is undefined whether",
                "(RS)32:63 are stored into the word in storage",
                "addressed by EA. Otherwise, no store is performed.",
                "",
                "If a reservation does not exist, no store is performed.",
                "",
                "CR Field 0 is set as follows.",
                "n is a 1-bit value that indicates whether the store was performed,",
                "except that if, per the preceding description, it is undefined",
                "whether the store is performed, the value of n is undefined (and need",
                "not reflect whether the store was performed).",
                "",
                "CR0LT GT EQ SO = 0b00 || n ||",
                "XERSO",
                "",
                "The reservation is cleared.",
                "",
                "EA must be a multiple of 4.",
                "If it is not, either the system alignment error handler is invoked or",
                "the results are boundedly undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Load Doubleword And Reserve Indexed",
                    "form": "X",
                    "mnemonic": "ldarx",
                    "operands": [
                        "RT",
                        "RA",
                        "RB",
                        "EH"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "84",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b +(RB)",
                "RESERVE := 1",
                "RESERVE_LENGTH := 8",
                "RESERVE_ADDR := real_addr(EA)",
                "RT := MEM(EA, 8)"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The doubleword in storage addressed by EA is loaded into RT.",
                "",
                "This instruction creates a reservation for use by a",
                "stdcx. or waitrsv",
                "instruction.",
                "A real address computed from the EA as described in Section",
                " is associated with the",
                "reservation, and replaces any address previously associated with the",
                "reservation.",
                "A length of 8 bytes is associated with the reservation, and replaces",
                "any length previously associated with the reservation.",
                "",
                "The value of EH provides a hint as to whether the program will",
                "perform a subsequent store to the doubleword in storage addressed by",
                "EA before some other processor attempts to modify it.",
                "",
                "",
                "",
                "[0.72in][l]0Other programs might attempt to modify the",
                "doubleword in storage addressed by EA regardless of the result of the",
                "corresponding stdcx. instruction.",
                "",
                "",
                "[0.72in][l]1Other programs will not attempt to modify the",
                "doubleword in storage addressed by EA until the program that has",
                "acquired the lock performs a subsequent store releasing the lock.",
                "",
                "",
                "EA must be a multiple of 8.",
                "If it is not, either the system alignment error handler is invoked or",
                "the results are boundedly undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Store Doubleword Conditional Indexed",
                    "form": "X",
                    "mnemonic": "stdcx.",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "429",
                    "size": "11"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "if RESERVE then",
                " if RESERVE_LENGTH = 8 &",
                "    RESERVE_ADDR = real_addr(EA) then",
                "     MEM(EA, 8) := (RS)",
                "     undefined_case  := 0",
                "     store_performed := 1",
                "  else",
                "     z := smallest real page size supported by",
                "         implementation",
                "     if RESERVE_ADDR / z = real_addr(EA) / z then",
                "       undefined_case  := 1",
                "     else",
                "       undefined_case  := 0",
                "       store_performed := 0",
                "else",
                " undefined_case  := 0",
                " store_performed := 0",
                "if undefined_case then",
                " u1 := undefined 1-bit value",
                " if u1 then",
                "   MEM(EA, 8) := (RS)",
                " u2 := undefined 1-bit value",
                " CR0 := 0b00 || u2 || XER<sub>SO</sub>",
                "else",
                " CR0 := 0b00 || store_performed || XER<sub>SO</sub>",
                "RESERVE := 0"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "If a reservation exists, the length associated with the reservation",
                "is 8 bytes, and the real storage location specified by the",
                "stdcx. is the same as the real storage location",
                "specified by the ldarx instruction that",
                "established the reservation, (RS) is stored into the doubleword in",
                "storage addressed by EA.",
                "",
                "If a reservation exists, and either the length associated with the",
                "reservation is not 8 bytes or the real storage location specified by",
                "the stdcx. is not the same as the real storage",
                "location specified by the ldarx instruction that",
                "established the reservation, the following applies.",
                "Let z denote the smallest real page size supported by the",
                "implementation.",
                "If the real storage location specified by the stdcx. is in the same aligned z-byte block of real storage as the",
                "real storage location specified by the ldarx",
                "instruction that established the reservation, it is undefined whether",
                "(RS) is stored into the doubleword in storage addressed by EA.",
                "Otherwise, no store is performed.",
                "",
                "If a reservation does not exist, no store is performed.",
                "",
                "CR Field 0 is set as follows.",
                "n is a 1-bit value that indicates whether the store was performed,",
                "except that if, per the preceding description, it is undefined",
                "whether the store is performed, the value of n is undefined (and need",
                "not reflect whether the store was performed).",
                "",
                "CR0LT GT EQ SO = 0b00 || n ||",
                "XERSO",
                "",
                "The reservation is cleared.",
                "",
                "EA must be a multiple of 8.",
                "If it is not, either the system alignment error handler is invoked or",
                "the results are boundedly undefined.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Load Quadword And Reserve Indexed",
                    "form": "X",
                    "mnemonic": "lqarx",
                    "operands": [
                        "RTp",
                        "RA",
                        "RB",
                        "EH"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RTp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "276",
                    "size": "10"
                },
                {
                    "name": "EH",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b +(RB)",
                "RESERVE := 1",
                "RESERVE_LENGTH := 16",
                "RESERVE_ADDR := real_addr(EA)",
                "RTp := MEM(EA, 16)"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The quadword in storage addressed by EA is loaded into RTp.",
                "",
                "This instruction creates a reservation for use by a",
                "stqcx. or waitrsv",
                "instruction.",
                "A real address computed from the EA as described in Section",
                " is associated with the",
                "reservation, and replaces any address previously associated with the",
                "reservation.",
                "A length of 16 bytes is associated with the reservation, and replaces",
                "any length previously associated with the reservation.",
                "",
                "The value of EH provides a hint as to whether the program will",
                "perform a subsequent store to the doubleword in storage addressed by",
                "EA before some other processor attempts to modify it.",
                "",
                "",
                "",
                "[0.72in][l]0Other programs might attempt to modify the",
                "doubleword in storage addressed by EA regardless of the result of the",
                "corresponding stqcx. instruction.",
                "",
                "",
                "[0.72in][l]1Other programs will not attempt to modify the",
                "doubleword in storage addressed by EA until the program that has",
                "acquired the lock performs a subsequent store releasing the lock.",
                "",
                "",
                "EA must be a multiple of 16.",
                "If it is not, either the system alignment error handler is invoked or",
                "the results are boundedly undefined.",
                "",
                "If RTp is odd, RTp=RA, or RTp=RB the instruction form is invalid.",
                "If RTp=RA or RTp=RB, an attempt to execute this instruction will",
                "invoke the system illegal instruction error handler.",
                "(The RTp=RA case includes the case of RTp=RA=0.)",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Store Quadword Conditional Indexed",
                    "form": "X",
                    "mnemonic": "stqcx.",
                    "operands": [
                        "RSp",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RSp",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "365",
                    "size": "11"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "if RESERVE then",
                " if RESERVE_LENGTH = 16 &",
                "    RESERVE_ADDR = real_addr(EA) then",
                "     MEM(EA, 16) := (RSp)",
                "     undefined_case  := 0",
                "     store_performed := 1",
                "  else",
                "     z := smallest real page size supported by",
                "         implementation",
                "     if RESERVE_ADDR / z = real_addr(EA) / z then",
                "undefined_case  := 1",
                "     else",
                "undefined_case  := 0",
                "store_performed := 0",
                "else",
                " undefined_case  := 0",
                " store_performed := 0",
                "if undefined_case then",
                " u1 := undefined 1-bit value",
                " if u1 then",
                "   MEM(EA, 16) := (RSp)",
                " u2 := undefined 1-bit value",
                " CR0 := 0b00 || u2 || XER<sub>SO</sub>",
                "else",
                " CR0 := 0b00 || store_performed || XER<sub>SO</sub>",
                "RESERVE := 0"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "",
                "If a reservation exists, the length associated with the reservation",
                "is 16 bytes, and the real storage location specified by the",
                "stqcx. is the same as the real storage location",
                "specified by the lqarx instruction that",
                "established the reservation, (RSp) is stored into the quadword in",
                "storage addressed by EA.",
                "",
                "If a reservation exists, and either the length associated with the",
                "reservation is not 16 bytes or the real storage location specified by",
                "the stqcx. is not the same as the real storage",
                "location specified by the lqarx instruction that",
                "established the reservation, the following applies.",
                "Let z denote the smallest real page size supported by the",
                "implementation.",
                "If the real storage location specified by the stqcx. is in the same aligned z-byte block of real storage as the",
                "real storage location specified by the lqarx",
                "instruction that established the reservation, it is undefined whether",
                "(RSp) is stored into the quadword in storage addressed by EA.",
                "Otherwise, no store is performed.",
                "",
                "If a reservation does not exist, no store is performed.",
                "",
                "CR Field 0 is set as follows.",
                "n is a 1-bit value that indicates whether the store was performed,",
                "except that if, per the preceding description, it is undefined",
                "whether the store is performed, the value of n is undefined (and need",
                "not reflect whether the store was performed).",
                "",
                "CR0LT GT EQ SO = 0b00 || n ||",
                "XERSO",
                "",
                "The reservation is cleared.",
                "",
                "EA must be a multiple of 16.",
                "If it is not, either the system alignment error handler is invoked or",
                "the results are boundedly undefined.",
                "",
                "If RSp is odd, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Synchronize",
                    "form": "X",
                    "mnemonic": "sync",
                    "operands": [
                        "L",
                        "SC"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "L",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "10"
                },
                {
                    "name": "598",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if SC!=0 then switch(SC)",
                "    case(1): stncisync",
                "    case(2): stcisync",
                "    case(3): stsync",
                "else switch(L)"
            ],
            "body": [
                "",
                "",
                "",
                "case(0): hwsync",
                "",
                "",
                " case(1): lwsync",
                "",
                "",
                " case(2): ptesync",
                "",
                "",
                " case(4): phwsync",
                "",
                "",
                " case(5): plwsync",
                "",
                "",
                "The sync instruction creates a memory barrier",
                "(see Section ).",
                "The set of storage accesses and/or data transfers that is ordered by",
                "the memory barrier depends on the contents of the L and SC fields as",
                "follows.",
                "",
                "SC0",
                "",
                "",
                "",
                "SC=0",
                "",
                "",
                "",
                "The ordering done by the memory barrier is cumulative (regardless of",
                "the L and SC values).",
                "",
                "If L=0 or L=4 (or L=2), the sync instruction has",
                "the following additional properties.",
                "",
                "",
                "Programming NoteSection  contains a detailed",
                "description of how to modify instructions such that a well-defined",
                "result is obtained.",
                "",
                "The L values 3, 6, and 7 are reserved.",
                "",
                "The sync instruction may complete before storage",
                "accesses associated with instructions preceding the",
                "sync instruction have been performed.",
                "",
                "Figure",
                "shows the valid combinations of SC and L values.",
                "Instructions that use any of these combinations will execute",
                "correctly on processors that comply with versions of the architecture",
                "that precede Version 3.1 (in which versions the L field is two bits",
                "long, the SC field does not exist, and bits 8 and 14:15 of the",
                "sync instruction are reserved) and on processors",
                "that comply with Version 3.1 and subsequent versions of the",
                "architecture.",
                "If any other combination is used, the instruction form is invalid.",
                "",
                "",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Enforce In-order Execution of I/O",
                    "form": "X",
                    "mnemonic": "eieio",
                    "operands": [],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "15"
                },
                {
                    "name": "854",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The eieio instruction creates a memory barrier",
                "(see Section, Storage",
                "Access Ordering    ), which provides an ordering function for the",
                "storage accesses caused by Load, Store, and",
                "dcbz instructions executed by the processor",
                "executing the eieio instruction.",
                "These storage accesses are divided into the two sets listed below.",
                "The storage access caused by a dcbz instruction",
                "is ordered as a store.",
                "",
                "",
                "",
                "The operations caused by the stream variants of the",
                "dcbt and dcbtst instructions",
                "(i.e., the providing of hints) are ordered by eieio as a third set of operations, the operations caused by",
                "tlbie and tlbsync",
                "instructions (see Book III) are ordered by eieio",
                "as a fourth set of operations, and the operations caused by",
                "slbieg or slbiag and",
                "slbsync instructions (see Book III) are ordered",
                "by eieio as a fifth set of operations.",
                "",
                "Each of the five sets of storage accesses or operations is ordered",
                "independently of the other four sets.",
                "The ordering done by eieio's memory barrier for",
                "the second set is cumulative; the ordering done by eieio's memory barrier for the other four sets is not cumulative.",
                "",
                "The eieio instruction may complete before storage",
                "accesses associated with instructions preceding the",
                "eieio instruction have been performed.",
                "The eieio instruction may complete before",
                "operations caused by dcbt and dcbtst instructions preceding the eieio",
                "instruction have been performed",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control Instructions",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Wait",
                    "form": "X",
                    "mnemonic": "wait",
                    "operands": [
                        "WC",
                        "PL"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "WC",
                    "size": "2"
                },
                {
                    "name": "reserved",
                    "size": "10"
                },
                {
                    "name": "30",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The wait instruction causes",
                "instruction fetching and execution to be suspended under certain",
                "conditions, depending on the values of the WC and PL fields.",
                "Instruction fetching and execution are resumed when the events",
                "specified by the WC field occur or in the rare case of an",
                "implementation-dependent event.",
                "",
                "The values of the WC field are as follows.",
                "",
                "",
                "[0.5in][l]0Resume instruction fetching and execution when",
                "an exception or event-based branch exception occurs.",
                "",
                "",
                "[0.5in][l]1Resume instruction fetching and execution when",
                "an exception or event-based branch exception occurs, or when a",
                "reservation made by the processor does not exist (see Section",
                ").",
                "",
                "",
                "[0.5in][l]2Resume instruction fetching and execution when",
                "an exception or event-based branch exception occurs, or when the",
                "amount of time specified by the PL field has passed.",
                "",
                "",
                "[0.5in][l]3Reserved.",
                "",
                "The values of the PL field are as follows.",
                "",
                "",
                "[0.5in][l]0b00A short wait time is specified.",
                "",
                "",
                "[0.5in][l]0b01:11Reserved.",
                "",
                "If WC=0, or if WC=1 and a reservation made by the processor exists,",
                "or if WC=2 and a value for PL that is not reserved is specified, the",
                "following applies.",
                "",
                "",
                "Engineering NoteBecause the waiting begins when the instruction completes, if the",
                "waiting is ended by an exception that causes a change of control flow",
                "(interrupt, event-based branch), the SPR that is set to reflect the",
                "point in the instruction stream at which the change of control flow",
                "occurred (e.g., SRR0 for a Decrementer interrupt) will contain the EA",
                "of the instruction following the  instruction.",
                "",
                "If WC=1 and a reservation made by the processor does not exist, or if",
                "WC=2 and a reserved value of PL is specified, the instruction is",
                "treated as a no-op.",
                "Engineering NoteBits 6 and 7 of the  instruction may be used",
                "in some implementations for an implementation-dependent field.",
                "Unless the intention is to use the implementation-dependent field,",
                "these bits must be coded zero.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Time Base",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Move From Time Base",
                    "form": "XFX",
                    "mnemonic": "mftb",
                    "operands": [
                        "RT",
                        "TBR"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "tbr1",
                    "size": "5"
                },
                {
                    "name": "tbr0",
                    "size": "5"
                },
                {
                    "name": "371",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "This instruction behaves as if it were an mfspr",
                "instruction; see the mfspr instruction",
                "description in",
                "Section",
                "of Book I.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Event-Based Branch Facility",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Return from Event-Based Branch",
                    "form": "XL",
                    "mnemonic": "rfebb",
                    "operands": [
                        "S"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "14"
                },
                {
                    "name": "S",
                    "size": "1"
                },
                {
                    "name": "146",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "BESCR<sub>GE</sub> := S",
                "NIA :=<sub>iea</sub> EBBRR<sub>0:61</sub> || 0b00"
            ],
            "body": [
                "",
                "BESCRGE is set to S.",
                "",
                "If there are no pending event-based exceptions, then the next",
                "instruction is fetched from the address EBBRR0:61 ||",
                "0b00 (when MSRSF=1) or 320 ||",
                "EBBRR32:61 || 0b00 (when MSRSF=0).",
                "If one or more pending event-based exceptions exist, an event-based",
                "branch is generated; in this case the value placed into EBBRR by the",
                "Event-Based Branch facility is the address of the instruction that",
                "would have been executed next had the event-based branch not occurred.",
                "",
                "If BESCR32:330b00 the instruction is treated",
                "as if the instruction form were invalid.",
                "",
                "See",
                "Section",
                "of Book III for additional information about this instruction.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch History Rolling Buffer",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Clear BHRB",
                    "form": "X",
                    "mnemonic": "clrbhrb",
                    "operands": [],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "15"
                },
                {
                    "name": "430",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "for n = 0 to (number_of_BHRBEs implemented - 1)",
                " BHRB(n) := 0"
            ],
            "body": [
                "",
                "All BHRB entries are set to 0s.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch History Rolling Buffer",
            "book": "II",
            "mnemonics": [
                {
                    "name": "Move From Branch History Rolling Buffer Entry",
                    "form": "XFX",
                    "mnemonic": "mfbhrbe",
                    "operands": [
                        "RT",
                        "BHRBE"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "bhrb1",
                    "size": "5"
                },
                {
                    "name": "bhrb0",
                    "size": "5"
                },
                {
                    "name": "302",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "n := BHRBE<sub>0:9</sub>",
                "If n < number of BHRBEs implemented then",
                "RT := BHRBE(n)",
                "else",
                "RT := <sup>64</sup>0"
            ],
            "body": [
                "",
                "The BHRBE field denotes an entry in the BHRB.",
                "If the designated entry is within the range of BHRB entries",
                "implemented and Performance Monitor alterts are disable (see",
                "Section of",
                "Book III), the contents of the designated BHRB entry are placed into",
                "register RT; otherwise, zero is placed into register RT.",
                "",
                "In order to ensure that the current BHRB contents are read by this",
                "instruction, one of the following must have occurred prior to this",
                "instruction and after all previous Branch and",
                "clrbhrb instructions have completed.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "System Call",
                    "form": "SC",
                    "mnemonic": "sc",
                    "operands": [
                        "LEV"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "17",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "14"
                },
                {
                    "name": "LEV",
                    "size": "7"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "1",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "SRR0 :=<sub>iea</sub> CIA + 4",
                "SRR1<sub>33:36 42:47</sub> := 0",
                "SRR1<sub>0:32 37:41 48:63</sub> := MSR<sub>0:32 37:41 48:63</sub>",
                "MSR := new_value (see below)",
                "NIA := 0x0000_0000_0000_0C00"
            ],
            "body": [
                "",
                "The effective address of the instruction following the System Call instruction is placed into SRR0.",
                "Bits 0:32, 37:41, and 48:63 of the MSR are placed into the",
                "corresponding bits of SRR1, and bits 33:36 and 42:47 of SRR1 are set",
                "to zero.",
                "",
                "Then a System Call interrupt is generated.",
                "The interrupt causes the MSR to be set as described in",
                "Section,",
                "Interrupt Definitions on",
                "pagesec:PPC3SChInterrupts-Interrupt-Definitions.",
                "The setting of the MSR is affected by the contents of the LEV field.",
                "LEV values greater than 2 are reserved.",
                "Bits 0:4 of the LEV field (instruction bits 20:24) are treated as a",
                "reserved field.",
                "",
                "The interrupt causes the next instruction to be fetched from",
                "effective address 0x0000000000000C00.",
                "",
                "This instruction is context synchronizing.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "System Call Vectored",
                    "form": "SC",
                    "mnemonic": "scv",
                    "operands": [
                        "LEV"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "17",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "14"
                },
                {
                    "name": "LEV",
                    "size": "7"
                },
                {
                    "name": "reserved",
                    "size": "3"
                },
                {
                    "name": "1",
                    "size": "2"
                }
            ],
            "code": [
                "LR := CIA + 4",
                "CTR<sub>33:36 42:47</sub> := undefined",
                "CTR<sub>0:32 37:41 48:63</sub> := MSR<sub>0:32 37:41 48:63</sub>",
                "MSR := new_value (see below)",
                "NIA := (see below)"
            ],
            "body": [
                "",
                "The effective address of the instruction following the System Call Vectored instruction is placed into the Link Register.",
                "Bits 0:32, 37:41, and 48:63 of the MSR are placed into the",
                "corresponding bits of Count Register, and bits 33:36 and 42:47 of",
                "Count Register are set to undefined values.",
                "",
                "Then a System Call Vectored interrupt is generated.",
                "The interrupt causes the MSR to be altered as described in Section",
                ".",
                "",
                "The interrupt causes the next instruction to be fetched as specified",
                "in LPCRAIL or LPCRHAIL as appropriate",
                "(see Section",
                ").",
                "",
                "The SRRs are not affected.",
                "",
                "This instruction is context synchronizing.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Return From System Call Vectored",
                    "form": "XL",
                    "mnemonic": "rfscv",
                    "operands": [],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "15"
                },
                {
                    "name": "82",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "MSR<sub>48</sub> := CTR<sub>48</sub> | CTR<sub>49</sub>",
                "MSR<sub>58</sub> := (CTR<sub>58</sub> | CTR<sub>49</sub>) & ~(MSR<sub>41</sub> & MSR<sub>3</sub> & (~CTR<sub>49</sub>))",
                "MSR<sub>59</sub> := (CTR<sub>59</sub> | CTR<sub>49</sub>) & ~(MSR<sub>41</sub> & MSR<sub>3</sub> & (~CTR<sub>49</sub>))",
                "MSR<sub>0:2 4:32 37:40 49:50 52:57 60:63</sub>:=CTR<sub>0:2 4:32 37:40 49:50 52:57 60:63</sub>",
                "NIA :=<sub>iea</sub> LR<sub>0:61</sub> || 0b00"
            ],
            "body": [
                "",
                " The result of ORing bits 48 and 49 of the Count Register is placed",
                "into MSR48.",
                "The result of ANDing bit 41 of the MSR with bit 3 of the MSR and with",
                "the complement of bit 49 of the Count Register is complemented and",
                "then ANDed with the result of ORing bits 58 and 49 of the Count",
                "Register and placed into MSR58.",
                "The result of ANDing bit 41 of the MSR with bit 3 of the MSR and with",
                "the complement of bit 49 of the Count Register is complemented and",
                "then ANDed with the result of ORing bits 59 and 49 of the Count",
                "Register and placed into MSR59.",
                "Bits 0:2, 4:32, 37:40, 49:50, 52:57, and 60:63 of the Count Register",
                "are placed into the corresponding bits of the MSR.",
                "",
                "If the new MSR value does not enable any pending exceptions, then the",
                "next instruction is fetched, under control of the new MSR value, from",
                "the address LR0:61 || 0b00 (when SF=1 in the new MSR",
                "value) or 320 || LR32:61 || 0b00",
                "(when SF=0 in the new MSR value).",
                "If the new MSR value enables one or more pending exceptions, the",
                "interrupt associated with the highest priority pending exception is",
                "generated; in this case the value placed into SRR0, HSRR0, or USRR0",
                "by the interrupt processing mechanism (see Section",
                ") is the address of",
                "the instruction that would have been executed next had the interrupt",
                "not occurred.",
                "",
                "This instruction is privileged and context synchronizing.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Return From Interrupt Doubleword",
                    "form": "XL",
                    "mnemonic": "rfid",
                    "operands": [],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "15"
                },
                {
                    "name": "18",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "MSR<sub>51</sub> := (MSR<sub>3</sub> & SRR1<sub>51</sub>) | ((~MSR<sub>3</sub>) & MSR<sub>51</sub>)",
                "MSR<sub>3</sub> := MSR<sub>3</sub> & SRR1<sub>3 </sub>",
                "MSR<sub>48</sub> := SRR1<sub>48</sub> | SRR1<sub>49</sub>",
                "MSR<sub>58</sub> := (SRR1<sub>58</sub> | SRR1<sub>49</sub>) & ~(MSR<sub>41</sub> & MSR<sub>3</sub> & (~SRR1<sub>49</sub>))",
                "MSR<sub>59</sub> := (SRR1<sub>59</sub> | SRR1<sub>49)</sub> & ~(MSR<sub>41</sub> & MSR<sub>3</sub> & (~SRR1<sub>49</sub>))",
                "MSR<sub>0:2 4:32 37:40 49:50 52:57 60:63</sub>:=SRR1<sub>0:2 4:32 37:40 49:50 52:57 60:63</sub>",
                "NIA :=<sub>iea</sub> SRR0<sub>0:61</sub> || 0b00"
            ],
            "body": [
                "",
                "If MSR3=1 then bits 3 and 51 of SRR1 are placed into",
                "the corresponding bits of the MSR.",
                "The result of ORing bits 48 and 49 of SRR1 is placed into",
                "MSR48.",
                "The result of ANDing bit 41 of the MSR with bit 3 of the MSR and with",
                "the complement of bit 49 of SRR1 is complemented and then ANDed with",
                "the result of ORing bits 58 and 49 of SRR1 and placed into",
                "MSR58.",
                "The result of ANDing bit 41 of the MSR with bit 3 of the MSR and with",
                "the complement of bit 49 of SRR1 is complemented and then ANDed with",
                "the result of ORing bits 59 and 49 of SRR1 and placed into",
                "MSR59.",
                "Bits 0:2, 4:32, 37:40, 49:50, 52:57, and 60:63 of SRR1 are placed",
                "into the corresponding bits of the MSR.",
                "",
                "If  the new MSR value does not enable any pending exceptions, then",
                "the next instruction is fetched, under control of the new MSR value,",
                "from the address SRR00:61 || 0b00 (when SF=1 in the",
                "new MSR value) or 320 || SRR032:61",
                "|| 0b00 (when SF=0 in the new MSR value).",
                "If the new MSR value enables one or more pending exceptions, the",
                "interrupt associated with the highest priority pending exception is",
                "generated; in this case the value placed into SRR0, HSRR0, or USRR0",
                "by the interrupt processing mechanism (see Section",
                ") is the address of",
                "the instruction that would have been executed next had the interrupt",
                "not occurred.",
                "",
                "This instruction is privileged and context synchronizing.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Hypervisor Return From Interrupt Doubleword",
                    "form": "XL",
                    "mnemonic": "hrfid",
                    "operands": [],
                    "conditions": [],
                    "release": "v2.02"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "15"
                },
                {
                    "name": "274",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "MSR<sub>48</sub> := HSRR1<sub>48</sub> | HSRR1<sub>49</sub>",
                "MSR<sub>58</sub> := (HSRR1<sub>58</sub> | HSRR1<sub>49</sub>) & ~(MSR<sub>41</sub> & MSR<sub>3</sub> & (~HSRR1<sub>49</sub>))",
                "MSR<sub>59</sub> := (HSRR1<sub>59</sub> | HSRR1<sub>49)</sub> & ~(MSR<sub>41</sub> & MSR<sub>3</sub> & (~HSRR1<sub>49</sub>))",
                "MSR<sub>0:32 37:40 49:57 60:63</sub> := HSRR1<sub>0:32 37:40 49:57 60:63</sub>",
                "NIA :=<sub>iea</sub> HSRR0<sub>0:61</sub> || 0b00"
            ],
            "body": [
                "",
                "The result of ORing bits 48 and 49 of HSRR1 is placed into",
                "MSR48.",
                "The result of ANDing bit 41 of the MSR with bit 3 of HSRR1 and with",
                "the complement of bit 49 of HSRR1 is complemented and then ANDed with",
                "the result of ORing bits 58 and 49 of HSRR1 and placed into",
                "MSR58.",
                "The result of ANDing bit 41 of the MSR with bit 3 of HSRR1 and with",
                "the complement of bit 49 of HSRR1 is complemented and then ANDed with",
                "the result of ORing bits 59 and 49 of HSRR1 and placed into",
                "MSR59.",
                "Bits 0:32, 37:40, 49:57, and 60:63 of HSRR1 are placed into the",
                "corresponding bits of the MSR.",
                "",
                "If the new MSR value does not enable any pending exceptions, then the",
                "next instruction is fetched, under control of the new MSR value, from",
                "the address HSRR00:61 || 0b00 (when SF=1 in the new",
                "MSR value) or 320 || HSRR032:61 ||",
                "0b00 (when SF=0 in the new MSR value).",
                "If the new MSR value enables one or more pending exceptions, the",
                "interrupt associated with the highest priority pending exception is",
                "generated; in this case the value placed into SRR0, HSRR0, or USRR0",
                "by the interrupt processing mechanism (see Section",
                ") is the address of",
                "the instruction that would have been executed next had the interrupt",
                "not occurred.",
                "",
                "This instruction is hypervisor privileged and context synchronizing.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Ultravisor Return From Interrupt Doubleword",
                    "form": "XL",
                    "mnemonic": "urfid",
                    "operands": [],
                    "conditions": [],
                    "release": "v3.0C"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "15"
                },
                {
                    "name": "306",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "MSR<sub>48</sub> := USRR1<sub>48</sub> | USRR1<sub>49</sub>",
                "MSR<sub>58</sub> := (USRR1<sub>58</sub> | USRR1<sub>49</sub>) & ~(USRR1<sub>41</sub> & USRR1<sub>3</sub> & (~USRR1<sub>49</sub>))",
                "MSR<sub>59</sub> := (USRR1<sub>59</sub> | USRR1<sub>49</sub>) & ~(USRR1<sub>41</sub> & USRR1<sub>3</sub> & (~USRR1<sub>49</sub>))",
                "MSR<sub>0:32 37:41 49:57 60:63</sub> := USRR1<sub>0:32 37:41 49:57 60:63</sub>",
                "NIA :=<sub>iea</sub> USRR0<sub>0:61</sub> || 0b00"
            ],
            "body": [
                "",
                "The result of ORing bits 48 and 49 of USRR1 is placed into",
                "MSR48.",
                "The result of ANDing bit 41 of USRR1 with bit 3 of USRR1 and with the",
                "complement of bit 49 of USRR1 is complemented and then ANDed with the",
                "result of ORing bits 58 and 49 of USRR1 and placed into",
                "MSR58.",
                "The result of ANDing bit 41 of USRR1 with bit 3 of USRR1 and with the",
                "complement of bit 49 of USRR1 is complemented and then ANDed with the",
                "result of ORing bits 59 and 49 of USRR1 and placed into",
                "MSR59.",
                "Bits 0:32, 37:41, 49:57, and 60:63 of USRR1 are placed into the",
                "corresponding bits of the MSR.",
                "",
                "If the new MSR value does not enable any pending exceptions, then the",
                "next instruction is fetched, under control of the new MSR value, from",
                "the address USRR00:61 || 0b00 (when SF=1 in the new",
                "MSR value) or 320 || USRR032:61 ||",
                "0b00 (when SF=0 in the new MSR value).",
                "If the new MSR value enables one or more pending exceptions, the",
                "interrupt associated with the highest priority pending exception is",
                "generated; in this case the value placed into SRR0, HSRR0, or USRR0",
                "by the interrupt processing mechanism (see Section",
                ") is the address of",
                "the instruction that would have been executed next had the interrupt",
                "not occurred.",
                "",
                "This instruction is ultravisor privileged and context synchronizing.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Branch Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Stop",
                    "form": "XL",
                    "mnemonic": "stop",
                    "operands": [],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "19",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "15"
                },
                {
                    "name": "370",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The thread is placed into power-saving mode and execution is stopped.",
                "",
                "The power-saving level that is entered is determined by the contents",
                "of the PSSCR (see Section",
                ").",
                "The thread state that is maintained depends on the power-saving level",
                "that is entered.",
                "The thread state that is maintained at each power-saving level is",
                "implementation-dependent, subject to the restrictions specified in",
                "Section",
                ".MSREE=0)",
                "or in the corresponding interrupt handler (if",
                "MSREE=1).",
                "",
                "The thread remains in power-saving mode until either a System Reset",
                "exception or certain other events occur.",
                "The events that may cause exit from power-saving mode are specified",
                "by PSSCREC, LPCRPECE, and",
                "SMFCTRLUDEE.",
                "If the event that causes the exit is a System Reset, Machine Check,",
                "or Hypervisor Maintenance exception, resource state that would be",
                "lost if the exception occurred when the thread was not in",
                "power-saving mode may be lost.",
                "",
                "This instruction should not be executed in ultravisor state because",
                "that scenario may not be thoroughly verified.",
                "",
                "This instruction is privileged and context synchronizing.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Load Byte and Zero Caching Inhibited Indexed",
                    "form": "X",
                    "mnemonic": "lbzcix",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "853",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := <sup>56</sup>0 || MEM(EA, 1)"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The byte in storage addressed by EA is loaded into",
                "RT56:63. RT0:55 are set to 0.",
                "",
                "The storage access caused by this instruction is performed as though",
                "the specified storage location is Caching Inhibited and Guarded.",
                "",
                "This instruction is hypervisor privileged.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Load Halfword and Zero Caching Inhibited Indexed",
                    "form": "X",
                    "mnemonic": "lhzcix",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "821",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := <sup>48</sup>0 || MEM(EA, 2)"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The halfword in storage addressed by EA is loaded into",
                "RT48:63. RT0:47 are set to 0.",
                "",
                "The storage access caused by this instruction is performed as though",
                "the specified storage location is Caching Inhibited and Guarded.",
                "",
                "This instruction is hypervisor privileged.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Load Word and Zero Caching Inhibited Indexed",
                    "form": "X",
                    "mnemonic": "lwzcix",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "789",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := <sup>32</sup>0 || MEM(EA, 4)"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The word in storage addressed by EA is loaded into",
                "RT32:63. RT0:31 are set to 0.",
                "",
                "The storage access caused by this instruction is performed as though",
                "the specified storage location is Caching Inhibited and Guarded.",
                "",
                "This instruction is hypervisor privileged.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Load Doubleword Caching Inhibited Indexed",
                    "form": "X",
                    "mnemonic": "ldcix",
                    "operands": [
                        "RT",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "885",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "RT := MEM(EA, 8)"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "The doubleword in storage addressed by EA is loaded into RT.",
                "",
                "The storage access caused by this instruction is performed as though",
                "the specified storage location is Caching Inhibited and Guarded.",
                "",
                "This instruction is hypervisor privileged.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Store Byte Caching Inhibited Indexed",
                    "form": "X",
                    "mnemonic": "stbcix",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "981",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 1) := (RS)<sub>56:63</sub>"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "(RS)56:63 are stored into the byte in storage",
                "addressed by EA.",
                "",
                "The storage access caused by this instruction is performed as though",
                "the specified storage location is Caching Inhibited and Guarded.",
                "",
                "This instruction is hypervisor privileged.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Store Halfword Caching Inhibited Indexed",
                    "form": "X",
                    "mnemonic": "sthcix",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "949",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 2) := (RS)<sub>48:63</sub>"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "(RS)48:63 are stored into the halfword in storage",
                "addressed by EA.",
                "",
                "The storage access caused by this instruction is performed as though",
                "the specified storage location is Caching Inhibited and Guarded.",
                "",
                "This instruction is hypervisor privileged.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Store Word Caching Inhibited Indexed",
                    "form": "X",
                    "mnemonic": "stwcix",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "917",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 4) := (RS)<sub>32:63</sub>"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "(RS)32:63 are stored into the word in storage",
                "addressed by EA.",
                "",
                "The storage access caused by this instruction is performed as though",
                "the specified storage location is Caching Inhibited and Guarded.",
                "",
                "This instruction is hypervisor privileged.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Store Doubleword Caching Inhibited Indexed",
                    "form": "X",
                    "mnemonic": "stdcix",
                    "operands": [
                        "RS",
                        "RA",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "1013",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if RA = 0 then b := 0",
                "else           b := (RA)",
                "EA := b + (RB)",
                "MEM(EA, 8) := (RS)"
            ],
            "body": [
                "",
                "Let the effective address (EA) be the sum (RA|0)+(RB).",
                "(RS) is stored into the doubleword in storage addressed by EA.",
                "",
                "The storage access caused by this instruction is performed as though",
                "the specified storage location is Caching Inhibited and Guarded.",
                "",
                "This instruction is hypervisor privileged.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Hash Store Privileged",
                    "form": "X",
                    "mnemonic": "hashstp",
                    "operands": [
                        "RB",
                        "offset(RA)"
                    ],
                    "conditions": [],
                    "release": "v3.1B"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "D",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "658",
                    "size": "10"
                },
                {
                    "name": "DX",
                    "size": "1"
                }
            ],
            "code": [
                "DW := 32*DX + D",
                "d := EXTS(0b111_1111 || DW || 0b000)",
                "EA := (RA) + d",
                "temp := HashDigest((RA),(RB),(HASHPKEYR))",
                "MEM(EA, 8) := temp",
                ""
            ],
            "body": [
                "",
                "Let DW be the value 32xDX + D.",
                "The offset is (0b1111111 || DW || 0b000) sign extended to 64 bits.",
                "Let the effective address (EA) be the sum (RA) + offset.",
                "The doubleword hash value computed from the contents of RA, RB, and",
                "the hypervisor privileged SPR HASHPKEYR, as specified by the",
                "HashDigest function  described in",
                "Section of Book I,",
                "is stored into the doubleword in storage addressed by EA.",
                "",
                "This instruction is privileged.",
                "",
                "EA must be a multiple of 8.",
                "If it is not, either an Alignment interrupt occurs or the results are",
                "boundedly undefined.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Hash Check Privileged",
                    "form": "X",
                    "mnemonic": "hashchkp",
                    "operands": [
                        "RB",
                        "offset(RA)"
                    ],
                    "conditions": [],
                    "release": "v3.1B"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "D",
                    "size": "5"
                },
                {
                    "name": "RA",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "690",
                    "size": "10"
                },
                {
                    "name": "DX",
                    "size": "1"
                }
            ],
            "code": [
                "DW := 32*DX + D",
                "d := EXTS(0b111_1111 || DW || 0b000)",
                "EA := (RA) + d",
                "temp := HashDigest((RA),(RB),(HASHPKEYR))",
                "temp1 := MEM(EA, 8)",
                "if (temp != temp1)then TRAP"
            ],
            "body": [
                "",
                "Let DW be the value 32xDX + D.",
                "The offset is (0b1111111 || DW || 0b000) sign extended to 64 bits.",
                "Let the effective address (EA) be the sum (RA) + offset.",
                "The doubleword in storage addressed by EA is read and compared with",
                "the doubleword hash value computed from the contents of RA, RB, and",
                "the hypervisor privileged SPR HASHPKEYR, as specified by the",
                "HashDigest function described in",
                "Section of Book I.",
                "If the values are unequal, the system trap handler is invoked.",
                "",
                "This instruction is treated as a Load; see",
                "Section",
                "of Book II.",
                "",
                "This instruction is privileged.",
                "",
                "If the values are unequal, this instruction is context synchronizing",
                "(see Book III).",
                "",
                "EA must be a multiple of 8.",
                "If it is not, either an Alignment interrupt occurs or the results are",
                "boundedly undefined.",
                "",
                "If RA=0, the instruction form is invalid.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Move To Special Purpose Register",
                    "form": "XFX",
                    "mnemonic": "mtspr",
                    "operands": [
                        "SPR",
                        "RS"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "spr1",
                    "size": "5"
                },
                {
                    "name": "spr0",
                    "size": "5"
                },
                {
                    "name": "467",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "n := spr<sub>5:9</sub> || spr<sub>0:4</sub>",
                "switch (n)",
                " case (13):",
                "           if MSR<sub>HV PR</sub> = 0b10 then",
                "             SPR(13) := (RS)",
                "           else if MSR<sub>HV PR</sub> = 0b00 then",
                "             SPR(13) := ((RS) & AMOR) | ((SPR(13)) & ~AMOR)",
                "           else",
                "               SPR(13) := ((RS) & UAMOR) | ((SPR(13)) & ~UAMOR)",
                " case (29,61):",
                "           if MSR<sub>HV PR</sub> = 0b10 then",
                "             SPR(n) := (RS)",
                "           else",
                "             SPR(n) := ((RS) & AMOR) | ((SPR(n)) & ~AMOR)",
                " case (157):",
                "           if MSR<sub>HV PR</sub> = 0b10 then",
                "             SPR(157) := (RS)",
                "           else",
                "             SPR(157) := (RS) & AMOR",
                " case (336):",
                "           SPR(336) := (SPR(336)) & (RS)",
                " case (158, 808, 809, 810, 811):",
                " default:",
                "           if length(SPR(n)) = 64 then",
                "             SPR(n) := (RS)",
                "           else",
                "             SPR(n) := (RS)<sub>32:63</sub>",
                ""
            ],
            "body": [
                "",
                "The SPR field denotes a Special Purpose Register, encoded as shown in",
                "Table.",
                "If the SPR field contains the value 158, the instruction is treated",
                "as a privileged no-op.",
                "If the SPR field contains a value from 808 through 811, the",
                "instruction specifies a reserved SPR, and is treated as a no-op;  see",
                "Section, Reserved",
                "Fields, Reserved Values, and Reserved SPRs in Book I.",
                "Otherwise, the contents of register RS are placed into the designated",
                "Special Purpose Register, except as described in the next five",
                "paragraphs.",
                "For Special Purpose Registers that are 32 bits long, the low-order 32",
                "bits of RS are placed into the SPR.",
                "",
                "When the designated SPR is the Authority Mask Register (AMR), (using",
                "SPR 13 or SPR 29), or the designated SPR is the Instruction Authority",
                "Mask Register (IAMR), and MSRHVPR=0b00, the contents",
                "of bit positions of register RS corresponding to 1 bits in the",
                "Authority Mask Override Register (AMOR) are placed into the",
                "corresponding bits of the AMR or IAMR, respectively; the other AMR or",
                "IAMR bits are not modified.",
                "",
                "When the designated SPR is the AMR, using SPR 13, and",
                "MSRPR=1, the contents of bit positions of register RS",
                "corresponding to 1 bits in the User Authority Mask Override Register",
                "(UAMOR) are placed into the corresponding bits of the AMR; the other",
                "AMR bits are not modified.",
                "",
                "When the designated SPR is the UAMOR and",
                "MSRHVPR=0b00, the contents of register RS are ANDed",
                "with the contents of the AMOR and the result is placed into the UAMOR.",
                "",
                "When the designated SPR is the Hypervisor Maintenance Exception",
                "Register (HMER), the contents of register RS are ANDed with the",
                "contents of the HMER and the result is placed into the HMER.",
                "",
                "For this instruction, SPRs TBL and TBU are treated as separate 32-bit",
                "registers; setting one leaves the other unaltered.",
                "",
                "spr0=1 if and only if writing the register is",
                "privileged.",
                "Execution of this instruction specifying an SPR number with",
                "spr0=1 when the privilege state of the thread does",
                "not permit the access causes one of the following.",
                "",
                "",
                "",
                "Execution of this instruction specifying an SPR number that is",
                "undefined for the implementation causes one of the following.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Move From Special Purpose Register",
                    "form": "XFX",
                    "mnemonic": "mfspr",
                    "operands": [
                        "RT",
                        "SPR"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "spr1",
                    "size": "5"
                },
                {
                    "name": "spr0",
                    "size": "5"
                },
                {
                    "name": "339",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "n := spr<sub>5:9</sub> || spr<sub>0:4</sub>",
                "switch (n)",
                "",
                " case(808, 809, 810, 811):",
                " default:",
                "   if length(SPR(n)) = 64 then",
                "     RT := SPR(n)",
                "   else",
                "     RT := <sup>32</sup>0 || SPR(n)",
                ""
            ],
            "body": [
                "",
                "The SPR field denotes a Special Purpose Register, encoded as shown in",
                "Table.",
                "If the SPR field contains a value from 808 through 811, the",
                "instruction specifies a reserved SPR, and is treated as a no-op; see",
                "Section, Reserved",
                "Fields, Reserved Values, and Reserved SPRs in Book I.",
                "Otherwise, the contents of the designated Special Purpose Register",
                "are placed into register RT.",
                "For Special Purpose Registers that are 32 bits long, the low-order 32",
                "bits of RT receive the contents of the Special Purpose Register and",
                "the high-order 32 bits of RT are set to zero.",
                "",
                "spr0=1 if and only if reading the register is",
                "privileged.",
                "Execution of this instruction specifying an SPR number with",
                "spr0=1 when the privilege state of the thread does",
                "not permit the access causes one of the following.",
                "",
                "",
                "",
                "Execution of this instruction specifying an SPR number that is not",
                "defined for the implementation causes one of the following.",
                "",
                "",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Move To Machine State Register",
                    "form": "X",
                    "mnemonic": "mtmsr",
                    "operands": [
                        "RS",
                        "L"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "146",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if L = 0 then",
                "  MSR<sub>48</sub> := (RS)<sub>48</sub> | (RS)<sub>49</sub>",
                "  MSR<sub>58</sub> := ((RS)<sub>58</sub> | (RS)<sub>49</sub>) & ~(MSR<sub>41</sub> & MSR<sub>3</sub> & (~(RS)<sub>49</sub>))",
                "  MSR<sub>59</sub> := ((RS)<sub>59</sub> | (RS)<sub>49</sub>) & ~(MSR<sub>41</sub> & MSR<sub>3</sub> & (~(RS)<sub>49</sub>))",
                "  MSR<sub>32:40 42:47 49:50 52:57 60:62</sub> :=(RS)<sub>32:40 42:47 49:50 52:57 60:62</sub>",
                "else",
                "  MSR<sub>48 62</sub> := (RS)<sub>48 62</sub>"
            ],
            "body": [
                "",
                "The MSR is set based on the contents of register RS and of the L",
                "field.",
                "",
                "L=0:",
                "",
                "",
                "",
                "The result of ORing bits 48 and 49 of register RS is placed into",
                "MSR48.",
                "The result of ANDing bit 41 of the MSR with bit 3 of the MSR and with",
                "the complement of bit 49 of register RS is complemented and then",
                "ANDed with the result of ORing bits 58 and 49 of register RS and",
                "placed into MSR58.",
                "The result of ANDing bit 41 of the MSR with bit 3 of the MSR and with",
                "the complement of bit 49 of register RS is complemented and then",
                "ANDed with the result of ORing bits 59 and 49 of register RS and",
                "placed into MSR59.",
                "Bits 32:40, 42:47, 49:50, 52:57, and 60:62 of register RS are placed",
                "into the corresponding bits of the MSR.",
                "",
                "",
                "L=1:",
                "",
                "",
                "",
                "Bits 48 and 62 of register RS are placed into the corresponding bits",
                "of the MSR. The remaining bits of the MSR are unchanged.",
                "",
                "",
                "This instruction is privileged.",
                "",
                "If L=0 this instruction is context synchronizing.",
                "If L=1 this instruction is execution synchronizing; in addition, the",
                "alterations of the EE and RI bits take effect as soon as the",
                "instruction completes.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Move To Machine State Register Doubleword",
                    "form": "X",
                    "mnemonic": "mtmsrd",
                    "operands": [
                        "RS",
                        "L"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "4"
                },
                {
                    "name": "L",
                    "size": "1"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "178",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if L = 0 then",
                "  MSR<sub>48</sub> := (RS)<sub>48</sub> | (RS)<sub>49</sub>",
                "  MSR<sub>58</sub> := ((RS)<sub>58</sub> | (RS)<sub>49</sub>) & ~(MSR<sub>41</sub> & MSR<sub>3</sub> & (~(RS)<sub>49</sub>))",
                "  MSR<sub>59</sub> := ((RS)<sub>59</sub> | (RS)<sub>49</sub>) & ~(MSR<sub>41</sub> & MSR<sub>3</sub> & (~(RS)<sub>49</sub>))",
                "  MSR<sub>0:2 4:40 42:47 49:50 52:57 60:62</sub> := (RS)<sub>0:2 4 6:40 42:47 49:50 52:57 60:62</sub>",
                "else",
                "  MSR<sub>48 62</sub> := (RS)<sub>48 62</sub>"
            ],
            "body": [
                "",
                "The MSR is set based on the contents of register RS and of the L",
                "field.",
                "",
                "L=0:",
                "",
                "",
                "",
                "The result of ORing bits 48 and 49 of register RS is placed into",
                "MSR48.",
                "The result of ANDing bit 41 of the MSR with bit 3 of the MSR and with",
                "the complement of bit 49 of register RS is complemented and then",
                "ANDed with the result of ORing bits 58 and 49 of register RS and",
                "placed into MSR58.",
                "The result of ANDing bit 41 of the MSR with bit 3 of the MSR and with",
                "the complement of bit 49 of register RS is complemented and then",
                "ANDed with the result of ORing bits 59 and 49 of register RS and",
                "placed into MSR59.",
                "Bits 0:2, 4:40 42:47, 49:50, 52:57, and 60:62 of register RS are",
                "placed into the corresponding bits of the MSR.",
                "",
                "",
                "L=1:",
                "",
                "",
                "",
                "Bits 48 and 62 of register RS are placed into the corresponding bits",
                "of the MSR. The remaining bits of the MSR are unchanged.",
                "",
                "",
                "This instruction is privileged.",
                "",
                "If L=0 this instruction is context synchronizing.",
                "If L=1 this instruction is execution synchronizing; in addition, the",
                "alterations of the EE and RI bits take effect as soon as the",
                "instruction completes.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Fixed-Point Facility",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Move From Machine State Register",
                    "form": "X",
                    "mnemonic": "mfmsr",
                    "operands": [
                        "RT"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "10"
                },
                {
                    "name": "83",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "RT := MSR"
            ],
            "body": [
                "",
                "The contents of the MSR are placed into register RT.",
                "",
                "This instruction is privileged.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "SLB Invalidate Entry",
                    "form": "X",
                    "mnemonic": "slbie",
                    "operands": [
                        "RB"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "10"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "434",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "ea<sub>0:35</sub> := (RB)<sub>0:35</sub>",
                "if, for SLB entry that translates or most recently translated ea,",
                "   entry_class = (RB)<sub>36 </sub>and",
                "   entry_seg_size = size specified in (RB)<sub>37:38</sub>",
                "then for SLB entry (if any) that translates ea",
                " SLBE<sub>V </sub>:= 0",
                " all other fields of SLBE := undefined",
                "else",
                "  s := log_base_2(entry_seg_size)",
                "  esid := (RB)<sub>0:63-s</sub>",
                "  u := undefined 1-bit value",
                "  if u then",
                "     if an SLB entry translates esid",
                "        SLBE<sub>V </sub>:= 0",
                "        all other fields of SLBE := undefined"
            ],
            "body": [
                "",
                "The operation performed by this instruction is based on the contents",
                "of register RB. The contents of this register are shown below.",
                "",
                "RB",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "Let the Effective Address (EA) be any EA for which",
                "EA0:35 = (RB)0:35.",
                "Let the class be (RB)36.",
                "Let the segment size be equal to the segment size specified in",
                "(RB)37:38; the allowed values of",
                "(RB)37:38, and the correspondence between the values",
                "and the segment size, are the same as for the B field in the SLBE",
                "(see Figure on",
                "pagefig:PPC3SChStorageControl-SLB-Entry).",
                "",
                "The class value and segment size must be the same as the class value",
                "and segment size in the SLB entry that translates the EA, or the",
                "values that were in the SLB entry that most recently translated the",
                "EA if the translation is no longer in the SLB; if these values are",
                "not the same, it is implementation-dependent whether the SLB entry",
                "(or implementation-dependent translation information) that translates",
                "the EA is invalidated, and the next paragraph need not apply.",
                "",
                "If the SLB contains only a single entry that translates the EA, then",
                "that is the only SLB entry that is invalidated, except that it is",
                "implementation-dependent whether an implementation-specific lookaside",
                "entry for a real mode address translation is invalidated.",
                "If the SLB contains more than one such entry, then zero or more such",
                "entries are invalidated, and similarly for any",
                "implementation-specific lookaside information used in address",
                "translation; additionally, a machine check may occur.",
                "",
                "SLB entries are invalidated by setting the V bit in the entry to 0,",
                "and the remaining fields of the entry are set to undefined values.",
                "",
                "This instruction terminates any Segment Table walks being performed",
                "on behalf of the thread that executes it.",
                "",
                "The hardware ignores the contents of RB listed below and software",
                "must set them to 0s.",
                "",
                "",
                "",
                "If this instruction is executed in 32-bit mode,",
                "(RB)0:31 must be zeros.",
                "",
                "This instruction is privileged.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "SLB Invalidate Entry Global",
                    "form": "X",
                    "mnemonic": "slbieg",
                    "operands": [
                        "RS",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "466",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "target_PID = RS<sub>0:31</sub>",
                "if MSR<sub>HV</sub>=1 then target_LPID = RS<sub>32:63</sub>",
                "else target_LPID = LPIDR",
                "ea<sub>0:35</sub> := (RB)<sub>0:35</sub>",
                "for each thread with LPIDR=target_LPID and",
                "                     PIDR=target_PID",
                " if, for each SLB entry that translates or most recently translated ea",
                "   entry_class = (RB)<sub>36</sub> and",
                "   entry_seg_size = size specified in (RB)<sub>37:38</sub>",
                " then for SLB entry (if any) that translates ea and is not software-created",
                "   SLBE<sub>V </sub>:= 0",
                "   all other fields of SLBE := undefined",
                " else",
                "    s := log_base_2(entry_seg_size)",
                "    esid := (RB)<sub>0:63-s</sub>",
                "    u := undefined 1-bit value",
                "    if u then",
                "       if an SLB entry translates esid and the entry is not software-created",
                "         SLBE<sub>V </sub>:= 0",
                "         all other fields of SLBE := undefined",
                ""
            ],
            "body": [
                "",
                "The operation performed by this instruction is based on the contents",
                "of registers RS and RB.",
                "The contents of these registers are shown below.",
                "",
                "RS",
                "",
                "",
                "",
                "",
                "RB",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "Let the target PID be RS0:31.",
                "If the instruction is executed in hypervisor state, let the target",
                "LPID be RS32:63; otherwise let the target LPID be the",
                "contents of LPIDR.",
                "Let the Effective Address (EA) be any EA for which",
                "EA0:35 = (RB)0:35.",
                "Let the class be (RB)36.",
                "Let the segment size be equal to the segment size specified in",
                "(RB)37:38; the allowed values of",
                "(RB)37:38, and the correspondence between the values",
                "and the segment size, are the same as for the B field in the SLBE",
                "(see Figure on",
                "pagefig:PPC3SChStorageControl-SLB-Entry).",
                "",
                "Only SLBs for threads running on behalf of targetLPID and",
                "targetPID are searched.",
                "Software-created entries are not invalidated.",
                "The class value and segment size must be the same as the class value",
                "and segment size in the SLB entry that translates the EA, or the",
                "values that were in the SLB entry that most recently translated the",
                "EA if the translation is no longer in the SLB; if these values are",
                "not the same, it is implementation-dependent whether the SLB entry",
                "(or implementation-dependent translation information) that translates",
                "the EA is invalidated, and the next paragraph need not apply.",
                "",
                "If the SLB contains only a single entry that translates the EA, then",
                "that is the only SLB entry that is invalidated, except that it is",
                "implementation-dependent whether an implementation-specific lookaside",
                "entry for a real mode address translation is invalidated.",
                "If the SLB contains more than one such entry, then zero or more such",
                "entries are invalidated, and similarly for any",
                "implementation-specific lookaside information used in address",
                "translation; additionally, a machine check may occur.",
                "",
                "SLB entries are invalidated by setting the V bit in the entry to 0,",
                "and the remaining fields of the entry are set to undefined values.",
                "",
                "The hardware ignores the contents of RB listed below and software",
                "must set them to 0s.",
                "",
                "",
                "",
                "If this instruction is executed in 32-bit mode,",
                "(RB)0:31 must be zeros.",
                "",
                "The operation performed by this instruction is ordered by the",
                "eieio (or [p]hwsync or ptesync)",
                "instruction with respect to a subsequent slbsync",
                "instruction executed by the thread executing the slbieg instruction.",
                "The operations caused by slbieg and",
                "slbsync are ordered by eieio",
                "as a fifth set of operations, which is independent of the other four",
                "sets that eieio orders.",
                "",
                "This instruction is privileged except when",
                "LPCRGTSE=0, making it hypervisor privileged.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "SLB Invalidate All",
                    "form": "X",
                    "mnemonic": "slbia",
                    "operands": [
                        "IH"
                    ],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "2"
                },
                {
                    "name": "IH",
                    "size": "3"
                },
                {
                    "name": "reserved",
                    "size": "10"
                },
                {
                    "name": "498",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "switch (IH)",
                " case (0b000, 0b001, 0b010, 0b110):",
                "   for each SLB entry except SLB entry 0",
                "     SLBE<sub>V</sub> := 0",
                "     all other fields of SLBE := undefined",
                " case (0b011):",
                "   for each SLB entry such that SLBE<sub>Class </sub>= 1",
                "     SLBE<sub>V</sub> := 0",
                "     all other fields of SLBE := undefined",
                " case (0b100):",
                "   for each SLB entry",
                "     SLBE<sub>V</sub> := 0",
                "     all other fields of SLBE := undefined",
                " case (0b111):"
            ],
            "body": [
                "",
                "slbia invalidates the contents of the SLB, and of",
                "implementation-specific lookaside information for effective to real",
                "address translations, based on the contents of the IH field as",
                "described below.",
                "SLB entries are invalidated by setting the V bit in the entry to 0.",
                "When an SLB entry is invalidated, the remaining fields of the entry",
                "are set to undefined values.",
                "",
                "In the description of the IH values, implementation-specific",
                "lookaside information is shorthand for implementation-specific",
                "lookaside information for effective to real address translations,",
                "and when address translation was enabled is shorthand for when",
                "MSRIR was equal to 1 or MSRDR was",
                "equal to 1, as appropriate for the type of access, and",
                "correspondingly for when address translation was disabled.  The",
                "descriptions specify which entries must be invalidated; additional",
                "entries may be invalidated except where the description states that",
                "certain SLB entries are not invalidated.",
                "",
                "",
                "",
                "All other IH values are reserved.",
                "If the IH field contains a reserved value, the set of SLB entries and",
                "implementation-specific lookaside information that is invalidated by",
                "the instruction is undefined.",
                "",
                "When IH=0b000, 0b100, or 0b111, execution of this instruction has the",
                "side effect of clearing the storage access history associated with",
                "the Hypervisor Real Mode Storage Control facility.",
                "See",
                "Section,",
                "Hypervisor Real Mode Storage Control for more details.",
                "",
                "This instruction terminates any Segment Table walks being performed",
                "on behalf of the thread that executes it, and ensures that any new",
                "table walks will be performed using the current PIDR value.",
                "",
                "This instruction is privileged.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "SLB Invalidate All Global",
                    "form": "X",
                    "mnemonic": "slbiag",
                    "operands": [
                        "RS",
                        "L"
                    ],
                    "conditions": [],
                    "release": "v3.0B"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "850",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "if L=0 then target_PID = RS<sub>0:31</sub>",
                "if MSR<sub>HV</sub>=1 then target_LPID = RS<sub>32:63</sub>",
                "else target_LPID = LPIDR",
                "for each nest SLB",
                " for each SLBE with LPID=target_LPID and (PID=target_PID | L=1)",
                "   SLBE<sub>V </sub>:= 0",
                "   all other fields of SLBE := undefined",
                ""
            ],
            "body": [
                "",
                "The operation performed by this instruction is based on the contents",
                "of register RS. The contents of this register is shown below.",
                "",
                "RS",
                "",
                "",
                "",
                "",
                "[0.5in][l]RSPID",
                "[0.5in][l]RSLPID",
                "",
                "If L=0, let the target PID be RS0:31.",
                "If the instruction is executed in hypervisor state, let the target",
                "LPID be RS32:63; otherwise let the target LPID be the",
                "contents of LPIDR.",
                "",
                "All nest SLBs are searched.",
                "If L=0, each SLBE for process PID in partition LPID is invalidated.",
                "If L=1, each SLBE for partition LPID is invalidated.",
                "",
                "SLB entries are invalidated by setting the V bit in the entry to 0,",
                "and the remaining fields of the entry are set to undefined values.",
                "",
                "All implementation specific lookaside information associated with",
                "SLB-derived translations for the target LPID || PID (L=0) or for the",
                "target LPID (L=1) is invalidated.",
                "Additional implementation specific lookaside information may be",
                "invalidated.",
                "",
                "The operation performed by this instruction is ordered by the",
                "eieio (or [p]hwsync or ptesync)",
                "instruction with respect to a subsequent slbsync",
                "instruction executed by the thread executing the slbiag instruction.",
                "The operations caused by slbiag and",
                "slbsync are ordered by eieio",
                "as a fifth set of operations, which is independent of the other four",
                "sets that eieio orders.",
                "",
                "This instruction is privileged except when",
                "LPCRGTSE=0, making it hypervisor privileged.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "SLB Move To Entry",
                    "form": "X",
                    "mnemonic": "slbmte",
                    "operands": [
                        "RS",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.00"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "402",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "When LPCRUPRT=0, this instruction is the sole means",
                "for specifying Segment translations to the hardware.",
                "When LPCRUPRT=1, Segment Table walks populate the",
                "SLB, and this instruction is used only to bolt thread-specific",
                "Segment translations.",
                "",
                "The SLB entry specified by bits 52:63 of register RB is loaded from",
                "register RS and from the remainder of register RB.",
                "The contents of these registers are interpreted as shown in",
                "Figure.",
                "",
                "",
                "",
                "On implementations that support a virtual address size of only n",
                "bits, n78, (RS)2:79-n must be zeros.",
                "",
                "When LPCRUPRT=1, the value of index must not exceed",
                "3.  (RB)52:61 are ignored.",
                "",
                "High-order bits of (RB)52:63 that correspond to SLB",
                "entries beyond the size of the SLB provided by the implementation",
                "must be zeros.",
                "",
                "The hardware ignores the contents of RS and RB listed below and",
                "software must set them to 0s.",
                "",
                "",
                "",
                "If this instruction is executed in 32-bit mode,",
                "(RB)0:31 must be zeros (i.e., the ESID must be in the",
                "range 0:15).",
                "",
                "This instruction must not be used to load a segment descriptor that",
                "is in the Segment Table when LPCRUPRT=1, and cannot",
                "be used  to invalidate the translation contained in an SLB entry.",
                "",
                "This instruction is privileged.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "SLB Move From Entry VSID",
                    "form": "X",
                    "mnemonic": "slbmfev",
                    "operands": [
                        "RT",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.00"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "851",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "This instruction is used to read software-loaded SLB entries.",
                "When LPCRUPRT=0, the entry is specified by bits 52:63",
                "of register RB.",
                "When LPCRUPRT=1, only the first four entries can be",
                "read, so bits 52:61 of register RB are ignored.",
                "If the specified entry is valid (V=1), the contents of the B, VSID,",
                "Ks, Kp, N, L, C,  and LP fields of",
                "the entry are placed into register RT.",
                "The contents of these registers are interpreted as shown in",
                "Figure.",
                "",
                "",
                "",
                "On implementations that support a virtual address size of only n",
                "bits, n78, RT2:79-n are set to zeros.",
                "",
                "If the SLB entry specified by bits 52:63 of register RB is invalid",
                "(V=0), the contents of register RT are set to 0.",
                "",
                "High-order bits of (RB)52:63 that correspond to SLB",
                "entries beyond the size of the SLB provided by the implementation",
                "must be zeros.",
                "",
                "The hardware ignores the contents of RB0:51.",
                "",
                "This instruction is privileged.",
                "",
                "The use of the L field is implementation specific.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "SLB Move From Entry ESID",
                    "form": "X",
                    "mnemonic": "slbmfee",
                    "operands": [
                        "RT",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.00"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "915",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "This instruction is used to read software-loaded SLB entries.",
                "When LPCRUPRT=0, the entry is specified by bits 52:63",
                "of register RB.",
                "When LPCRUPRT=1, only the first four entries can be",
                "read, so bits 52:61 of register RB are ignored.",
                "If the specified entry is valid (V=1), the contents of the ESID and V",
                "fields of the entry are placed into register RT.",
                "If LPCRUPRT=1, the value of the BO field of the entry",
                "is also placed into register RT.",
                "The contents of these registers are interpreted as shown in",
                "Figure.",
                "",
                "",
                "",
                "If the SLB entry specified by bits 52:63 of register RB is invalid",
                "(V=0), the contents of register RT are set to 0.",
                "",
                "High-order bits of (RB)52:63 that correspond to SLB",
                "entries beyond the size of the SLB provided by the implementation",
                "must be zeros.",
                "",
                "The hardware ignores the contents of RB0:51.",
                "",
                "This instruction is privileged.",
                "",
                "The use of the L field is implementation specific.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "SLB Find Entry ESID",
                    "form": "X",
                    "mnemonic": "slbfee.",
                    "operands": [
                        "RT",
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.05"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RT",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "5"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "1959",
                    "size": "11"
                }
            ],
            "code": [],
            "body": [
                "",
                "The SLB is searched for an entry that matches the effective address",
                "specified by register RB.",
                "When LPCRUPRT=1, this instruction is nonfunctional.",
                "The search is performed as if it were being performed for purposes of",
                "address translation.",
                "That is, in order for a given entry to satisfy the search, the entry",
                "must be valid (V=1), and (RB)0:63-s must equal",
                "SLBE[ESID0:63-s] (where 2s is the",
                "segment size selected by the B field in the entry).If exactly one",
                "matching entry is found, the contents of the B, VSID,",
                "Ks, Kp, N, L, C, and LP fields of the",
                "entry are placed into register RT.",
                "If no matching entry is found, register RT is set to 0.",
                "If more than one matching entry is found, either one of the matching",
                "entries is used, as if it were the only matching entry, or a Machine",
                "Check occurs.",
                "If a Machine Check occurs, register RT, and CR Field 0 are set to",
                "undefined values, and the description below of how this register and",
                "this field is set does not apply.",
                "",
                "The contents of registers RT and RB are interpreted as shown in",
                "Figure.",
                "",
                "",
                "",
                "If s  28, RT80-s:51 are set to zeros.",
                "On implementations that support a virtual address size of only n",
                "bits, n78, RT2:79-n are set to zeros.",
                "",
                "CR Field 0 is set as follows.",
                "j is a 1-bit value that is equal to 0b1 if a matching entry was",
                "found. Otherwise, j is 0b0.",
                "When LPCRUPRT0,  j=0b0.",
                "",
                "",
                "",
                "CR0LT GT EQ SO = 0b00 || j || XERSO",
                "",
                "",
                "The hardware ignores the contents of RB36:38 40:63.",
                "",
                "If this instruction is executed in 32-bit mode,",
                "(RB)0:31 must be zeros (i.e., the ESID must be in the",
                "range 0-15).",
                "",
                "This instruction is privileged.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "SLB Synchronize",
                    "form": "X",
                    "mnemonic": "slbsync",
                    "operands": [],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "15"
                },
                {
                    "name": "338",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The slbsync instruction provides an ordering",
                "function for the effects of all slbieg and",
                "slbiag instructions executed by the thread",
                "executing the slbsync instruction, with respect",
                "to the memory barrier created by a subsequent ptesync instruction executed by the same thread.",
                "Executing a slbsync instruction ensures that all",
                "of the following will occur.",
                "",
                "",
                "",
                "The operation performed by this instruction is ordered by the",
                "eieio (or [p]hwsync or ptesync)",
                "instruction with respect to preceding slbieg and",
                "slbiag instructions executed by the thread",
                "executing the slbsync instruction.",
                "The operations caused by slbieg or",
                "slbiag and slbsync are",
                "ordered by eieio as a fifth set of operations,",
                "which is independent of the other four sets that eieio orders.",
                "",
                "The slbsync instruction may complete before",
                "operations caused by slbieg",
                "or slbiag instructions preceding the",
                "slbsync instruction have been performed.",
                "",
                "This instruction is privileged except when",
                "LPCRGTSE=0, making it hypervisor privileged.",
                "",
                "See",
                "Section",
                "for a description of other requirements associated with the use of",
                "this instruction.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "TLB Invalidate Entry",
                    "form": "X",
                    "mnemonic": "tlbie",
                    "operands": [
                        "RB",
                        "RS",
                        "RIC",
                        "PRS",
                        "R"
                    ],
                    "conditions": [],
                    "release": "P1"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "RIC",
                    "size": "2"
                },
                {
                    "name": "PRS",
                    "size": "1"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "306",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "IS := (RB)<sub>52:53</sub>",
                "if MSR<sub>HV</sub>=1 then search_LPID=RS<sub>32:63</sub>",
                "else search_LPID=LPIDR<sub>LPID</sub>",
                "switch(IS)",
                " case (0b00):",
                "   If RIC=0",
                "     if effR=0 then",
                "       L := (RB)<sub>63</sub>",
                "       if L = 0",
                "         then inst_AVA = RB<sub>0:51</sub>",
                "         else inst_AVA = RB<sub>0:43</sub>||RB<sub>56:62</sub>||0b0",
                "",
                "       sg_size :=segment size specified in (RB)<sub>54:55</sub>",
                "       for each thread",
                "         for each TLB entry",
                "           entry_scope = number of bytes of VA space translated by TLB entry",
                "           es := log_base_2(entry_scope)",
                "           i = 63-es",
                "           if (entry_VA<sub>14:i+14</sub> = inst_AVA<sub>0:i</sub>) &",
                "              (entry_sg_size = sg_size) &",
                "              (entry_LPID = search_LPID) &",
                "              (entry_process_scoped = 0)",
                "           then TLB entry := invalid",
                "",
                "     else  # effR!=0",
                "       actual_pg_size = page size specified in (RB)<sub>56:58</sub>",
                "       p := log_base_2(actual_pg_size)",
                "       i = 63-p",
                "       for each thread",
                "         for each TLB entry",
                "           if (entry_EA<sub>0:i</sub> = (RB)<sub>0:i</sub>) &",
                "              (entry_actual_pg_size = actual_pg_size) &",
                "              (entry_LPID = search_LPID) &",
                "              (entry_process_scoped = PRS) &",
                "              ((PRS = 0) | (entry_PID = (RS)<sub>0:31</sub>))",
                "           then",
                "             TLB entry := invalid",
                "   else if RIC=3 then",
                "     sg_size := segment size specified in (RB)<sub>54:55</sub>",
                "     pg_size := f(GS)",
                "     number_of_pgs := g(GS)",
                "     p := log_base_2(pg_size)",
                "     n := log_base_2(number_of_pgs)",
                "     i := 63-p",
                "     va<sub>14:14+i</sub> := (RB)<sub>0:i-n</sub> || <sup>n</sup>0",
                "     do j=<sup>n</sup>0 to <sup>n</sup>1    # j=0 to 2<sup>n</sup>-1, in binary",
                "       for each thread",
                "         for each TLB entry",
                "           entry_scope = number of bytes of VA space translated by TLB entry",
                "           if (entry_VA<sub>14:14+i</sub> = (va<sub>14:14+i</sub>+j) &",
                "              (entry_sg_size = sg_size) &",
                "              (entry_scope = pg_size) &",
                "              (entry_LPID = search_LPID) &",
                "              (entry_process_scoped = 0)",
                "           then TLB entry := invalid",
                "",
                " case (0b01):",
                "   if RIC=0 | RIC=2 then",
                "     for each TLB entry for each thread",
                "       if (entry_LPID=search_LPID)",
                "          & (entry_PID=RS<sub>0:31</sub>)",
                "          & (entry_PRS=1)",
                "       then TLB entry := invalid",
                "   if RIC=1 | RIC=2 then",
                "     for each thread",
                "       invalidate process-scoped radix page walk caching associated",
                "       with process RS<sub>0:31</sub> in partition search_LPID",
                "   if (RIC=2) & (PRS=1) then",
                "     for each thread",
                "       invalidate Process Table caching associated with",
                "       process RS<sub>0:31</sub> in partition search_LPID",
                " case (0b10):",
                "   if RIC=0 | RIC=2 then",
                "     if (PRS=0) & ((MSR<sub>HV</sub>=1) | (effR=0)) then",
                "       for each partition-scoped TLB entry for each thread",
                "         if entry_LPID=search_LPID",
                "         then TLB entry := invalid",
                "     if PRS=1 then",
                "       for each process-scoped TLB entry for each thread",
                "         if entry_LPID=search_LPID",
                "         then TLB entry := invalid",
                "   if RIC=1 | RIC=2 then",
                "     for each thread",
                "       if (PRS=0)&(MSR<sub>HV</sub>=1) then",
                "         for each thread invalidate partition-scoped page walk caching associated with",
                "         partition search_LPID",
                "       if PRS=1 then",
                "         for each thread invalidate process-scoped page walk caching associated with",
                "         partition search_LPID",
                "   if RIC=2 then",
                "     if (PRS=0)&(MSR<sub>HV</sub>=1) then",
                "       for each thread invalidate Partition Table caching associated with",
                "       partition search_LPID",
                "     if PRS=1 then",
                "       for each thread invalidate Process Table caching associated",
                "       with partition search_LPID",
                " case (0b11):",
                "   if RIC=0 | RIC=2 then",
                "     if MSR<sub>HV</sub>=1 then",
                "       for all threads",
                "         if PRS=0 then",
                "           all partition-scoped TLB entries :=invalid",
                "         else",
                "           all process-scoped TLB entries :=invalid",
                "     if (MSR<sub>HV</sub>=0) & (PRS=1) then",
                "       for each process-scoped TLB entry for each thread",
                "         if TLBE<sub>LPID</sub>=search_LPID",
                "           then TLB entry := invalid",
                "     if (MSR<sub>HV</sub>=0) & (PRS=0) & (effR=0) then",
                "       for each partition-scoped TLB entry for each thread",
                "         if TLBE<sub>LPID</sub>=search_LPID",
                "           then TLB entry := invalid",
                "   if RIC=1 | RIC=2 then",
                "     if MSR<sub>HV</sub>=1 then",
                "       if PRS=0 then",
                "         for all threads",
                "           invalidate all partition-scoped page walk caching",
                "       else",
                "         for all threads",
                "           invalidate all process-scoped page walk caching",
                "     if (MSR<sub>HV</sub>=0) & (PRS=1) then",
                "         for each thread",
                "           invalidate process-scoped page walk caching associated with partition search_LPID",
                "   if RIC=2 then",
                "     if MSR<sub>HV</sub>=1 then",
                "       if PRS=0 then",
                "         for each thread",
                "           invalidate all Partition Table caching",
                "       else",
                "         for each thread",
                "           invalidate all Process Table caching",
                "     if (MSR<sub>HV</sub>=0) & (PRS=1) then",
                "       for each thread",
                "         invalidate Process Table caching associated with partition search_LPID"
            ],
            "body": [
                "",
                "The operation performed by this instruction is based on the contents",
                "of registers RS and RB.",
                "The contents of these registers are shown below, where IS is",
                "(RB)52:53   and L is (RB)63.",
                "",
                "RS:",
                "",
                "",
                "",
                "Programming NoteNote that although there is no PID compare for partition-scoped",
                "translation, software must still place the PID in RS when IS=0 or 1.",
                "It may be used, for example, in the TLB hash.",
                "",
                "RB for effR=1 and IS=0b00:",
                "",
                "",
                "",
                "",
                "RB for effR=0, IS=0b00, RIC3, and L=0:",
                "",
                "",
                "",
                "",
                "RB for effR=0, IS=0b00, RIC3, and L=1:",
                "",
                "",
                "",
                "",
                "RB for effR=0, IS=0b00, and RIC=3:",
                "",
                "",
                "",
                "",
                "RB for IS=0b01, 0b10, or 0b11:",
                "",
                "",
                "",
                "",
                "If this instruction is executed in hypervisor state,",
                "RS32:63 contains the searchLPID, which is the",
                "partition ID (LPID) of the partition for which one or more",
                "translations are being invalidated.",
                "Otherwise, the value in LPIDR is used as the searchLPID.",
                "The supported (RS)32:63 values are the same as the",
                "LPID values supported in LPIDR.",
                "RS0:31 contains a PID value.",
                "The supported values of RS0:31 are the same as the",
                "PID values supported in PIDR.",
                "",
                "The following forms are treated as if the instruction form were",
                "invalid.",
                "",
                "",
                "",
                "The results of an attempt to invalidate a translation outside of",
                "quadrant 0 for Radix Tree translation (effR=1, RIC=0,",
                "PRS=1,  IS=0, and EA0:10b00) are boundedly",
                "undefined.",
                "",
                "IS field in RB contains 0b00",
                "",
                "If RIC=0, this is a search for a single TLB entry.",
                "The following relationships must be true and tests and actions are",
                "performed to search for an HPT translation.",
                "",
                "",
                "",
                "Variable i is equal to 63 - log2 (scope of the TLB",
                "entry)",
                "",
                "",
                "If the base page size specified by the PTE that was used to create",
                "the TLB entry to be invalidated is 4 KB, the L field in register RB",
                "must contain 0.",
                "",
                "",
                "If the L field in RB contains 0, the base page size is 4 KB and",
                "RB56:58 (AP - Actual Page size field) must be set to",
                "the SLBEL||LP encoding for the page size",
                "corresponding to the actual page size specified by the PTE that was",
                "used to create the TLB entry to be invalidated.",
                "Thus, b is equal to 12 and p is equal to log2 (actual",
                "page size specified by (RB)56:58).",
                "The Abbreviated Virtual Address (AVA) field in register RB must",
                "contain bits 14:65 of the virtual address translated by the TLB entry",
                "to be invalidated. Variable instAVA is equal to the AVA field of RB.",
                "",
                "",
                "If the L field in RB contains 1, the following rules apply.",
                "",
                "",
                "",
                "",
                "",
                "",
                "Let the segment size be equal to the segment size specified in",
                "(RB)54:55 (B field).",
                "The contents of RB54:55 must be the same as the",
                "contents of the B field of the PTE that was used to create the TLB",
                "entry to be invalidated.",
                "",
                "",
                "RB52:53 and RB59:62 (when",
                "(RB)63 = 0) must contain zeros and are ignored by the",
                "hardware.",
                "",
                "",
                "All TLB entries on all threads that have all of the following",
                "properties are made invalid.",
                "",
                "",
                "",
                "",
                "The following relationships must be true and tests and actions are",
                "performed to search for a Radix Tree translation.",
                "For a partition-scoped invalidation, references to the effective",
                "address are understood to refer to the guest real address.",
                "",
                "",
                "",
                "The page size is encoded in RB56:58 (AP - Actual Page",
                "size field).",
                "Thus p is equal to log2( page size specified by",
                "RB56:58).",
                "The Effective Page Number (EPN) field in register RB must contain the",
                "bits 0:i of the effective address translated by the TLB entry to be",
                "invalidated.  Variable i is equal to 63-p.",
                "",
                "",
                "The fields shown as zeros must be set to zero and are ignored by the",
                "hardware.",
                "",
                "",
                "All TLB entries on all threads that have all of the following",
                "properties are made invalid.",
                "",
                "",
                "",
                "",
                "",
                "",
                "Additional TLB entries may also be made invalid if those TLB entries",
                "contain an LPID that matches searchLPID.",
                "",
                "",
                "If RIC=3, then the TLB entries mapping an aligned sequence of virtual",
                "pages are made invalid on all threads.",
                "The number of virtual pages in the sequence, and their page size",
                "(base page size = actual page size), are provided using an",
                "implementation-specific encoding of the GS field of RB.",
                "The number of virtual pages is a power of two.",
                "The abbreviated virtual address of the beginning of the sequence is",
                "provided by the AVA field of RB with the appropriate number of",
                "low-order bits treated as zero to cause the affected region of VA",
                "space to be aligned at a multiple of its size.",
                "The effect is as if a tlbie instruction with",
                "RIC=PRS=effR=0 were executed for each virtual page in the",
                "sequence, using the supplied contents of RS and RB except using the",
                "AVA value corresponding to the virtual page and using the base and",
                "actual page size provided by GS, and with the additional match",
                "criterion that the base and actual page sizes match the scope of the",
                "TLB entry.",
                "",
                "IS field in RB is non-zero",
                "",
                "If RIC=0 or RIC=2, all partition-scoped TLB entries when PRS=0 and",
                "either MSRHV=1 or effR=0, or all",
                "process-scoped TLB entries when PRS=1 on all threads for which any of",
                "the following conditions are met for the entry are made invalid.",
                "",
                "",
                "",
                "If RIC=1 or RIC=2, if the following conditions are met, the",
                "respective partition-scoped contents when PRS=0 and",
                "MSRHV=1 or process-scoped contents when PRS=1 of the",
                "page walk cache are invalidated.",
                "",
                "",
                "",
                "If RIC=2, if the following conditions are met, the respective",
                "partition and Process Table caching are invalidated for all threads.",
                "",
                "",
                "",
                "When i40, RB40:i-1 may contain any value and are",
                "ignored by the hardware.",
                "",
                "For all IS values",
                "",
                "For all threads, any implementation specific lookaside information",
                "that is based on any TLB entry that would be invalidated by this",
                "instruction will also be invalidated.",
                "",
                "Depending on the variant of the instruction, RB0:51,",
                "RB59:62, RB59:63,",
                "RB54:55, and RB54:63  are the",
                "equivalent of reserved fields, should contain 0s, and are ignored by",
                "the hardware.",
                "When the thread is in privileged non-hypervisor state,",
                "RS32:63 is the equivalent of a reserved field, should",
                "contain 0s, and is ignored by the hardware.",
                "",
                "MSRSF must be 1 when this instruction is executed;",
                "otherwise the results are undefined.",
                "",
                "If the value specified in RS0:31,",
                "RS32:63, RB54:55,",
                "RB56:58, RB44:51, or",
                "RB56:63, when it is needed to perform the specified",
                "operation,  is not supported by the implementation, the instruction",
                "is treated as if the instruction form were invalid.",
                "",
                "The operation performed by this instruction is ordered by the",
                "eieio (or [p]hwsync or ptesync)",
                "instruction with respect to a subsequent tlbsync",
                "instruction executed by the thread executing the tlbie instruction.",
                "The operations caused by tlbie and",
                "tlbsync are ordered by eieio",
                "as a fourth set of operations, which is independent of the other four",
                "sets that eieio orders.",
                "",
                "This instruction is privileged except when LPCRGTSE=0",
                "or when PRS=0 and HR=1, making it hypervisor privileged.",
                "",
                "See",
                "Section,",
                "Translation Table Update Synchronization Requirements for a",
                "description of other requirements associated with the use of this",
                "instruction.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "TLB Invalidate Entry Local",
                    "form": "X",
                    "mnemonic": "tlbiel",
                    "operands": [
                        "RB",
                        "RS",
                        "RIC",
                        "PRS",
                        "R"
                    ],
                    "conditions": [],
                    "release": "v2.03"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "RS",
                    "size": "5"
                },
                {
                    "name": "reserved",
                    "size": "1"
                },
                {
                    "name": "RIC",
                    "size": "2"
                },
                {
                    "name": "PRS",
                    "size": "1"
                },
                {
                    "name": "R",
                    "size": "1"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "274",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "IS := (RB)<sub>52:53</sub>",
                "search_LPID=LPIDR<sub>LPID</sub>",
                "switch(IS)",
                " case (0b00):",
                "   If RIC=0",
                "     If effR=0",
                "       L := (RB)<sub>63</sub>",
                "       if L = 0 then inst_AVA = RB<sub>0:51</sub>",
                "       else inst_AVA = RB<sub>0:43</sub>||RB<sub>56:62</sub>||0b0",
                "       sg_size:=segment size specified in (RB)<sub>54:55</sub>",
                "       for each TLB entry",
                "         entry_scope = number of bytes of VA space translated by TLB entry",
                "         es := log_base_2(entry_scope)",
                "         i = 63-es",
                "         if (entry_VA<sub>14:i+14</sub> = inst_AVA<sub>0:i</sub>) &",
                "            (entry_sg_size = sg_size) &",
                "            (TLBE<sub>LPID</sub>=search_LPID) &",
                "            (entry_process_scoped = 0)",
                "         then TLB entry := invalid",
                "",
                "     else  # effR!=0",
                "       pg_size = page size specified in (RB)<sub>56:58</sub>",
                "       p := log_base_2(pg_size)",
                "       i = 63-p",
                "       for each TLB entry",
                "         if (entry_EA<sub>0:i</sub> = (RB)<sub>0:i</sub>) &",
                "            (entry_pg_size = pg_size) &",
                "            (entry_LPID = search_LPID) &",
                "            (entry_process_scoped = PRS) &",
                "            ((PRS = 0) | (entry_PID = (RS)<sub>0:31</sub>))",
                "         then",
                "           TLB entry := invalid",
                "",
                " case (0b01):",
                "   if SET=0 then",
                "     if RIC=0 | RIC=2 then",
                "       for each TLB entry",
                "         if (entry_LPID=search_LPID)",
                "            & (entry_PID=RS<sub>0:31</sub>)",
                "            & (entry_PRS=1)",
                "         then TLB entry := invalid",
                "     if RIC=1 | RIC=2 then",
                "       invalidate process-scoped radix page walk caching associated with",
                "       process RS<sub>0:31</sub> in partition search_LPID",
                "     if (RIC=2)&(PRS=1) then",
                "       invalidate Process Table caching associated with",
                "       process RS<sub>0:31</sub> in partition search_LPID",
                "",
                " case (0b10):",
                "   if SET=0 then",
                "     if RIC=0 | RIC=2 then",
                "       if (PRS=0) & ((MSR<sub>HV</sub>=1) | (effR=0)) then",
                "         for each partition-scoped TLB entry",
                "           if entry_LPID = search_LPID",
                "             then TLB entry := invalid",
                "       if PRS=1 then",
                "         for each process-scoped TLB entry",
                "           if entry_LPID = search_LPID",
                "             then TLB entry := invalid",
                "     if RIC=1 | RIC=2 then",
                "       if (PRS=0) & (MSR<sub>HV</sub>=1) then",
                "         invalidate partition-scoped page walk caching associated with",
                "         partition search_LPID",
                "       if PRS=1 then",
                "         invalidate process-scoped page walk caching associated with",
                "         partition search_LPID",
                "     if RIC=2 then",
                "       if (PRS=0) & (MSR<sub>HV</sub>=1) then",
                "         invalidate Partition Table caching associated with partition search_LPID",
                "       if PRS=1 then",
                "         invalidate Process Table caching associated with partition search_LPID",
                "",
                " case (0b11):",
                "   if SET=0 then",
                "     if RIC=0 | RIC=2 then",
                "       if MSR<sub>HV</sub>=1 then",
                "         if PRS=0 then",
                "           all partition-scoped TLB entries := invalid",
                "         else",
                "           all process-scoped TLB entries := invalid",
                "       if (MSR<sub>HV</sub>=0) & (PRS=1) then",
                "         for each process-scoped TLB entry",
                "           if entry_LPID=search_LPID",
                "             then TLB entry := invalid",
                "       if (MSR<sub>HV</sub>=0) & (PRS=0) & (effR=0) then",
                "         for each partition-scoped TLB entry",
                "           if entry_LPID=search_LPID",
                "             then TLB entry := invalid",
                "     if RIC=1 | RIC=2 then",
                "       if MSR<sub>HV</sub>=1 then",
                "         if PRS=0 then",
                "           invalidate all partition-scoped page walk caching",
                "         else",
                "           invalidate all process-scoped page walk caching",
                "       if (MSR<sub>HV</sub>=0) & (PRS=1) then",
                "         invalidate process-scoped page walk caching associated with",
                "         partition search_LPID",
                "     if RIC=2 then",
                "       if MSR<sub>HV</sub>=1 then",
                "         if PRS=0 then",
                "           invalidate all Partition Table caching",
                "         else",
                "           invalidate all Process Table caching",
                "     if (MSR<sub>HV</sub>=0) & (PRS=1) then",
                "       invalidate Process Table caching associated with partition search_LPID"
            ],
            "body": [
                "",
                "The operation performed by this instruction is based on the contents",
                "of registers RS and RB.",
                "The contents of these registers are shown below, where IS is",
                "(RB)52:53 and L is (RB)63.",
                "",
                "RS:",
                "",
                "",
                "",
                "Programming NoteNote that although there is no PID compare for partition-scoped",
                "translation, software must still place the PID in RS when IS=0 or 1.",
                "It may be used, for example, in the TLB hash.",
                "",
                "RB for effR=1 and IS=0b00:",
                "",
                "",
                "",
                "",
                "RB for effR=0, IS=0b00, and L=0:",
                "",
                "",
                "",
                "",
                "RB for effR=0, IS=0b00, and L=1:",
                "",
                "",
                "",
                "",
                "RB for IS=0b01, 0b10, or 0b11:",
                "",
                "",
                "",
                "Programming NoteIn versions of the architecture that precede Version 3.1,",
                " with IS= 1, 2, or 3 invalidated",
                "appropriate entries only in a specific congruence class of the TLB,",
                "specified by SET in register RB.",
                "As a result, software was required to use a  loop to iterate through all congruence classes in order to",
                "invalidate the TLB.",
                "Software that will not be run on hardware complying with those",
                "versions should specify SET=0 in register RB.",
                "The description for  specifies SET instead",
                "of 0 in register RB to illustrate compatibility with software written",
                "to run on hardware complying with those versions.",
                "",
                "LPIDR contains the searchLPID, which is the partition ID (LPID) of",
                "the partition for which the translation is being invalidated.",
                "RS0:31 contains a PID value.",
                "The supported values of RS0:31 are the same as the",
                "PID values supported in PIDR.",
                "",
                "The following forms are invalid.",
                "",
                "",
                "",
                "The following forms are treated as though the instruction form was",
                "invalid.",
                "",
                "",
                "",
                "The results of an attempt to invalidate a translation outside of",
                "quadrant 0 for Radix Tree translation (effR=1, RIC=0,",
                "PRS=1,  IS=0, and EA0:10b00) are boundedly",
                "undefined.",
                "",
                "IS field in RB contains 0b00",
                "",
                "If RIC=0, this is a search for a single TLB entry.",
                "The following relationships must be true and tests and actions are",
                "performed to search for an HPT translation.",
                "",
                "",
                "",
                "Variable i is equal to 63 - log2 (scope of the TLB",
                "entry).",
                "",
                "",
                "If the base page size specified by the PTE that was used to create",
                "the TLB entry to be invalidated is 4 KB, the L field in register RB",
                "must contain 0.",
                "",
                "",
                "If the L field in RB contains 0, the base page size is 4 KB and",
                "RB56:58 (AP - Actual Page size field) must be set to",
                "the SLBEL||LP encoding for the page size",
                "corresponding to the actual page size specified by the PTE that was",
                "used to create the TLB entry to be invalidated.",
                "Thus, b is equal to 12 and p is equal to log2 (actual",
                "page size specified by (RB)56:58).",
                "The Abbreviated Virtual Address (AVA) field in register RB must",
                "contain bits 14:65 of the virtual address translated by the TLB entry",
                "to be invalidated. Variable instAVA is equal to the AVA field of RB.",
                "",
                "",
                "If the L field in RB contains 1, the following rules apply.",
                "",
                "",
                "",
                "",
                "",
                "",
                "Let the segment size be equal to the segment size specified in",
                "(RB)54:55 (B field).",
                "The contents of RB54:55 must be the same as the",
                "contents of the B field of the PTE that was used to create the TLB",
                "entry to be invalidated.",
                "",
                "",
                "All TLB entries that have all of the following properties are made",
                "invalid on the thread executing the tlbiel",
                "instruction.",
                "",
                "",
                "",
                "",
                "The following relationships must be true and tests and actions are",
                "performed to search for a Radix Tree translation.",
                "For a partition-scoped invalidation, references to the effective",
                "address are understood to refer to the guest real address.",
                "",
                "",
                "",
                "The page size is encoded in RB56:58 (AP - Actual Page",
                "size field).",
                "Thus p is equal to log2( page size specified by",
                "RB56:58).",
                "The Effective Page Number (EPN) field in register RB must contain the",
                "bits 0:i of the effective address translated by the TLB entry to be",
                "invalidated.  Variable i is equal to 63-p.",
                "",
                "",
                "The fields shown as zeros must be set to zero and are ignored by the",
                "hardware.",
                "",
                "",
                "All TLB entries that have all of the following properties are made",
                "invalid on the thread executing the tlbiel",
                "instruction..",
                "",
                "",
                "",
                "",
                "Additional TLB entries may also be made invalid if those TLB entries",
                "contain an LPID that matches searchLPID.",
                "",
                "IS field in RB is non-zero",
                "",
                "When SET=0 is specified and either RIC=0 or RIC=2, each",
                "partition-scoped entry when PRS=0 and either MSRHV=1",
                "or effR=0, or each process-scoped entry when PRS=1 is",
                "invalidated if any of the following conditions are met for the entry.",
                "",
                "",
                "",
                "When SET=0  is specified and either RIC=1 or RIC=2, if the following",
                "conditions are met, the respective partition-scoped contents when",
                "PRS=0 and MSRHV=1 or process-scoped contents when",
                "PRS=1 of the page walk cache are invalidated.",
                "",
                "",
                "",
                "When SET=0 is specified and RIC=2, if the following conditions are",
                "met, the respective partition and Process Table caching are",
                "invalidated.",
                "",
                "",
                "",
                "For all IS values",
                "",
                "Any implementation specific lookaside information that is based on",
                "any TLB entry that would be invalidated by this instruction will also",
                "be invalidated.",
                "",
                "Depending on the variant of the instruction, RB0:39,",
                "RB59:62, RB59:63,",
                "RB54:55, and RB54:63  are the",
                "equivalent of reserved fields, should contain 0s, and are ignored by",
                "the hardware.",
                "RS32:63 is always the equivalent of a reserved field,",
                "should contain 0s, and is ignored by the hardware.",
                "",
                "Only TLB entries, page walk caching, and Process and Partition Table",
                "caching on the thread executing the tlbiel",
                "instruction are affected.",
                "",
                "MSRSF must be 1 when this instruction is executed;",
                "otherwise the results are boundedly undefined.",
                "",
                "If the value specified in RS0:31,",
                "RB54:55, RB56:58, or",
                "RB44:51, when it is needed to perform the specified",
                "operation, is not supported by the implementation, the instruction is",
                "treated as if the instruction form were invalid.",
                "",
                "This instruction is privileged except when PRS=0 and HR=1, making it",
                "hypervisor privileged.",
                "",
                "See",
                "Section,",
                "Translation Table Update Synchronization Requirements on",
                "pagesec:PPC3SChStorageControl-Page-Table-Update-Synchronization-Requirements",
                "for a description of other requirements associated with the use of",
                "this instruction.",
                "",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Storage Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "TLB Synchronize",
                    "form": "X",
                    "mnemonic": "tlbsync",
                    "operands": [],
                    "conditions": [],
                    "release": "PPC"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "15"
                },
                {
                    "name": "566",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "The tlbsync instruction provides an ordering",
                "function for the effects of all tlbie",
                "instructions executed by the thread executing the tlbsync instruction, with respect to the memory barrier created by a",
                "subsequent ptesync instruction executed by the",
                "same thread.",
                "Executing a tlbsync instruction ensures that all",
                "of the following will occur.",
                "",
                "",
                "",
                "The operation performed by this instruction is ordered by the",
                "eieio (or [p]hwsync or ptesync)",
                "instruction with respect to preceding tlbie",
                "instructions executed by the thread executing the tlbsync instruction.",
                "The operations caused by tlbie and",
                "tlbsync are ordered by eieio",
                "as a fourth set of operations, which is independent of the other",
                "three sets that eieio orders.",
                "",
                "The tlbsync instruction may complete before",
                "operations caused by tlbie instructions preceding",
                "the tlbsync instruction have been performed.",
                "",
                "This instruction is privileged except when",
                "LPCRGTSE=0, making it hypervisor privileged.",
                "",
                "See",
                "Section",
                "for a description of other requirements associated with the use of",
                "this instruction.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Processor Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Message Send Ultravisor",
                    "form": "X",
                    "mnemonic": "msgsndu",
                    "operands": [
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0C"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "10"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "78",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "msgtype := GPR(RB)<sub>32:36</sub>",
                "payload := GPR(RB)<sub>37:63</sub>",
                "if (msgtype = 0x05)",
                "then",
                "  send_msg(msgtype, payload)"
            ],
            "body": [
                "",
                "msgsndu sends a message to other threads in the",
                "system.",
                "The message type and destination thread(s) are specified in RB.",
                "",
                "",
                "",
                "",
                "The contents of RB are defined below.",
                "Bits 37:63 are referred to as the message payload.",
                "",
                "",
                "",
                "The actions taken on receipt of a message are defined in",
                "Section.",
                "",
                "This instruction is ultravisor privileged.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Processor Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Message Clear Ultravisor",
                    "form": "X",
                    "mnemonic": "msgclru",
                    "operands": [
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v3.0C"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "10"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "110",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "t := hypervisor thread number of executing thread",
                "if (msgtype = 0x05) then",
                "       clear any Directed Ultravisor Doorbell exception for thread t"
            ],
            "body": [
                "",
                "msgclru clears a message previously accepted by",
                "the thread executing the msgclru.",
                "",
                "Let msgtype be (RB)32:36, and let t be the",
                "hypervisor thread number of the thread executing the",
                "msgclru instruction.",
                "",
                "If msgtype = 0x05, then clear any Directed Ultravisor Doorbell",
                "exception that exists on thread t; otherwise, this instruction is",
                "treated as a no-op.",
                "",
                "This instruction is ultravisor privileged.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Processor Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Message Send",
                    "form": "X",
                    "mnemonic": "msgsnd",
                    "operands": [
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "10"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "206",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "msgtype := GPR(RB)<sub>32:36</sub>",
                "payload := GPR(RB)<sub>37:63</sub>",
                "if (msgtype = 0x05)",
                "then",
                "  send_msg(msgtype, payload)"
            ],
            "body": [
                "",
                "msgsnd sends a message to other threads in the",
                "system.",
                "The message type and destination thread(s) are specified in RB.",
                "",
                "",
                "",
                "",
                "The contents of RB are defined below.",
                "Bits 37:63 are referred to as the message payload.",
                "",
                "",
                "",
                "The actions taken on receipt of a message are defined in",
                "Section.",
                "",
                "This instruction is hypervisor privileged.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Processor Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Message Clear",
                    "form": "X",
                    "mnemonic": "msgclr",
                    "operands": [
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "10"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "238",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "t := hypervisor thread number of executing thread",
                "if (msgtype = 0x05)",
                "then",
                "  clear any Directed Hypervisor Doorbell exception for thread t"
            ],
            "body": [
                "",
                "msgclr clears a message previously accepted by",
                "the thread executing the msgclr.",
                "",
                "Let msgtype be (RB)32:36, and let t be the",
                "hypervisor thread number of the thread executing the",
                "msgclr instruction.",
                "",
                "If msgtype = 0x05, then clear any Directed Hypervisor Doorbell",
                "exception that exists on thread t; otherwise, this instruction is",
                "treated as a no-op.",
                "",
                "This instruction is hypervisor privileged.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Processor Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Message Send Privileged",
                    "form": "X",
                    "mnemonic": "msgsndp",
                    "operands": [
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "10"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "142",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "msgtype := (RB)<sub>32:36</sub>",
                "payload := (RB)<sub>37:63</sub>",
                "t := (RB)<sub>57:63</sub>",
                "if msgtype = 5 and",
                "  t <=  maximum privileged thread number on processor or sub-processor",
                "then",
                "  DPDES<sub>63-t</sub> := 1",
                "  send_msg(msgtype, payload, t)"
            ],
            "body": [
                "",
                "msgsndp sends a message to other threads that are",
                "on the same multi-threaded processor (if the processor is not in",
                "sub-processor mode) or to other threads that are on the same",
                "sub-processor (if the processor is in sub-processor mode).",
                "The message type and destination thread(s) are specified in RB.",
                "",
                "",
                "",
                "",
                "The contents of RB are defined below.",
                "Bits 37:63 are referred to as the message payload.",
                "",
                "",
                "",
                "The actions taken on receipt of a message are defined in",
                "Section.",
                "",
                "This instruction is privileged.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Processor Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Message Clear Privileged",
                    "form": "X",
                    "mnemonic": "msgclrp",
                    "operands": [
                        "RB"
                    ],
                    "conditions": [],
                    "release": "v2.07"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "10"
                },
                {
                    "name": "RB",
                    "size": "5"
                },
                {
                    "name": "174",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [
                "msgtype := (RB)<sub>32:36</sub>",
                "t := privileged thread number of executing thread",
                "IF (msgtype = 0x05)",
                "then",
                "  DPDES<sub>63-t</sub> := 0"
            ],
            "body": [
                "",
                "msgclrp clears a message previously accepted by",
                "the thread executing the msgclrp.",
                "",
                "Let msgtype be (RB)32:36, and let t be the privileged",
                "thread number of the thread executing the msgclrp.",
                "",
                "If msgtype = 0x05, then clear any Directed Privileged Doorbell",
                "exception that exists on thread t by setting",
                "DPDES63-t to 0; otherwise, this instruction is",
                "treated as a no-op.",
                "",
                "This instruction is privileged.",
                ""
            ],
            "intrinsics": []
        },
        {
            "category": "Processor Control",
            "book": "III",
            "mnemonics": [
                {
                    "name": "Message Synchronize",
                    "form": "X",
                    "mnemonic": "msgsync",
                    "operands": [],
                    "conditions": [],
                    "release": "v3.0"
                }
            ],
            "layout": [
                {
                    "name": "31",
                    "size": "6"
                },
                {
                    "name": "reserved",
                    "size": "15"
                },
                {
                    "name": "886",
                    "size": "10"
                },
                {
                    "name": "reserved",
                    "size": "1"
                }
            ],
            "code": [],
            "body": [
                "",
                "In conjunction with the Synchronize and msgsndu or msgsnd instructions, the",
                "msgsync instruction provides an ordering function",
                "for stores that have been performed with respect to the thread",
                "executing the Synchronize and msgsndu",
                "or msgsnd instructions, relative to data accesses",
                "by other threads that are performed after a Directed Ultravisor",
                "Doorbell or Directed Hypervisor Doorbell interrupt has occurred, as",
                "described in the Synchronize instruction description on p.",
                "sec:PPC3SChStorageControl-Synchronize-Instruction.",
                "",
                "This instruction is hypervisor privileged.",
                ""
            ],
            "intrinsics": []
        }
    ],
    "forms": [
        "8LS:D",
        "8RR:D",
        "8RR:XX4",
        "A",
        "B",
        "D",
        "DQ",
        "DS",
        "DX",
        "I",
        "M",
        "MD",
        "MDS",
        "MLS:D",
        "MMIRR:XX3",
        "MRR:*",
        "SC",
        "VA",
        "VC",
        "VN",
        "VX",
        "X",
        "XFL",
        "XFX",
        "XL",
        "XO",
        "XS",
        "XX2",
        "XX3",
        "XX4",
        "Z22",
        "Z23"
    ],
    "chapters": [
        {
            "name": "Branch Facility",
            "chapters": []
        },
        {
            "name": "Fixed-Point Facility",
            "chapters": []
        },
        {
            "name": "Floating-Point Facility",
            "chapters": []
        },
        {
            "name": "Decimal Floating-Point",
            "chapters": []
        },
        {
            "name": "Vector Facility",
            "chapters": []
        },
        {
            "name": "Vector-Scalar Extension Facility",
            "chapters": []
        },
        {
            "name": "Storage Control Instructions",
            "chapters": []
        },
        {
            "name": "Time Base",
            "chapters": []
        },
        {
            "name": "Event-Based Branch Facility",
            "chapters": []
        },
        {
            "name": "Branch History Rolling Buffer",
            "chapters": []
        },
        {
            "name": "Storage Control",
            "chapters": []
        },
        {
            "name": "Processor Control",
            "chapters": []
        }
    ],
    "books": [
        {
            "shortname": "I",
            "title": "User Instruction Set Architecture"
        },
        {
            "shortname": "II",
            "title": "Virtual Environment Architecture"
        },
        {
            "shortname": "III",
            "title": "Operating Environment Architecture"
        }
    ],
    "intrinsics": [
        {
            "mnemonic": "vec_abs",
            "name": "Vector Absolute Value",
            "syntax": "r = vec_abs (a)",
            "purpose": "Returns a vector r that contains the\n      absolute values of the contents of the vector\n      a.",
            "result": "The value of each element of r is the\n      absolute value of the corresponding element of\n      a.  For integer vectors, the arithmetic\n      is modular.",
            "endianness": "None.",
            "instructions": [
                "vspltisw",
                "vsububm",
                "vmaxsb",
                "vsubuwm",
                "vmaxsw",
                "vsubudm",
                "vmaxsd",
                "xvabssp",
                "xvabsdp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "implementation": "vspltisw t,0\n   vsububm  t,t,a\n   vmaxsb   r,t,a"
                    },
                    {
                        "id": "1",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "implementation": "vspltisw t,0\n   vsubuhm  t,t,a\n   vmaxsh   r,t,a"
                    },
                    {
                        "id": "2",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "implementation": "vspltisw t,0\n   vsubuwm  t,t,a\n   vmaxsw   r,t,a"
                    },
                    {
                        "id": "3",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "implementation": "vspltisw t,0\n   vsubudm  t,t,a\n   vmaxsd   r,t,a"
                    },
                    {
                        "id": "4",
                        "r": "vector float",
                        "a": "vector float",
                        "implementation": "xvabssp  r,a"
                    },
                    {
                        "id": "5",
                        "r": "vector double",
                        "a": "vector double",
                        "implementation": "xvabsdp  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_absd",
            "name": "Vector Absolute Difference",
            "syntax": "r = vec_absd (a, b)",
            "purpose": "Computes the absolute difference of two vectors.",
            "result": "The value of each element of r is the\n      absolute difference of the corresponding elements of a and b, using\n      modular arithmetic.",
            "endianness": "None.",
            "instructions": [
                "vabsdub",
                "vabsduh",
                "vabsduw"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vabsdub r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vabsduh r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vabsduw r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_abss",
            "name": "Vector Absolute Value Saturated",
            "syntax": "r = vec_abss (a)",
            "purpose": "Returns a vector r that contains the\n      saturated absolute values of the contents of the vector\n      a.",
            "result": "The value of each element of r is the\n      saturated absolute value of the corresponding element of\n      a.",
            "endianness": "None.",
            "instructions": [
                "vspltisb",
                "vsubsbs",
                "vmaxsb",
                "vspltish",
                "vsubshs",
                "vmaxsh",
                "vspltisw",
                "vsubsws",
                "vmaxsw"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "implementation": "vspltisb t,0\n   vsubsbs  t,t,a\n   vmaxsb   r,t,a"
                    },
                    {
                        "id": "1",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "implementation": "vspltish t,0\n   vsubshs  t,t,a\n   vmaxsh   r,t,a"
                    },
                    {
                        "id": "2",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "implementation": "vspltisw t,0\n   vsubsws  t,t,a\n   vmaxsw   r,t,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_add",
            "name": "Vector Addition",
            "syntax": "r = vec_add (a, b)",
            "purpose": "Computes the sum of two vectors.",
            "result": "The value of each element of r is the\n      sum of the corresponding elements of a and b.  Modular\n      arithmetic is used for both signed and unsigned integers.",
            "endianness": "None.",
            "instructions": [
                "vaddubm",
                "vadduhm",
                "vadduwm",
                "vaddudm",
                "vadduqm",
                "xvaddsp",
                "xvadddp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vaddubm r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vaddubm r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vadduhm r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vadduhm r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vadduwm r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vadduwm r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vaddudm r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vaddudm r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector signed __int128",
                        "a": "vector signed __int128",
                        "b": "vector signed __int128",
                        "implementation": "vadduqm r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector unsigned __int128",
                        "a": "vector unsigned __int128",
                        "b": "vector unsigned __int128",
                        "implementation": "vadduqm r,a,b"
                    },
                    {
                        "id": "10",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvaddsp r,a,b"
                    },
                    {
                        "id": "11",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvadddp r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_addc",
            "name": "Vector Add Carrying",
            "syntax": "r = vec_addc (a, b)",
            "purpose": "Returns a vector of carries produced by adding two vectors.",
            "result": "The value of each element of r is the\n      carry produced by adding the corresponding elements of a and b (1\n      if there is a carry, 0 otherwise).",
            "endianness": "None.",
            "instructions": [
                "vaddcuw",
                "vaddcuq"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vaddcuw r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vaddcuw r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed __int128",
                        "a": "vector signed __int128",
                        "b": "vector signed __int128",
                        "implementation": "vaddcuq r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned __int128",
                        "a": "vector unsigned __int128",
                        "b": "vector unsigned __int128",
                        "implementation": "vaddcuq r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_adde",
            "name": "Vector Add Extended",
            "syntax": "r = vec_adde (a, b, c)",
            "purpose": "Returns a vector formed as the sum of two vectors and a carry vector.",
            "result": "The value of each element of r is\n      produced by adding the corresponding elements of a and b with\n      a carry specified in the corresponding element of c (1 if there is a carry, 0 otherwise).",
            "endianness": "None.",
            "instructions": [
                "vspltisw",
                "vadduwm",
                "xxland",
                "vaddeuqm"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "c": "vector signed int",
                        "implementation": "vspltisw t,1\n   vadduwm  r,a,b\n   xxland   c,c,t\n   vadduwm  r,r,c"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "c": "vector unsigned int",
                        "implementation": "vspltisw t,1\n   vadduwm  r,a,b\n   xxland   c,c,t\n   vadduwm  r,r,c"
                    },
                    {
                        "id": "2",
                        "r": "vector signed __int128",
                        "a": "vector signed __int128",
                        "b": "vector signed __int128",
                        "c": "vector signed __int128",
                        "implementation": "vaddeuqm r,a,b,c"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned __int128",
                        "a": "vector unsigned __int128",
                        "b": "vector unsigned __int128",
                        "c": "vector unsigned __int128",
                        "implementation": "vaddeuqm r,a,b,c"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_addec",
            "name": "Vector Add Extended Carrying",
            "syntax": "r = vec_addec (a, b, c)",
            "purpose": "Returns a vector of carries produced by adding two vectors and\n      a carry vector.",
            "result": "The value of each element of r is\n      the carry produced by adding the corresponding elements of a and b and\n      a carry specified in the corresponding element of c (1 if there is a carry, 0 otherwise).",
            "endianness": "None.",
            "instructions": [
                "vspltisw",
                "xxland",
                "vadduwm",
                "vaddcuw",
                "xxlor",
                "vaddecuq"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "c": "vector signed int",
                        "implementation": "vspltisw t,1\n   xxland   u,c,t\n   vadduwm  v,a,b\n   vaddcuw  w,a,b\n   vaddcuw  x,v,u\n   xxlor    r,w,x"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "c": "vector unsigned int",
                        "implementation": "vspltisw t,1\n   xxland   u,c,t\n   vadduwm  v,a,b\n   vaddcuw  w,a,b\n   vaddcuw  x,v,u\n   xxlor    r,w,x"
                    },
                    {
                        "id": "2",
                        "r": "vector signed __int128",
                        "a": "vector signed __int128",
                        "b": "vector signed __int128",
                        "c": "vector signed __int128",
                        "implementation": "vaddecuq r,a,b,c"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned __int128",
                        "a": "vector unsigned __int128",
                        "b": "vector unsigned __int128",
                        "c": "vector unsigned __int128",
                        "implementation": "vaddecuq r,a,b,c"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_adds",
            "name": "Vector Add Saturating",
            "syntax": "r = vec_adds (a, b)",
            "purpose": "Computes the saturated sum of two vectors.",
            "result": "The value of each element of r is the\n      saturated sum of the corresponding elements of a and b.",
            "endianness": "None.",
            "instructions": [
                "vaddsbs",
                "vaddubs",
                "vaddshs",
                "vadduhs",
                "vaddsws",
                "vadduws"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vaddsbs r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vaddubs r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vaddshs r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vadduhs r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vaddsws r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vadduws r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_all_eq",
            "name": "Vector All Equal",
            "syntax": "r = vec_all_eq (a, b)",
            "purpose": "Tests whether all elements of a\n      are equal to the corresponding elements of b.",
            "result": "r is 1 if each\n      element of a is equal to the\n      corresponding element of b. Otherwise,\n      r is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpequb.",
                "mfocrf",
                "rlwinm",
                "vcmpequw.",
                "vcmpequd.",
                "vcmpequh.",
                "xvcmpeqdp.",
                "xvcmpeqsp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "implementation": "vcmpequb.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpequb.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "2",
                        "r": "int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpequb.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "3",
                        "r": "int",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "implementation": "vcmpequh.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "4",
                        "r": "int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpequh.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "5",
                        "r": "int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpequh.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "6",
                        "r": "int",
                        "a": "vector pixel",
                        "b": "vector pixel",
                        "implementation": "vcmpequh.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "7",
                        "r": "int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "vcmpequw.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "8",
                        "r": "int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpequw.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "9",
                        "r": "int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpequw.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "10",
                        "r": "int",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "11",
                        "r": "int",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "12",
                        "r": "int",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "13",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpeqsp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,25,1"
                    },
                    {
                        "id": "14",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpeqdp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,25,1"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_all_ge",
            "name": "Vector All Greater or Equal",
            "syntax": "r = vec_all_ge (a, b)",
            "purpose": "Tests whether all elements of a are\n      greater than or equal to the corresponding elements of b.",
            "result": "r is 1 if\n      all elements of a are greater\n      than or equal to the corresponding elements of b.  Otherwise, r is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpgtsb.",
                "mfocrf",
                "rlwinm",
                "vcmpgtub.",
                "vcmpgtsw.",
                "vcmpgtuw.",
                "vcmpgtsd.",
                "vcmpgtud.",
                "vcmpgtsh.",
                "vcmpgtuh.",
                "xvcmpgedp.",
                "xvcmpgesp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpgtsb.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpgtub.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "2",
                        "r": "int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpgtsh.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "3",
                        "r": "int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpgtuh.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "4",
                        "r": "int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpgtsw.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "5",
                        "r": "int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpgtuw.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "6",
                        "r": "int",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpgtsd.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "7",
                        "r": "int",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpgtud.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "8",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgesp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,25,1"
                    },
                    {
                        "id": "9",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgedp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,25,1"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_all_gt",
            "name": "Vector All Greater Than",
            "syntax": "r = vec_all_gt (a, b)",
            "purpose": "Tests whether all elements of a are\n      greater than the corresponding elements of b.",
            "result": "r is 1 if\n      all elements of a are greater\n      than the corresponding elements of b.  Otherwise, r is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpgtsb.",
                "mfocrf",
                "rlwinm",
                "vcmpgtub.",
                "vcmpgtsw.",
                "vcmpgtuw.",
                "vcmpgtsd.",
                "vcmpgtud.",
                "vcmpgtsh.",
                "vcmpgtuh.",
                "xvcmpgtdp.",
                "xvcmpgtsp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpgtsb.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpgtub.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "2",
                        "r": "int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpgtsh.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "3",
                        "r": "int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpgtuh.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "4",
                        "r": "int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpgtsw.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "5",
                        "r": "int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpgtuw.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "6",
                        "r": "int",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpgtsd.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "7",
                        "r": "int",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpgtud.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "8",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgtsp. t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "9",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgtdp. t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_all_in",
            "name": "Vector All In Range",
            "syntax": "r = vec_all_in (a, b)",
            "purpose": "Tests whether all elements of a vector are within a given range.",
            "result": "r  is 1 if each\n      element of a has a value less than or\n      equal to the value of the corresponding element of b, and greater than or equal to the negative of\n      the value of the corresponding element of b. Otherwise, r\n      is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpbfp.",
                "mfocrf",
                "rlwinm"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "vcmpbfp.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,27,1"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_all_le",
            "name": "Vector All Less or Equal",
            "syntax": "r = vec_all_le (a, b)",
            "purpose": "Tests whether all elements of a are\n      less than or equal to the corresponding elements of b.",
            "result": "r is 1 if all\n      elements of a are less than or equal to\n      the corresponding elements of b.\n      Otherwise, r is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpgtsb.",
                "mfocrf",
                "rlwinm",
                "vcmpgtub.",
                "vcmpgtsw.",
                "vcmpgtuw.",
                "vcmpgtsd.",
                "vcmpgtud.",
                "vcmpgtsh.",
                "vcmpgtuh.",
                "xvcmpgedp.",
                "xvcmpgesp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpgtsb.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpgtub.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "2",
                        "r": "int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpgtsh.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "3",
                        "r": "int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpgtuh.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "4",
                        "r": "int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpgtsw.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "5",
                        "r": "int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpgtuw.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "6",
                        "r": "int",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpgtsd.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "7",
                        "r": "int",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpgtud.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "8",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgesp.  t,b,a\n  mfocrf      u,2\n  rlwinm      r,u,25,1"
                    },
                    {
                        "id": "9",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgedp.  t,b,a\n  mfocrf      u,2\n  rlwinm      r,u,25,1"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_all_lt",
            "name": "Vector All Less Than",
            "syntax": "r = vec_all_lt (a, b)",
            "purpose": "Tests whether all elements of a are\n      less than the corresponding elements of b.",
            "result": "r is 1 if all\n      elements of a are less than the\n      corresponding elements of b. Otherwise,\n      r is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpgtsb.",
                "mfocrf",
                "rlwinm",
                "vcmpgtub.",
                "vcmpgtsw.",
                "vcmpgtuw.",
                "vcmpgtsd.",
                "vcmpgtud.",
                "vcmpgtsh.",
                "vcmpgtuh.",
                "xvcmpgtdp.",
                "xvcmpgtsp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpgtsb.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpgtub.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "2",
                        "r": "int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpgtsh.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "3",
                        "r": "int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpgtuh.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "4",
                        "r": "int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpgtsw.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "5",
                        "r": "int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpgtuw.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "6",
                        "r": "int",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpgtsd.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "7",
                        "r": "int",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpgtud.  t,b,a\n  mfocrf     u,2\n  rlwinm     r,u,25,1"
                    },
                    {
                        "id": "8",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgtsp.  t,b,a\n  mfocrf      u,2\n  rlwinm      r,u,25,1"
                    },
                    {
                        "id": "9",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgtdp.  t,b,a\n  mfocrf      u,2\n  rlwinm      r,u,25,1"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_all_nan",
            "name": "Vector All Not-a-Number",
            "syntax": "r = vec_all_nan (a)",
            "purpose": "Tests whether all elements of a\n      are not-a-number (NaN).",
            "result": "r is 1 if\n      all elements of a are\n      NaN.  Otherwise, r is 0.",
            "endianness": "None.",
            "instructions": [
                "xvcmpeqdp.",
                "mfocrf",
                "rlwinm",
                "xvcmpeqsp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector float",
                        "implementation": "xvcmpeqsp.  t,a,a\n  mfocrf      u,2\n  rlwinm      r,u,27,1"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector double",
                        "implementation": "xvcmpeqdp.  t,a,a\n  mfocrf      u,2\n  rlwinm      r,u,27,1"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_all_ne",
            "name": "Vector All Not Equal",
            "syntax": "r = vec_all_ne (a, b)",
            "purpose": "Tests whether all elements of a\n      are not equal to the corresponding elements of b.",
            "result": "r is 1 if\n      all elements of a are not equal\n      to the corresponding elements of b.  Otherwise, r is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpneb.",
                "mfocrf",
                "rlwinm",
                "vcmpnew.",
                "vcmpequd.",
                "vcmpneh.",
                "xvcmpeqdp.",
                "xvcmpeqsp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "implementation": "vcmpneb.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpneb.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1"
                    },
                    {
                        "id": "2",
                        "r": "int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpneb.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1"
                    },
                    {
                        "id": "3",
                        "r": "int",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "implementation": "vcmpneh.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1"
                    },
                    {
                        "id": "4",
                        "r": "int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpneh.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1"
                    },
                    {
                        "id": "5",
                        "r": "int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpneh.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1"
                    },
                    {
                        "id": "6",
                        "r": "int",
                        "a": "vector pixel",
                        "b": "vector pixel",
                        "implementation": "vcmpneh.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1"
                    },
                    {
                        "id": "7",
                        "r": "int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "vcmpnew.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1"
                    },
                    {
                        "id": "8",
                        "r": "int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpnew.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1"
                    },
                    {
                        "id": "9",
                        "r": "int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpnew.  t,a,b\n  mfocrf    u,2\n  rlwinm    r,u,25,1"
                    },
                    {
                        "id": "10",
                        "r": "int",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "11",
                        "r": "int",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "12",
                        "r": "int",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     r,u,27,1"
                    },
                    {
                        "id": "13",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpeqsp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,27,1"
                    },
                    {
                        "id": "14",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpeqdp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,27,1"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_all_nge",
            "name": "Vector All Not Greater or Equal",
            "syntax": "r = vec_all_nge (a, b)",
            "purpose": "Tests whether all elements of a\n      are not greater than or equal to the corresponding elements of\n      b.",
            "result": "r is 1 if\n      all elements of a are not\n      greater than or equal to the corresponding elements of b. Otherwise, r is 0.",
            "endianness": "None.",
            "instructions": [
                "xvcmpeqdp.",
                "mfocrf",
                "rlwinm",
                "xvcmpeqsp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgesp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,27,1"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgedp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,27,1"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_all_ngt",
            "name": "Vector All Not Greater Than",
            "syntax": "r = vec_all_ngt (a, b)",
            "purpose": "Tests whether all elements of a\n      are not greater than the corresponding elements of b.",
            "result": "r is 1 if\n      all elements of a are not\n      greater than the corresponding elements of b.  Otherwise, r is 0.",
            "endianness": "None.",
            "instructions": [
                "xvcmpgtdp.",
                "mfocrf",
                "rlwinm",
                "xvcmpgtsp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgtsp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,27,1"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgtdp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,27,1"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_all_nle",
            "name": "Vector All Not Less or Equal",
            "syntax": "r = vec_all_nle (a, b)",
            "purpose": "Tests whether all elements of a\n      are not less than or equal to the corresponding elements of\n      b.",
            "result": "r is 1 if\n      all elements of a are not less\n      than or equal to the corresponding elements of b.  Otherwise, r is 0.",
            "endianness": "None.",
            "instructions": [
                "xvcmpgedp.",
                "mfocrf",
                "rlwinm",
                "xvcmpgesp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgesp.  t,b,a\n  mfocrf      u,2\n  rlwinm      r,u,27,1"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgedp.  t,b,a\n  mfocrf      u,2\n  rlwinm      r,u,27,1"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_all_nlt",
            "name": "Vector All Not Less Than",
            "syntax": "r = vec_all_nlt (a, b)",
            "purpose": "Tests whether all elements of a\n      are not less than the corresponding elements of b.",
            "result": "r is 1 if\n      all elements of a are not less\n      than the corresponding elements of b.  Otherwise, r is 0.",
            "endianness": "None.",
            "instructions": [
                "xvcmpgtdp.",
                "mfocrf",
                "rlwinm",
                "xvcmpgtsp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgtsp.  t,b,a\n  mfocrf      u,2\n  rlwinm      r,u,27,1"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgtdp.  t,b,a\n  mfocrf      u,2\n  rlwinm      r,u,27,1"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_all_numeric",
            "name": "Vector All Numeric",
            "syntax": "r = vec_all_numeric (a)",
            "purpose": "Tests whether all elements of the vector are numeric (not NaN).",
            "result": "r is 1 if\n      all elements of a are numeric\n      (not NaN).  Otherwise, r is\n      0.",
            "endianness": "None.",
            "instructions": [
                "xvcmpeqdp.",
                "mfocrf",
                "rlwinm",
                "xvcmpeqsp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector float",
                        "implementation": "xvcmpeqsp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,25,1"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector double",
                        "implementation": "xvcmpeqdp.  t,a,b\n  mfocrf      u,2\n  rlwinm      r,u,25,1"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_and",
            "name": "Vector AND",
            "syntax": "r = vec_and (a, b)",
            "purpose": "Performs a bitwise AND of two vectors.",
            "result": "The value of r is the bitwise AND\n      of a and b.",
            "endianness": "None.",
            "instructions": [
                "xxland"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "implementation": "xxland r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "xxland r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "xxland r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "implementation": "xxland r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "xxland r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "xxland r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "xxland r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "xxland r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "xxland r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "xxland r,a,b",
                        "Restrictions": ""
                    },
                    {
                        "id": "10",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "xxland r,a,b",
                        "Restrictions": ""
                    },
                    {
                        "id": "11",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "xxland r,a,b",
                        "Restrictions": ""
                    },
                    {
                        "id": "12",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xxland r,a,b"
                    },
                    {
                        "id": "13",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xxland r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_andc",
            "name": "Vector AND with Complement",
            "syntax": "r = vec_andc (a, b)",
            "purpose": "Performs a bitwise AND of one vector with the bitwise complement of\n      another vector.",
            "result": "The value of r is the bitwise AND\n      of a with the bitwise complement\n      of b.",
            "endianness": "None.",
            "instructions": [
                "xxlandc"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "implementation": "xxlandc r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "xxlandc r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "xxlandc r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "implementation": "xxlandc r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "xxlandc r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "xxlandc r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "xxlandc r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "xxlandc r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "xxlandc r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "xxlandc r,a,b",
                        "Restrictions": ""
                    },
                    {
                        "id": "10",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "xxlandc r,a,b",
                        "Restrictions": ""
                    },
                    {
                        "id": "11",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "xxlandc r,a,b",
                        "Restrictions": ""
                    },
                    {
                        "id": "12",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xxlandc r,a,b"
                    },
                    {
                        "id": "13",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xxlandc r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_any_eq",
            "name": "Vector Any Equal",
            "syntax": "r = vec_any_eq (a, b)",
            "purpose": "Tests whether any element of a\n      is equal to the corresponding element of b.",
            "result": "r is 1 if any\n      element of a is equal to the\n      corresponding element of b. Otherwise,\n      r is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpneb.",
                "mfocrf",
                "rlwinm",
                "cntlzw",
                "srwi",
                "vcmpnew.",
                "vcmpequd.",
                "vcmpneh.",
                "xvcmpeqdp.",
                "xvcmpeqsp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "implementation": "vcmpneb.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpneb.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5"
                    },
                    {
                        "id": "2",
                        "r": "int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpneb.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5"
                    },
                    {
                        "id": "3",
                        "r": "int",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "implementation": "vcmpneh.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5"
                    },
                    {
                        "id": "4",
                        "r": "int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpneh.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5"
                    },
                    {
                        "id": "5",
                        "r": "int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpneh.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5"
                    },
                    {
                        "id": "6",
                        "r": "int",
                        "a": "vector pixel",
                        "b": "vector pixel",
                        "implementation": "vcmpneh.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5"
                    },
                    {
                        "id": "7",
                        "r": "int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "vcmpnew.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5"
                    },
                    {
                        "id": "8",
                        "r": "int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpnew.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5"
                    },
                    {
                        "id": "9",
                        "r": "int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpnew.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,25,1\n  cntlzw    w,v\n  srwi      r,w,5"
                    },
                    {
                        "id": "10",
                        "r": "int",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "11",
                        "r": "int",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "12",
                        "r": "int",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "13",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpeqsp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    },
                    {
                        "id": "14",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpeqdp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_any_ge",
            "name": "Vector Any Greater or Equal",
            "syntax": "r = vec_any_ge (a, b)",
            "purpose": "Tests whether any element of a is\n      greater than or equal to the corresponding element of b.",
            "result": "r is 1 if any\n      element of a is greater than or equal\n      to the corresponding element of b.\n      Otherwise, r is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpgtsb.",
                "mfocrf",
                "rlwinm",
                "cntlzw",
                "srwi",
                "vcmpgtub.",
                "vcmpgtsw.",
                "vcmpgtuw.",
                "vcmpgtsd.",
                "vcmpgtud.",
                "vcmpgtsh.",
                "vcmpgtuh.",
                "xvcmpgedp.",
                "xvcmpgesp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpgtsb.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpgtub.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "2",
                        "r": "int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpgtsw.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "3",
                        "r": "int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpgtuw.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "4",
                        "r": "int",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpgtsd.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "5",
                        "r": "int",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpgtud.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "6",
                        "r": "int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpgtsh.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "7",
                        "r": "int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpgtuh.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "8",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgedp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    },
                    {
                        "id": "9",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "vcmpgesp.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_any_gt",
            "name": "Vector Any Greater Than",
            "syntax": "r = vec_any_gt (a, b)",
            "purpose": "Tests whether any element of a is\n      greater than the corresponding element of b.",
            "result": "r is 1 if any\n      element of a is greater than the\n      corresponding element of b. Otherwise,\n      r is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpgtsb.",
                "mfocrf",
                "rlwinm",
                "cntlzw",
                "srwi",
                "vcmpgtub.",
                "vcmpgtsw.",
                "vcmpgtuw.",
                "vcmpgtsd.",
                "vcmpgtud.",
                "vcmpgtsh.",
                "vcmpgtuh.",
                "xvcmpgtdp.",
                "xvcmpgtsp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpgtsb.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpgtub.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "2",
                        "r": "int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpgtsh.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "3",
                        "r": "int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpgtuh.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "4",
                        "r": "int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpgtsw.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "5",
                        "r": "int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpgtuw.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "6",
                        "r": "int",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpgtsd.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "7",
                        "r": "int",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpgtud.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "8",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgtsp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    },
                    {
                        "id": "9",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgtdp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_any_le",
            "name": "Vector Any Less or Equal",
            "syntax": "r = vec_any_le (a, b)",
            "purpose": "Tests whether any element of a is less\n      than or equal to the corresponding element of b.",
            "result": "r is 1 if any\n      element of a is less than or equal to\n      the corresponding element of b.\n      Otherwise, r is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpgtsb.",
                "mfocrf",
                "rlwinm",
                "cntlzw",
                "srwi",
                "vcmpgtub.",
                "vcmpgtsw.",
                "vcmpgtuw.",
                "vcmpgtsd.",
                "vcmpgtud.",
                "vcmpgtsh.",
                "vcmpgtuh.",
                "xvcmpgedp.",
                "xvcmpgesp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpgtsb.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpgtub.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "2",
                        "r": "int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpgtsh.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "3",
                        "r": "int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpgtuh.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "4",
                        "r": "int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpgtsw.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "5",
                        "r": "int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpgtuw.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "6",
                        "r": "int",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpgtsd.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "7",
                        "r": "int",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpgtud.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "8",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgesp.  t,b,a\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    },
                    {
                        "id": "9",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgedp.  t,b,a\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_any_lt",
            "name": "Vector Any Less Than",
            "syntax": "r = vec_any_lt (a, b)",
            "purpose": "Tests whether any element of a is less\n      than the corresponding element of b.",
            "result": "r is 1 if any\n      element of a is less than the\n      corresponding element of b. Otherwise,\n      r is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpgtsb.",
                "mfocrf",
                "rlwinm",
                "cntlzw",
                "srwi",
                "vcmpgtub.",
                "vcmpgtsw.",
                "vcmpgtuw.",
                "vcmpgtsd.",
                "vcmpgtud.",
                "vcmpgtsh.",
                "vcmpgtuh.",
                "xvcmpgtdp.",
                "xvcmpgtsp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpgtsb.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpgtub.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "2",
                        "r": "int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpgtsh.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "3",
                        "r": "int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpgtuh.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "4",
                        "r": "int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpgtsw.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "5",
                        "r": "int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpgtuw.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "6",
                        "r": "int",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpgtsd.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "7",
                        "r": "int",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpgtud.  t,b,a\n  mfocrf     u,2\n  rlwinm     v,u,27,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "8",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgtsp.  t,b,a\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    },
                    {
                        "id": "9",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgtdp.  t,b,a\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_any_nan",
            "name": "Vector Any Not-a-Number",
            "syntax": "r = vec_any_nan (a)",
            "purpose": "Tests whether any element of the source vector is a NaN.",
            "result": "r is 1 if any\n      element of a is a NaN. Otherwise,\n      r is 0.",
            "endianness": "None.",
            "instructions": [
                "xvcmpeqdp.",
                "mfocrf",
                "rlwinm",
                "cntlzw",
                "srwi",
                "xvcmpeqsp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector float",
                        "implementation": "xvcmpeqsp.  t,a,a\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector double",
                        "implementation": "xvcmpeqdp.  t,a,a\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_any_ne",
            "name": "Vector Any Not Equal",
            "syntax": "r = vec_any_ne (a, b)",
            "purpose": "Tests whether any element of a\n      is not equal to the corresponding element of b.",
            "result": "r is 1 if any\n      element of a is not equal to the\n      corresponding element of b. Otherwise,\n      r is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpequb.",
                "mfocrf",
                "rlwinm",
                "cntlzw",
                "srwi",
                "vcmpequw.",
                "vcmpequd.",
                "vcmpequh.",
                "xvcmpeqdp.",
                "xvcmpeqsp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "implementation": "vcmpequb.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpequb.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "2",
                        "r": "int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpequb.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "3",
                        "r": "int",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "implementation": "vcmpequh.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "4",
                        "r": "int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpequh.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "5",
                        "r": "int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpequh.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "6",
                        "r": "int",
                        "a": "vector pixel",
                        "b": "vector pixel",
                        "implementation": "vcmpequh.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "7",
                        "r": "int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "vcmpequw.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "8",
                        "r": "int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpequw.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "9",
                        "r": "int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpequw.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "10",
                        "r": "int",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "11",
                        "r": "int",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "12",
                        "r": "int",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpequd.  t,a,b\n  mfocrf     u,2\n  rlwinm     v,u,25,1\n  cntlzw     w,v\n  srwi       r,w,5"
                    },
                    {
                        "id": "13",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpeqsp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    },
                    {
                        "id": "14",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpeqdp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_any_nge",
            "name": "Vector Any Not Greater or Equal",
            "syntax": "r = vec_any_nge (a, b)",
            "purpose": "Tests whether any element of a is not\n      greater than or equal to the corresponding element of b.",
            "result": "r is 1 if any\n      element of a is not greater than or\n      equal to the corresponding element of b. Otherwise, r\n      is 0.",
            "endianness": "None.",
            "instructions": [
                "xvcmpgedp.",
                "mfocrf",
                "rlwinm",
                "cntlzw",
                "srwi",
                "xvcmpgesp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgesp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgedp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_any_ngt",
            "name": "Vector Any Not Greater Than",
            "syntax": "r = vec_any_ngt (a, b)",
            "purpose": "Tests whether any element of a is not\n      greater than the corresponding element of b.",
            "result": "r is 1 if any\n      element of a is not greater than the\n      corresponding element of b. Otherwise,\n      r is 0.",
            "endianness": "None.",
            "instructions": [
                "xvcmpgtdp.",
                "mfocrf",
                "rlwinm",
                "cntlzw",
                "srwi",
                "xvcmpgtsp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgtsp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgtdp.  t,a,b\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_any_nle",
            "name": "Vector Any Not Less or Equal",
            "syntax": "r = vec_any_nle (a, b)",
            "purpose": "Tests whether any element of a is not\n      less than or equal to the corresponding element of b.",
            "result": "r is 1 if any\n      element of a is not less than or equal\n      to the corresponding element of b.\n      Otherwise, r is 0.",
            "endianness": "None.",
            "instructions": [
                "xvcmpgedp.",
                "mfocrf",
                "rlwinm",
                "cntlzw",
                "srwi",
                "xvcmpgesp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgesp.  t,b,a\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgedp.  t,b,a\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_any_nlt",
            "name": "Vector Any Not Less Than",
            "syntax": "r = vec_any_nlt (a, b)",
            "purpose": "Tests whether any element of a is not\n      less than the corresponding element of b.",
            "result": "r is 1 if any\n      element of a is not less than the\n      corresponding element of b. Otherwise,\n      r is 0.",
            "endianness": "None.",
            "instructions": [
                "xvcmpgtdp.",
                "mfocrf",
                "rlwinm",
                "cntlzw",
                "srwi",
                "xvcmpgtsp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgtdp.  t,b,a\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgtdp.  t,b,a\n  mfocrf      u,2\n  rlwinm      v,u,25,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_any_numeric",
            "name": "Vector Any Numeric",
            "syntax": "r = vec_any_numeric (a)",
            "purpose": "Tests whether any element of the source vector is numeric (not a NaN).",
            "result": "r is 1 if any\n      element of a is numeric (not a NaN).\n      Otherwise, r is 0.",
            "endianness": "None.",
            "instructions": [
                "xvcmpeqdp.",
                "mfocrf",
                "rlwinm",
                "cntlzw",
                "srwi",
                "xvcmpeqsp."
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector float",
                        "implementation": "xvcmpeqsp.  t,a,a\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    },
                    {
                        "id": "1",
                        "r": "int",
                        "a": "vector double",
                        "implementation": "xvcmpeqdp.  t,a,a\n  mfocrf      u,2\n  rlwinm      v,u,27,1\n  cntlzw      w,v\n  srwi        r,w,5"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_any_out",
            "name": "Vector Any Out of Range",
            "syntax": "r = vec_any_out (a, b)",
            "purpose": "Tests whether the value of any element of a vector is outside of a\n      given range.",
            "result": "r is 1 if the\n      value of any element of a is greater\n      than the value of the corresponding element of b or less than the negative of the value of the\n      corresponding element of b. Otherwise,\n      r is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpbfp.",
                "mfocrf",
                "rlwinm",
                "cntlzw",
                "srwi"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "vcmpbfp.  t,a,b\n  mfocrf    u,2\n  rlwinm    v,u,27,1\n  cntlzw    w,v\n  srwi      r,w,5"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_avg",
            "name": "Vector Average",
            "syntax": "r = vec_avg (a, b)",
            "purpose": "Returns a vector containing the elementwise average of two vectors.",
            "result": "The value of each element of r is the\n      average of the value of the corresponding elements of a and b.",
            "endianness": "None.",
            "instructions": [
                "vavgsb",
                "vavgub",
                "vavgsh",
                "vavguh",
                "vavgsw",
                "vavguw"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vavgsb r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vavgub r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vavgsh r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vavguh r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vavgsw r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vavguw r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_bperm",
            "name": "Vector Bit Permute",
            "syntax": "r = vec_bperm (a, b)",
            "purpose": "Gathers up to 16 one-bit values from a quadword or from each\n      doubleword element in the specified order, zeroing other bits.",
            "result": "",
            "endianness": "",
            "instructions": [
                "vbpermq",
                "vbpermd"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vbpermq r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned __int128",
                        "b": "vector unsigned char",
                        "implementation": "vbpermq r,a,b",
                        "Restrictions": ""
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned char",
                        "implementation": "vbpermd r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_ceil",
            "name": "Vector Ceiling",
            "syntax": "r = vec_ceil (a)",
            "purpose": "Returns a vector r that contains the\n      result of applying the floating-point ceiling function to each\n      element of a.",
            "result": "The value of each element of r is the\n      smallest representable floating-point integral value greater than or\n      equal to the value of the corresponding element of\n      a.",
            "endianness": "None.",
            "instructions": [
                "xvrspip",
                "xvrdpip"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector float",
                        "implementation": "xvrspip  r,a"
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector double",
                        "implementation": "xvrdpip  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_cipher_be",
            "name": "Vector AES Cipher Big-Endian",
            "syntax": "r = vec_cipher_be (a, b)",
            "purpose": "Performs one round of the AES cipher operation on an intermediate state\n      array a by using a given round key\n      b.",
            "result": "r contains the\n      resulting intermediate state, after one round of the AES cipher\n      operation on intermediate state array a,\n      using the round key specified by b.",
            "endianness": "",
            "instructions": [
                "vcipher"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcipher  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_cipherlast_be",
            "name": "Vector AES Cipher Last Big-Endian",
            "syntax": "r = vec_cipherlast_be (a, b)",
            "purpose": "Performs the final round of the AES cipher operation on an intermediate\n      state array a using the specified\n      round key b.",
            "result": "r contains the\n      resulting final state, after the final round of the AES cipher\n      operation on intermediate state array a,\n      using the round key specified by b.",
            "endianness": "",
            "instructions": [
                "vcipherlast"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcipherlast  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_cmpb",
            "name": "Vector Compare Bytes",
            "syntax": "r = vec_cmpb (a, b)",
            "purpose": "Performs a bounds comparison of each set of corresponding elements\n      of two vectors.",
            "result": "",
            "endianness": "None.",
            "instructions": [
                "vcmpbfp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "vcmpbfp  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_cmpeq",
            "name": "Vector Compare Equal",
            "syntax": "r = vec_cmpeq (a, b)",
            "purpose": "Returns a vector containing the results of comparing each set of\n      corresponding elements of two vectors for equality.",
            "result": "For each element of r, the value\n      of each bit is 1 if the corresponding elements of a and b\n      are equal.  Otherwise, the value of each bit is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpequb",
                "vcmpequh",
                "vcmpequw",
                "vcmpequd",
                "xvcmpeqsp",
                "xvcmpeqdp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "implementation": "vcmpequb  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector bool char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpequb  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector bool char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpequb  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "implementation": "vcmpequh  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector bool short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpequh  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector bool short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpequh  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "vcmpequw  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector bool int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpequw  r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector bool int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpequw  r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "vcmpequd  r,a,b"
                    },
                    {
                        "id": "10",
                        "r": "vector bool long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpequd  r,a,b"
                    },
                    {
                        "id": "11",
                        "r": "vector bool long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpequd  r,a,b"
                    },
                    {
                        "id": "12",
                        "r": "vector bool int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpeqsp  r,a,b"
                    },
                    {
                        "id": "13",
                        "r": "vector bool long long",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpeqdp  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_cmpge",
            "name": "Vector Compare Greater or Equal",
            "syntax": "r = vec_cmpge (a, b)",
            "purpose": "Returns a vector containing the results of a greater-than-or-equal-to\n      comparison between each set of corresponding elements of two\n      vectors.",
            "result": "For each element of r, the value\n      of each bit is 1 if the corresponding element of a is greater than or equal to the corresponding\n      element of b.  Otherwise, the value\n      of each bit is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpgtsb",
                "xxlnor",
                "vcmpgtub",
                "vcmpgtsh",
                "vcmpgtuh",
                "vcmpgtsw",
                "vcmpgtuw",
                "vcmpgtsd",
                "vcmpgtud",
                "xvcmpgesp",
                "xvcmpgedp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpgtsb  t,b,a\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "1",
                        "r": "vector bool char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpgtub  t,b,a\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "2",
                        "r": "vector bool short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpgtsh  t,b,a\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpgtuh  t,b,a\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "4",
                        "r": "vector bool int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpgtsw  t,b,a\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "5",
                        "r": "vector bool int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpgtuw  t,b,a\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "6",
                        "r": "vector bool long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpgtsd  t,b,a\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "7",
                        "r": "vector bool long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpgtud  t,b,a\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "8",
                        "r": "vector bool int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgesp  r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector bool long long",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgedp  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_cmpgt",
            "name": "Vector Compare Greater Than",
            "syntax": "r = vec_cmpgt (a, b)",
            "purpose": "Returns a vector containing the results of a greater-than\n      comparison between each set of corresponding elements of two\n      vectors.",
            "result": "For each element of r, the value\n      of each bit is 1 if the corresponding element of a is greater than the corresponding\n      element of b.  Otherwise, the value\n      of each bit is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpgtsb",
                "vcmpgtub",
                "vcmpgtsh",
                "vcmpgtuh",
                "vcmpgtsw",
                "vcmpgtuw",
                "vcmpgtsd",
                "vcmpgtud",
                "xvcmpgtsp",
                "xvcmpgtdp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpgtsb  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector bool char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpgtub  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector bool short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpgtsh  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpgtuh  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector bool int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpgtsw  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector bool int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpgtuw  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector bool long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpgtsd  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector bool long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpgtud  r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector bool int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgtsp  r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector bool long long",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgtdp  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_cmple",
            "name": "Vector Compare Less Than or Equal",
            "syntax": "r = vec_cmple (a, b)",
            "purpose": "Returns a vector containing the results of a less-than-or-equal\n      comparison between each set of corresponding elements of two\n      vectors.",
            "result": "For each element of r, the value\n      of each bit is 1 if the corresponding element of a is less than or equal to the corresponding\n      element of b.  Otherwise, the value\n      of each bit is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpgtsb",
                "xxlnor",
                "vcmpgtub",
                "vcmpgtsh",
                "vcmpgtuh",
                "vcmpgtsw",
                "vcmpgtuw",
                "vcmpgtsd",
                "vcmpgtud",
                "xvcmpgesp",
                "xvcmpgedp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpgtsb  t,a,b\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "1",
                        "r": "vector bool char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpgtub  t,a,b\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "2",
                        "r": "vector bool short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpgtsh  t,a,b\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpgtuh  t,a,b\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "4",
                        "r": "vector bool int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpgtsw  t,a,b\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "5",
                        "r": "vector bool int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpgtuw  t,a,b\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "6",
                        "r": "vector bool long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpgtsd  t,a,b\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "7",
                        "r": "vector bool long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpgtud  t,a,b\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "8",
                        "r": "vector bool int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgesp  r,b,a"
                    },
                    {
                        "id": "9",
                        "r": "vector bool long long",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgedp  r,b,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_cmplt",
            "name": "Vector Compare Less Than",
            "syntax": "r = vec_cmplt (a, b)",
            "purpose": "Returns a vector containing the results of a less-than\n      comparison between each set of corresponding elements of two\n      vectors.",
            "result": "For each element of r, the value\n      of each bit is 1 if the corresponding element of a is less than the corresponding\n      element of b.  Otherwise, the value\n      of each bit is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpgtsb",
                "vcmpgtub",
                "vcmpgtsh",
                "vcmpgtuh",
                "vcmpgtsw",
                "vcmpgtuw",
                "vcmpgtsd",
                "vcmpgtud",
                "xvcmpgtsp",
                "xvcmpgtdp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpgtsb  r,b,a"
                    },
                    {
                        "id": "1",
                        "r": "vector bool char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpgtub  r,b,a"
                    },
                    {
                        "id": "2",
                        "r": "vector bool short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpgtsh  r,b,a"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpgtuh  r,b,a"
                    },
                    {
                        "id": "4",
                        "r": "vector bool int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpgtsw  r,b,a"
                    },
                    {
                        "id": "5",
                        "r": "vector bool int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpgtuw  r,b,a"
                    },
                    {
                        "id": "6",
                        "r": "vector bool long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpgtsd  r,b,a"
                    },
                    {
                        "id": "7",
                        "r": "vector bool long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpgtud  r,b,a"
                    },
                    {
                        "id": "8",
                        "r": "vector bool int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpgtsp  r,b,a"
                    },
                    {
                        "id": "9",
                        "r": "vector bool long long",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpgtdp  r,b,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_cmpne",
            "name": "Vector Compare Not Equal",
            "syntax": "r = vec_cmpne (a, b)",
            "purpose": "Returns a vector containing the results of comparing each set of\n      corresponding elements of two vectors for inequality.",
            "result": "For each element of r, the value\n      of each bit is 1 if the corresponding elements of a and b\n      are not equal.  Otherwise, the value of each bit is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpneb",
                "vcmpneh",
                "vcmpnew",
                "vcmpequd",
                "xxlnor",
                "xvcmpeqsp",
                "xvcmpeqdp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "implementation": "vcmpneb  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector bool char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpneb  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector bool char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpneb  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "implementation": "vcmpneh  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector bool short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpneh  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector bool short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpneh  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "vcmpnew  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector bool int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpnew  r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector bool int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpnew  r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "vcmpequd  t,a,b\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "10",
                        "r": "vector bool long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vcmpequd  t,a,b\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "11",
                        "r": "vector bool long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vcmpequd  t,a,b\n   xxlnor    r,t,t"
                    },
                    {
                        "id": "12",
                        "r": "vector bool int",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcmpeqsp  t,a,b\n   xxlnor     r,t,t"
                    },
                    {
                        "id": "13",
                        "r": "vector bool long long",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcmpeqdp  t,a,b\n   xxlnor     r,t,t"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_cmpnez",
            "name": "Vector Compare Not Equal or Zero",
            "syntax": "r = vec_cmpnez (a, b)",
            "purpose": "Returns a vector containing the results of comparing each set of\n      corresponding elements of two vectors for inequality, or for\n      an element with a zero value.",
            "result": "For each element of r, the value\n      of each bit is 1 if the corresponding elements of a and b\n      are not equal, or if the a element or\n      the b element is zero.  Otherwise,\n      the value of each bit is 0.",
            "endianness": "None.",
            "instructions": [
                "vcmpnezb",
                "vcmpnezh",
                "vcmpnezw"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpnezb  r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "vector bool char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpnezb  r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "2",
                        "r": "vector bool short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpnezh  r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpnezh  r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "4",
                        "r": "vector bool int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpnezw  r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "5",
                        "r": "vector bool int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpnezw  r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_cntlz",
            "name": "Vector Count Leading Zeros",
            "syntax": "r = vec_cntlz (a)",
            "purpose": "Returns a vector containing the number of most-significant bits\n      equal to zero of each corresponding element of the source vector.",
            "result": "The value of each element of r is\n      set to the number of leading zeros of the corresponding element\n      of a.",
            "endianness": "None.",
            "instructions": [
                "vclzb",
                "vclzh",
                "vclzw",
                "vclzd"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "implementation": "vclzb  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "implementation": "vclzb  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "implementation": "vclzh  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "implementation": "vclzh  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "implementation": "vclzw  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "implementation": "vclzw  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "implementation": "vclzd  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned int long long",
                        "implementation": "vclzd  r,a",
                        "Restrictions": ""
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_cntlz_lsbb",
            "name": "Vector Count Leading Zero Least-Significant Bits by Byte",
            "syntax": "r = vec_cntlz_lsbb (a)",
            "purpose": "Returns the number of leading byte elements (starting at the\n      lowest-numbered element) of a vector that have a least-significant\n      bit of zero.",
            "result": "The value of r is set to the\n      number of leading byte elements (starting at the lowest-numbered\n      element) of a that have a\n      least-significant bit of zero.",
            "endianness": "The element numbering within a register is left-to-right for\n      big-endian targets, and right-to-left for little-endian\n      targets.",
            "instructions": [
                "vclzlsbb"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "signed int",
                        "a": "vector signed char",
                        "implementation": "vctzlsbb  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "signed int",
                        "a": "vector unsigned char",
                        "implementation": "vctzlsbb  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_cnttz",
            "name": "Vector Count Trailing Zeros",
            "syntax": "r = vec_cnttz (a)",
            "purpose": "Returns a vector containing the number of least-significant bits\n      equal to zero of each corresponding element of the source vector.",
            "result": "The value of each element of r is\n      set to the number of trailing zeros of the corresponding element\n      of a.",
            "endianness": "None.",
            "instructions": [
                "vctzb",
                "vctzh",
                "vctzw",
                "vctzd"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "implementation": "vctzb  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "implementation": "vctzb  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "implementation": "vctzh  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "implementation": "vctzh  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "implementation": "vctzw  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "implementation": "vctzw  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "implementation": "vctzd  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned int long long",
                        "implementation": "vctzd  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_cnttz_lsbb",
            "name": "Vector Count Trailing Zero Least-Significant Bits by Byte",
            "syntax": "r = vec_cnttz_lsbb (a)",
            "purpose": "Returns the number of trailing byte elements (starting at the\n      highest-numbered element) of a vector that have a least-significant\n      bit of zero.",
            "result": "The value of r is set to the\n      number of trailing byte elements (starting at the highest-numbered\n      element) of a that have a\n      least-significant bit of zero.",
            "endianness": "The element numbering within a register is left-to-right for\n      big-endian targets, and right-to-left for little-endian\n      targets.",
            "instructions": [
                "vctzlsbb"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "signed int",
                        "a": "vector signed char",
                        "implementation": "vclzlsbb  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "signed int",
                        "a": "vector unsigned char",
                        "implementation": "vclzlsbb  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_cpsgn",
            "name": "Vector Copy Sign",
            "syntax": "r = vec_cpsgn (a, b)",
            "purpose": "Returns a vector by copying the sign of the elements in one\n      vector to the sign of the corresponding elements of another\n      vector.",
            "result": "The value of each element of r is set\n      to the corresponding element of b\n      with its sign replaced by the sign from the corresponding element of\n      a.",
            "endianness": "None.",
            "instructions": [
                "xvcpsgnsp",
                "xvcpsgndp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcpsgnsp  r,b,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvcpsgndp  r,b,a",
                        "Restrictions": ""
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_ctf",
            "name": "Vector Convert to Floating-Point",
            "syntax": "r = vec_ctf (a, b)",
            "purpose": "Converts an integer vector into a floating-point vector.",
            "result": "The value of each element of r is the\n      closest floating-point approximation of the value of the\n      corresponding element of a divided\n      by 2 to the power of b, which must\n      be in the range 0\u201331.",
            "endianness": "None.",
            "instructions": [
                "vcfsx",
                "vcfux"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector signed int",
                        "b": "5-bit unsigned literal",
                        "implementation": "vcfsx  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector float",
                        "a": "vector unsigned int",
                        "b": "5-bit unsigned literal",
                        "implementation": "vcfux  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector double",
                        "a": "vector signed long long",
                        "b": "5-bit unsigned literal",
                        "implementation": "xvcvsxddp  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector double",
                        "a": "vector unsigned long long",
                        "b": "5-bit unsigned literal",
                        "implementation": "xvcvuxddp  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_cts",
            "name": "Vector Convert to Signed Integer",
            "syntax": "r = vec_cts (a, b)",
            "purpose": "Converts a floating-point vector into a signed integer vector.",
            "result": "The value of each element of r is the\n      saturated signed-integer value, truncated towards zero, obtained by\n      multiplying the corresponding element of a multiplied by 2 to the power of b, which must be in the range 0\u201331.",
            "endianness": "None.",
            "instructions": [
                "vctsxs"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "vector float",
                        "b": "5-bit unsigned literal",
                        "implementation": "vctsxs  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_ctu",
            "name": "Vector Convert to Unsigned Integer",
            "syntax": "r = vec_ctu (a, b)",
            "purpose": "Converts a floating-point vector into an unsigned integer vector.",
            "result": "The value of each element of r is the\n      saturated unsigned-integer value, truncated towards zero, obtained by\n      multiplying the corresponding element of a multiplied by 2 to the power of b, which must be in the range 0\u201331.",
            "endianness": "None.",
            "instructions": [
                "vctuxs"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned int",
                        "a": "vector float",
                        "b": "5-bit unsigned literal",
                        "implementation": "vctuxs  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_div",
            "name": "Vector Divide",
            "syntax": "r = vec_div (a, b)",
            "purpose": "Divides the elements in one vector by the corresponding elements\n      in another vector and places the quotients in the result vector.",
            "result": "The value of each element of r is\n      obtained by dividing the corresponding element of a by the corresponding element of b.",
            "endianness": "None.",
            "instructions": [
                "xxspltd",
                "mfvsrd",
                "divd",
                "mtvsrd",
                "xxmrghd",
                "xvdivsp",
                "xvdivdp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "xxspltd t,a,1\n   mfvsrd  u,t\n   xxspltd v,b,1\n   mfvsrd  w,v\n   divd    x,u,w\n   mfvsrd  u,a\n   mtvsrd  y,x\n   mfvsrd  w,b\n   divd    x,u,w\n   mtvsrd  z,x\n   xxmrghd r,z,y"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "xxspltd t,a,1\n   mfvsrd  u,t\n   xxspltd v,b,1\n   mfvsrd  w,v\n   divd    x,u,w\n   mfvsrd  u,a\n   mtvsrd  y,x\n   mfvsrd  w,b\n   divd    x,u,w\n   mtvsrd  z,x\n   xxmrghd r,z,y"
                    },
                    {
                        "id": "2",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvdivsp r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvdivdp r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_double",
            "name": "Vector Convert to Double Precision",
            "syntax": "r = vec_double (a)",
            "purpose": "Converts a vector of long integers into a vector of double-precision\n      numbers.",
            "result": "The value of each element of r is\n      obtained by converting the corresponding element of a to double precision floating-point.",
            "endianness": "None.",
            "instructions": [
                "xvcvsxddp",
                "xvcvuxddp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector double",
                        "a": "vector signed long long",
                        "implementation": "xvcvsxddp r,a"
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector unsigned long long",
                        "implementation": "xvcvuxddp r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_doublee",
            "name": "Vector Convert Even Elements to Double Precision",
            "syntax": "r = vec_doublee (a)",
            "purpose": "Converts the even elements of a vector into a vector of double-precision\n      numbers.",
            "result": "Elements 0 and 1 of r are set to\n      the converted values of elements 0 and 2 of a.",
            "endianness": "Differences in element numbering require different implementations\n      for big- and little-endian code generation.",
            "instructions": [
                "xxsldwi",
                "xvcvsxwdp",
                "xvcvuxwdp",
                "xvcvspdp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector double",
                        "a": "vector signed int",
                        "implementation": "xvcvsxwdp  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector unsigned int",
                        "implementation": "xvcvuxwdp  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "2",
                        "r": "vector double",
                        "a": "vector float",
                        "implementation": "xvcvspdp   r,a",
                        "Restrictions": ""
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_doubleh",
            "name": "Vector Convert High Elements to Double Precision",
            "syntax": "r = vec_doubleh (a)",
            "purpose": "Converts the high-order elements of a vector into a vector\n      of double-precision numbers.",
            "result": "Elements 0 and 1 of r are set to\n      the converted values of elements 0 and 1 of a.",
            "endianness": "Differences in element numbering require different implementations\n      for big- and little-endian code generation.",
            "instructions": [
                "xxsldwi",
                "xvcvsxwdp",
                "xvcvuxwdp",
                "xvcvspdp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector double",
                        "a": "vector signed int",
                        "implementation": "xxsldwi    t,a,a,1\n   xxsldwi    u,t,a,3\n   xvcvsxwdp  r,u",
                        "Restrictions": ""
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector unsigned int",
                        "implementation": "xxsldwi    t,a,a,1\n   xxsldwi    u,t,a,3\n   xvcvuxwdp  r,u",
                        "Restrictions": ""
                    },
                    {
                        "id": "2",
                        "r": "vector double",
                        "a": "vector float",
                        "implementation": "xxsldwi    t,a,a,1\n   xxsldwi    u,t,a,3\n   xvcvspdp   r,u",
                        "Restrictions": ""
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_doublel",
            "name": "Vector Convert Low Elements to Double Precision",
            "syntax": "r = vec_doublel (a)",
            "purpose": "Converts the low-order elements of a vector into a vector\n      of double-precision numbers.",
            "result": "Elements 0 and 1 of r are set to\n      the converted values of elements 2 and 3 of a.",
            "endianness": "Differences in element numbering require different implementations\n      for big- and little-endian code generation.",
            "instructions": [
                "xxsldwi",
                "xvcvsxwdp",
                "xvcvuxwdp",
                "xvcvspdp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector double",
                        "a": "vector signed int",
                        "implementation": "xxsldwi    t,a,a,3\n   xxsldwi    u,a,t,2\n   xvcvsxwdp  r,u",
                        "Restrictions": ""
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector unsigned int",
                        "implementation": "xxsldwi    t,a,a,3\n   xxsldwi    u,a,t,2\n   xvcvuxwdp  r,u",
                        "Restrictions": ""
                    },
                    {
                        "id": "2",
                        "r": "vector double",
                        "a": "vector float",
                        "implementation": "xxsldwi    t,a,a,3\n   xxsldwi    u,a,t,2\n   xvcvspdp   r,u",
                        "Restrictions": ""
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_doubleo",
            "name": "Vector Convert Odd Elements to Double Precision",
            "syntax": "r = vec_doubleo (a)",
            "purpose": "Converts the odd elements of a vector into a vector\n      of double-precision numbers.",
            "result": "Elements 0 and 1 of r are set to\n      the converted values of elements 1 and 3 of a.",
            "endianness": "Differences in element numbering require different implementations\n      for big- and little-endian code generation.",
            "instructions": [
                "xvcvsxwdp",
                "xxsldwi",
                "xvcvuxwdp",
                "xvcvspdp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector double",
                        "a": "vector signed int",
                        "implementation": "xxsldwi    t,a,a,1\n   xvcvsxwdp  r,t",
                        "Restrictions": ""
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector unsigned int",
                        "implementation": "xxsldwi    t,a,a,1\n   xvcvuxwdp  r,t",
                        "Restrictions": ""
                    },
                    {
                        "id": "2",
                        "r": "vector double",
                        "a": "vector float",
                        "implementation": "xxsldwi    t,a,a,1\n   xvcvspdp   r,t",
                        "Restrictions": ""
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_eqv",
            "name": "Vector Equivalence",
            "syntax": "r = vec_eqv (a, b)",
            "purpose": "Performs a bitwise equivalence (exclusive NOR) of two vectors.",
            "result": "The value of r is the bitwise XNOR\n      of a and b.",
            "endianness": "None.",
            "instructions": [
                "xxleqv"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "implementation": "xxleqv r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "xxleqv r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "xxleqv r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "implementation": "xxleqv r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "xxleqv r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "xxleqv r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "xxleqv r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "xxleqv r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "xxleqv r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "xxleqv r,a,b"
                    },
                    {
                        "id": "10",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "xxleqv r,a,b"
                    },
                    {
                        "id": "11",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "xxleqv r,a,b"
                    },
                    {
                        "id": "12",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xxleqv r,a,b"
                    },
                    {
                        "id": "13",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xxleqv r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_expte",
            "name": "Vector Exponential Estimate",
            "syntax": "r = vec_expte (a)",
            "purpose": "Returns a vector r containing\n      estimates of 2 raised to the power of the corresponding elements\n      of a.",
            "result": "The value of each element of r is the\n      estimated value of 2 raised to the power of the corresponding element of\n      a.",
            "endianness": "None.",
            "instructions": [
                "vexptefp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector float",
                        "implementation": "vexptefp  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_extract",
            "name": "Vector Extract",
            "syntax": "r = vec_extract (a, b)",
            "purpose": "Returns the value of the bth\n      element of vector a.",
            "result": "The value of each element of r is the\n      element of a at position\n      b modulo the number of elements of\n      a.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vextubrx",
                "extsb",
                "vextublx",
                "slwi",
                "vextuwrx",
                "extsw",
                "vextuwlx",
                "xori",
                "rldic",
                "mtvsrdd",
                "vslo",
                "mfvsrd",
                "vextuhrx",
                "extsh",
                "vextuhlx",
                "rldicl",
                "subfic",
                "sldi",
                "xscvspdp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example ISA 3.0 LE\n  Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example ISA 3.0 BE\n  Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "signed char",
                        "a": "vector signed char",
                        "b": "signed int",
                        "implementation": "vextublx t,b,a\n extsb    r,t"
                    },
                    {
                        "id": "1",
                        "r": "unsigned char",
                        "a": "vector bool char",
                        "b": "signed int",
                        "implementation": "vextublx t,b,a"
                    },
                    {
                        "id": "2",
                        "r": "unsigned char",
                        "a": "vector unsigned char",
                        "b": "signed int",
                        "implementation": "vextublx t,b,a"
                    },
                    {
                        "id": "3",
                        "r": "signed short",
                        "a": "vector signed short",
                        "b": "signed int",
                        "implementation": "slwi     t,b,1\n vextuhlx u,t,a\n extsh    r,u"
                    },
                    {
                        "id": "4",
                        "r": "unsigned short",
                        "a": "vector bool short",
                        "b": "signed int",
                        "implementation": "slwi     t,b,1\n vextuhlx r,t,a"
                    },
                    {
                        "id": "5",
                        "r": "unsigned short",
                        "a": "vector unsigned short",
                        "b": "signed int",
                        "implementation": "slwi     t,b,1\n vextuhlx r,t,a"
                    },
                    {
                        "id": "6",
                        "r": "signed int",
                        "a": "vector signed int",
                        "b": "signed int",
                        "implementation": "slwi     t,b,2\n vextuwlx u,t,a\n extsw    r,u"
                    },
                    {
                        "id": "7",
                        "r": "unsigned int",
                        "a": "vector bool int",
                        "b": "signed int",
                        "implementation": "slwi     t,b,2\n vextuwlx r,t,a"
                    },
                    {
                        "id": "8",
                        "r": "unsigned int",
                        "a": "vector unsigned int",
                        "b": "signed int",
                        "implementation": "slwi     t,b,2\n vextuwlx r,t,a"
                    },
                    {
                        "id": "9",
                        "r": "signed long long",
                        "a": "vector signed long long",
                        "b": "signed int",
                        "implementation": "rldic   t,b,6,57\n mtvsrdd u,t,t\n vslo    v,a,u\n mfvsrd  r,v"
                    },
                    {
                        "id": "10",
                        "r": "unsigned long long",
                        "a": "vector bool long long",
                        "b": "signed int",
                        "implementation": "rldic   t,b,6,57\n mtvsrdd u,t,t\n vslo    v,a,u\n mfvsrd  r,v"
                    },
                    {
                        "id": "11",
                        "r": "unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "signed int",
                        "implementation": "rldic   t,b,6,57\n mtvsrdd u,t,t\n vslo    v,a,u\n mfvsrd  r,v"
                    },
                    {
                        "id": "12",
                        "r": "float",
                        "a": "vector float",
                        "b": "signed int",
                        "implementation": "sldi     t,b,5\n mtvsrdd  u,t,t\n vslo     v,a,u\n xscvspdp r,v"
                    },
                    {
                        "id": "13",
                        "r": "double",
                        "a": "vector double",
                        "b": "signed int",
                        "implementation": "rldic   t,b,6,57\n mtvsrdd u,t,t\n vslo    r,a,u"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_extract_exp",
            "name": "Vector Extract Exponent",
            "syntax": "r = vec_extract_exp (a)",
            "purpose": "Extracts exponents from a vector of floating-point numbers.",
            "result": "Each element of r is extracted\n      from the exponent field of the corresponding floating-point\n      vector element of a.",
            "endianness": "None.",
            "instructions": [
                "xvxexpdp",
                "xvxexpsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned int",
                        "a": "vector float",
                        "implementation": "xvxexpsp r,a",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned long long",
                        "a": "vector double",
                        "implementation": "xvxexpdp r,a",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_extract_fp32_from_shorth",
            "name": "Vector Extract Floats from High Elements of Vector Short Int",
            "syntax": "r = vec_extract_fp32_from_shorth (a)",
            "purpose": "Extracts four single-precision floating-point numbers from the high\n      elements of a vector of eight 16-bit elements, interpreting each\n      element as a 16-bit floating-point number in IEEE format.",
            "result": "The first four elements of a are\n      interpreted as 16-bit floating-point numbers in IEEE format, and\n      extended to single-precision format, returning a vector with four\n      single-precision IEEE numbers.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "lxv",
                "vperm",
                "vpermr",
                "xvcvhpsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector unsigned short",
                        "implementation": "lxv      t,0(pcv)\n  vperm[r] u,a,a,t\n  xvcvhpsp r,u",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_extract_fp32_from_shortl",
            "name": "Vector Extract Floats from Low Elements of Vector Short Int",
            "syntax": "r = vec_extract_fp32_from_shortl (a)",
            "purpose": "Extracts four single-precision floating-point numbers from the low\n      elements of a vector of eight 16-bit elements, interpreting each\n      element as a 16-bit floating-point number in IEEE format.",
            "result": "The last four elements of a are\n      interpreted as 16-bit floating-point numbers in IEEE format, and\n      extended to single-precision format, returning a vector with four\n      single-precision IEEE numbers.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "lxv",
                "vperm",
                "vpermr",
                "xvcvhpsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector unsigned short",
                        "implementation": "lxv      t,0(pcv)\n  vperm[r] u,a,a,t\n  xvcvhpsp r,u",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_extract_sig",
            "name": "Vector Extract Significand",
            "syntax": "r = vec_extract_sig (a)",
            "purpose": "Extracts a vector of significands (mantissas) from a vector of\n      floating-point numbers.",
            "result": "Each element of\n      r is extracted from the significand\n      (mantissa) field of the corresponding floating-point element of\n      a.",
            "endianness": "None.",
            "instructions": [
                "xvxsigdp",
                "xvxsigsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned int",
                        "a": "vector float",
                        "implementation": "xvxsigsp r,a",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned long long",
                        "a": "vector double",
                        "implementation": "xvxsigdp r,a",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_extract4b",
            "name": "Vector Extract Four Bytes",
            "syntax": "r = vec_extract4b (a, b)",
            "purpose": "Extracts a word from vector a at\n      constant byte position b.",
            "result": "The first\n      doubleword element of r contains\n      the zero-extended extracted word from a.\n      The second doubleword is set to 0. b\n      specifies the least-significant byte number (0\u201312) of the word\n      to be extracted.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "xxextractuw"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned char",
                        "b": "const int (range [0,12])",
                        "implementation": "xxextractuw r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_first_match_index",
            "name": "Vector Index of First Match",
            "syntax": "r = vec_first_match_index (a, b)",
            "purpose": "Performs a comparison of equality on each of the corresponding\n      elements of a and b, and returns the first position of\n      equality.",
            "result": "Returns the\n      element index of the position of the first character match in\n      natural element order.  If no match, returns the number of\n      characters as an element count in the vector argument.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vcmpneb",
                "vcmpneh",
                "vcmpnew",
                "xxlnor",
                "vctzlsbb",
                "vclzlsbb",
                "rldicl"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE\nImplementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE\nImplementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "unsigned int",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpneb  t,a,b\n  xxlnor    u,t,t\n  vclzlsbb  r,u",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "unsigned int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpneb  t,a,b\n  xxlnor    u,t,t\n  vclzlsbb  r,u",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "2",
                        "r": "unsigned int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpneh  t,a,b\n  xxlnor    u,t,t\n  vclzlsbb  v,u\n  rldicl    r,v,63,33",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "3",
                        "r": "unsigned int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpneh  t,a,b\n  xxlnor    u,t,t\n  vclzlsbb  v,u\n  rldicl    r,v,63,33",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "4",
                        "r": "unsigned int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpnew  t,a,b\n  xxlnor    u,t,t\n  vclzlsbb  v,u\n  rldicl    r,v,62,34",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "5",
                        "r": "unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpnew  t,a,b\n  xxlnor    u,t,t\n  vclzlsbb  v,u\n  rldicl    r,v,62,34",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_first_match_or_eos_index",
            "name": "Vector Index of First Match or End of String",
            "syntax": "r = vec_first_match_or_eos_index (a, b)",
            "purpose": "Performs a comparison of equality on each of the corresponding\n      elements of a and b. Returns the first position of\n      equality, or the zero string terminator.",
            "result": "Returns the\n      element index of the position, in natural element order, of\n      either the first character match or an end-of-string (EOS)\n      terminator. If no match or terminator, returns the number of\n      characters as an element count in the vector argument.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "xxspltib",
                "vcmpneb",
                "vcmpnezb",
                "vcmpneh",
                "vcmpnezh",
                "vcmpnew",
                "vcmpnezw",
                "xxland",
                "xxlnand",
                "vctzlsbb",
                "vclzlsbb",
                "rldicl"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE\nImplementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE\nImplementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "unsigned int",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "xxspltib  t,0\n vcmpneb   u,a,t\n vcmpneb   v,b,t\n vcmpnezb  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vclzlsbb  r,y",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "unsigned int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "xxspltib  t,0\n vcmpneb   u,a,t\n vcmpneb   v,b,t\n vcmpnezb  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vclzlsbb  r,y",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "2",
                        "r": "unsigned int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "xxspltib  t,0\n vcmpneh   u,a,t\n vcmpneh   v,b,t\n vcmpnezh  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vclzlsbb  z,y\n rldicl    r,z,63,33",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "3",
                        "r": "unsigned int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "xxspltib  t,0\n vcmpneh   u,a,t\n vcmpneh   v,b,t\n vcmpnezh  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vclzlsbb  z,y\n rldicl    r,z,63,33",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "4",
                        "r": "unsigned int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "xxspltib  t,0\n vcmpnew   u,a,t\n vcmpnew   v,b,t\n vcmpnezw  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vclzlsbb  z,y\n rldicl    r,z,62,34",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "5",
                        "r": "unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "xxspltib  t,0\n vcmpnew   u,a,t\n vcmpnew   v,b,t\n vcmpnezw  w,a,b\n xxland    x,u,v\n xxlnand   y,x,w\n vclzlsbb  z,y\n rldicl    r,z,62,34",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_first_mismatch_index",
            "name": "Vector Index of First Mismatch",
            "syntax": "r = vec_first_mismatch_index (a, b)",
            "purpose": "Performs a comparison of inequality on each of the corresponding\n      elements of a and b, and returns the first position of\n      inequality.",
            "result": "Returns the\n      element index of the position of the first character mismatch in\n      natural element order. If no mismatch, returns the number of\n      characters as an element count in the vector argument.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vcmpneb",
                "vcmpneh",
                "vcmpnew",
                "vctzlsbb",
                "vclzlsbb",
                "rldicl"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE\nImplementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE\nImplementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "unsigned int",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vcmpneb   t,a,b\n vclzlsbb  r,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "unsigned int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vcmpneb   t,a,b\n vclzlsbb  r,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "2",
                        "r": "unsigned int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vcmpneh   t,a,b\n vclzlsbb  u,t\n rldicl    r,u,63,33",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "3",
                        "r": "unsigned int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vcmpneh   t,a,b\n vclzlsbb  u,t\n rldicl    r,u,63,33",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "4",
                        "r": "unsigned int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vcmpnew   t,a,b\n vclzlsbb  u,t\n rldicl    r,u,62,34",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "5",
                        "r": "unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vcmpnew   t,a,b\n vclzlsbb  u,t\n rldicl    r,u,62,34",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_first_mismatch_or_eos_index",
            "name": "Vector Index of First Mismatch or End of String",
            "syntax": "r = vec_first_mismatch_or_eos_index (a, b)",
            "purpose": "Performs a comparison of inequality on each of the corresponding\n      elements of a and b. Returns the first position of\n      inequality, or the zero string terminator.",
            "result": "Returns the\n      element index of the position, in natural element order, of\n      either the first character mismatch or an end-of-string (EOS)\n      terminator. If no mismatch or terminator, returns the number of\n      characters as an element count in the vector argument.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "xxspltib",
                "vcmpneb",
                "vcmpnezb",
                "vcmpneh",
                "vcmpnezh",
                "vcmpnew",
                "vcmpnezw",
                "xxland",
                "xxlorc",
                "vctzlsbb",
                "vclzlsbb",
                "rldicl"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE\nImplementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE\nImplementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "unsigned int",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "xxspltib  t,0\n vcmpneb   u,a,t\n vcmpneb   v,b,t\n vcmpnezb  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vclzlsbb  r,y",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "unsigned int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "xxspltib  t,0\n vcmpneb   u,a,t\n vcmpneb   v,b,t\n vcmpnezb  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vclzlsbb  r,y",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "2",
                        "r": "unsigned int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "xxspltib  t,0\n vcmpneh   u,a,t\n vcmpneh   v,b,t\n vcmpnezh  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vclzlsbb  z,y\n rldicl    r,z,63,33",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "3",
                        "r": "unsigned int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "xxspltib  t,0\n vcmpneh   u,a,t\n vcmpneh   v,b,t\n vcmpnezh  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vclzlsbb  z,y\n rldicl    r,z,63,33",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "4",
                        "r": "unsigned int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "xxspltib  t,0\n vcmpnew   u,a,t\n vcmpnew   v,b,t\n vcmpnezw  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vclzlsbb  z,y\n rldicr    r,z,62,34",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "5",
                        "r": "unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "xxspltib  t,0\n vcmpnew   u,a,t\n vcmpnew   v,b,t\n vcmpnezw  w,a,b\n xxland    x,u,v\n xxlorc    y,w,x\n vclzlsbb  z,y\n rldicr    r,z,62,34",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_float",
            "name": "Vector Convert Integer to Floating-Point",
            "syntax": "r = vec_float (a)",
            "purpose": "Converts a vector of integers to a vector of single-precision\n      floating-point numbers.",
            "result": "Elements of\n      r are obtained by converting the\n      respective elements of a to\n      single-precision floating-point numbers.",
            "endianness": "None.",
            "instructions": [
                "xvcvsxwsp",
                "xvcvuxwsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector signed int",
                        "implementation": "xvcvsxwsp r,a"
                    },
                    {
                        "id": "1",
                        "r": "vector float",
                        "a": "vector unsigned int",
                        "implementation": "xvcvuxwsp r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_float2",
            "name": "Vector Convert Two Vectors to Floating-Point",
            "syntax": "r = vec_float2 (a, b)",
            "purpose": "Converts two vectors of long long integers or double-precision\n      floating-point numbers to a vector of single-precision numbers.",
            "result": "Elements of\n      r are obtained by converting the\n      elements of a and\n      b to single-precision numbers.\n      Elements 0 and 1 of r are converted\n      from elements 0 and 1 of a,\n      respectively, and elements 2 and 3 of r\n      are converted from elements 0 and 1 of b, respectively.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "xxpermdi",
                "xvcvsxdsp",
                "vmrgow",
                "vmrgew"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "xxpermdi  t,b,a,0\n xxpermdi  u,b,a,3\n xvcvsxdsp v,t\n xvcvsxdsp w,u\n vmrgew    r,v,w"
                    },
                    {
                        "id": "1",
                        "r": "vector float",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "xxpermdi  t,b,a,0\n xxpermdi  u,b,a,3\n xvcvsxdsp v,t\n xvcvsxdsp w,u\n vmrgew    r,v,w"
                    },
                    {
                        "id": "2",
                        "r": "vector float",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xxpermdi  t,b,a,0\n xxpermdi  u,b,a,3\n xvcvsxdsp v,t\n xvcvsxdsp w,u\n vmrgew    r,v,w"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_floate",
            "name": "Vector Convert to Floating-Point in Even Elements",
            "syntax": "r = vec_floate (a)",
            "purpose": "Converts the elements of a source vector to single-precision\n      floating-point and stores the results in the even elements of\n      the target vector.",
            "result": "The even-numbered\n      elements of r are obtained by\n      converting the elements of a to\n      single-precision numbers, using the current floating-point rounding\n      mode.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "xvcvsxdsp",
                "vsldoi",
                "xvcvuxdsp",
                "xvcvdpsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector signed long long",
                        "implementation": "xvcvsxdsp  t,a\n vsldoi     r,t,t,4"
                    },
                    {
                        "id": "1",
                        "r": "vector float",
                        "a": "vector unsigned long long",
                        "implementation": "xvcvuxdsp  t,a\n vsldoi     r,t,t,4"
                    },
                    {
                        "id": "2",
                        "r": "vector float",
                        "a": "vector double",
                        "implementation": "xvcvdpsp  t,a\n vsldoi    r,t,t,4"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_floato",
            "name": "Vector Convert to Floating-Point in Odd Elements",
            "syntax": "r = vec_floato (a)",
            "purpose": "Converts the elements of a source vector to single-precision\n      floating-point and stores the results in the odd elements of the\n      target vector.",
            "result": "The odd-numbered\n      elements of r are obtained by\n      converting the elements of a to\n      single-precision numbers, using the current floating-point rounding\n      mode.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "xvcvsxdsp",
                "vsldoi",
                "xvcvuxdsp",
                "xvcvdpsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector signed long long",
                        "implementation": "xvcvsxdsp r,a"
                    },
                    {
                        "id": "1",
                        "r": "vector float",
                        "a": "vector unsigned long long",
                        "implementation": "xvcvuxdsp r,a"
                    },
                    {
                        "id": "2",
                        "r": "vector float",
                        "a": "vector double",
                        "implementation": "xvcvdpsp  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_floor",
            "name": "Vector Floor",
            "syntax": "r = vec_floor (a)",
            "purpose": "Returns a vector containing the largest representable floating-point\n      integral values less than or equal to the values of the corresponding\n      elements of the source vector.",
            "result": "Each element of\n      r contains the largest representable\n      floating-point integral value less than or equal to the value of the\n      corresponding element of a.",
            "endianness": "None.",
            "instructions": [
                "xvrdpim",
                "xvrspim"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector float",
                        "implementation": "xvrspim  r,a"
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector double",
                        "implementation": "xvrdpim  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_gb",
            "name": "Vector Gather Bits by Byte",
            "syntax": "r = vec_gb (a)",
            "purpose": "Performs a gather-bits operation on the input.",
            "result": "Within each\n      doubleword, let x(i) (0 \u2264 i < 8) denote the byte elements, with\n      x(0) the most-significant byte. For each pair of i and j (0 \u2264 i\n      < 8, 0 \u2264 j < 8), the jth bit of the\n      ith byte element of\n      r is set to the value of the\n      ith bit of the jth byte\n      element of a.",
            "endianness": "None.",
            "instructions": [
                "vgbbd"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "implementation": "vgbbd  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_insert",
            "name": "Vector Insert",
            "syntax": "r = vec_insert (a, b, c)",
            "purpose": "Returns a copy of vector b  with\n      element c replaced by the value of\n      a.",
            "result": "r contains a copy of vector\n      b with element c replaced by the value of a. This function uses modular arithmetic on\n      c to determine the element number.\n      For example, if c is out of range, the\n      compiler uses c modulo the number of\n      elements in the vector to determine the element position.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "mtvsrwz",
                "vinsertb",
                "xxinsertw",
                "mtvsrd",
                "xxpermdi",
                "vinserth",
                "xscvdpspn",
                "xxextractuw"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example ISA 3.0 LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example ISA 3.0 BE Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "signed char",
                        "b": "vector signed char",
                        "c": "signed int",
                        "implementation": "mtvsrwz  t,b\n vinsertb r,t,c"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "unsigned char",
                        "b": "vector unsigned char",
                        "c": "signed int",
                        "implementation": "mtvsrwz  t,b\n vinsertb r,t,c"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "signed short",
                        "b": "vector signed short",
                        "c": "signed int",
                        "implementation": "mtvsrd   t,b\n vinserth r,t,a,c*2"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "unsigned short",
                        "b": "vector unsigned short",
                        "c": "signed int",
                        "implementation": "mtvsrd   t,b\n vinserth r,t,a,c*2"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "signed int",
                        "b": "vector signed int",
                        "c": "signed int",
                        "implementation": "mtvsrwz  t,b\n vinsertb r,t,c*4"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "unsigned int",
                        "b": "vector unsigned int",
                        "c": "signed int",
                        "implementation": "mtvsrwz  t,b\n vinsertb r,t,c*4"
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "signed long long",
                        "b": "vector signed long long",
                        "c": "signed int",
                        "implementation": "mtvsrd   t,b\n xxpermdi r,t,a,1-c"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "unsigned long long",
                        "b": "vector unsigned long long",
                        "c": "signed int",
                        "implementation": "mtvsrd   t,b\n xxpermdi r,t,a,1-c"
                    },
                    {
                        "id": "8",
                        "r": "vector float",
                        "a": "float",
                        "b": "vector float",
                        "c": "signed int",
                        "implementation": "xscvdpspn   t,a\n xxextractuw u,t,0\n xxinsertw   r/b,u,c*4"
                    },
                    {
                        "id": "9",
                        "r": "vector double",
                        "a": "double",
                        "b": "vector double",
                        "c": "signed int",
                        "implementation": "xxpermdi r,a,b,1 [c=0]\n        [or]\n xxpermdi r,b,a,1 [c=1]"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_insert_exp",
            "name": "Vector Insert Exponent",
            "syntax": "r = vec_insert_exp (a, b)",
            "purpose": "Inserts exponents into a vector of floating-point numbers.",
            "result": "Each element of\n      r is generated by combining the exponent\n      specified by the corresponding element of b with the sign and significand of the\n      corresponding element of a.",
            "endianness": "None.",
            "instructions": [
                "xviexpdp",
                "xviexpsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "xviexpsp  r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector unsigned int",
                        "implementation": "xviexpsp  r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "2",
                        "r": "vector double",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "xviexpdp  r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "3",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector unsigned long long",
                        "implementation": "xviexpdp  r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_insert4b",
            "name": "Vector Insert Four Bytes",
            "syntax": "r = vec_insert4b (a, b, c)",
            "purpose": "Inserts a word into a vector at a byte position.",
            "result": "Let W be the first\n      doubleword element of a, truncated to\n      32 bits. The result vector r is formed\n      by inserting W into b at the byte\n      position (0\u201312) specified by c.",
            "endianness": "The element and byte numbering within a register is left-to-right for\n      big-endian targets, and right-to-left for little-endian targets.",
            "instructions": [
                "xxpermdi",
                "xxinsertw"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned char",
                        "a": "vector signed int",
                        "b": "vector unsigned char",
                        "c": "const int (range [0,12])",
                        "implementation": "xxinsertw b,t,c",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned int",
                        "b": "vector unsigned char",
                        "c": "const int (range [0,12])",
                        "implementation": "xxinsertw b,t,c",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_ld",
            "name": "Vector Load Indexed",
            "syntax": "r = vec_ld (a, b)",
            "purpose": "Loads a 16-byte vector from the memory address specified by the\n      displacement and the pointer, ignoring the four low-order bits\n      of the calculated address.",
            "result": "The value of\n      r is obtained by adding a and b,\n      masking off the four low-order bits of the result, and\n      loading the 16-byte vector from the resultant memory address.",
            "endianness": "None.",
            "instructions": [
                "lvx"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example ISA 3.0\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "signed long long",
                        "b": "const vector bool char *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "signed long long",
                        "b": "const signed char *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "2",
                        "r": "vector signed char",
                        "a": "signed long long",
                        "b": "const vector signed char *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned char",
                        "a": "signed long long",
                        "b": "const unsigned char *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "4",
                        "r": "vector unsigned char",
                        "a": "signed long long",
                        "b": "const vector unsigned char *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "5",
                        "r": "vector bool short",
                        "a": "signed long long",
                        "b": "const vector bool short *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "6",
                        "r": "vector signed short",
                        "a": "signed long long",
                        "b": "const signed short *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "7",
                        "r": "vector signed short",
                        "a": "signed long long",
                        "b": "const vector signed short *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "8",
                        "r": "vector unsigned short",
                        "a": "signed long long",
                        "b": "const unsigned short *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "9",
                        "r": "vector unsigned short",
                        "a": "signed long long",
                        "b": "const vector unsigned short *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "10",
                        "r": "vector pixel",
                        "a": "signed long long",
                        "b": "const vector pixel *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "11",
                        "r": "vector bool int",
                        "a": "signed long long",
                        "b": "const vector bool int *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "12",
                        "r": "vector signed int",
                        "a": "signed long long",
                        "b": "const signed int *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "13",
                        "r": "vector signed int",
                        "a": "signed long long",
                        "b": "const vector signed int *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "14",
                        "r": "vector unsigned int",
                        "a": "signed long long",
                        "b": "const unsigned int *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "15",
                        "r": "vector unsigned int",
                        "a": "signed long long",
                        "b": "const vector unsigned int *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "16",
                        "r": "vector bool long long",
                        "a": "signed long long",
                        "b": "const vector bool long long *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "17",
                        "r": "vector signed long long",
                        "a": "signed long long",
                        "b": "const signed long long *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "18",
                        "r": "vector signed long long",
                        "a": "signed long long",
                        "b": "const vector signed long long *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "19",
                        "r": "vector unsigned long long",
                        "a": "signed long long",
                        "b": "const unsigned long long *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "20",
                        "r": "vector unsigned long long",
                        "a": "signed long long",
                        "b": "const vector unsigned long long *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "21",
                        "r": "vector signed __int128",
                        "a": "signed long long",
                        "b": "const signed __int128 *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "22",
                        "r": "vector signed __int128",
                        "a": "signed long long",
                        "b": "const vector signed __int128 *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "23",
                        "r": "vector unsigned __int128",
                        "a": "signed long long",
                        "b": "const unsigned __int128 *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "24",
                        "r": "vector unsigned __int128",
                        "a": "signed long long",
                        "b": "const vector unsigned __int128 *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "25",
                        "r": "vector float",
                        "a": "signed long long",
                        "b": "const float *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "26",
                        "r": "vector float",
                        "a": "signed long long",
                        "b": "const vector float *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "27",
                        "r": "vector double",
                        "a": "signed long long",
                        "b": "const double *",
                        "implementation": "lvx  r,b,a"
                    },
                    {
                        "id": "28",
                        "r": "vector double",
                        "a": "signed long long",
                        "b": "const vector double *",
                        "implementation": "lvx  r,b,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_lde",
            "name": "Vector Load Element Indexed",
            "syntax": "r = vec_lde (a, b)",
            "purpose": "Loads a single element into the position in the vector register\n      corresponding to its address, leaving the remaining elements of\n      the register undefined.",
            "result": "The integer value a is added to the\n      pointer value b.  The resulting\n      address is rounded down to the nearest address that is a multiple of\n      es, where es is 1 for\n      char pointers, 2 for short pointers, and 4 for float or int pointers.\n      The element at this address is loaded into an element of r, leaving all other elements of r undefined.  The position of the loaded\n      element in r is determined by taking the\n      address modulo 16.",
            "endianness": "None.",
            "instructions": [
                "lvebx",
                "lvewx",
                "lvehx"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example ISA 3.0\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "signed long long",
                        "b": "const signed char *",
                        "implementation": "lvebx  r,b,a"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "signed long long",
                        "b": "const unsigned char *",
                        "implementation": "lvebx  r,b,a"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "signed long long",
                        "b": "const signed short *",
                        "implementation": "lvehx  r,b,a"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "signed long long",
                        "b": "const unsigned short *",
                        "implementation": "lvehx  r,b,a"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "signed long long",
                        "b": "const signed int *",
                        "implementation": "lvewx  r,b,a"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "signed long long",
                        "b": "const unsigned int *",
                        "implementation": "lvewx  r,b,a"
                    },
                    {
                        "id": "6",
                        "r": "vector float",
                        "a": "signed long long",
                        "b": "const float *",
                        "implementation": "lvewx  r,b,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_ldl",
            "name": "Vector Load Indexed Least Recently Used",
            "syntax": "r = vec_ldl (a, b)",
            "purpose": "Loads a 16-byte vector from the memory address specified by the\n      displacement and the pointer, ignoring the four low-order bits\n      of the calculated address, and marks the cache line loaded from\n      as least recently used.",
            "result": "The value of\n      r is obtained by adding a and b,\n      masking off the four low-order bits of the result, and\n      loading the 16-byte vector from the resultant memory address.",
            "endianness": "None.",
            "instructions": [
                "lvxl"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example ISA 3.0\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "signed long long",
                        "b": "const vector bool char *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "signed long long",
                        "b": "const signed char *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "2",
                        "r": "vector signed char",
                        "a": "signed long long",
                        "b": "const vector signed char *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned char",
                        "a": "signed long long",
                        "b": "const unsigned char *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "4",
                        "r": "vector unsigned char",
                        "a": "signed long long",
                        "b": "const vector unsigned char *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "5",
                        "r": "vector bool short",
                        "a": "signed long long",
                        "b": "const vector bool short *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "6",
                        "r": "vector signed short",
                        "a": "signed long long",
                        "b": "const signed short *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "7",
                        "r": "vector signed short",
                        "a": "signed long long",
                        "b": "const vector signed short *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "8",
                        "r": "vector unsigned short",
                        "a": "signed long long",
                        "b": "const unsigned short *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "9",
                        "r": "vector unsigned short",
                        "a": "signed long long",
                        "b": "const vector unsigned short *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "10",
                        "r": "vector pixel",
                        "a": "signed long long",
                        "b": "const vector pixel *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "11",
                        "r": "vector bool int",
                        "a": "signed long long",
                        "b": "const vector bool int *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "12",
                        "r": "vector signed int",
                        "a": "signed long long",
                        "b": "const signed int *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "13",
                        "r": "vector signed int",
                        "a": "signed long long",
                        "b": "const vector signed int *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "14",
                        "r": "vector unsigned int",
                        "a": "signed long long",
                        "b": "const unsigned int *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "15",
                        "r": "vector unsigned int",
                        "a": "signed long long",
                        "b": "const vector unsigned int *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "16",
                        "r": "vector bool long long",
                        "a": "signed long long",
                        "b": "const vector bool long long *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "17",
                        "r": "vector signed long long",
                        "a": "signed long long",
                        "b": "const signed long long *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "18",
                        "r": "vector signed long long",
                        "a": "signed long long",
                        "b": "const vector signed long long *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "19",
                        "r": "vector unsigned long long",
                        "a": "signed long long",
                        "b": "const unsigned long long *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "20",
                        "r": "vector unsigned long long",
                        "a": "signed long long",
                        "b": "const vector unsigned long long *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "21",
                        "r": "vector float",
                        "a": "signed long long",
                        "b": "const float *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "22",
                        "r": "vector float",
                        "a": "signed long long",
                        "b": "const vector float *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "23",
                        "r": "vector double",
                        "a": "signed long long",
                        "b": "const double *",
                        "implementation": "lvxl  r,b,a"
                    },
                    {
                        "id": "24",
                        "r": "vector double",
                        "a": "signed long long",
                        "b": "const vector double *",
                        "implementation": "lvxl  r,b,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_loge",
            "name": "Vector Base-2 Logarithm Estimate",
            "syntax": "r = vec_loge (a)",
            "purpose": "Returns a vector containing estimates of the base-2 logarithms of the\n      corresponding elements of the source vector.",
            "result": "Each element of\n      r contains an estimated value of the\n      base-2 logarithm of the corresponding element of a.",
            "endianness": "None.",
            "instructions": [
                "vlogefp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector float",
                        "implementation": "vlogefp  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_madd",
            "name": "Vector Multiply-Add",
            "syntax": "r = vec_madd (a, b, c)",
            "purpose": "Returns a vector containing the results of performing a fused\n      multiply-add operation for each corresponding set of elements of the\n      source vectors.",
            "result": "The value of each\n      element of r is the product of the\n      values of the corresponding elements of a and b, added\n      to the value of the corresponding element of c.",
            "endianness": "None.",
            "instructions": [
                "vmladduhm",
                "xvmaddmdp",
                "xvmaddmsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "c": "vector signed short",
                        "implementation": "vmladduhm r,a,b,c"
                    },
                    {
                        "id": "1",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector unsigned short",
                        "c": "vector unsigned short",
                        "implementation": "vmladduhm r,a,b,c"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector unsigned short",
                        "b": "vector signed short",
                        "c": "vector signed short",
                        "implementation": "vmladduhm r,a,b,c"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "c": "vector unsigned short",
                        "implementation": "vmladduhm r,a,b,c"
                    },
                    {
                        "id": "4",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "c": "vector float",
                        "implementation": "xvmaddmsp r/a,b,c"
                    },
                    {
                        "id": "5",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "c": "vector double",
                        "implementation": "xvmaddmdp r/a,b,c"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_madds",
            "name": "Vector Multiply-Add Saturated",
            "syntax": "r = vec_madds (a, b, c)",
            "purpose": "Returns a vector containing the results of performing a saturated\n      multiply-high-and-add operation for each corresponding set of elements\n      of the source vectors.",
            "result": "The value of each\n      element of r is produced as follows:\n      The values of the corresponding elements of a and b are\n      multiplied. The value of the 17 most-significant bits of this product\n      is then added, using 16-bit-saturated addition, to the value of the\n      corresponding element of c.",
            "endianness": "None.",
            "instructions": [
                "vmhaddshs"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "c": "vector signed short",
                        "implementation": "vmhaddshs r,a,b,c"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_max",
            "name": "Vector Maximum",
            "syntax": "r = vec_max (a, b)",
            "purpose": "Returns a vector containing the maximum value from each set of\n      corresponding elements of the source vectors.",
            "result": "The value of each element of r is the\n      maximum of the values of the corresponding elements of a and b.",
            "endianness": "None.",
            "instructions": [
                "vmaxsb",
                "vmaxub",
                "vmaxsw",
                "vmaxuw",
                "vmaxsd",
                "vmaxud",
                "vmaxsh",
                "vmaxuh",
                "xvmaxdp",
                "xvmaxsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vmaxsb  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vmaxub  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vmaxsh  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vmaxuh  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vmaxsw  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vmaxuw  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vmaxsd  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vmaxud  r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvmaxsp  r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvmaxdp  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_mergee",
            "name": "Vector Merge Even",
            "syntax": "r = vec_mergee (a, b)",
            "purpose": "Merges the even-numbered values from two vectors.",
            "result": "The even-numbered\n      elements of a are stored into the\n      even-numbered elements of r. The\n      even-numbered elements of b are stored\n      into the odd-numbered elements of r.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vmrgow",
                "vmrgew",
                "xxpermdi"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "vmrgew  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vmrgew  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vmrgew  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "xxpermdi  r,a,b,0"
                    },
                    {
                        "id": "4",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "xxpermdi  r,a,b,0"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "xxpermdi  r,a,b,0"
                    },
                    {
                        "id": "6",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "vmrgew  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xxpermdi  r,a,b,0"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_mergeh",
            "name": "Vector Merge High",
            "syntax": "r = vec_mergeh (a, b)",
            "purpose": "Merges the first halves (in element order) of two vectors.",
            "result": "The\n      nth element of r,\n      if n is an even number, is given the value of the\n      (n/2)th element of a.  The (n+1)th element\n      of r, if n is an\n      even number, is given the value of the (n/2)th\n      element of b.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vmrglb",
                "xxpermdi",
                "vmrghb",
                "vmrglw",
                "vmrghw",
                "vmrglh",
                "vmrghh"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "implementation": "vmrghb r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vmrghb r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vmrghb r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "implementation": "vmrghh r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vmrghh r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vmrghh r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector pixel",
                        "a": "vector pixel",
                        "b": "vector pixel",
                        "implementation": "vmrghh r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "vmrghw r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vmrghw r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vmrghw r,a,b"
                    },
                    {
                        "id": "10",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "xxpermdi r,a,b,0"
                    },
                    {
                        "id": "11",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "xxpermdi r,a,b,0"
                    },
                    {
                        "id": "12",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "xxpermdi r,a,b,0"
                    },
                    {
                        "id": "13",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "vmrghw r,a,b"
                    },
                    {
                        "id": "14",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xxpermdi r,a,b,0"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_mergel",
            "name": "Vector Merge Low",
            "syntax": "r = vec_mergel (a, b)",
            "purpose": "Merges the last halves (in element order) of two vectors.",
            "result": "Let\n      m be the number of elements in r.  The nth element of\n      r, if n is an even\n      number, is given the value of the m/2 +\n      (n/2)th element of a.  The (n+1)th element\n      of r, if n is an\n      even number, is given the value of the m/2 +\n      (n/2)th element of b.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vmrghb",
                "vmrglb",
                "vmrghw",
                "vmrglw",
                "xxpermdi",
                "vmrghh",
                "vmrglh"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "implementation": "vmrglb r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vmrglb r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vmrglb r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "implementation": "vmrglh r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vmrglh r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vmrglh r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector pixel",
                        "a": "vector pixel",
                        "b": "vector pixel",
                        "implementation": "vmrglh r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "vmrglw r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vmrglw r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vmrglw r,a,b"
                    },
                    {
                        "id": "10",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "xxpermdi r,a,b,3"
                    },
                    {
                        "id": "11",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "xxpermdi r,a,b,3"
                    },
                    {
                        "id": "12",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "xxpermdi r,a,b,3"
                    },
                    {
                        "id": "13",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "vmrglw r,a,b"
                    },
                    {
                        "id": "14",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xxpermdi r,a,b,3"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_mergeo",
            "name": "Vector Merge Odd",
            "syntax": "r = vec_mergeo (a, b)",
            "purpose": "Merges the odd-numbered values from two vectors.",
            "result": "The odd-numbered\n      elements of a are stored into the\n      even-numbered elements of r. The\n      odd-numbered elements of b are stored\n      into the odd-numbered elements of r.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vmrgew",
                "vmrgow",
                "xxpermdi"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "vmrgow r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vmrgow r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vmrgow r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "xxpermdi r,a,b,3"
                    },
                    {
                        "id": "4",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "xxpermdi r,a,b,3"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "xxpermdi r,a,b,3"
                    },
                    {
                        "id": "6",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "vmrgow r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xxpermdi r,a,b,3"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_mfvscr",
            "name": "Vector Move From Vector Status and Control Register",
            "syntax": "r = vec_mfvscr ()",
            "purpose": "Copies the contents of the Vector Status and Control Register\n      (VSCR) into the result vector.",
            "result": "The high-order 16\n      bits of the VSCR are copied into the seventh element of r, using big-endian (left-to-right) order. The\n      low-order 16 bits of the VSCR are copied into the eighth element of\n      r, using big-endian order.  All other\n      elements of r are set to zero.",
            "endianness": "The contents of the VSCR are placed in the low-order 32 bits of the\n      result vector, regardless of endianness.",
            "instructions": [
                "mfvscr"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "implementation",
                        "header": "Example\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned short",
                        "implementation": "mfvscr  a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_min",
            "name": "Vector Minimum",
            "syntax": "r = vec_min (a, b)",
            "purpose": "Returns a vector containing the minimum value from each set of\n      corresponding elements of the source vectors.",
            "result": "The value of each\n      element of r is the minimum of the\n      values of the corresponding elements of a and b.",
            "endianness": "None.",
            "instructions": [
                "vminsb",
                "vminub",
                "vminsw",
                "vminuw",
                "vminsd",
                "vminud",
                "vminsh",
                "vminuh",
                "xvmindp",
                "xvminsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vminsb  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vminub  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vminsh  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vminuh  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vminsw  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vminuw  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vminsd  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vminud  r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvminsp  r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvmindp  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_mradds",
            "name": "Vector Multiply-High Round and Add Saturated",
            "syntax": "r = vec_mradds (a, b, c)",
            "purpose": "Returns a vector containing the results of performing a saturated\n      multiply-high-round-and-add operation for each corresponding set of\n      elements of the source vectors.",
            "result": "The value of each\n      element of r is produced as follows.\n      The values of the corresponding elements of a and b are\n      multiplied and rounded such that the 15 least-significant bits are 0.\n      The value of the 17 most-significant bits of this rounded product is\n      then added, using 16-bit-saturated addition, to the value of the\n      corresponding element of c.",
            "endianness": "None.",
            "instructions": [
                "vmhraddshs"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "c": "vector signed short",
                        "implementation": "vmhraddshs r,a,b,c"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_msub",
            "name": "Vector Multiply-Subtract",
            "syntax": "r = vec_msub (a, b, c)",
            "purpose": "Returns a vector containing the results of performing a multiply-subtract\n      operation using the source vectors.",
            "result": "Each element of\n      r is produced by multiplying the\n      corresponding element of a by the\n      corresponding element of b and then\n      subtracting the corresponding element of c.",
            "endianness": "None.",
            "instructions": [
                "xvmsubmdp",
                "xvmsubmsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "c": "vector float",
                        "implementation": "xvmsubmsp r/a,b,c"
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "c": "vector double",
                        "implementation": "xvmsubmdp r/a,b,c"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_msum",
            "name": "Vector Multiply-Sum",
            "syntax": "r = vec_msum (a, b, c)",
            "purpose": "Returns a vector containing the results of performing a multiply-sum\n      operation using the source vectors.",
            "result": "",
            "endianness": "None.",
            "instructions": [
                "vmsummbm",
                "vmsumshm",
                "vmsumubm",
                "vmsumuhm"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "vector signed char",
                        "b": "vector unsigned char",
                        "c": "vector signed int",
                        "implementation": "vmsummbm r,a,b,c"
                    },
                    {
                        "id": "1",
                        "r": "vector signed int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "c": "vector signed int",
                        "implementation": "vmsumshm r,a,b,c"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "c": "vector unsigned int",
                        "implementation": "vmsumubm r,a,b,c"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "c": "vector unsigned int",
                        "implementation": "vmsumuhm r,a,b,c"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_msums",
            "name": "Vector Multiply-Sum Saturated",
            "syntax": "r = vec_msums (a, b, c)",
            "purpose": "Returns a vector containing the results of performing a saturated\n      multiply-sum operation using the source vectors.",
            "result": "Assume that the\n      elements of each vector are numbered beginning with 0. The value of each\n      element n of r\n      is obtained as follows. For p =\n      2n to 2n+1, multiply element\n      p of a by element\n      p of b. Add the\n      sum of these products to element n of\n      c. All additions are performed using\n      32-bit saturated arithmetic.",
            "endianness": "None.",
            "instructions": [
                "vmsumshs",
                "vmsumuhs"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "c": "vector signed int",
                        "implementation": "vmsumshs r,a,b,c"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "c": "vector unsigned int",
                        "implementation": "vmsumuhs r,a,b,c"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_mtvscr",
            "name": "Vector Move to Vector Status and Control Register",
            "syntax": "vec_mtvscr (a)",
            "purpose": "Copies a value into the Vector Status and Control Register\n      (VSCR).  The low-order 32 bits of a are copied into the VSCR.",
            "result": "None.",
            "endianness": "None.",
            "instructions": [
                "mtvscr"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "a": "vector bool char",
                        "implementation": "mtvscr  a"
                    },
                    {
                        "id": "1",
                        "a": "vector signed char",
                        "implementation": "mtvscr  a"
                    },
                    {
                        "id": "2",
                        "a": "vector unsigned char",
                        "implementation": "mtvscr  a"
                    },
                    {
                        "id": "3",
                        "a": "vector bool short",
                        "implementation": "mtvscr  a"
                    },
                    {
                        "id": "4",
                        "a": "vector signed short",
                        "implementation": "mtvscr  a"
                    },
                    {
                        "id": "5",
                        "a": "vector unsigned short",
                        "implementation": "mtvscr  a"
                    },
                    {
                        "id": "6",
                        "a": "vector pixel",
                        "implementation": "mtvscr  a"
                    },
                    {
                        "id": "7",
                        "a": "vector bool int",
                        "implementation": "mtvscr  a"
                    },
                    {
                        "id": "8",
                        "a": "vector signed int",
                        "implementation": "mtvscr  a"
                    },
                    {
                        "id": "9",
                        "a": "vector unsigned int",
                        "implementation": "mtvscr  a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_mul",
            "name": "Vector Multiply",
            "syntax": "r = vec_mul (a, b)",
            "purpose": "Compute the products of corresponding elements of two vectors.",
            "result": "Each element of\n      r receives the product of\n      the corresponding elements of a and\n      b.",
            "endianness": "None.",
            "instructions": [
                "vmulesb",
                "vmulosb",
                "lxvw4x",
                "vperm",
                "vmuluwm",
                "xxspltib",
                "vmladduhm",
                "xvmuldp",
                "xvmulsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vmulesb  t,a,b\n  vmulosb  u,a,b\n  lxvw4x   v,0,pcv\n  vperm    r,t,u,v"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vmulesb  t,a,b\n  vmulosb  u,a,b\n  lxvw4x   v,0,pcv\n  vperm    r,t,u,v"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "xxspltib  t,0\n  vmladduhm r,a,b,t"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "xxspltib  t,0\n  vmladduhm r,a,b,t"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vmuluwm r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vmuluwm r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "[scalarized]"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "[scalarized]"
                    },
                    {
                        "id": "8",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvmulsp r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvmuldp r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_mule",
            "name": "Vector Multiply Even",
            "syntax": "r = vec_mule (a, b)",
            "purpose": "Multiplies the even-numbered elements of the source vectors to\n      produce the target vector.",
            "result": "Each element\n      n of r is the\n      product of element 2n of a and element 2n of\n      b.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vmulosh",
                "vmulesh",
                "vmulouh",
                "vmuleuh",
                "vmulosw",
                "vmulesw",
                "vmulouw",
                "vmuleuw",
                "vmulosb",
                "vmulesb",
                "vmuloub",
                "vmuleub"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed short",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vmulesb r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned short",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vmuleub r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vmulesh r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vmuleuh r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed long long",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vmulesw r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vmuleuw r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_mulo",
            "name": "Vector Multiply Odd",
            "syntax": "r = vec_mulo (a, b)",
            "purpose": "Multiplies the odd-numbered elements of the source vectors to\n      produce the target vector.",
            "result": "Each element\n      n of r is the\n      product of element 2n+1 of a and element 2n+1 of\n      b.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vmulesh",
                "vmulosh",
                "vmuleuh",
                "vmulouh",
                "vmulesw",
                "vmulosw",
                "vmuleuw",
                "vmulouw",
                "vmulesb",
                "vmulosb",
                "vmuleub",
                "vmuloub"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed short",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vmulosb r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned short",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vmuloub r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed int",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vmulosh r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vmulouh r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed long long",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vmulosw r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vmulouw r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_nabs",
            "name": "Vector Negated Absolute Value",
            "syntax": "r = vec_nabs (a)",
            "purpose": "Returns a vector containing the negated absolute values of the contents\n      of the source vector.",
            "result": "The value of each\n      element of r is the negated absolute\n      value of the corresponding element of a. For integer vectors, the arithmetic is\n      modular.",
            "endianness": "None.",
            "instructions": [
                "vspltisw",
                "vsububm",
                "vminsb",
                "vsubuwm",
                "vminsw",
                "vsubudm",
                "vminsd",
                "vsubuhm",
                "vminsh",
                "xvnabsdp",
                "xvnabssp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "implementation": "vspltisw t,0\n  vsububm  u,t,a\n  vminsb   r,u,a"
                    },
                    {
                        "id": "1",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "implementation": "vspltisw t,0\n  vsubuhm  u,t,a\n  vminsh   r,u,a"
                    },
                    {
                        "id": "2",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "implementation": "vspltisw t,0\n  vsubuwm  u,t,a\n  vminsw   r,u,a"
                    },
                    {
                        "id": "3",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "implementation": "vspltisw t,0\n  vsubudm  u,t,a\n  vminsd   r,u,a"
                    },
                    {
                        "id": "4",
                        "r": "vector float",
                        "a": "vector float",
                        "implementation": "xvnabssp  r,a"
                    },
                    {
                        "id": "5",
                        "r": "vector double",
                        "a": "vector double",
                        "implementation": "xvnabsdp  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_nand",
            "name": "Vector NAND",
            "syntax": "r = vec_nand (a, b)",
            "purpose": "Performs a bitwise NAND of two vectors.",
            "result": "r is the bitwise\n      NAND of a and b.",
            "endianness": "None.",
            "instructions": [
                "xxlnand"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "implementation": "xxlnand  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "xxlnand  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "xxlnand  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "implementation": "xxlnand  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "xxlnand  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "xxlnand  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "xxlnand  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "xxlnand  r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "xxlnand  r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "xxlnand  r,a,b"
                    },
                    {
                        "id": "10",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "xxlnand  r,a,b"
                    },
                    {
                        "id": "11",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "xxlnand  r,a,b"
                    },
                    {
                        "id": "12",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xxlnand  r,a,b"
                    },
                    {
                        "id": "13",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xxlnand  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_ncipher_be",
            "name": "Vector AES Inverse Cipher Big-Endian",
            "syntax": "r = vec_ncipher_be (a, b)",
            "purpose": "Performs one round of the AES inverse cipher operation on an\n      intermediate state array a by using a\n      given round key b.",
            "result": "r contains the\n      resulting intermediate state, after one round of the AES inverse cipher\n      operation on intermediate state array a,\n      using the round key specified by b.",
            "endianness": "",
            "instructions": [
                "vncipher"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vncipher  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_ncipherlast_be",
            "name": "Vector AES Inverse Cipher Last Big-Endian",
            "syntax": "r = vec_ncipherlast_be (a, b)",
            "purpose": "Performs the final round of the AES inverse cipher operation on an\n      intermediate state array a using the\n      specified round key b.",
            "result": "r contains the\n      resulting final state, after the final round of the AES inverse cipher\n      operation on intermediate state array a,\n      using the round key specified by b.",
            "endianness": "",
            "instructions": [
                "vncipherlast"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vncipherlast  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_nearbyint",
            "name": "Vector Nearby Integer",
            "syntax": "r = vec_nearbyint (a)",
            "purpose": "Returns a vector containing the floating-point integral values nearest to\n      the values of the corresponding elements of the source vector.",
            "result": "Each\n      element of r contains the\n      nearest representable floating-point integral value to the value\n      of the corresponding element of a. When an input element value is exactly\n      between two integer values, the input value with the larger\n      absolute value is selected.  The current floating-point rounding\n      mode is ignored.",
            "endianness": "None.",
            "instructions": [
                "xvrdpi",
                "xvrspi"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector float",
                        "implementation": "xvrspi  r,a"
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector double",
                        "implementation": "xvrdpi  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_neg",
            "name": "Vector Negate",
            "syntax": "r = vec_neg (a)",
            "purpose": "Returns a vector containing the negated values of the contents of the\n      source vector.",
            "result": "The value of each\n      element of r is the negated value of\n      the corresponding element of a. For\n      integer vectors, the arithmetic is modular.",
            "endianness": "None.",
            "instructions": [
                "vspltisw",
                "vsububm",
                "vsubuwm",
                "vsubudm",
                "vsubuhm",
                "xvnegdp",
                "xvnegsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "implementation": "vspltisw  t,0\n  vsububm   r,t,a"
                    },
                    {
                        "id": "1",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "implementation": "vspltisw  t,0\n  vsubuhm   r,t,a"
                    },
                    {
                        "id": "2",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "implementation": "vspltisw  t,0\n  vsubuwm   r,t,a"
                    },
                    {
                        "id": "3",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "implementation": "vspltisw  t,0\n  vsubudm   r,t,a"
                    },
                    {
                        "id": "4",
                        "r": "vector float",
                        "a": "vector float",
                        "implementation": "xvnegsp  r,a"
                    },
                    {
                        "id": "5",
                        "r": "vector double",
                        "a": "vector double",
                        "implementation": "xvnegdp  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_nmadd",
            "name": "Vector Negated Multiply-Add",
            "syntax": "r = vec_nmadd (a, b, c)",
            "purpose": "Returns a vector containing the results of performing a negated\n      multiply-add operation on the source vectors.",
            "result": "The value of each\n      element of r is the product of the\n      corresponding elements of a and\n      b, added to the corresponding elements\n      of c, then multiplied by\n      \u20131.0.",
            "endianness": "None.",
            "instructions": [
                "xvnmaddadp",
                "xvnmaddasp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "c": "vector float",
                        "implementation": "xvnmaddasp  r/c,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "c": "vector double",
                        "implementation": "xvnmaddadp  r/c,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_nmsub",
            "name": "Vector Negated Multiply-Subtract",
            "syntax": "r = vec_nmsub (a, b, c)",
            "purpose": "Returns a vector containing the results of performing a negated\n      multiply-subtract operation on the source vectors.",
            "result": "The value of each\n      element of r is the value of the\n      corresponding element of c subtracted\n      from the product of the corresponding elements of a and b, and\n      then multiplied by \u20131.0.",
            "endianness": "None.",
            "instructions": [
                "xvnmsubmdp",
                "xvnmsubmsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "c": "vector float",
                        "implementation": "xvnmsubmsp  r/a,b,c"
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "c": "vector double",
                        "implementation": "xvnmsubmdp  r/a,b,c"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_nor",
            "name": "Vector NOR",
            "syntax": "r = vec_nor (a, b)",
            "purpose": "Performs a bitwise NOR of two vectors.",
            "result": "r is the bitwise NOR\n      of a and b.",
            "endianness": "None.",
            "instructions": [
                "xxlnor"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "implementation": "xxlnor  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "xxlnor  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "xxlnor  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "implementation": "xxlnor  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "xxlnor  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "xxlnor  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "xxlnor  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "xxlnor  r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "xxlnor  r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "xxlnor  r,a,b"
                    },
                    {
                        "id": "10",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "xxlnor  r,a,b"
                    },
                    {
                        "id": "11",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "xxlnor  r,a,b"
                    },
                    {
                        "id": "12",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xxlnor  r,a,b"
                    },
                    {
                        "id": "13",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xxlnor  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_or",
            "name": "Vector OR",
            "syntax": "r = vec_or (a, b)",
            "purpose": "Performs a bitwise OR of two vectors.",
            "result": "r is the bitwise OR\n      of a and b.",
            "endianness": "None.",
            "instructions": [
                "xxlor"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "implementation": "xxlor  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "xxlor  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "xxlor  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "implementation": "xxlor  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "xxlor  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "xxlor  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "xxlor  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "xxlor  r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "xxlor  r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "xxlor  r,a,b"
                    },
                    {
                        "id": "10",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "xxlor  r,a,b"
                    },
                    {
                        "id": "11",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "xxlor  r,a,b"
                    },
                    {
                        "id": "12",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xxlor  r,a,b"
                    },
                    {
                        "id": "13",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xxlor  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_orc",
            "name": "Vector OR with Complement",
            "syntax": "r = vec_orc (a, b)",
            "purpose": "Performs a bitwise OR of the first vector with the bitwise-complemented\n      second vector.",
            "result": "r is the bitwise OR\n      of a and the bitwise complement of\n      b.",
            "endianness": "None.",
            "instructions": [
                "xxlorc"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "implementation": "xxlorc  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "xxlorc  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "xxlorc  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "implementation": "xxlorc  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "xxlorc  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "xxlorc  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "xxlorc  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "xxlorc  r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "xxlorc  r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "xxlorc  r,a,b"
                    },
                    {
                        "id": "10",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "xxlorc  r,a,b"
                    },
                    {
                        "id": "11",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "xxlorc  r,a,b"
                    },
                    {
                        "id": "12",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xxlorc  r,a,b"
                    },
                    {
                        "id": "13",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xxlorc  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_pack",
            "name": "Vector Pack",
            "syntax": "r = vec_pack (a, b)",
            "purpose": "Packs information from each element of two vectors into the result\n      vector.",
            "result": "Let v represent the concatenation of vectors\n      a and b.  For integer types, the value of each element\n      of r is taken from the low-order half\n      of the corresponding element of v. For\n      floating-point types, the value of each element of r is the corresponding element of v, rounded to the result type.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vpkuhum",
                "vpkudum",
                "vpkuwum",
                "xxpermdi",
                "xvcvdpsp",
                "vmrgow",
                "vmrgew"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "implementation": "vpkuhum r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vpkuhum r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vpkuhum r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "vpkuwum r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vpkuwum r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned short",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vpkuwum r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector bool int",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "vpkudum r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector signed int",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vpkudum r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector unsigned int",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vpkudum r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector float",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xxpermdi  t,a,b,0\n xxpermdi  u,a,b,3\n xvcvdpsp  t,t\n xvcvdpsp  u,u\n vmrgew    r,t,u"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_pack_to_short_fp32",
            "name": "Vector Pack 32-bit Float to Short",
            "syntax": "r = vec_pack_to_short_fp32 (a, b)",
            "purpose": "Packs eight single-precision 32-bit floating-point numbers from two\n      source vectors into a vector of eight 16-bit floating-point numbers.",
            "result": "Let v represent the 16-element concatenation of\n      a and b.  Each value of r contains the result of converting the\n      corresponding single-precision element of v to half-precision.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vctuxs",
                "vpkswss"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned short",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvcvsphp t,a\n xvcvsphp u,b\n vpkuwum  r,u,t",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_packpx",
            "name": "Vector Pack Pixel",
            "syntax": "r = vec_packpx (a, b)",
            "purpose": "Packs information from each element of two vectors into the result\n      vector.",
            "result": "Let v be the concatenation of a and b.  The\n      value of each element of r is taken\n      from the corresponding element of v as\n      follows:",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vpkpx"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector pixel",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vpkpx r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_packs",
            "name": "Vector Pack Saturated",
            "syntax": "r = vec_packs (a, b)",
            "purpose": "Packs information from each element of two vectors into the result\n      vector, using saturated values.",
            "result": "Let v be the concatenation of a and b. The\n      value of each element of r is the\n      saturated value of the corresponding element of v.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vpkshss",
                "vpkuhus",
                "vpksdss",
                "vpkudus",
                "vpkswss",
                "vpkuwus"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vpkshss  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vpkuhus  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vpkswss  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vpkuwus  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vpksdss  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vpkudus  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_packsu",
            "name": "Vector Pack Saturated Unsigned",
            "syntax": "r = vec_packsu (a, b)",
            "purpose": "Packs information from each element of two vectors into the result\n      vector, using unsigned saturated values.",
            "result": "Let v be the concatenation of a and b. The\n      value of each element of r is the\n      saturated value of the corresponding element of v.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vpkshus",
                "vpkuhus",
                "vpksdus",
                "vpkudus",
                "vpkswus",
                "vpkuwus"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned char",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vpkshus r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vpkuhus r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned short",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vpkswus r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vpkuwus r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector unsigned int",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vpksdus r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vpkudus r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_parity_lsbb",
            "name": "Vector Parity over Least-Significant Bits of Bytes",
            "syntax": "r = vec_parity_lsbb (a)",
            "purpose": "Compute parity on the least-significant bit of each byte.",
            "result": "Each element of\n      r contains the parity computed over the\n      low-order bit of each of the bytes in the corresponding element of\n      a.",
            "endianness": "None.",
            "instructions": [
                "vprtybw",
                "vprtybq",
                "vprtybd"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned int",
                        "a": "vector signed int",
                        "implementation": "vprtybw  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "implementation": "vprtybw  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned long long",
                        "a": "vector signed long long",
                        "implementation": "vprtybd  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "implementation": "vprtybd  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "4",
                        "r": "vector unsigned __int128",
                        "a": "vector signed __int128",
                        "implementation": "vprtybq  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned __int128",
                        "a": "vector unsigned __int128",
                        "implementation": "vprtybq  r,a",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_perm",
            "name": "Vector Permute",
            "syntax": "r = vec_perm (a, b, c)",
            "purpose": "Returns a vector that contains elements selected from two\n      vectors, in the order specified by a third vector.",
            "result": "Let v be the concatenation of a and b.  Each\n      byte of r selected by using the\n      least-significant 5 bits of the corresponding byte of c as an index into v.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vpermr",
                "vperm"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "c": "vector unsigned char",
                        "implementation": "vperm r,a,b,c"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "c": "vector unsigned char",
                        "implementation": "vperm r,a,b,c"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "c": "vector unsigned char",
                        "implementation": "vperm r,a,b,c"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "c": "vector unsigned char",
                        "implementation": "vperm r,a,b,c"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "c": "vector unsigned char",
                        "implementation": "vperm r,a,b,c"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "c": "vector unsigned char",
                        "implementation": "vperm r,a,b,c"
                    },
                    {
                        "id": "6",
                        "r": "vector pixel",
                        "a": "vector pixel",
                        "b": "vector pixel",
                        "c": "vector unsigned char",
                        "implementation": "vperm r,a,b,c"
                    },
                    {
                        "id": "7",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "c": "vector unsigned char",
                        "implementation": "vperm r,a,b,c"
                    },
                    {
                        "id": "8",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "c": "vector unsigned char",
                        "implementation": "vperm r,a,b,c"
                    },
                    {
                        "id": "9",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "c": "vector unsigned char",
                        "implementation": "vperm r,a,b,c"
                    },
                    {
                        "id": "10",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "c": "vector unsigned char",
                        "implementation": "vperm r,a,b,c"
                    },
                    {
                        "id": "11",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "c": "vector unsigned char",
                        "implementation": "vperm r,a,b,c"
                    },
                    {
                        "id": "12",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "c": "vector unsigned char",
                        "implementation": "vperm r,a,b,c"
                    },
                    {
                        "id": "13",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "c": "vector unsigned char",
                        "implementation": "vperm r,a,b,c"
                    },
                    {
                        "id": "14",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "c": "vector unsigned char",
                        "implementation": "vperm r,a,b,c"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_permxor",
            "name": "Vector Permute and Exclusive-OR",
            "syntax": "r = vec_permxor (a, b, c)",
            "purpose": "Applies a permute and exclusive-OR operation on two vectors of byte\n      elements, with the selected elements identified by a third vector.",
            "result": "For each\n      i (0 \u2264 i < 16), let\n      x be bits 0\u20133 and\n      y be bits 4\u20137 of byte element\n      i of c.  Byte\n      element i of r\n      is set to the exclusive-OR of byte elements x\n      of a and y\n      of b.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "xxlnor",
                "vpermxor"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE Implementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "c": "vector bool char",
                        "implementation": "vpermxor r,a,b,c"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "c": "vector signed char",
                        "implementation": "vpermxor r,a,b,c"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "c": "vector unsigned char",
                        "implementation": "vpermxor r,a,b,c"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_pmsum_be",
            "name": "Vector Polynomial Multiply-Sum Big-Endian",
            "syntax": "r = vec_pmsum_be (a, b)",
            "purpose": "Performs the exclusive-OR operation (implementing polynomial addition)\n      on each even-odd pair of the polynomial-multiplication result of the\n      corresponding elements of a and\n      b.",
            "result": "Each element\n      i of r is\n      computed by an exclusive-OR operation of the polynomial\n      multiplication of input elements 2 \u00d7 i of\n      a and b and input elements 2 \u00d7\n      i + 1 of a and\n      b.",
            "endianness": "",
            "instructions": [
                "vpmsumh",
                "vpmsumd",
                "vpmsumw",
                "vpmsumb"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned short",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vpmsumb  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned int",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vpmsumh  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vpmsumw  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned __int128",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vpmsumd  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_popcnt",
            "name": "Vector Population Count",
            "syntax": "r = vec_popcnt (a)",
            "purpose": "Returns a vector containing the number of bits set in each element of\n      the source vector.",
            "result": "The value of each\n      element of r is the number of bits set\n      in the corresponding element of a.",
            "endianness": "None.",
            "instructions": [
                "vpopcntb",
                "vpopcntw",
                "vpopcntd",
                "vpopcnth"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned char",
                        "a": "vector signed char",
                        "implementation": "vpopcntb  r,a"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "implementation": "vpopcntb  r,a"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned short",
                        "a": "vector signed short",
                        "implementation": "vpopcnth  r,a"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "implementation": "vpopcnth  r,a"
                    },
                    {
                        "id": "4",
                        "r": "vector unsigned int",
                        "a": "vector signed int",
                        "implementation": "vpopcntw  r,a"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "implementation": "vpopcntw  r,a"
                    },
                    {
                        "id": "6",
                        "r": "vector unsigned long long",
                        "a": "vector signed long long",
                        "implementation": "vpopcntd  r,a"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "implementation": "vpopcntd  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_re",
            "name": "Vector Reciprocal Estimate",
            "syntax": "r = vec_re (a)",
            "purpose": "Returns a vector containing estimates of the reciprocals of the\n      corresponding elements of the source vector.",
            "result": "Each element of\n      r contains the estimated value of the\n      reciprocal of the corresponding element of a.",
            "endianness": "None.",
            "instructions": [
                "xvredp",
                "xvresp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector float",
                        "implementation": "xvresp  r,a"
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector double",
                        "implementation": "xvredp  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_recipdiv",
            "name": "Vector Reciprocal Divide",
            "syntax": "r = vec_recipdiv (a, b)",
            "purpose": "Returns a vector containing refined approximations of the\n      division of the corresponding elements of a by the corresponding elements of\n      b.",
            "result": "Each element of\n      r contains a refined approximation of\n      the division of the corresponding element of a by the corresponding element of b.",
            "endianness": "None.",
            "instructions": [
                "xvredp",
                "xvnmsubadp",
                "xvmaddmdp",
                "xvmuldp",
                "xvresp",
                "xvmulsp",
                "xvnmsubasp",
                "xvmaddmsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvresp      t,b\n  xvmulsp     u,a,t\n  xvnmsubasp  r/a,b,u\n  xvmaddmsp   r/a,t,u"
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvredp      t,b\n  xvnmsubadp  z,b,t\n  xvmaddadp   u,z,t\n  xvmuldp     v,a,u\n  xvnmsubadp  r/a,b,v\n  xvmaddmdp   r/a,u,v"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_revb",
            "name": "Vector Reverse Bytes",
            "syntax": "r = vec_revb (a)",
            "purpose": "Reverse the bytes of each vector element of a vector.",
            "result": "Each element of\n      r contains the byte-reversed value of\n      the corresponding element of a.",
            "endianness": "None.",
            "instructions": [
                "xxbrw",
                "xxbrq",
                "xxbrd",
                "xxbrh"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example ISA 3.0 Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "implementation": "[none]",
                        "Restrictions": "Deprecated"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "implementation": "[none]",
                        "Restrictions": "Deprecated"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "implementation": "[none]",
                        "Restrictions": "Deprecated"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "implementation": "xxbrh  r,a",
                        "Restrictions": "Deprecated"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "implementation": "xxbrh  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "implementation": "xxbrh  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "6",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "implementation": "xxbrw  r,a",
                        "Restrictions": "Deprecated"
                    },
                    {
                        "id": "7",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "implementation": "xxbrw  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "8",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "implementation": "xxbrw  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "9",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "implementation": "xxbrd  r,a",
                        "Restrictions": "Deprecated"
                    },
                    {
                        "id": "10",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "implementation": "xxbrd  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "11",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "implementation": "xxbrd  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "12",
                        "r": "vector signed __int128",
                        "a": "vector signed __int128",
                        "implementation": "xxbrq  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "13",
                        "r": "vector unsigned __int128",
                        "a": "vector unsigned __int128",
                        "implementation": "xxbrq  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "14",
                        "r": "vector float",
                        "a": "vector float",
                        "implementation": "xxbrw  r,a",
                        "Restrictions": ""
                    },
                    {
                        "id": "15",
                        "r": "vector double",
                        "a": "vector double",
                        "implementation": "xxbrd  r,a",
                        "Restrictions": ""
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_reve",
            "name": "Vector Reverse Elements",
            "syntax": "r = vec_reve (a)",
            "purpose": "Reverse the elements of a vector.",
            "result": "Returns a vector\n      with the elements of the source vector in reversed order.",
            "endianness": "The vpermr instruction is most naturally used to implement this built-in\n      function for a little-endian target, and the vperm instruction for a\n      big-endian target.  This is not technically necessary, however, provided\n      the correct permute control vector is used.  Note that use of vpermr\n      requires ISA 3.0.",
            "instructions": [
                "vperm",
                "vpermr"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "implementation": "vperm[r]  r,a,a,pcv"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "implementation": "vperm[r]  r,a,a,pcv"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "implementation": "vperm[r]  r,a,a,pcv"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "implementation": "vperm[r]  r,a,a,pcv"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "implementation": "vperm[r]  r,a,a,pcv"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "implementation": "vperm[r]  r,a,a,pcv"
                    },
                    {
                        "id": "6",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "implementation": "vperm[r]  r,a,a,pcv"
                    },
                    {
                        "id": "7",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "implementation": "vperm[r]  r,a,a,pcv"
                    },
                    {
                        "id": "8",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "implementation": "vperm[r]  r,a,a,pcv"
                    },
                    {
                        "id": "9",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "implementation": "vperm[r]  r,a,a,pcv"
                    },
                    {
                        "id": "10",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "implementation": "vperm[r]  r,a,a,pcv"
                    },
                    {
                        "id": "11",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "implementation": "vperm[r]  r,a,a,pcv"
                    },
                    {
                        "id": "12",
                        "r": "vector float",
                        "a": "vector float",
                        "implementation": "vperm[r]  r,a,a,pcv"
                    },
                    {
                        "id": "13",
                        "r": "vector double",
                        "a": "vector double",
                        "implementation": "vperm[r]  r,a,a,pcv"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_rint",
            "name": "Vector Round to Nearest Integer",
            "syntax": "r = vec_rint (a)",
            "purpose": "Returns a vector containing the floating-point integral values nearest\n      to the values of the corresponding elements of the source vector.",
            "result": "Each element of\n      r contains the nearest representable\n      floating-point integral value to the value of the corresponding element\n      of a. When an input element value is\n      exactly between two integer values, the result value is selected based\n      on the rounding mode specified by the Floating-Point Rounding Control\n      field (RN) of the FPSCR register.",
            "endianness": "None.",
            "instructions": [
                "xvrdpic",
                "xvrspic"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector float",
                        "implementation": "xvrspic  r,a"
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector double",
                        "implementation": "xvrdpic  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_rl",
            "name": "Vector Rotate Left",
            "syntax": "r = vec_rl (a, b)",
            "purpose": "Rotates each element of a vector left by a given number of bits.",
            "result": "Each element of\n      r is obtained by rotating the\n      corresponding element of a left by the\n      number of bits specified by the corresponding element of\n      b.",
            "endianness": "None.",
            "instructions": [
                "vrlb",
                "vrlw",
                "vrld",
                "vrlh"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector unsigned char",
                        "implementation": "vrlb  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vrlb  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector unsigned short",
                        "implementation": "vrlh  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vrlh  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector unsigned int",
                        "implementation": "vrlw  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vrlw  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector unsigned long long",
                        "implementation": "vrld  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vrld  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_rlmi",
            "name": "Vector Rotate Left then Mask Insert",
            "syntax": "r = vec_rlmi (a, b, c)",
            "purpose": "Rotates each element of a vector left and inserts each element under\n      a mask.",
            "result": "Each element of\n      r is obtained by rotating the\n      corresponding element of vector b left\n      and inserting it under mask into the corresponding element of\n      a. Bits 11:15 of the corresponding\n      element of c contain the mask\n      beginning, bits 19:23 contain the mask end, and bits 27:31 contain the\n      shift count.",
            "endianness": "The referenced bit numbers within the elements of c are in left-to-right order.",
            "instructions": [
                "vrlwmi",
                "vrldmi"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "c": "vector unsigned int",
                        "implementation": "vrlwmi r/a,b,c",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "c": "vector unsigned long long",
                        "implementation": "vrldmi r/a,b,c",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_rlnm",
            "name": "Vector Rotate Left then AND with Mask",
            "syntax": "r = vec_rlnm (a, b, c)",
            "purpose": "Rotates each element of a vector left, then logically ANDs it with a\n      mask.",
            "result": "Each element of\n      a is rotated left, then logically ANDed\n      with a mask specified by b and\n      c.",
            "endianness": "None.",
            "instructions": [
                "vspltisw",
                "vslw",
                "xxlor",
                "vrlwnm",
                "xxspltib",
                "vextsb2d",
                "vsld",
                "vrldnm"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "c": "vector unsigned int",
                        "implementation": "vspltisw t,8\n vslw     u,b,t\n xxlor    v,u,c\n vrlwnm   r,a,v",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "c": "vector unsigned long long",
                        "implementation": "xxspltib t,8\n vextsb2d u,t\n vsld     v,b,u\n xxlor    w,v,c\n vrldnm   r,a,w",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_round",
            "name": "Vector Round",
            "syntax": "r = vec_round (a)",
            "purpose": "Returns a vector containing the rounded values of the corresponding\n      elements of the source vector.",
            "result": "Each element of\n      r contains the value of the\n      corresponding element of a, rounded\n      to the nearest representable floating-point integer, using IEEE\n      round-to-nearest rounding.  The current floating-point rounding\n      mode is ignored.",
            "endianness": "None.",
            "instructions": [
                "xvrdpi",
                "vrfin"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector float",
                        "implementation": "vrfin  r,a"
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector double",
                        "implementation": "xvrdpi  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_rsqrt",
            "name": "Vector Reciprocal Square Root",
            "syntax": "r = vec_rsqrt (a)",
            "purpose": "Returns a vector containing a refined approximation of the reciprocal\n      square roots of the corresponding elements of the source vector. This\n      function provides an implementation-dependent greater precision than\n      vec_rsqrte.",
            "result": "Each element of\n      r contains a refined approximation of\n      the reciprocal square root of the corresponding element of\n      a.",
            "endianness": "None.",
            "instructions": [
                "xvrsqrtedp",
                "xvmuldp",
                "xxlor",
                "xvnmsubadp",
                "xvmaddadp",
                "xvnmsubmdp",
                "xvadddp",
                "xvrsqrtesp",
                "xvmulsp",
                "xvnmsubmsp",
                "xvmaddmsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector float",
                        "implementation": "xvrsqrtesp  t,a\n  xvmulsp     u,t,a\n  xvmulsp     v,t,h\n  xvnmsubmsp  v,u,h\n  xvmaddmsp   r/v,t,t"
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector double",
                        "implementation": "xvrsqrtedp  t,a\n  xvmuldp     u,t,a\n  xvmuldp     v,t,h\n  xxlor       w,h,h\n  xvnmsubadp  w,u,v\n  xvmaddadp   v,v,w\n  xvmaddadp   u,u,w\n  xvnmsubmdp  u,v,h\n  xvmaddadp   v,v,u\n  xvadddp     r,v,v"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_rsqrte",
            "name": "Vector Reciprocal Square Root Estimate",
            "syntax": "r = vec_rsqrte (a)",
            "purpose": "Returns a vector containing estimates of the reciprocal square roots of\n      the corresponding elements of the source vector.",
            "result": "Each element of\n      r contains the estimated value of the\n      reciprocal square root of the corresponding element of a.",
            "endianness": "None.",
            "instructions": [
                "xvrsqrtedp",
                "xvrsqrtesp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector float",
                        "implementation": "xvrsqrtesp  r,a"
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector double",
                        "implementation": "xvrsqrtedp  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_sbox_be",
            "name": "Vector AES SubBytes Big-Endian",
            "syntax": "r = vec_sbox_be (a)",
            "purpose": "Performs the SubBytes operation, as defined in Federal Information\n      Processing Standards FIPS-197, on a state_array contained in\n      a.",
            "result": "r contains the\n      result of the SubBytes operation, as defined in Federal Information\n      Processing Standard FIPS-197, on the state array represented by\n      a.",
            "endianness": "",
            "instructions": [
                "vsbox"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "implementation": "vsbox  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_sel",
            "name": "Vector Select",
            "syntax": "r = vec_sel (a, b, c)",
            "purpose": "Returns a vector selecting bits from two source vectors\n      depending on the corresponding bit values of a third source\n      vector.",
            "result": "Each bit of\n      r has the value of the corresponding\n      bit of a if the corresponding bit of\n      c is 0. Otherwise, the bit of\n      r has the value of the corresponding\n      bit of b.",
            "endianness": "None.",
            "instructions": [
                "xxsel"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "c": "vector bool char",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "1",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "c": "vector unsigned char",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "2",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "c": "vector bool char",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "3",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "c": "vector unsigned char",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "4",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "c": "vector bool char",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "c": "vector unsigned char",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "6",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "c": "vector bool short",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "7",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "c": "vector unsigned short",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "8",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "c": "vector bool short",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "9",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "c": "vector unsigned short",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "10",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "c": "vector bool short",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "11",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "c": "vector unsigned short",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "12",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "c": "vector bool int",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "13",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "c": "vector unsigned int",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "14",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "c": "vector bool int",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "15",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "c": "vector unsigned int",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "16",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "c": "vector bool int",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "17",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "c": "vector unsigned int",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "18",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "c": "vector bool long long",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "19",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "c": "vector unsigned long long",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "20",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "c": "vector bool long long",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "21",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "c": "vector unsigned long long",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "22",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "c": "vector bool long long",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "23",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "c": "vector unsigned long long",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "24",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "c": "vector bool int",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "25",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "c": "vector unsigned int",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "26",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "c": "vector bool long long",
                        "implementation": "xxsel  r,a,b,c"
                    },
                    {
                        "id": "27",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "c": "vector unsigned long long",
                        "implementation": "xxsel  r,a,b,c"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_shasigma_be",
            "name": "Vector SHA Sigma Big-Endian",
            "syntax": "r = vec_shasigma_be (a, b, c)",
            "purpose": "Performs a Secure Hash computation in accordance with Federal\n      Information Processing Standards FIPS-180-3.",
            "result": "Each element of\n      r contains the SHA256 or SHA512 hash\n      as follows.",
            "endianness": "",
            "instructions": [
                "vshasigmaw"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "const int",
                        "c": "4-bit unsigned literal",
                        "implementation": "vshasigmaw  r,a,b,c"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "const int",
                        "c": "4-bit unsigned literal",
                        "implementation": "vshasigmaw  r,a,b,d"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_signed",
            "name": "Vector Convert Floating-Point to Signed Integer",
            "syntax": "r = vec_signed (a)",
            "purpose": "Converts a vector of floating-point numbers to a vector of signed\n      integers.",
            "result": "Each\n      element of r is obtained by\n      truncating the corresponding element of a to a signed integer.  The current\n      floating-point rounding mode is ignored.",
            "endianness": "None.",
            "instructions": [
                "xvcvspsxws",
                "xvcvdpsxds"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "vector float",
                        "implementation": "xvcvspsxws  r,a"
                    },
                    {
                        "id": "1",
                        "r": "vector signed long long",
                        "a": "vector double",
                        "implementation": "xvcvdpsxds  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_signed2",
            "name": "Vector Convert Double-Precision to Signed Word",
            "syntax": "r = vec_signed2 (a, b)",
            "purpose": "Converts two vectors of double-precision floating-point numbers to a\n      vector of signed 32-bit integers.",
            "result": "Let v be the concatenation of a and b.  Each\n      element of r is obtained by truncating\n      the corresponding element of v to a\n      signed 32-bit integer.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "xxpermdi",
                "xvcvdpsxws",
                "vmrgow",
                "vmrgew"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE\nImplementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xxpermdi   t,a,b,0\n xxpermdi   u,a,b,3\n xvcvdpsxws v,t\n xvcvdpsxws w,u\n vmrgew     r,v,w"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_signede",
            "name": "Vector Convert Double-Precision to Signed Word Even",
            "syntax": "r = vec_signede (a)",
            "purpose": "Converts elements of a source vector to signed integers and stores\n      them in the even-numbered elements of the result vector.",
            "result": "Element 0 of\n      r contains element 0 of a, truncated to a signed integer.  Element 2 of\n      r contains element 1 of a, truncated to a signed integer.  Elements 1 and\n      3 of r are undefined.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "xvcvdpsxws",
                "vsldoi"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE\nImplementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "vector double",
                        "implementation": "xvcvdpsxws  t,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_signedo",
            "name": "Vector Convert Double-Precision to Signed Word Odd",
            "syntax": "r = vec_signedo (a)",
            "purpose": "Converts elements of a source vector to signed integers and stores them\n      in the odd-numbered elements of the result vector.",
            "result": "Element 1 of\n      r contains element 0 of a, truncated to a signed integer.  Element 3 of\n      r contains element 1 of a, truncated to a signed integer.  Elements 0 and\n      2 of r are undefined.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "xvcvdpsxws",
                "vsldoi"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE\nImplementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "vector double",
                        "implementation": "xvcvdpsxws  t,a\n  vsldoi      r,t,t,12"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_sl",
            "name": "Vector Shift Left",
            "syntax": "r = vec_sl (a, b)",
            "purpose": "Performs a left shift for each element of a vector.",
            "result": "Each element of\n      r is the result of left-shifting the\n      corresponding element of a by the\n      number of bits specified by the corresponding element of b, modulo the number of bits in the element.\n      Zeros are shifted in from the right.",
            "endianness": "None.",
            "instructions": [
                "vslb",
                "vslw",
                "vsld",
                "vslh"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector unsigned char",
                        "implementation": "vslb  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vslb  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector unsigned short",
                        "implementation": "vslh  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vslh  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector unsigned int",
                        "implementation": "vslw  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vslw  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector unsigned long long",
                        "implementation": "vsld  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vsld  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_sld",
            "name": "Vector Shift Left Double",
            "syntax": "r = vec_sld (a, b, c)",
            "purpose": "Left shifts a double vector (that is, two concatenated vectors) by a\n      given number of bytes. For vec_sld being performed on the vector bool\n      and floating-point types, the result is undefined when the specified\n      shift count is not a multiple of the element size.",
            "result": "Vector r receives the most-significant 16 bytes obtained\n      by concatenating a and b and shifting left by the number of bytes\n      specified by c, which must be in the\n      range 0\u201315.",
            "endianness": "",
            "instructions": [
                "vsldoi"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "c": "4-bit unsigned literal",
                        "implementation": "vsldoi  r,a,b,c"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "c": "4-bit unsigned literal",
                        "implementation": "vsldoi  r,a,b,c"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "c": "4-bit unsigned literal",
                        "implementation": "vsldoi  r,a,b,c"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "c": "4-bit unsigned literal",
                        "implementation": "vsldoi  r,a,b,c"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "c": "4-bit unsigned literal",
                        "implementation": "vsldoi  r,a,b,c"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "c": "4-bit unsigned literal",
                        "implementation": "vsldoi  r,a,b,c"
                    },
                    {
                        "id": "6",
                        "r": "vector pixel",
                        "a": "vector pixel",
                        "b": "vector pixel",
                        "c": "4-bit unsigned literal",
                        "implementation": "vsldoi  r,a,b,c"
                    },
                    {
                        "id": "7",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "c": "4-bit unsigned literal",
                        "implementation": "vsldoi  r,a,b,c"
                    },
                    {
                        "id": "8",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "c": "4-bit unsigned literal",
                        "implementation": "vsldoi  r,a,b,c"
                    },
                    {
                        "id": "9",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "c": "4-bit unsigned literal",
                        "implementation": "vsldoi  r,a,b,c"
                    },
                    {
                        "id": "10",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "c": "4-bit unsigned literal",
                        "implementation": "vsldoi  r,a,b,c"
                    },
                    {
                        "id": "11",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "c": "4-bit unsigned literal",
                        "implementation": "vsldoi  r,a,b,c"
                    },
                    {
                        "id": "12",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "c": "4-bit unsigned literal",
                        "implementation": "vsldoi  r,a,b,c"
                    },
                    {
                        "id": "13",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "c": "4-bit unsigned literal",
                        "implementation": "vsldoi  r,a,b,c"
                    },
                    {
                        "id": "14",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "c": "4-bit unsigned literal",
                        "implementation": "vsldoi  r,a,b,c"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_sldw",
            "name": "Vector Shift Left Double by Words",
            "syntax": "r = vec_sldw (a, b, c)",
            "purpose": "Returns a vector obtained by shifting left the concatenated source\n      vectors by the number of specified words.",
            "result": "Vector r receives the most-significant 16 bytes obtained\n      by concatenating a and b and shifting left by the number of words\n      specified by c, which must be in the\n      range 0\u20133.",
            "endianness": "This intrinsic is not endian-neutral, so uses of\n      vec_sldw in big-endian code must be rewritten for little-endian targets.\n      The concatenation of a and b is\n      done in big-endian fashion (left to right), and the shift is always\n      to the left.  This will generally produce surprising results for\n      little-endian targets.",
            "instructions": [
                "xxsldwi"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "c": "2-bit unsigned literal",
                        "implementation": "xxsldwi r,a,b,c"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "c": "2-bit unsigned literal",
                        "implementation": "xxsldwi r,a,b,c"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "c": "2-bit unsigned literal",
                        "implementation": "xxsldwi r,a,b,c"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "c": "2-bit unsigned literal",
                        "implementation": "xxsldwi r,a,b,c"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "c": "2-bit unsigned literal",
                        "implementation": "xxsldwi r,a,b,c"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "c": "2-bit unsigned literal",
                        "implementation": "xxsldwi r,a,b,c"
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "c": "2-bit unsigned literal",
                        "implementation": "xxsldwi r,a,b,c"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "c": "2-bit unsigned literal",
                        "implementation": "xxsldwi r,a,b,c"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_sll",
            "name": "Vector Shift Left Long",
            "syntax": "r = vec_sll (a, b)",
            "purpose": "Left shifts an entire vector by a given number of bits.",
            "result": "Vector\n      r contains the contents of a, shifted left by the number of bits specified\n      by the three least-significant bits of b. Zeros are supplied on the right. The shift\n      count must have been replicated into all bytes of b; if not, the value of r is undefined.",
            "endianness": "This intrinsic is not endian-neutral, so uses of\n      vec_sll in big-endian code must be rewritten for little-endian targets.",
            "instructions": [
                "vsl"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector unsigned char",
                        "implementation": "vsl  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vsl  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector unsigned char",
                        "implementation": "vsl  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned char",
                        "implementation": "vsl  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector pixel",
                        "a": "vector pixel",
                        "b": "vector unsigned char",
                        "implementation": "vsl  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector unsigned char",
                        "implementation": "vsl  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned char",
                        "implementation": "vsl  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector unsigned char",
                        "implementation": "vsl  r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned char",
                        "implementation": "vsl  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_slo",
            "name": "Vector Shift Left by Octets",
            "syntax": "r = vec_slo (a, b)",
            "purpose": "Left shifts a vector by a given number of bytes (octets).",
            "result": "Vector r receives the contents of a, shifted left by the number of bytes specified\n      by bits 1:4 of the least-significant byte of b.",
            "endianness": "This intrinsic is not endian-neutral, so uses of\n      vec_slo in big-endian code must be rewritten for little-endian targets.\n      The shift count is in element 15 of b\n      for big-endian, but in element 0 of b\n      for little-endian.",
            "instructions": [
                "vslo"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector unsigned char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector signed char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector unsigned char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector signed char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector pixel",
                        "a": "vector pixel",
                        "b": "vector signed char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector pixel",
                        "a": "vector pixel",
                        "b": "vector unsigned char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "10",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "11",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector unsigned char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "12",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector signed char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "13",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "14",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "15",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector unsigned char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "16",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector signed char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "17",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "18",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector signed char",
                        "implementation": "vslo  r,a,b"
                    },
                    {
                        "id": "19",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector unsigned char",
                        "implementation": "vslo  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_slv",
            "name": "Vector Shift Left Variable",
            "syntax": "r = vec_slv (a, b)",
            "purpose": "Left-shifts a vector by a varying number of bits by element.",
            "result": "Let v be a 17-byte vector formed from a in bytes [0:15] and a zero byte in element 16.\n      Then each byte element i of r is determined as follows.  The start bit\n      sb is obtained from bits 5:7 of byte element\n      i of b.  Then\n      the contents of bits sb:sb+7\n      of the halfword in byte elements\n      i:i+1 of v are placed into byte element\n      i of r.",
            "endianness": "All bit and byte element numbers are specified in big-endian order.\n      This intrinsic is not endian-neutral.",
            "instructions": [
                "vslv"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vslv  r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_splat",
            "name": "Vector Splat",
            "syntax": "r = vec_splat (a, b)",
            "purpose": "Returns a vector that has all of its elements set to a given value.",
            "result": "The value of each\n      element of r is the value of the\n      element of a specified by b, which must be an element number less than the\n      number of elements supported for a's\n      type.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vspltb",
                "xxspltw",
                "xxpermdi",
                "vsplth"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE\nImplementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "const int",
                        "implementation": "vspltb r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "const int",
                        "implementation": "vspltb r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "const int",
                        "implementation": "vspltb r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "b": "const int",
                        "implementation": "vsplth r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "const int",
                        "implementation": "vsplth r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "const int",
                        "implementation": "vsplth r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector pixel",
                        "a": "vector pixel",
                        "b": "const int",
                        "implementation": "vsplth r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "const int",
                        "implementation": "xxspltw r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "const int",
                        "implementation": "xxspltw r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "const int",
                        "implementation": "xxspltw r,a,b"
                    },
                    {
                        "id": "10",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "const int",
                        "implementation": "xxpermdi r,a,a,b"
                    },
                    {
                        "id": "11",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "const int",
                        "implementation": "xxpermdi r,a,a,b"
                    },
                    {
                        "id": "12",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "const int",
                        "implementation": "xxpermdi r,a,a,b"
                    },
                    {
                        "id": "13",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "const int",
                        "implementation": "xxspltw r,a,b"
                    },
                    {
                        "id": "14",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "const int",
                        "implementation": "xxpermdi r,a,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_splat_s8",
            "name": "Vector Splat to Signed Byte",
            "syntax": "r = vec_splat_s8 (a)",
            "purpose": "Returns a vector with all elements equal to the given value.",
            "result": "Each element of r is given the\n      sign-extended 5-bit value of a.\n      The range of this value is [-16:15].",
            "endianness": "None.",
            "instructions": [
                "vspltisb"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "5-bit signed literal",
                        "implementation": "vspltisb  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_splat_s16",
            "name": "Vector Splat to Signed Halfword",
            "syntax": "r = vec_splat_s16 (a)",
            "purpose": "Returns a vector with all elements equal to the given value.",
            "result": "Each element of r is given the\n      sign-extended 5-bit value of a.\n      The range of this value is [-16:15].",
            "endianness": "None.",
            "instructions": [
                "vspltish"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed short",
                        "a": "5-bit signed literal",
                        "implementation": "vspltish  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_splat_s32",
            "name": "Vector Splat to Signed Word",
            "syntax": "r = vec_splat_s32 (a)",
            "purpose": "Returns a vector with all elements equal to the given value.",
            "result": "Each element of r is given the\n      sign-extended 5-bit value of a.\n      The range of this value is [-16:15].",
            "endianness": "None.",
            "instructions": [
                "vspltisw"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "5-bit signed literal",
                        "implementation": "vspltisw  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_splat_u8",
            "name": "Vector Splat to Unsigned Byte",
            "syntax": "r = vec_splat_u8 (a)",
            "purpose": "Returns a vector with all elements equal to the given value.",
            "result": "The 5-bit signed value of a is\n      sign-extended to a byte and the resulting value is cast to an\n      unsigned char.  This value is placed in each element of\n      r.  The range of the original value is\n      [-16:15].",
            "endianness": "None.",
            "instructions": [
                "vspltisb"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned char",
                        "a": "5-bit signed literal",
                        "implementation": "vspltisb  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_splat_u16",
            "name": "Vector Splat to Unsigned Halfword",
            "syntax": "r = vec_splat_u16 (a)",
            "purpose": "Returns a vector with all elements equal to the given value.",
            "result": "The 5-bit signed value of a is\n      sign-extended to a halfword and the resulting value is cast to an\n      unsigned short.  This value is placed in each element of\n      r.  The range of the original value is\n      [-16:15].",
            "endianness": "None.",
            "instructions": [
                "vspltish"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned short",
                        "a": "5-bit signed literal",
                        "implementation": "vspltish  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_splat_u32",
            "name": "Vector Splat to Unsigned Word",
            "syntax": "r = vec_splat_u32 (a)",
            "purpose": "Returns a vector with all elements equal to the given value.",
            "result": "The 5-bit signed value of a is\n      sign-extended to a word and the resulting value is cast to an\n      unsigned int.  This value is placed in each element of\n      r.  The range of the original value is\n      [-16:15].",
            "endianness": "None.",
            "instructions": [
                "vspltisw"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned int",
                        "a": "5-bit signed literal",
                        "implementation": "vspltisw  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_splats",
            "name": "Vector Splat Scalar",
            "syntax": "r = vec_splats (a)",
            "purpose": "Returns a vector with the value of each element set to the value of\n      the scalar input parameter.",
            "result": "Each element of\n      r is set to the value of a.",
            "endianness": "None.",
            "instructions": [
                "rlwinm",
                "mtvsrd",
                "vspltb",
                "mtvsrwz",
                "xxspltw",
                "xxpermdi",
                "vsplth",
                "xxscvdpspn"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "signed char",
                        "implementation": "rlwinm  t,a,0,0xff\n  mtvsrd  u,t\n  vspltb  r,u,7"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "unsigned char",
                        "implementation": "rlwinm  t,a,0,0xff\n  mtvsrd  u,t\n  vspltb  r,u,7"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "signed short",
                        "implementation": "rlwinm  t,a,0,0xffff\n  mtvsrd  u,t\n  vsplth  r,u,3"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "unsigned short",
                        "implementation": "rlwinm  t,a,0,0xffff\n  mtvsrd  u,t\n  vsplth  r,u,3"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "signed int",
                        "implementation": "mtvsrd  t,a\n  vspltb  r,t,7"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "unsigned int",
                        "implementation": "mtvsrd  t,a\n  vspltb  r,t,7"
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "signed long long",
                        "implementation": "mtvsrd    t,a\n  xxpermdi  r,t,t,0"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "unsigned long long",
                        "implementation": "mtvsrd    t,a\n  xxpermdi  r,t,t,0"
                    },
                    {
                        "id": "8",
                        "r": "vector signed __int128",
                        "a": "signed __int128",
                        "implementation": "mtvsrwz  t,a\n  xxspltw  r,t,1"
                    },
                    {
                        "id": "9",
                        "r": "vector unsigned __int128",
                        "a": "unsigned __int128",
                        "implementation": "mtvsrwz  t,a\n  xxspltw  r,t,1"
                    },
                    {
                        "id": "10",
                        "r": "vector float",
                        "a": "float",
                        "implementation": "xxscvdpspn  t,a\n  xxspltw     r,t,0"
                    },
                    {
                        "id": "11",
                        "r": "vector double",
                        "a": "double",
                        "implementation": "xxpermdi  r,a,a,0"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_sqrt",
            "name": "Vector Square Root",
            "syntax": "r = vec_sqrt (a)",
            "purpose": "Returns a vector containing the square root of each element in the\n      source vector.",
            "result": "Each element of\n      r is the square root of the\n      corresponding element of a.",
            "endianness": "None.",
            "instructions": [
                "xvsqrtdp",
                "xvsqrtsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector float",
                        "implementation": "xvsqrtsp  r,a"
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector double",
                        "implementation": "xvsqrtdp  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_sr",
            "name": "Vector Shift Right",
            "syntax": "r = vec_sr (a, b)",
            "purpose": "Performs a logical right shift for each element of a vector.",
            "result": "Each element of\n      r is the result of logically\n      right-shifting the corresponding element of a by the number of bits specified by the\n      corresponding element of b, modulo the\n      number of bits in the element. Zeros are shifted in from the\n      left.",
            "endianness": "None.",
            "instructions": [
                "vsrb",
                "vsrw",
                "vsrd",
                "vsrh"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector unsigned char",
                        "implementation": "vsrb  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vsrb  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector unsigned short",
                        "implementation": "vsrh  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vsrh  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector unsigned int",
                        "implementation": "vsrw  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vsrw  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector unsigned long long",
                        "implementation": "vsrd  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vsrd  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_sra",
            "name": "Vector Shift Right Algebraic",
            "syntax": "r = vec_sra (a, b)",
            "purpose": "Performs an algebraic right shift for each element of a vector.",
            "result": "Each element of\n      r is the result of algebraically\n      right-shifting the corresponding element of a by the number of bits specified by the\n      corresponding element of b, modulo the\n      number of bits in the element. Copies of the sign bit are shifted in\n      from the left.",
            "endianness": "None.",
            "instructions": [
                "vsrab",
                "vsraw",
                "vsrad",
                "vsrah"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector unsigned char",
                        "implementation": "vsrab  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vsrab  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector unsigned short",
                        "implementation": "vsrah  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vsrah  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector unsigned int",
                        "implementation": "vsraw  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vsraw  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector unsigned long long",
                        "implementation": "vsrad  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vsrad  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_srl",
            "name": "Vector Shift Right Long",
            "syntax": "r = vec_srl (a, b)",
            "purpose": "Right shifts a vector by a given number of bits.",
            "result": "Vector r contains the contents of a, shifted right by the number of bits specified\n      by the 3 least-significant bits of b.\n      Zeros are supplied on the left. The shift count must have been\n      replicated into all bytes of b; if not,\n      the value of r is undefined.",
            "endianness": "This intrinsic is not endian-neutral, so uses of\n      vec_srl in big-endian code must be rewritten for little-endian targets.",
            "instructions": [
                "vsr"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector unsigned char",
                        "implementation": "vsr  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vsr  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector unsigned char",
                        "implementation": "vsr  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned char",
                        "implementation": "vsr  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector pixel",
                        "a": "vector pixel",
                        "b": "vector unsigned char",
                        "implementation": "vsr  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector unsigned char",
                        "implementation": "vsr  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned char",
                        "implementation": "vsr  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector unsigned char",
                        "implementation": "vsr  r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned char",
                        "implementation": "vsr  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_sro",
            "name": "Vector Shift Right by Octets",
            "syntax": "r = vec_sro (a, b)",
            "purpose": "Right shifts a vector by a given number of bytes (octets).",
            "result": "Vector\n      r receives the contents of\n      a, shifted right by the number of bytes\n      specified by bits 1\u20134 of the least-significant byte of\n      b.\n      Zeros are supplied from the left.",
            "endianness": "",
            "instructions": [
                "vsro"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector unsigned char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector signed char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector unsigned char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector signed char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector pixel",
                        "a": "vector pixel",
                        "b": "vector signed char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector pixel",
                        "a": "vector pixel",
                        "b": "vector unsigned char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "10",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "11",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector unsigned char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "12",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector signed char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "13",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "14",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "15",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector unsigned char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "16",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector signed char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "17",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "18",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector signed char",
                        "implementation": "vsro  r,a,b"
                    },
                    {
                        "id": "19",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector unsigned char",
                        "implementation": "vsro  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_srv",
            "name": "Vector Shift Right Variable",
            "syntax": "r = vec_srv (a, b)",
            "purpose": "Right-shifts a vector by a varying number of bits by element.",
            "result": "Let v be a 17-byte vector formed from a zero byte\n      in element 0 and the elements of a\n      in bytes [1:16].  Then each byte element i of\n      r is determined as follows.  The\n      start bit sb is obtained from bits 5:7 of\n      byte element i of b.  Then the contents of bits\n      (8 \u2013 sb):(15 \u2013 sb) of the\n      halfword in byte elements i:i+1\n      of v are placed into byte element\n      i of r.",
            "endianness": "All bit and byte element numbers are specified in big-endian order.\n      This intrinsic is not endian-neutral.",
            "instructions": [
                "vsrv"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vsrv  r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_st",
            "name": "Vector Store Indexed",
            "syntax": "vec_st (a, b, c)",
            "purpose": "Stores a 16-byte vector into memory at the address specified by a\n      displacement and a pointer, ignoring the four low-order bits\n      of the calculated address.",
            "result": "A memory address\n      is obtained by adding b and c, and masking off the four low-order bits of the\n      result.  The 16-byte vector in a is\n      stored to the resultant memory address.",
            "endianness": "None.",
            "instructions": [
                "stvx"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example ISA 3.0\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "a": "vector bool char",
                        "b": "signed long long",
                        "c": "vector bool char *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "1",
                        "a": "vector bool char",
                        "b": "signed long long",
                        "c": "signed char *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "2",
                        "a": "vector bool char",
                        "b": "signed long long",
                        "c": "unsigned char *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "3",
                        "a": "vector signed char",
                        "b": "signed long long",
                        "c": "signed char *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "4",
                        "a": "vector signed char",
                        "b": "signed long long",
                        "c": "vector signed char *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "5",
                        "a": "vector unsigned char",
                        "b": "signed long long",
                        "c": "unsigned char *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "6",
                        "a": "vector unsigned char",
                        "b": "signed long long",
                        "c": "vector unsigned char *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "7",
                        "a": "vector bool short",
                        "b": "signed long long",
                        "c": "vector bool short *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "8",
                        "a": "vector bool short",
                        "b": "signed long long",
                        "c": "signed short *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "9",
                        "a": "vector bool short",
                        "b": "signed long long",
                        "c": "unsigned short *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "10",
                        "a": "vector signed short",
                        "b": "signed long long",
                        "c": "signed short *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "11",
                        "a": "vector signed short",
                        "b": "signed long long",
                        "c": "vector signed short *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "12",
                        "a": "vector unsigned short",
                        "b": "signed long long",
                        "c": "unsigned short *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "13",
                        "a": "vector unsigned short",
                        "b": "signed long long",
                        "c": "vector unsigned short *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "14",
                        "a": "vector pixel",
                        "b": "signed long long",
                        "c": "vector pixel *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "15",
                        "a": "vector bool int",
                        "b": "signed long long",
                        "c": "vector bool int *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "16",
                        "a": "vector bool int",
                        "b": "signed long long",
                        "c": "signed int *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "17",
                        "a": "vector bool int",
                        "b": "signed long long",
                        "c": "unsigned int *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "18",
                        "a": "vector signed int",
                        "b": "signed long long",
                        "c": "signed int *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "19",
                        "a": "vector signed int",
                        "b": "signed long long",
                        "c": "vector signed int *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "20",
                        "a": "vector unsigned int",
                        "b": "signed long long",
                        "c": "unsigned int *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "21",
                        "a": "vector unsigned int",
                        "b": "signed long long",
                        "c": "vector unsigned int *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "22",
                        "a": "vector bool long long",
                        "b": "signed long long",
                        "c": "vector bool long long *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "23",
                        "a": "vector signed long long",
                        "b": "signed long long",
                        "c": "signed long long *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "24",
                        "a": "vector signed long long",
                        "b": "signed long long",
                        "c": "vector signed long long *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "25",
                        "a": "vector unsigned long long",
                        "b": "signed long long",
                        "c": "unsigned long long *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "26",
                        "a": "vector unsigned long long",
                        "b": "signed long long",
                        "c": "vector unsigned long long *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "27",
                        "a": "vector float",
                        "b": "signed long long",
                        "c": "float *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "28",
                        "a": "vector float",
                        "b": "signed long long",
                        "c": "vector float *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "29",
                        "a": "vector double",
                        "b": "signed long long",
                        "c": "double *",
                        "implementation": "stvx  r,b,a"
                    },
                    {
                        "id": "30",
                        "a": "vector double",
                        "b": "signed long long",
                        "c": "vector double *",
                        "implementation": "stvx  r,b,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_ste",
            "name": "Vector Store Element Indexed",
            "syntax": "vec_ste (a, b, c)",
            "purpose": "Stores a single element from a 16-byte vector into memory at the address\n      specified by a displacement and a pointer, aligned to the element size.",
            "result": "The integer value\n      b is added to the pointer value\n      c.  The resulting address is rounded\n      down to the nearest address that is a multiple of\n      es, where es is 1 for char\n      pointers, 2 for short pointers, and 4 for float or int pointers.\n      An element offset eo is calculated by taking the\n      resultant address modulo 16.  The vector element of a at offset eo is stored\n      to the resultant address.",
            "endianness": "None.",
            "instructions": [
                "stvebx",
                "stvewx",
                "stvehx"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example ISA 3.0\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "a": "vector bool char",
                        "b": "signed long long",
                        "c": "signed char *",
                        "implementation": "stvebx  r,b,a"
                    },
                    {
                        "id": "1",
                        "a": "vector bool char",
                        "b": "signed long long",
                        "c": "unsigned char *",
                        "implementation": "stvebx  r,b,a"
                    },
                    {
                        "id": "2",
                        "a": "vector signed char",
                        "b": "signed long long",
                        "c": "signed char *",
                        "implementation": "stvebx  r,b,a"
                    },
                    {
                        "id": "3",
                        "a": "vector unsigned char",
                        "b": "signed long long",
                        "c": "unsigned char *",
                        "implementation": "stvebx  r,b,a"
                    },
                    {
                        "id": "4",
                        "a": "vector bool short",
                        "b": "signed long long",
                        "c": "signed short *",
                        "implementation": "stvehx  r,b,a"
                    },
                    {
                        "id": "5",
                        "a": "vector bool short",
                        "b": "signed long long",
                        "c": "unsigned short *",
                        "implementation": "stvehx  r,b,a"
                    },
                    {
                        "id": "6",
                        "a": "vector signed short",
                        "b": "signed long long",
                        "c": "signed short *",
                        "implementation": "stvehx  r,b,a"
                    },
                    {
                        "id": "7",
                        "a": "vector unsigned short",
                        "b": "signed long long",
                        "c": "unsigned short *",
                        "implementation": "stvehx  r,b,a"
                    },
                    {
                        "id": "8",
                        "a": "vector pixel",
                        "b": "signed long long",
                        "c": "unsigned short *",
                        "implementation": "stvehx  r,b,a"
                    },
                    {
                        "id": "9",
                        "a": "vector bool int",
                        "b": "signed long long",
                        "c": "signed int *",
                        "implementation": "stvewx  r,b,a"
                    },
                    {
                        "id": "10",
                        "a": "vector bool int",
                        "b": "signed long long",
                        "c": "unsigned int *",
                        "implementation": "stvewx  r,b,a"
                    },
                    {
                        "id": "11",
                        "a": "vector signed int",
                        "b": "signed long long",
                        "c": "signed int *",
                        "implementation": "stvewx  r,b,a"
                    },
                    {
                        "id": "12",
                        "a": "vector unsigned int",
                        "b": "signed long long",
                        "c": "unsigned int *",
                        "implementation": "stvewx  r,b,a"
                    },
                    {
                        "id": "13",
                        "a": "vector float",
                        "b": "signed long long",
                        "c": "float *",
                        "implementation": "stvewx  r,b,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_stl",
            "name": "Vector Store Indexed Least Recently Used",
            "syntax": "vec_stl (a, b, c)",
            "purpose": "Stores a 16-byte vector into memory at the address specified by a\n      displacement and a pointer, ignoring the four low-order bits\n      of the calculated address, and marking the cache line containing\n      the address as least frequently used.",
            "result": "A memory address\n      is obtained by adding b and c, and masking off the four low-order bits of the\n      result.  The 16-byte vector in a is\n      stored to the resultant memory address, and the containing cache\n      line is marked as least frequently used.",
            "endianness": "None.",
            "instructions": [
                "stvxl"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example ISA 3.0\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "a": "vector bool char",
                        "b": "signed long long",
                        "c": "vector bool char *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "1",
                        "a": "vector bool char",
                        "b": "signed long long",
                        "c": "signed char *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "2",
                        "a": "vector bool char",
                        "b": "signed long long",
                        "c": "unsigned char *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "3",
                        "a": "vector signed char",
                        "b": "signed long long",
                        "c": "signed char *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "4",
                        "a": "vector signed char",
                        "b": "signed long long",
                        "c": "vector signed char *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "5",
                        "a": "vector unsigned char",
                        "b": "signed long long",
                        "c": "unsigned char *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "6",
                        "a": "vector unsigned char",
                        "b": "signed long long",
                        "c": "vector unsigned char *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "7",
                        "a": "vector bool short",
                        "b": "signed long long",
                        "c": "vector bool short *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "8",
                        "a": "vector bool short",
                        "b": "signed long long",
                        "c": "signed short *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "9",
                        "a": "vector bool short",
                        "b": "signed long long",
                        "c": "unsigned short *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "10",
                        "a": "vector signed short",
                        "b": "signed long long",
                        "c": "signed short *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "11",
                        "a": "vector signed short",
                        "b": "signed long long",
                        "c": "vector signed short *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "12",
                        "a": "vector unsigned short",
                        "b": "signed long long",
                        "c": "unsigned short *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "13",
                        "a": "vector unsigned short",
                        "b": "signed long long",
                        "c": "vector unsigned short *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "14",
                        "a": "vector pixel",
                        "b": "signed long long",
                        "c": "vector pixel *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "15",
                        "a": "vector bool int",
                        "b": "signed long long",
                        "c": "vector bool int *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "16",
                        "a": "vector bool int",
                        "b": "signed long long",
                        "c": "signed int *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "17",
                        "a": "vector bool int",
                        "b": "signed long long",
                        "c": "unsigned int *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "18",
                        "a": "vector signed int",
                        "b": "signed long long",
                        "c": "signed int *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "19",
                        "a": "vector signed int",
                        "b": "signed long long",
                        "c": "vector signed int *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "20",
                        "a": "vector unsigned int",
                        "b": "signed long long",
                        "c": "unsigned int *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "21",
                        "a": "vector unsigned int",
                        "b": "signed long long",
                        "c": "vector unsigned int *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "22",
                        "a": "vector bool long long",
                        "b": "signed long long",
                        "c": "vector bool long long *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "23",
                        "a": "vector signed long long",
                        "b": "signed long long",
                        "c": "signed long long *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "24",
                        "a": "vector signed long long",
                        "b": "signed long long",
                        "c": "vector signed long long *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "25",
                        "a": "vector unsigned long long",
                        "b": "signed long long",
                        "c": "unsigned long long *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "26",
                        "a": "vector unsigned long long",
                        "b": "signed long long",
                        "c": "vector unsigned long long *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "27",
                        "a": "vector float",
                        "b": "signed long long",
                        "c": "float *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "28",
                        "a": "vector float",
                        "b": "signed long long",
                        "c": "vector float *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "29",
                        "a": "vector double",
                        "b": "signed long long",
                        "c": "double *",
                        "implementation": "stvxl  r,b,a"
                    },
                    {
                        "id": "30",
                        "a": "vector double",
                        "b": "signed long long",
                        "c": "vector double *",
                        "implementation": "stvxl  r,b,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_sub",
            "name": "Vector Subtract",
            "syntax": "r = vec_sub (a, b)",
            "purpose": "Returns a vector containing the result of subtracting each element of\n      one source vector from the corresponding element of another source\n      vector.",
            "result": "The value of each\n      element of r is the result of\n      subtracting the value of the corresponding element of b from the value of the corresponding element of\n      a. The arithmetic is modular for\n      integer vectors.",
            "endianness": "None.",
            "instructions": [
                "vsububm",
                "vsubuwm",
                "vsubuqm",
                "vsubudm",
                "vsubuhm",
                "xvsubdp",
                "xvsubsp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vsububm  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vsububm  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vsubuhm  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vsubuhm  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vsubuwm  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vsubuwm  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "vsubudm  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "vsubudm  r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector signed __int128",
                        "a": "vector signed __int128",
                        "b": "vector signed __int128",
                        "implementation": "vsubuqm  r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector unsigned __int128",
                        "a": "vector unsigned __int128",
                        "b": "vector unsigned __int128",
                        "implementation": "vsubuqm  r,a,b"
                    },
                    {
                        "id": "10",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xvsubsp  r,a,b"
                    },
                    {
                        "id": "11",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xvsubdp  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_subc",
            "name": "Vector Subtract Carryout",
            "syntax": "r = vec_subc (a, b)",
            "purpose": "Returns a vector wherein each element contains the carry\n      produced by subtracting the corresponding elements of the two\n      source vectors.",
            "result": "The value of each\n      element of r is the complement of the\n      carry produced by subtracting the value of the corresponding element of\n      b from the value of the corresponding\n      element of a. The value is 0 if a\n      borrow occurred, or 1 if no borrow occurred.",
            "endianness": "None.",
            "instructions": [
                "vsubcuw",
                "vsubcuq"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vsubcuw  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vsubcuw  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed __int128",
                        "a": "vector signed __int128",
                        "b": "vector signed __int128",
                        "implementation": "vsubcuq  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned __int128",
                        "a": "vector unsigned __int128",
                        "b": "vector unsigned __int128",
                        "implementation": "vsubcuq  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_sube",
            "name": "Vector Subtract Extended",
            "syntax": "r = vec_sube (a, b, c)",
            "purpose": "Returns a vector containing the result of first elementwise subtracting\n      one vector from another vector, and then elementwise adding a third\n      carry vector. Elements of the carry vector have a value of 0 or 1.",
            "result": "Let c' be a vector for which each element is 0 if\n      the rightmost bit of the corresponding element of c is 0, and 1 otherwise. Then the value of each\n      element of r is produced by subtracting\n      the corresponding element of b from the\n      corresponding element of a, and then\n      adding the corresponding element of c'.",
            "endianness": "None.",
            "instructions": [
                "vspltisw",
                "vsubuwm",
                "xxland",
                "vsubeuqm"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "c": "vector signed int",
                        "implementation": "vspltisw  t,1\n  vsubuwm   u,a,b\n  xxland    v,c,t\n  vsubuwm   r,u,v"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "c": "vector unsigned int",
                        "implementation": "vspltisw  t,1\n  vsubuwm   u,a,b\n  xxland    v,c,t\n  vsubuwm   r,u,v"
                    },
                    {
                        "id": "2",
                        "r": "vector signed __int128",
                        "a": "vector signed __int128",
                        "b": "vector signed __int128",
                        "c": "vector signed __int128",
                        "implementation": "vsubeuqm  r,a,b,c"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned __int128",
                        "a": "vector unsigned __int128",
                        "b": "vector unsigned __int128",
                        "c": "vector unsigned __int128",
                        "implementation": "vsubeuqm  r,a,b,c"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_subec",
            "name": "Vector Subtract Extended Carryout",
            "syntax": "r = vec_subec (a, b, c)",
            "purpose": "Returns a vector containing the carries produced by subtracting one\n      vector from another, then adding a third vector to the difference.  The\n      third vector is a carry vector, with each element having a value of 0\n      or 1.",
            "result": "The value of each\n      element of r is the carry produced by\n      subtracting the corresponding element of b from the corresponding element of a, and then adding the carry specified in the\n      corresponding element of c (1 if there\n      is a carry, 0 otherwise).",
            "endianness": "None.",
            "instructions": [
                "vspltisw",
                "xxland",
                "vsubuwm",
                "vsubcuw",
                "xxlor",
                "vsubecuq"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "c": "vector signed int",
                        "implementation": "vspltisw  t,1\n  xxland    u,c,t\n  vsubuwm   v,a,b\n  vsubcuw   w,a,b\n  vsubcuw   x,v,u\n  xxlor     r,w,x"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "c": "vector unsigned int",
                        "implementation": "vspltisw  t,1\n  xxland    u,c,t\n  vsubuwm   v,a,b\n  vsubcuw   w,a,b\n  vsubcuw   x,v,u\n  xxlor     r,w,x"
                    },
                    {
                        "id": "2",
                        "r": "vector signed __int128",
                        "a": "vector signed __int128",
                        "b": "vector signed __int128",
                        "c": "vector signed __int128",
                        "implementation": "vsubecuq  r,a,b,c"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned __int128",
                        "a": "vector unsigned __int128",
                        "b": "vector unsigned __int128",
                        "c": "vector unsigned __int128",
                        "implementation": "vsubecuq  r,a,b,c"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_subs",
            "name": "Vector Subtract Saturated",
            "syntax": "r = vec_subs (a, b)",
            "purpose": "Returns a vector containing the saturated differences of each set of\n      corresponding elements of the source vectors.",
            "result": "The value of each\n      element of r is the saturated result of\n      subtracting the value of the corresponding element of b from the value of the corresponding element of\n      a.",
            "endianness": "None.",
            "instructions": [
                "vsubsbs",
                "vsububs",
                "vsubsws",
                "vsubuws",
                "vsubshs",
                "vsubuhs"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "vsubsbs  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "vsububs  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "vsubshs  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "vsubuhs  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vsubsws  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "vsubuws  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_sum2s",
            "name": "Vector Sum Across Half",
            "syntax": "r = vec_sum2s (a, b)",
            "purpose": "Returns a vector containing the results of performing a sum-across\n      operation within each doubleword of the first source vector together with\n      accumulated results in the second source vector.",
            "result": "Elements 0 and 2\n      of r are 0. Element 1 of r contains the saturated sum of elements 0 and 1\n      of a and element 1 of b. Element 3 of r contains the saturated sum of elements 2 and 3\n      of a and element 3 of b.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vsldoi",
                "vsum2sws"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE\nImplementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vsum2sws  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_sum4s",
            "name": "Vector Sum Across Quarter",
            "syntax": "r = vec_sum4s (a, b)",
            "purpose": "Returns a vector containing the results of performing a sum-across\n      operation within each word of the first source vector together with\n      accumulated results in the second source vector.",
            "result": "",
            "endianness": "None.",
            "instructions": [
                "vsum4sbs",
                "vsum4shs",
                "vsum4ubs"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "vector signed char",
                        "b": "vector signed int",
                        "implementation": "vsum4sbs  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned int",
                        "a": "vector unsigned char",
                        "b": "vector unsigned int",
                        "implementation": "vsum4ubs  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed int",
                        "a": "vector signed short",
                        "b": "vector signed int",
                        "implementation": "vsum4shs  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_sums",
            "name": "Vector Sum Across",
            "syntax": "r = vec_sums (a, b)",
            "purpose": "Returns a vector containing the results of performing a sum-across\n      operation on the first source vector together with accumulated results\n      in the second source vector.",
            "result": "Elements 0, 1, and 2\n      of r are 0. Element 3 is the saturated\n      sum of all the elements of a and\n      element 3 of b.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "vspltw",
                "vsumsws",
                "vsldoi"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE\nImplementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "vsumsws  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_test_data_class",
            "name": "Vector Test Data Class",
            "syntax": "r = vec_test_data_class (a, b)",
            "purpose": "Determines the data class for each floating-point element.",
            "result": "",
            "endianness": "None.",
            "instructions": [
                "xvtstdcsp",
                "xvtstdcdp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool int",
                        "a": "vector float",
                        "b": "7-bit unsigned literal",
                        "implementation": "xvtstdcsp  r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "vector bool long long",
                        "a": "vector double",
                        "b": "7-bit unsigned literal",
                        "implementation": "xvtstdcdp  r,a,b",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_trunc",
            "name": "Vector Truncate",
            "syntax": "r = vec_trunc (a)",
            "purpose": "Returns a vector containing the truncated values of the corresponding\n      elements of the source vector.",
            "result": "Each element of\n      r contains the value of the\n      corresponding element of a, truncated\n      to an integral value.",
            "endianness": "None.",
            "instructions": [
                "xvrdpiz",
                "xvrspiz"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector float",
                        "a": "vector float",
                        "implementation": "xvrspiz  r,a"
                    },
                    {
                        "id": "1",
                        "r": "vector double",
                        "a": "vector double",
                        "implementation": "xvrdpiz  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_unpackh",
            "name": "Vector Unpack High",
            "syntax": "r = vec_unpackh (a)",
            "purpose": "Unpacks the most-significant (\u201chigh\u201d) half of a vector into a vector\n      with larger elements.",
            "result": "If a is an integer vector, the value of each element\n      of r is the value of the corresponding\n      element of the most-significant half of a.",
            "endianness": "The &quot;high&quot; half of a vector with n elements is the\n      first n/2 elements of the vector.  For little\n      endian, these elements are in the rightmost half of the vector.  For\n      big endian, these elements are in the leftmost half of the vector.",
            "instructions": [
                "vupklsh",
                "vupkhsh",
                "vupklpx",
                "vupkhpx",
                "vupklsw",
                "vupkhsw",
                "vupklsb",
                "vupkhsb",
                "xxsldwi",
                "xvcvspdp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE\nImplementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool short",
                        "a": "vector bool char",
                        "implementation": "vupkhsb  r,a"
                    },
                    {
                        "id": "1",
                        "r": "vector signed short",
                        "a": "vector signed char",
                        "implementation": "vupkhsb  r,a"
                    },
                    {
                        "id": "2",
                        "r": "vector bool int",
                        "a": "vector bool short",
                        "implementation": "vupkhsh  r,a"
                    },
                    {
                        "id": "3",
                        "r": "vector signed int",
                        "a": "vector signed short",
                        "implementation": "vupkhsh  r,a"
                    },
                    {
                        "id": "4",
                        "r": "vector unsigned int",
                        "a": "vector pixel",
                        "implementation": "vupkhpx  r,a"
                    },
                    {
                        "id": "5",
                        "r": "vector bool long long",
                        "a": "vector bool int",
                        "implementation": "vupkhsw  r,a"
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "vector signed int",
                        "implementation": "vupkhsw  r,a"
                    },
                    {
                        "id": "7",
                        "r": "vector double",
                        "a": "vector float",
                        "implementation": "xxsldwi   t,a,a,1\n xxsldwi   u,t,a,3\n xvcvspdp  r,u"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_unpackl",
            "name": "Vector Unpack Low",
            "syntax": "r = vec_unpackl (a)",
            "purpose": "Unpacks the least-significant (\u201clow\u201d) half of a vector into a vector\n      with larger elements.",
            "result": "If a is an integer vector, the value of each element\n      of r is the value of the corresponding\n      element of the least-significant half of a.",
            "endianness": "The &quot;high&quot; half of a vector with n elements is the\n      first n/2 elements of the vector.  For little\n      endian, these elements are in the rightmost half of the vector.  For\n      big endian, these elements are in the leftmost half of the vector.",
            "instructions": [
                "vupkhsh",
                "vupklsh",
                "vupkhpx",
                "vupklpx",
                "vupkhsw",
                "vupklsw",
                "vupkhsb",
                "vupklsb",
                "xxsldwi",
                "xvcvspdp"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE\nImplementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool short",
                        "a": "vector bool char",
                        "implementation": "vupklsb  r,a"
                    },
                    {
                        "id": "1",
                        "r": "vector signed short",
                        "a": "vector signed char",
                        "implementation": "vupklsb  r,a"
                    },
                    {
                        "id": "2",
                        "r": "vector bool int",
                        "a": "vector bool short",
                        "implementation": "vupklsh  r,a"
                    },
                    {
                        "id": "3",
                        "r": "vector signed int",
                        "a": "vector signed short",
                        "implementation": "vupklsh  r,a"
                    },
                    {
                        "id": "4",
                        "r": "vector unsigned int",
                        "a": "vector pixel",
                        "implementation": "vupklpx  r,a"
                    },
                    {
                        "id": "5",
                        "r": "vector bool long long",
                        "a": "vector bool int",
                        "implementation": "vupklsw  r,a"
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "vector signed int",
                        "implementation": "vupklsw  r,a"
                    },
                    {
                        "id": "7",
                        "r": "vector double",
                        "a": "vector float",
                        "implementation": "xxsldwi   t,a,a,3\n xxsldwi   u,a,t,2\n xvcvspdp  r,u"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_unsigned",
            "name": "Vector Convert Floating-Point to Unsigned Integer",
            "syntax": "r = vec_unsigned (a)",
            "purpose": "Converts a vector of floating-point numbers to a vector of unsigned\n      integers.",
            "result": "Each element of\n      r is obtained by truncating the\n      corresponding element of a to an\n      unsigned integer.  The current floating-point rounding mode is\n      ignored.",
            "endianness": "None.",
            "instructions": [
                "xvcvspsxws",
                "xvcvdpsxds"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned int",
                        "a": "vector float",
                        "implementation": "xvcvspsxws  r,a"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned long long",
                        "a": "vector double",
                        "implementation": "xvcvdpsxds  r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_unsigned2",
            "name": "Vector Convert Double-Precision to Unsigned Word",
            "syntax": "r = vec_unsigned2 (a, b)",
            "purpose": "Converts two vectors of double-precision floating-point numbers to a\n      vector of unsigned 32-bit integers.",
            "result": "Let v be the concatenation of a and b.  Each\n      element of r is obtained by truncating\n      the corresponding element of v to an\n      unsigned 32-bit integer.  The current floating-point rounding\n      mode is ignored.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "xxpermdi",
                "xvcvdpuxws",
                "vmrgow",
                "vmrgew"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE\nImplementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned int",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xxpermdi   t,a,b,3\n xxpermdi   u,a,b,0\n xvcvdpuxws v,t\n xvcvdpuxws w,u\n vmrgew     r,v,w"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_unsignede",
            "name": "Vector Convert Double-Precision to Unsigned Word Even",
            "syntax": "r = vec_unsignede (a)",
            "purpose": "Converts elements of the source vector to unsigned integers and stores\n      them in the even-numbered elements of the result vector.",
            "result": "Element 0 of\n      r contains element 0 of a, truncated to an unsigned integer.  Element 2 of\n      r contains element 1 of a, truncated to a signed integer.  Elements 1 and\n      3 of r are undefined.  Truncation\n      of a negative number to an unsigned integer results in a value of\n      zero.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "xvcvdpuxws",
                "vsldoi"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE\nImplementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned int",
                        "a": "vector double",
                        "implementation": "xvcvdpuxws r,a"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_unsignedo",
            "name": "Vector Convert Double-Precision to Unsigned Word Odd",
            "syntax": "r = vec_unsignedo (a)",
            "purpose": "Converts elements of the source vector to unsigned integers and stores\n      them in the odd-numbered elements of the result vector.",
            "result": "Element 1 of\n      r contains element 0 of a, truncated to an unsigned integer.  Element 3 of\n      r contains element 1 of a, truncated to an unsigned integer.  Elements 0\n      and 2 of r are undefined.  Truncation\n      of a negative number to an unsigned integer results in a value of\n      zero.",
            "endianness": "The element numbering within a register is left-to-right for big-endian\n      targets, and right-to-left for little-endian targets.",
            "instructions": [
                "xvcvdpuxws",
                "vsldoi"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "implementation",
                        "header": "Example LE\nImplementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example BE\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned int",
                        "a": "vector double",
                        "implementation": "xvcvdpuxws t,a\n vsldoi     r,t,t,12"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_xl",
            "name": "VSX Unaligned Load",
            "syntax": "r = vec_xl (a, b)",
            "purpose": "Loads a 16-byte vector from the memory address specified by the\n      displacement and the pointer.",
            "result": "The value of\n      r is obtained by adding a and b, then\n      loading the 16-byte vector from the resultant memory address.",
            "endianness": "For ISA 2.07, there is no bi-endian unaligned load instruction.\n      For little-endian targets, it is necessary to use the lxvd2x instruction\n      and swap the doublewords with an xxswapd instruction.  For big-endian\n      targets, the lxvd2x instruction or lxvw4x instruction suffices.  The\n      examples below assume ISA 3.0, where the bi-endian lxv instruction is\n      available.",
            "instructions": [
                "lxv"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example ISA 3.0\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "signed long long",
                        "b": "const signed char *",
                        "implementation": "lxv  r,a(b)"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "signed long long",
                        "b": "const unsigned char *",
                        "implementation": "lxv  r,a(b)"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "signed long long",
                        "b": "const signed short *",
                        "implementation": "lxv  r,a(b)"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "signed long long",
                        "b": "const unsigned short *",
                        "implementation": "lxv  r,a(b)"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "signed long long",
                        "b": "const signed int *",
                        "implementation": "lxv  r,a(b)"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "signed long long",
                        "b": "const unsigned int *",
                        "implementation": "lxv  r,a(b)"
                    },
                    {
                        "id": "6",
                        "r": "vector signed signed long long",
                        "a": "signed long long",
                        "b": "const signed long long *",
                        "implementation": "lxv  r,a(b)"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "signed long long",
                        "b": "const unsigned long long *",
                        "implementation": "lxv  r,a(b)"
                    },
                    {
                        "id": "8",
                        "r": "vector signed __int128",
                        "a": "signed long long",
                        "b": "const signed __int128 *",
                        "implementation": "lxv  r,a(b)"
                    },
                    {
                        "id": "9",
                        "r": "vector unsigned __int128",
                        "a": "signed long long",
                        "b": "const unsigned __int128 *",
                        "implementation": "lxv  r,a(b)"
                    },
                    {
                        "id": "10",
                        "r": "vector float",
                        "a": "signed long long",
                        "b": "const float *",
                        "implementation": "lxv  r,a(b)"
                    },
                    {
                        "id": "11",
                        "r": "vector double",
                        "a": "signed long long",
                        "b": "const double *",
                        "implementation": "lxv  r,a(b)"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_xl_be",
            "name": "VSX Unaligned Load as Big Endian",
            "syntax": "r = vec_xl_be (a, b)",
            "purpose": "Loads a vector from an address into a register in big-endian element\n      order, regardless of the endianness of the target machine.",
            "result": "The value of\n      r is obtained by adding a and b, then\n      loading the vector elements from the resulting address in big-endian\n      order.",
            "endianness": "In big-endian mode, this acts just like the vec_xl intrinsic.\n      In little-endian mode, the highest-numbered element of r is loaded from the lowest data address, and\n      the lowest-numbered element of r from\n      the highest data address.",
            "instructions": [
                "lxvb16x",
                "lxv",
                "lxvw4x",
                "lxvd2x",
                "lxvh8x"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example ISA 3.0 LE\nImplementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example ISA 3.0 BE\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "signed long long",
                        "b": "const signed char *",
                        "implementation": "lxv r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "signed long long",
                        "b": "const unsigned char *",
                        "implementation": "lxv r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "signed long long",
                        "b": "const signed short *",
                        "implementation": "lxv r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "signed long long",
                        "b": "const unsigned short *",
                        "implementation": "lxv r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "signed long long",
                        "b": "const signed int *",
                        "implementation": "lxv r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "signed long long",
                        "b": "const unsigned int *",
                        "implementation": "lxv r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "signed long long",
                        "b": "const signed long long *",
                        "implementation": "lxv r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "signed long long",
                        "b": "const unsigned long long *",
                        "implementation": "lxv r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector signed __int128",
                        "a": "signed long long",
                        "b": "const signed __int128 *",
                        "implementation": "lxv r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector unsigned __int128",
                        "a": "signed long long",
                        "b": "const unsigned __int128 *",
                        "implementation": "lxv r,a,b"
                    },
                    {
                        "id": "10",
                        "r": "vector float",
                        "a": "signed long long",
                        "b": "const float *",
                        "implementation": "lxv r,a,b"
                    },
                    {
                        "id": "11",
                        "r": "vector double",
                        "a": "signed long long",
                        "b": "const double *",
                        "implementation": "lxv r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_xl_len",
            "name": "Vector Load with Length",
            "syntax": "r = vec_xl_len (a, b)",
            "purpose": "Loads a vector of a specified byte length.",
            "result": "Loads the number of\n      bytes specified by b from the address\n      specified in a. Initializes elements in\n      order from the byte stream (as defined by the endianness of the target).\n      Any bytes of elements that cannot be initialized from the\n      number of loaded bytes have a zero value.",
            "endianness": "None.",
            "instructions": [
                "sldi",
                "lxvl"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example\nImplementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector signed char",
                        "a": "const signed char *",
                        "b": "size_t",
                        "implementation": "sldi  t,b,56\n  lxvl  r,a,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "r": "vector unsigned char",
                        "a": "const unsigned char *",
                        "b": "size_t",
                        "implementation": "sldi  t,b,56\n  lxvl  r,a,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "2",
                        "r": "vector signed short",
                        "a": "const signed short *",
                        "b": "size_t",
                        "implementation": "sldi  t,b,56\n  lxvl  r,a,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "3",
                        "r": "vector unsigned short",
                        "a": "const unsigned short *",
                        "b": "size_t",
                        "implementation": "sldi  t,b,56\n  lxvl  r,a,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "4",
                        "r": "vector signed int",
                        "a": "const signed int *",
                        "b": "size_t",
                        "implementation": "sldi  t,b,56\n  lxvl  r,a,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned int",
                        "a": "const unsigned int *",
                        "b": "size_t",
                        "implementation": "sldi  t,b,56\n  lxvl  r,a,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "6",
                        "r": "vector signed long long",
                        "a": "const signed long long *",
                        "b": "size_t",
                        "implementation": "sldi  t,b,56\n  lxvl  r,a,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "7",
                        "r": "vector unsigned long long",
                        "a": "const unsigned long long *",
                        "b": "size_t",
                        "implementation": "sldi  t,b,56\n  lxvl  r,a,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "8",
                        "r": "vector signed __int128",
                        "a": "const signed __int128 *",
                        "b": "size_t",
                        "implementation": "sldi  t,b,56\n  lxvl  r,a,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "9",
                        "r": "vector unsigned __int128",
                        "a": "const unsigned __int128 *",
                        "b": "size_t",
                        "implementation": "sldi  t,b,56\n  lxvl  r,a,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "10",
                        "r": "vector float",
                        "a": "const float *",
                        "b": "size_t",
                        "implementation": "sldi  t,b,56\n  lxvl  r,a,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "11",
                        "r": "vector double",
                        "a": "const double *",
                        "b": "size_t",
                        "implementation": "sldi  t,b,56\n  lxvl  r,a,t",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_xl_len_r",
            "name": "Vector Load with Length Right-Justified",
            "syntax": "r = vec_xl_len_r (a, b)",
            "purpose": "Loads a vector of a specified byte length, right-justified.",
            "result": "Loads the number of\n      bytes specified by b from the address\n      specified in a, right justified in\n      r. Initializes elements in order from\n      the byte stream (as defined by the endianness of the target).\n      Any bytes of elements that cannot be initialized from the\n      number of loaded bytes have a zero value.",
            "endianness": "None.",
            "instructions": [
                "sldi",
                "lvsl",
                "lxvll",
                "vperm"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example\nImplementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector unsigned char",
                        "a": "const unsigned char *",
                        "b": "size_t",
                        "implementation": "sldi  t,b,56\n  lvsl  u,0,b\n  lxvll v,a,t\n  vperm r,v,v,u",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_xor",
            "name": "Vector Exclusive OR",
            "syntax": "r = vec_xor (a, b)",
            "purpose": "Performs a bitwise XOR of two vectors.",
            "result": "v is the bitwise\n      exclusive OR of a and b.",
            "endianness": "None.",
            "instructions": [
                "xxlxor"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "r",
                        "header": "r"
                    },
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "r": "vector bool char",
                        "a": "vector bool char",
                        "b": "vector bool char",
                        "implementation": "xxlxor  r,a,b"
                    },
                    {
                        "id": "1",
                        "r": "vector signed char",
                        "a": "vector signed char",
                        "b": "vector signed char",
                        "implementation": "xxlxor  r,a,b"
                    },
                    {
                        "id": "2",
                        "r": "vector unsigned char",
                        "a": "vector unsigned char",
                        "b": "vector unsigned char",
                        "implementation": "xxlxor  r,a,b"
                    },
                    {
                        "id": "3",
                        "r": "vector bool short",
                        "a": "vector bool short",
                        "b": "vector bool short",
                        "implementation": "xxlxor  r,a,b"
                    },
                    {
                        "id": "4",
                        "r": "vector signed short",
                        "a": "vector signed short",
                        "b": "vector signed short",
                        "implementation": "xxlxor  r,a,b"
                    },
                    {
                        "id": "5",
                        "r": "vector unsigned short",
                        "a": "vector unsigned short",
                        "b": "vector unsigned short",
                        "implementation": "xxlxor  r,a,b"
                    },
                    {
                        "id": "6",
                        "r": "vector bool int",
                        "a": "vector bool int",
                        "b": "vector bool int",
                        "implementation": "xxlxor  r,a,b"
                    },
                    {
                        "id": "7",
                        "r": "vector signed int",
                        "a": "vector signed int",
                        "b": "vector signed int",
                        "implementation": "xxlxor  r,a,b"
                    },
                    {
                        "id": "8",
                        "r": "vector unsigned int",
                        "a": "vector unsigned int",
                        "b": "vector unsigned int",
                        "implementation": "xxlxor  r,a,b"
                    },
                    {
                        "id": "9",
                        "r": "vector bool long long",
                        "a": "vector bool long long",
                        "b": "vector bool long long",
                        "implementation": "xxlxor  r,a,b"
                    },
                    {
                        "id": "10",
                        "r": "vector signed long long",
                        "a": "vector signed long long",
                        "b": "vector signed long long",
                        "implementation": "xxlxor  r,a,b"
                    },
                    {
                        "id": "11",
                        "r": "vector unsigned long long",
                        "a": "vector unsigned long long",
                        "b": "vector unsigned long long",
                        "implementation": "xxlxor  r,a,b"
                    },
                    {
                        "id": "12",
                        "r": "vector float",
                        "a": "vector float",
                        "b": "vector float",
                        "implementation": "xxlxor  r,a,b"
                    },
                    {
                        "id": "13",
                        "r": "vector double",
                        "a": "vector double",
                        "b": "vector double",
                        "implementation": "xxlxor  r,a,b"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_xst",
            "name": "VSX Unaligned Store",
            "syntax": "vec_xst (a, b, c)",
            "purpose": "Stores a 16-byte value into memory at the address specified by the\n      displacement and pointer.",
            "result": "The values of\n      b and c are added, and the value of a is stored to the resultant address.",
            "endianness": "For ISA 2.07, there is no bi-endian unaligned store instruction.  For\n      little-endian targets, it is necessary to first swap the doublewords\n      of the value to be stored using an xxswapd instruction, and then store\n      the result using the stxvd2x instruction.  For big-endian targets, the\n      stxvd2x or stxvw4x instruction suffices.  The examples below assume ISA\n      3.0, where the bi-endian stxv instruction is available.",
            "instructions": [
                "stxv"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example ISA 3.0\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "a": "vector signed char",
                        "b": "signed long long",
                        "c": "signed char *",
                        "implementation": "stxv  a,b(c)"
                    },
                    {
                        "id": "1",
                        "a": "vector unsigned char",
                        "b": "signed long long",
                        "c": "unsigned char *",
                        "implementation": "stxv  a,b(c)"
                    },
                    {
                        "id": "2",
                        "a": "vector signed short",
                        "b": "signed long long",
                        "c": "signed short *",
                        "implementation": "stxv  a,b(c)"
                    },
                    {
                        "id": "3",
                        "a": "vector unsigned short",
                        "b": "signed long long",
                        "c": "unsigned short *",
                        "implementation": "stxv  a,b(c)"
                    },
                    {
                        "id": "4",
                        "a": "vector signed int",
                        "b": "signed long long",
                        "c": "signed int *",
                        "implementation": "stxv  a,b(c)"
                    },
                    {
                        "id": "5",
                        "a": "vector unsigned int",
                        "b": "signed long long",
                        "c": "unsigned int *",
                        "implementation": "stxv  a,b(c)"
                    },
                    {
                        "id": "6",
                        "a": "vector signed long long",
                        "b": "signed long long",
                        "c": "signed long long *",
                        "implementation": "stxv  a,b(c)"
                    },
                    {
                        "id": "7",
                        "a": "vector unsigned long long",
                        "b": "signed long long",
                        "c": "unsigned long long *",
                        "implementation": "stxv  a,b(c)"
                    },
                    {
                        "id": "8",
                        "a": "vector signed __int128",
                        "b": "signed long long",
                        "c": "signed __int128 *",
                        "implementation": "stxv  a,b(c)"
                    },
                    {
                        "id": "9",
                        "a": "vector unsigned __int128",
                        "b": "signed long long",
                        "c": "unsigned __int128 *",
                        "implementation": "stxv  a,b(c)"
                    },
                    {
                        "id": "10",
                        "a": "vector float",
                        "b": "signed long long",
                        "c": "float *",
                        "implementation": "stxv  a,b(c)"
                    },
                    {
                        "id": "11",
                        "a": "vector double",
                        "b": "signed long long",
                        "c": "double *",
                        "implementation": "stxv  a,b(c)"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_xst_be",
            "name": "VSX Unaligned Store as Big Endian",
            "syntax": "vec_xst_be (a, b, c)",
            "purpose": "Stores a vector to an address using big-endian\n      element order, regardless of the endianness of the target machine.",
            "result": "The values of\n      b and c are added, and the value of a is stored to the resultant address using\n      big-endian element order.",
            "endianness": "In big-endian mode, this acts just like the vec_xst intrinsic.  In\n      little-endian mode, the lowest data address receives the\n      highest-numbered element of a, and\n      the highest data address receives the lowest-numbered element of\n      a.",
            "instructions": [
                "stxvb16x",
                "stxv",
                "stxvw4x",
                "stxvd2x",
                "stxvh8x"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example ISA 3.0 LE\nImplementation"
                    },
                    {
                        "key": "implementation",
                        "header": "Example ISA 3.0 BE\nImplementation"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "a": "vector signed char",
                        "b": "signed long long",
                        "c": "signed char *",
                        "implementation": "stxv a,b,c"
                    },
                    {
                        "id": "1",
                        "a": "vector unsigned char",
                        "b": "signed long long",
                        "c": "unsigned char *",
                        "implementation": "stxv a,b,c"
                    },
                    {
                        "id": "2",
                        "a": "vector signed short",
                        "b": "signed long long",
                        "c": "signed short *",
                        "implementation": "stxv a,b,c"
                    },
                    {
                        "id": "3",
                        "a": "vector unsigned short",
                        "b": "signed long long",
                        "c": "unsigned short *",
                        "implementation": "stxv a,b,c"
                    },
                    {
                        "id": "4",
                        "a": "vector signed int",
                        "b": "signed long long",
                        "c": "signed int *",
                        "implementation": "stxv a,b,c"
                    },
                    {
                        "id": "5",
                        "a": "vector unsigned int",
                        "b": "signed long long",
                        "c": "unsigned int *",
                        "implementation": "stxv a,b,c"
                    },
                    {
                        "id": "6",
                        "a": "vector signed long long",
                        "b": "signed long long",
                        "c": "signed long long *",
                        "implementation": "stxv a,b,c"
                    },
                    {
                        "id": "7",
                        "a": "vector unsigned long long",
                        "b": "signed long long",
                        "c": "unsigned long long *",
                        "implementation": "stxv a,b,c"
                    },
                    {
                        "id": "8",
                        "a": "vector signed __int128",
                        "b": "signed long long",
                        "c": "signed __int128 *",
                        "implementation": "stxv a,b,c"
                    },
                    {
                        "id": "9",
                        "a": "vector unsigned __int128",
                        "b": "signed long long",
                        "c": "unsigned __int128 *",
                        "implementation": "stxv a,b,c"
                    },
                    {
                        "id": "10",
                        "a": "vector float",
                        "b": "signed long long",
                        "c": "float *",
                        "implementation": "stxv a,b,c"
                    },
                    {
                        "id": "11",
                        "a": "vector double",
                        "b": "signed long long",
                        "c": "double *",
                        "implementation": "stxv a,b,c"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_xst_len",
            "name": "Vector Store with Length",
            "syntax": "vec_xst_len (a, b, c)",
            "purpose": "Stores a vector of a specified byte length.",
            "result": "Stores the number of\n      bytes specified by c of the vector\n      a to the address specified in\n      b. The bytes are obtained starting from\n      the lowest-numbered byte of the lowest-numbered element (as defined by\n      the endianness of the target). All bytes of an element\n      are accessed before proceeding to the next higher element.",
            "endianness": "None.",
            "instructions": [
                "sldi",
                "stxvl"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "a": "vector signed char",
                        "b": "signed char *",
                        "c": "size_t",
                        "implementation": "sldi   t,c,56\n  stxvl  a,b,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "1",
                        "a": "vector unsigned char",
                        "b": "unsigned char *",
                        "c": "size_t",
                        "implementation": "sldi   t,c,56\n  stxvl  a,b,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "2",
                        "a": "vector signed short",
                        "b": "signed short *",
                        "c": "size_t",
                        "implementation": "sldi   t,c,56\n  stxvl  a,b,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "3",
                        "a": "vector unsigned short",
                        "b": "unsigned short *",
                        "c": "size_t",
                        "implementation": "sldi   t,c,56\n  stxvl  a,b,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "4",
                        "a": "vector signed int",
                        "b": "signed int *",
                        "c": "size_t",
                        "implementation": "sldi   t,c,56\n  stxvl  a,b,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "5",
                        "a": "vector unsigned int",
                        "b": "unsigned int *",
                        "c": "size_t",
                        "implementation": "sldi   t,c,56\n  stxvl  a,b,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "6",
                        "a": "vector signed long long",
                        "b": "signed long long *",
                        "c": "size_t",
                        "implementation": "sldi   t,c,56\n  stxvl  a,b,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "7",
                        "a": "vector unsigned long long",
                        "b": "unsigned long long *",
                        "c": "size_t",
                        "implementation": "sldi   t,c,56\n  stxvl  a,b,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "8",
                        "a": "vector signed __int128",
                        "b": "signed __int128 *",
                        "c": "size_t",
                        "implementation": "sldi   t,c,56\n  stxvl  a,b,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "9",
                        "a": "vector unsigned __int128",
                        "b": "unsigned __int128 *",
                        "c": "size_t",
                        "implementation": "sldi   t,c,56\n  stxvl  a,b,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "10",
                        "a": "vector float",
                        "b": "float *",
                        "c": "size_t",
                        "implementation": "sldi   t,c,56\n  stxvl  a,b,t",
                        "Restrictions": "ISA 3.0 or later"
                    },
                    {
                        "id": "11",
                        "a": "vector double",
                        "b": "double *",
                        "c": "size_t",
                        "implementation": "sldi   t,c,56\n  stxvl  a,b,t",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        },
        {
            "mnemonic": "vec_xst_len_r",
            "name": "Vector Store with Length Right-Justified",
            "syntax": "vec_xst_len_r (a, b, c)",
            "purpose": "Stores a right-justified vector of a specified byte length.",
            "result": "Stores the number of\n      bytes specified by c of the\n      right-justified vector a to the address\n      specified by b.",
            "endianness": "None.",
            "instructions": [
                "lvsr",
                "sldi",
                "vperm",
                "stxvll"
            ],
            "type_signatures": {
                "var_heads": [
                    {
                        "key": "a",
                        "header": "a"
                    },
                    {
                        "key": "b",
                        "header": "b"
                    },
                    {
                        "key": "c",
                        "header": "c"
                    },
                    {
                        "key": "implementation",
                        "header": "Example Implementation"
                    },
                    {
                        "key": "Restrictions",
                        "header": "Restrictions"
                    }
                ],
                "list": [
                    {
                        "id": "0",
                        "a": "vector unsigned char",
                        "b": "unsigned char *",
                        "c": "size_t",
                        "implementation": "lvsr   t,0,c\n  sldi   u,c,56\n  vperm  v,a,a,t\n  stxvll v,b,u",
                        "Restrictions": "ISA 3.0 or later"
                    }
                ]
            }
        }
    ]
}
